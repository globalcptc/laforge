// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/gen0cide/laforge/ent/adhocplan"
	"github.com/gen0cide/laforge/ent/agentstatus"
	"github.com/gen0cide/laforge/ent/agenttask"
	"github.com/gen0cide/laforge/ent/ansible"
	"github.com/gen0cide/laforge/ent/authuser"
	"github.com/gen0cide/laforge/ent/build"
	"github.com/gen0cide/laforge/ent/buildcommit"
	"github.com/gen0cide/laforge/ent/command"
	"github.com/gen0cide/laforge/ent/competition"
	"github.com/gen0cide/laforge/ent/disk"
	"github.com/gen0cide/laforge/ent/dns"
	"github.com/gen0cide/laforge/ent/dnsrecord"
	"github.com/gen0cide/laforge/ent/environment"
	"github.com/gen0cide/laforge/ent/filedelete"
	"github.com/gen0cide/laforge/ent/filedownload"
	"github.com/gen0cide/laforge/ent/fileextract"
	"github.com/gen0cide/laforge/ent/finding"
	"github.com/gen0cide/laforge/ent/ginfilemiddleware"
	"github.com/gen0cide/laforge/ent/host"
	"github.com/gen0cide/laforge/ent/hostdependency"
	"github.com/gen0cide/laforge/ent/identity"
	"github.com/gen0cide/laforge/ent/includednetwork"
	"github.com/gen0cide/laforge/ent/network"
	"github.com/gen0cide/laforge/ent/plan"
	"github.com/gen0cide/laforge/ent/plandiff"
	"github.com/gen0cide/laforge/ent/predicate"
	"github.com/gen0cide/laforge/ent/provisionedhost"
	"github.com/gen0cide/laforge/ent/provisionednetwork"
	"github.com/gen0cide/laforge/ent/provisioningscheduledstep"
	"github.com/gen0cide/laforge/ent/provisioningstep"
	"github.com/gen0cide/laforge/ent/repocommit"
	"github.com/gen0cide/laforge/ent/repository"
	"github.com/gen0cide/laforge/ent/scheduledstep"
	"github.com/gen0cide/laforge/ent/script"
	"github.com/gen0cide/laforge/ent/servertask"
	"github.com/gen0cide/laforge/ent/status"
	"github.com/gen0cide/laforge/ent/tag"
	"github.com/gen0cide/laforge/ent/team"
	"github.com/gen0cide/laforge/ent/token"
	"github.com/gen0cide/laforge/ent/user"
	"github.com/go-git/go-git/v5/plumbing/object"
	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdhocPlan                 = "AdhocPlan"
	TypeAgentStatus               = "AgentStatus"
	TypeAgentTask                 = "AgentTask"
	TypeAnsible                   = "Ansible"
	TypeAuthUser                  = "AuthUser"
	TypeBuild                     = "Build"
	TypeBuildCommit               = "BuildCommit"
	TypeCommand                   = "Command"
	TypeCompetition               = "Competition"
	TypeDNS                       = "DNS"
	TypeDNSRecord                 = "DNSRecord"
	TypeDisk                      = "Disk"
	TypeEnvironment               = "Environment"
	TypeFileDelete                = "FileDelete"
	TypeFileDownload              = "FileDownload"
	TypeFileExtract               = "FileExtract"
	TypeFinding                   = "Finding"
	TypeGinFileMiddleware         = "GinFileMiddleware"
	TypeHost                      = "Host"
	TypeHostDependency            = "HostDependency"
	TypeIdentity                  = "Identity"
	TypeIncludedNetwork           = "IncludedNetwork"
	TypeNetwork                   = "Network"
	TypePlan                      = "Plan"
	TypePlanDiff                  = "PlanDiff"
	TypeProvisionedHost           = "ProvisionedHost"
	TypeProvisionedNetwork        = "ProvisionedNetwork"
	TypeProvisioningScheduledStep = "ProvisioningScheduledStep"
	TypeProvisioningStep          = "ProvisioningStep"
	TypeRepoCommit                = "RepoCommit"
	TypeRepository                = "Repository"
	TypeScheduledStep             = "ScheduledStep"
	TypeScript                    = "Script"
	TypeServerTask                = "ServerTask"
	TypeStatus                    = "Status"
	TypeTag                       = "Tag"
	TypeTeam                      = "Team"
	TypeToken                     = "Token"
	TypeUser                      = "User"
)

// AdhocPlanMutation represents an operation that mutates the AdhocPlan nodes in the graph.
type AdhocPlanMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	clearedFields          map[string]struct{}
	_PrevAdhocPlans        map[uuid.UUID]struct{}
	removed_PrevAdhocPlans map[uuid.UUID]struct{}
	cleared_PrevAdhocPlans bool
	_NextAdhocPlans        map[uuid.UUID]struct{}
	removed_NextAdhocPlans map[uuid.UUID]struct{}
	cleared_NextAdhocPlans bool
	_Build                 *uuid.UUID
	cleared_Build          bool
	_Status                *uuid.UUID
	cleared_Status         bool
	_AgentTask             *uuid.UUID
	cleared_AgentTask      bool
	done                   bool
	oldValue               func(context.Context) (*AdhocPlan, error)
	predicates             []predicate.AdhocPlan
}

var _ ent.Mutation = (*AdhocPlanMutation)(nil)

// adhocplanOption allows management of the mutation configuration using functional options.
type adhocplanOption func(*AdhocPlanMutation)

// newAdhocPlanMutation creates new mutation for the AdhocPlan entity.
func newAdhocPlanMutation(c config, op Op, opts ...adhocplanOption) *AdhocPlanMutation {
	m := &AdhocPlanMutation{
		config:        c,
		op:            op,
		typ:           TypeAdhocPlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdhocPlanID sets the ID field of the mutation.
func withAdhocPlanID(id uuid.UUID) adhocplanOption {
	return func(m *AdhocPlanMutation) {
		var (
			err   error
			once  sync.Once
			value *AdhocPlan
		)
		m.oldValue = func(ctx context.Context) (*AdhocPlan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdhocPlan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdhocPlan sets the old AdhocPlan of the mutation.
func withAdhocPlan(node *AdhocPlan) adhocplanOption {
	return func(m *AdhocPlanMutation) {
		m.oldValue = func(context.Context) (*AdhocPlan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdhocPlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdhocPlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AdhocPlan entities.
func (m *AdhocPlanMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdhocPlanMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdhocPlanMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdhocPlan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// AddPrevAdhocPlanIDs adds the "PrevAdhocPlans" edge to the AdhocPlan entity by ids.
func (m *AdhocPlanMutation) AddPrevAdhocPlanIDs(ids ...uuid.UUID) {
	if m._PrevAdhocPlans == nil {
		m._PrevAdhocPlans = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._PrevAdhocPlans[ids[i]] = struct{}{}
	}
}

// ClearPrevAdhocPlans clears the "PrevAdhocPlans" edge to the AdhocPlan entity.
func (m *AdhocPlanMutation) ClearPrevAdhocPlans() {
	m.cleared_PrevAdhocPlans = true
}

// PrevAdhocPlansCleared reports if the "PrevAdhocPlans" edge to the AdhocPlan entity was cleared.
func (m *AdhocPlanMutation) PrevAdhocPlansCleared() bool {
	return m.cleared_PrevAdhocPlans
}

// RemovePrevAdhocPlanIDs removes the "PrevAdhocPlans" edge to the AdhocPlan entity by IDs.
func (m *AdhocPlanMutation) RemovePrevAdhocPlanIDs(ids ...uuid.UUID) {
	if m.removed_PrevAdhocPlans == nil {
		m.removed_PrevAdhocPlans = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._PrevAdhocPlans, ids[i])
		m.removed_PrevAdhocPlans[ids[i]] = struct{}{}
	}
}

// RemovedPrevAdhocPlans returns the removed IDs of the "PrevAdhocPlans" edge to the AdhocPlan entity.
func (m *AdhocPlanMutation) RemovedPrevAdhocPlansIDs() (ids []uuid.UUID) {
	for id := range m.removed_PrevAdhocPlans {
		ids = append(ids, id)
	}
	return
}

// PrevAdhocPlansIDs returns the "PrevAdhocPlans" edge IDs in the mutation.
func (m *AdhocPlanMutation) PrevAdhocPlansIDs() (ids []uuid.UUID) {
	for id := range m._PrevAdhocPlans {
		ids = append(ids, id)
	}
	return
}

// ResetPrevAdhocPlans resets all changes to the "PrevAdhocPlans" edge.
func (m *AdhocPlanMutation) ResetPrevAdhocPlans() {
	m._PrevAdhocPlans = nil
	m.cleared_PrevAdhocPlans = false
	m.removed_PrevAdhocPlans = nil
}

// AddNextAdhocPlanIDs adds the "NextAdhocPlans" edge to the AdhocPlan entity by ids.
func (m *AdhocPlanMutation) AddNextAdhocPlanIDs(ids ...uuid.UUID) {
	if m._NextAdhocPlans == nil {
		m._NextAdhocPlans = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._NextAdhocPlans[ids[i]] = struct{}{}
	}
}

// ClearNextAdhocPlans clears the "NextAdhocPlans" edge to the AdhocPlan entity.
func (m *AdhocPlanMutation) ClearNextAdhocPlans() {
	m.cleared_NextAdhocPlans = true
}

// NextAdhocPlansCleared reports if the "NextAdhocPlans" edge to the AdhocPlan entity was cleared.
func (m *AdhocPlanMutation) NextAdhocPlansCleared() bool {
	return m.cleared_NextAdhocPlans
}

// RemoveNextAdhocPlanIDs removes the "NextAdhocPlans" edge to the AdhocPlan entity by IDs.
func (m *AdhocPlanMutation) RemoveNextAdhocPlanIDs(ids ...uuid.UUID) {
	if m.removed_NextAdhocPlans == nil {
		m.removed_NextAdhocPlans = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._NextAdhocPlans, ids[i])
		m.removed_NextAdhocPlans[ids[i]] = struct{}{}
	}
}

// RemovedNextAdhocPlans returns the removed IDs of the "NextAdhocPlans" edge to the AdhocPlan entity.
func (m *AdhocPlanMutation) RemovedNextAdhocPlansIDs() (ids []uuid.UUID) {
	for id := range m.removed_NextAdhocPlans {
		ids = append(ids, id)
	}
	return
}

// NextAdhocPlansIDs returns the "NextAdhocPlans" edge IDs in the mutation.
func (m *AdhocPlanMutation) NextAdhocPlansIDs() (ids []uuid.UUID) {
	for id := range m._NextAdhocPlans {
		ids = append(ids, id)
	}
	return
}

// ResetNextAdhocPlans resets all changes to the "NextAdhocPlans" edge.
func (m *AdhocPlanMutation) ResetNextAdhocPlans() {
	m._NextAdhocPlans = nil
	m.cleared_NextAdhocPlans = false
	m.removed_NextAdhocPlans = nil
}

// SetBuildID sets the "Build" edge to the Build entity by id.
func (m *AdhocPlanMutation) SetBuildID(id uuid.UUID) {
	m._Build = &id
}

// ClearBuild clears the "Build" edge to the Build entity.
func (m *AdhocPlanMutation) ClearBuild() {
	m.cleared_Build = true
}

// BuildCleared reports if the "Build" edge to the Build entity was cleared.
func (m *AdhocPlanMutation) BuildCleared() bool {
	return m.cleared_Build
}

// BuildID returns the "Build" edge ID in the mutation.
func (m *AdhocPlanMutation) BuildID() (id uuid.UUID, exists bool) {
	if m._Build != nil {
		return *m._Build, true
	}
	return
}

// BuildIDs returns the "Build" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuildID instead. It exists only for internal usage by the builders.
func (m *AdhocPlanMutation) BuildIDs() (ids []uuid.UUID) {
	if id := m._Build; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuild resets all changes to the "Build" edge.
func (m *AdhocPlanMutation) ResetBuild() {
	m._Build = nil
	m.cleared_Build = false
}

// SetStatusID sets the "Status" edge to the Status entity by id.
func (m *AdhocPlanMutation) SetStatusID(id uuid.UUID) {
	m._Status = &id
}

// ClearStatus clears the "Status" edge to the Status entity.
func (m *AdhocPlanMutation) ClearStatus() {
	m.cleared_Status = true
}

// StatusCleared reports if the "Status" edge to the Status entity was cleared.
func (m *AdhocPlanMutation) StatusCleared() bool {
	return m.cleared_Status
}

// StatusID returns the "Status" edge ID in the mutation.
func (m *AdhocPlanMutation) StatusID() (id uuid.UUID, exists bool) {
	if m._Status != nil {
		return *m._Status, true
	}
	return
}

// StatusIDs returns the "Status" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusID instead. It exists only for internal usage by the builders.
func (m *AdhocPlanMutation) StatusIDs() (ids []uuid.UUID) {
	if id := m._Status; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatus resets all changes to the "Status" edge.
func (m *AdhocPlanMutation) ResetStatus() {
	m._Status = nil
	m.cleared_Status = false
}

// SetAgentTaskID sets the "AgentTask" edge to the AgentTask entity by id.
func (m *AdhocPlanMutation) SetAgentTaskID(id uuid.UUID) {
	m._AgentTask = &id
}

// ClearAgentTask clears the "AgentTask" edge to the AgentTask entity.
func (m *AdhocPlanMutation) ClearAgentTask() {
	m.cleared_AgentTask = true
}

// AgentTaskCleared reports if the "AgentTask" edge to the AgentTask entity was cleared.
func (m *AdhocPlanMutation) AgentTaskCleared() bool {
	return m.cleared_AgentTask
}

// AgentTaskID returns the "AgentTask" edge ID in the mutation.
func (m *AdhocPlanMutation) AgentTaskID() (id uuid.UUID, exists bool) {
	if m._AgentTask != nil {
		return *m._AgentTask, true
	}
	return
}

// AgentTaskIDs returns the "AgentTask" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentTaskID instead. It exists only for internal usage by the builders.
func (m *AdhocPlanMutation) AgentTaskIDs() (ids []uuid.UUID) {
	if id := m._AgentTask; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgentTask resets all changes to the "AgentTask" edge.
func (m *AdhocPlanMutation) ResetAgentTask() {
	m._AgentTask = nil
	m.cleared_AgentTask = false
}

// Where appends a list predicates to the AdhocPlanMutation builder.
func (m *AdhocPlanMutation) Where(ps ...predicate.AdhocPlan) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AdhocPlanMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AdhocPlan).
func (m *AdhocPlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdhocPlanMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdhocPlanMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdhocPlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown AdhocPlan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdhocPlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AdhocPlan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdhocPlanMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdhocPlanMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdhocPlanMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown AdhocPlan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdhocPlanMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdhocPlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdhocPlanMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AdhocPlan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdhocPlanMutation) ResetField(name string) error {
	return fmt.Errorf("unknown AdhocPlan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdhocPlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m._PrevAdhocPlans != nil {
		edges = append(edges, adhocplan.EdgePrevAdhocPlans)
	}
	if m._NextAdhocPlans != nil {
		edges = append(edges, adhocplan.EdgeNextAdhocPlans)
	}
	if m._Build != nil {
		edges = append(edges, adhocplan.EdgeBuild)
	}
	if m._Status != nil {
		edges = append(edges, adhocplan.EdgeStatus)
	}
	if m._AgentTask != nil {
		edges = append(edges, adhocplan.EdgeAgentTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdhocPlanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case adhocplan.EdgePrevAdhocPlans:
		ids := make([]ent.Value, 0, len(m._PrevAdhocPlans))
		for id := range m._PrevAdhocPlans {
			ids = append(ids, id)
		}
		return ids
	case adhocplan.EdgeNextAdhocPlans:
		ids := make([]ent.Value, 0, len(m._NextAdhocPlans))
		for id := range m._NextAdhocPlans {
			ids = append(ids, id)
		}
		return ids
	case adhocplan.EdgeBuild:
		if id := m._Build; id != nil {
			return []ent.Value{*id}
		}
	case adhocplan.EdgeStatus:
		if id := m._Status; id != nil {
			return []ent.Value{*id}
		}
	case adhocplan.EdgeAgentTask:
		if id := m._AgentTask; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdhocPlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removed_PrevAdhocPlans != nil {
		edges = append(edges, adhocplan.EdgePrevAdhocPlans)
	}
	if m.removed_NextAdhocPlans != nil {
		edges = append(edges, adhocplan.EdgeNextAdhocPlans)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdhocPlanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case adhocplan.EdgePrevAdhocPlans:
		ids := make([]ent.Value, 0, len(m.removed_PrevAdhocPlans))
		for id := range m.removed_PrevAdhocPlans {
			ids = append(ids, id)
		}
		return ids
	case adhocplan.EdgeNextAdhocPlans:
		ids := make([]ent.Value, 0, len(m.removed_NextAdhocPlans))
		for id := range m.removed_NextAdhocPlans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdhocPlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleared_PrevAdhocPlans {
		edges = append(edges, adhocplan.EdgePrevAdhocPlans)
	}
	if m.cleared_NextAdhocPlans {
		edges = append(edges, adhocplan.EdgeNextAdhocPlans)
	}
	if m.cleared_Build {
		edges = append(edges, adhocplan.EdgeBuild)
	}
	if m.cleared_Status {
		edges = append(edges, adhocplan.EdgeStatus)
	}
	if m.cleared_AgentTask {
		edges = append(edges, adhocplan.EdgeAgentTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdhocPlanMutation) EdgeCleared(name string) bool {
	switch name {
	case adhocplan.EdgePrevAdhocPlans:
		return m.cleared_PrevAdhocPlans
	case adhocplan.EdgeNextAdhocPlans:
		return m.cleared_NextAdhocPlans
	case adhocplan.EdgeBuild:
		return m.cleared_Build
	case adhocplan.EdgeStatus:
		return m.cleared_Status
	case adhocplan.EdgeAgentTask:
		return m.cleared_AgentTask
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdhocPlanMutation) ClearEdge(name string) error {
	switch name {
	case adhocplan.EdgeBuild:
		m.ClearBuild()
		return nil
	case adhocplan.EdgeStatus:
		m.ClearStatus()
		return nil
	case adhocplan.EdgeAgentTask:
		m.ClearAgentTask()
		return nil
	}
	return fmt.Errorf("unknown AdhocPlan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdhocPlanMutation) ResetEdge(name string) error {
	switch name {
	case adhocplan.EdgePrevAdhocPlans:
		m.ResetPrevAdhocPlans()
		return nil
	case adhocplan.EdgeNextAdhocPlans:
		m.ResetNextAdhocPlans()
		return nil
	case adhocplan.EdgeBuild:
		m.ResetBuild()
		return nil
	case adhocplan.EdgeStatus:
		m.ResetStatus()
		return nil
	case adhocplan.EdgeAgentTask:
		m.ResetAgentTask()
		return nil
	}
	return fmt.Errorf("unknown AdhocPlan edge %s", name)
}

// AgentStatusMutation represents an operation that mutates the AgentStatus nodes in the graph.
type AgentStatusMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	_ClientID                  *string
	_Hostname                  *string
	_UpTime                    *int64
	add_UpTime                 *int64
	_BootTime                  *int64
	add_BootTime               *int64
	_NumProcs                  *int64
	add_NumProcs               *int64
	_Os                        *string
	_HostID                    *string
	_Load1                     *float64
	add_Load1                  *float64
	_Load5                     *float64
	add_Load5                  *float64
	_Load15                    *float64
	add_Load15                 *float64
	_TotalMem                  *int64
	add_TotalMem               *int64
	_FreeMem                   *int64
	add_FreeMem                *int64
	_UsedMem                   *int64
	add_UsedMem                *int64
	_Timestamp                 *int64
	add_Timestamp              *int64
	clearedFields              map[string]struct{}
	_ProvisionedHost           *uuid.UUID
	cleared_ProvisionedHost    bool
	_ProvisionedNetwork        *uuid.UUID
	cleared_ProvisionedNetwork bool
	_Build                     *uuid.UUID
	cleared_Build              bool
	done                       bool
	oldValue                   func(context.Context) (*AgentStatus, error)
	predicates                 []predicate.AgentStatus
}

var _ ent.Mutation = (*AgentStatusMutation)(nil)

// agentstatusOption allows management of the mutation configuration using functional options.
type agentstatusOption func(*AgentStatusMutation)

// newAgentStatusMutation creates new mutation for the AgentStatus entity.
func newAgentStatusMutation(c config, op Op, opts ...agentstatusOption) *AgentStatusMutation {
	m := &AgentStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeAgentStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentStatusID sets the ID field of the mutation.
func withAgentStatusID(id uuid.UUID) agentstatusOption {
	return func(m *AgentStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *AgentStatus
		)
		m.oldValue = func(ctx context.Context) (*AgentStatus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AgentStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgentStatus sets the old AgentStatus of the mutation.
func withAgentStatus(node *AgentStatus) agentstatusOption {
	return func(m *AgentStatusMutation) {
		m.oldValue = func(context.Context) (*AgentStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AgentStatus entities.
func (m *AgentStatusMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgentStatusMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgentStatusMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AgentStatus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClientID sets the "ClientID" field.
func (m *AgentStatusMutation) SetClientID(s string) {
	m._ClientID = &s
}

// ClientID returns the value of the "ClientID" field in the mutation.
func (m *AgentStatusMutation) ClientID() (r string, exists bool) {
	v := m._ClientID
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "ClientID" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "ClientID" field.
func (m *AgentStatusMutation) ResetClientID() {
	m._ClientID = nil
}

// SetHostname sets the "Hostname" field.
func (m *AgentStatusMutation) SetHostname(s string) {
	m._Hostname = &s
}

// Hostname returns the value of the "Hostname" field in the mutation.
func (m *AgentStatusMutation) Hostname() (r string, exists bool) {
	v := m._Hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "Hostname" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname resets all changes to the "Hostname" field.
func (m *AgentStatusMutation) ResetHostname() {
	m._Hostname = nil
}

// SetUpTime sets the "UpTime" field.
func (m *AgentStatusMutation) SetUpTime(i int64) {
	m._UpTime = &i
	m.add_UpTime = nil
}

// UpTime returns the value of the "UpTime" field in the mutation.
func (m *AgentStatusMutation) UpTime() (r int64, exists bool) {
	v := m._UpTime
	if v == nil {
		return
	}
	return *v, true
}

// OldUpTime returns the old "UpTime" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldUpTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpTime: %w", err)
	}
	return oldValue.UpTime, nil
}

// AddUpTime adds i to the "UpTime" field.
func (m *AgentStatusMutation) AddUpTime(i int64) {
	if m.add_UpTime != nil {
		*m.add_UpTime += i
	} else {
		m.add_UpTime = &i
	}
}

// AddedUpTime returns the value that was added to the "UpTime" field in this mutation.
func (m *AgentStatusMutation) AddedUpTime() (r int64, exists bool) {
	v := m.add_UpTime
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpTime resets all changes to the "UpTime" field.
func (m *AgentStatusMutation) ResetUpTime() {
	m._UpTime = nil
	m.add_UpTime = nil
}

// SetBootTime sets the "BootTime" field.
func (m *AgentStatusMutation) SetBootTime(i int64) {
	m._BootTime = &i
	m.add_BootTime = nil
}

// BootTime returns the value of the "BootTime" field in the mutation.
func (m *AgentStatusMutation) BootTime() (r int64, exists bool) {
	v := m._BootTime
	if v == nil {
		return
	}
	return *v, true
}

// OldBootTime returns the old "BootTime" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldBootTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBootTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBootTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBootTime: %w", err)
	}
	return oldValue.BootTime, nil
}

// AddBootTime adds i to the "BootTime" field.
func (m *AgentStatusMutation) AddBootTime(i int64) {
	if m.add_BootTime != nil {
		*m.add_BootTime += i
	} else {
		m.add_BootTime = &i
	}
}

// AddedBootTime returns the value that was added to the "BootTime" field in this mutation.
func (m *AgentStatusMutation) AddedBootTime() (r int64, exists bool) {
	v := m.add_BootTime
	if v == nil {
		return
	}
	return *v, true
}

// ResetBootTime resets all changes to the "BootTime" field.
func (m *AgentStatusMutation) ResetBootTime() {
	m._BootTime = nil
	m.add_BootTime = nil
}

// SetNumProcs sets the "NumProcs" field.
func (m *AgentStatusMutation) SetNumProcs(i int64) {
	m._NumProcs = &i
	m.add_NumProcs = nil
}

// NumProcs returns the value of the "NumProcs" field in the mutation.
func (m *AgentStatusMutation) NumProcs() (r int64, exists bool) {
	v := m._NumProcs
	if v == nil {
		return
	}
	return *v, true
}

// OldNumProcs returns the old "NumProcs" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldNumProcs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumProcs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumProcs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumProcs: %w", err)
	}
	return oldValue.NumProcs, nil
}

// AddNumProcs adds i to the "NumProcs" field.
func (m *AgentStatusMutation) AddNumProcs(i int64) {
	if m.add_NumProcs != nil {
		*m.add_NumProcs += i
	} else {
		m.add_NumProcs = &i
	}
}

// AddedNumProcs returns the value that was added to the "NumProcs" field in this mutation.
func (m *AgentStatusMutation) AddedNumProcs() (r int64, exists bool) {
	v := m.add_NumProcs
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumProcs resets all changes to the "NumProcs" field.
func (m *AgentStatusMutation) ResetNumProcs() {
	m._NumProcs = nil
	m.add_NumProcs = nil
}

// SetOs sets the "Os" field.
func (m *AgentStatusMutation) SetOs(s string) {
	m._Os = &s
}

// Os returns the value of the "Os" field in the mutation.
func (m *AgentStatusMutation) Os() (r string, exists bool) {
	v := m._Os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "Os" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldOs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ResetOs resets all changes to the "Os" field.
func (m *AgentStatusMutation) ResetOs() {
	m._Os = nil
}

// SetHostID sets the "HostID" field.
func (m *AgentStatusMutation) SetHostID(s string) {
	m._HostID = &s
}

// HostID returns the value of the "HostID" field in the mutation.
func (m *AgentStatusMutation) HostID() (r string, exists bool) {
	v := m._HostID
	if v == nil {
		return
	}
	return *v, true
}

// OldHostID returns the old "HostID" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldHostID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostID: %w", err)
	}
	return oldValue.HostID, nil
}

// ResetHostID resets all changes to the "HostID" field.
func (m *AgentStatusMutation) ResetHostID() {
	m._HostID = nil
}

// SetLoad1 sets the "Load1" field.
func (m *AgentStatusMutation) SetLoad1(f float64) {
	m._Load1 = &f
	m.add_Load1 = nil
}

// Load1 returns the value of the "Load1" field in the mutation.
func (m *AgentStatusMutation) Load1() (r float64, exists bool) {
	v := m._Load1
	if v == nil {
		return
	}
	return *v, true
}

// OldLoad1 returns the old "Load1" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldLoad1(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoad1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoad1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoad1: %w", err)
	}
	return oldValue.Load1, nil
}

// AddLoad1 adds f to the "Load1" field.
func (m *AgentStatusMutation) AddLoad1(f float64) {
	if m.add_Load1 != nil {
		*m.add_Load1 += f
	} else {
		m.add_Load1 = &f
	}
}

// AddedLoad1 returns the value that was added to the "Load1" field in this mutation.
func (m *AgentStatusMutation) AddedLoad1() (r float64, exists bool) {
	v := m.add_Load1
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoad1 resets all changes to the "Load1" field.
func (m *AgentStatusMutation) ResetLoad1() {
	m._Load1 = nil
	m.add_Load1 = nil
}

// SetLoad5 sets the "Load5" field.
func (m *AgentStatusMutation) SetLoad5(f float64) {
	m._Load5 = &f
	m.add_Load5 = nil
}

// Load5 returns the value of the "Load5" field in the mutation.
func (m *AgentStatusMutation) Load5() (r float64, exists bool) {
	v := m._Load5
	if v == nil {
		return
	}
	return *v, true
}

// OldLoad5 returns the old "Load5" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldLoad5(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoad5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoad5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoad5: %w", err)
	}
	return oldValue.Load5, nil
}

// AddLoad5 adds f to the "Load5" field.
func (m *AgentStatusMutation) AddLoad5(f float64) {
	if m.add_Load5 != nil {
		*m.add_Load5 += f
	} else {
		m.add_Load5 = &f
	}
}

// AddedLoad5 returns the value that was added to the "Load5" field in this mutation.
func (m *AgentStatusMutation) AddedLoad5() (r float64, exists bool) {
	v := m.add_Load5
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoad5 resets all changes to the "Load5" field.
func (m *AgentStatusMutation) ResetLoad5() {
	m._Load5 = nil
	m.add_Load5 = nil
}

// SetLoad15 sets the "Load15" field.
func (m *AgentStatusMutation) SetLoad15(f float64) {
	m._Load15 = &f
	m.add_Load15 = nil
}

// Load15 returns the value of the "Load15" field in the mutation.
func (m *AgentStatusMutation) Load15() (r float64, exists bool) {
	v := m._Load15
	if v == nil {
		return
	}
	return *v, true
}

// OldLoad15 returns the old "Load15" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldLoad15(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoad15 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoad15 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoad15: %w", err)
	}
	return oldValue.Load15, nil
}

// AddLoad15 adds f to the "Load15" field.
func (m *AgentStatusMutation) AddLoad15(f float64) {
	if m.add_Load15 != nil {
		*m.add_Load15 += f
	} else {
		m.add_Load15 = &f
	}
}

// AddedLoad15 returns the value that was added to the "Load15" field in this mutation.
func (m *AgentStatusMutation) AddedLoad15() (r float64, exists bool) {
	v := m.add_Load15
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoad15 resets all changes to the "Load15" field.
func (m *AgentStatusMutation) ResetLoad15() {
	m._Load15 = nil
	m.add_Load15 = nil
}

// SetTotalMem sets the "TotalMem" field.
func (m *AgentStatusMutation) SetTotalMem(i int64) {
	m._TotalMem = &i
	m.add_TotalMem = nil
}

// TotalMem returns the value of the "TotalMem" field in the mutation.
func (m *AgentStatusMutation) TotalMem() (r int64, exists bool) {
	v := m._TotalMem
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalMem returns the old "TotalMem" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldTotalMem(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalMem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalMem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalMem: %w", err)
	}
	return oldValue.TotalMem, nil
}

// AddTotalMem adds i to the "TotalMem" field.
func (m *AgentStatusMutation) AddTotalMem(i int64) {
	if m.add_TotalMem != nil {
		*m.add_TotalMem += i
	} else {
		m.add_TotalMem = &i
	}
}

// AddedTotalMem returns the value that was added to the "TotalMem" field in this mutation.
func (m *AgentStatusMutation) AddedTotalMem() (r int64, exists bool) {
	v := m.add_TotalMem
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalMem resets all changes to the "TotalMem" field.
func (m *AgentStatusMutation) ResetTotalMem() {
	m._TotalMem = nil
	m.add_TotalMem = nil
}

// SetFreeMem sets the "FreeMem" field.
func (m *AgentStatusMutation) SetFreeMem(i int64) {
	m._FreeMem = &i
	m.add_FreeMem = nil
}

// FreeMem returns the value of the "FreeMem" field in the mutation.
func (m *AgentStatusMutation) FreeMem() (r int64, exists bool) {
	v := m._FreeMem
	if v == nil {
		return
	}
	return *v, true
}

// OldFreeMem returns the old "FreeMem" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldFreeMem(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreeMem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreeMem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreeMem: %w", err)
	}
	return oldValue.FreeMem, nil
}

// AddFreeMem adds i to the "FreeMem" field.
func (m *AgentStatusMutation) AddFreeMem(i int64) {
	if m.add_FreeMem != nil {
		*m.add_FreeMem += i
	} else {
		m.add_FreeMem = &i
	}
}

// AddedFreeMem returns the value that was added to the "FreeMem" field in this mutation.
func (m *AgentStatusMutation) AddedFreeMem() (r int64, exists bool) {
	v := m.add_FreeMem
	if v == nil {
		return
	}
	return *v, true
}

// ResetFreeMem resets all changes to the "FreeMem" field.
func (m *AgentStatusMutation) ResetFreeMem() {
	m._FreeMem = nil
	m.add_FreeMem = nil
}

// SetUsedMem sets the "UsedMem" field.
func (m *AgentStatusMutation) SetUsedMem(i int64) {
	m._UsedMem = &i
	m.add_UsedMem = nil
}

// UsedMem returns the value of the "UsedMem" field in the mutation.
func (m *AgentStatusMutation) UsedMem() (r int64, exists bool) {
	v := m._UsedMem
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedMem returns the old "UsedMem" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldUsedMem(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedMem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedMem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedMem: %w", err)
	}
	return oldValue.UsedMem, nil
}

// AddUsedMem adds i to the "UsedMem" field.
func (m *AgentStatusMutation) AddUsedMem(i int64) {
	if m.add_UsedMem != nil {
		*m.add_UsedMem += i
	} else {
		m.add_UsedMem = &i
	}
}

// AddedUsedMem returns the value that was added to the "UsedMem" field in this mutation.
func (m *AgentStatusMutation) AddedUsedMem() (r int64, exists bool) {
	v := m.add_UsedMem
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsedMem resets all changes to the "UsedMem" field.
func (m *AgentStatusMutation) ResetUsedMem() {
	m._UsedMem = nil
	m.add_UsedMem = nil
}

// SetTimestamp sets the "Timestamp" field.
func (m *AgentStatusMutation) SetTimestamp(i int64) {
	m._Timestamp = &i
	m.add_Timestamp = nil
}

// Timestamp returns the value of the "Timestamp" field in the mutation.
func (m *AgentStatusMutation) Timestamp() (r int64, exists bool) {
	v := m._Timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "Timestamp" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldTimestamp(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// AddTimestamp adds i to the "Timestamp" field.
func (m *AgentStatusMutation) AddTimestamp(i int64) {
	if m.add_Timestamp != nil {
		*m.add_Timestamp += i
	} else {
		m.add_Timestamp = &i
	}
}

// AddedTimestamp returns the value that was added to the "Timestamp" field in this mutation.
func (m *AgentStatusMutation) AddedTimestamp() (r int64, exists bool) {
	v := m.add_Timestamp
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimestamp resets all changes to the "Timestamp" field.
func (m *AgentStatusMutation) ResetTimestamp() {
	m._Timestamp = nil
	m.add_Timestamp = nil
}

// SetProvisionedHostID sets the "ProvisionedHost" edge to the ProvisionedHost entity by id.
func (m *AgentStatusMutation) SetProvisionedHostID(id uuid.UUID) {
	m._ProvisionedHost = &id
}

// ClearProvisionedHost clears the "ProvisionedHost" edge to the ProvisionedHost entity.
func (m *AgentStatusMutation) ClearProvisionedHost() {
	m.cleared_ProvisionedHost = true
}

// ProvisionedHostCleared reports if the "ProvisionedHost" edge to the ProvisionedHost entity was cleared.
func (m *AgentStatusMutation) ProvisionedHostCleared() bool {
	return m.cleared_ProvisionedHost
}

// ProvisionedHostID returns the "ProvisionedHost" edge ID in the mutation.
func (m *AgentStatusMutation) ProvisionedHostID() (id uuid.UUID, exists bool) {
	if m._ProvisionedHost != nil {
		return *m._ProvisionedHost, true
	}
	return
}

// ProvisionedHostIDs returns the "ProvisionedHost" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisionedHostID instead. It exists only for internal usage by the builders.
func (m *AgentStatusMutation) ProvisionedHostIDs() (ids []uuid.UUID) {
	if id := m._ProvisionedHost; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisionedHost resets all changes to the "ProvisionedHost" edge.
func (m *AgentStatusMutation) ResetProvisionedHost() {
	m._ProvisionedHost = nil
	m.cleared_ProvisionedHost = false
}

// SetProvisionedNetworkID sets the "ProvisionedNetwork" edge to the ProvisionedNetwork entity by id.
func (m *AgentStatusMutation) SetProvisionedNetworkID(id uuid.UUID) {
	m._ProvisionedNetwork = &id
}

// ClearProvisionedNetwork clears the "ProvisionedNetwork" edge to the ProvisionedNetwork entity.
func (m *AgentStatusMutation) ClearProvisionedNetwork() {
	m.cleared_ProvisionedNetwork = true
}

// ProvisionedNetworkCleared reports if the "ProvisionedNetwork" edge to the ProvisionedNetwork entity was cleared.
func (m *AgentStatusMutation) ProvisionedNetworkCleared() bool {
	return m.cleared_ProvisionedNetwork
}

// ProvisionedNetworkID returns the "ProvisionedNetwork" edge ID in the mutation.
func (m *AgentStatusMutation) ProvisionedNetworkID() (id uuid.UUID, exists bool) {
	if m._ProvisionedNetwork != nil {
		return *m._ProvisionedNetwork, true
	}
	return
}

// ProvisionedNetworkIDs returns the "ProvisionedNetwork" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisionedNetworkID instead. It exists only for internal usage by the builders.
func (m *AgentStatusMutation) ProvisionedNetworkIDs() (ids []uuid.UUID) {
	if id := m._ProvisionedNetwork; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisionedNetwork resets all changes to the "ProvisionedNetwork" edge.
func (m *AgentStatusMutation) ResetProvisionedNetwork() {
	m._ProvisionedNetwork = nil
	m.cleared_ProvisionedNetwork = false
}

// SetBuildID sets the "Build" edge to the Build entity by id.
func (m *AgentStatusMutation) SetBuildID(id uuid.UUID) {
	m._Build = &id
}

// ClearBuild clears the "Build" edge to the Build entity.
func (m *AgentStatusMutation) ClearBuild() {
	m.cleared_Build = true
}

// BuildCleared reports if the "Build" edge to the Build entity was cleared.
func (m *AgentStatusMutation) BuildCleared() bool {
	return m.cleared_Build
}

// BuildID returns the "Build" edge ID in the mutation.
func (m *AgentStatusMutation) BuildID() (id uuid.UUID, exists bool) {
	if m._Build != nil {
		return *m._Build, true
	}
	return
}

// BuildIDs returns the "Build" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuildID instead. It exists only for internal usage by the builders.
func (m *AgentStatusMutation) BuildIDs() (ids []uuid.UUID) {
	if id := m._Build; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuild resets all changes to the "Build" edge.
func (m *AgentStatusMutation) ResetBuild() {
	m._Build = nil
	m.cleared_Build = false
}

// Where appends a list predicates to the AgentStatusMutation builder.
func (m *AgentStatusMutation) Where(ps ...predicate.AgentStatus) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AgentStatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AgentStatus).
func (m *AgentStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentStatusMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m._ClientID != nil {
		fields = append(fields, agentstatus.FieldClientID)
	}
	if m._Hostname != nil {
		fields = append(fields, agentstatus.FieldHostname)
	}
	if m._UpTime != nil {
		fields = append(fields, agentstatus.FieldUpTime)
	}
	if m._BootTime != nil {
		fields = append(fields, agentstatus.FieldBootTime)
	}
	if m._NumProcs != nil {
		fields = append(fields, agentstatus.FieldNumProcs)
	}
	if m._Os != nil {
		fields = append(fields, agentstatus.FieldOs)
	}
	if m._HostID != nil {
		fields = append(fields, agentstatus.FieldHostID)
	}
	if m._Load1 != nil {
		fields = append(fields, agentstatus.FieldLoad1)
	}
	if m._Load5 != nil {
		fields = append(fields, agentstatus.FieldLoad5)
	}
	if m._Load15 != nil {
		fields = append(fields, agentstatus.FieldLoad15)
	}
	if m._TotalMem != nil {
		fields = append(fields, agentstatus.FieldTotalMem)
	}
	if m._FreeMem != nil {
		fields = append(fields, agentstatus.FieldFreeMem)
	}
	if m._UsedMem != nil {
		fields = append(fields, agentstatus.FieldUsedMem)
	}
	if m._Timestamp != nil {
		fields = append(fields, agentstatus.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agentstatus.FieldClientID:
		return m.ClientID()
	case agentstatus.FieldHostname:
		return m.Hostname()
	case agentstatus.FieldUpTime:
		return m.UpTime()
	case agentstatus.FieldBootTime:
		return m.BootTime()
	case agentstatus.FieldNumProcs:
		return m.NumProcs()
	case agentstatus.FieldOs:
		return m.Os()
	case agentstatus.FieldHostID:
		return m.HostID()
	case agentstatus.FieldLoad1:
		return m.Load1()
	case agentstatus.FieldLoad5:
		return m.Load5()
	case agentstatus.FieldLoad15:
		return m.Load15()
	case agentstatus.FieldTotalMem:
		return m.TotalMem()
	case agentstatus.FieldFreeMem:
		return m.FreeMem()
	case agentstatus.FieldUsedMem:
		return m.UsedMem()
	case agentstatus.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agentstatus.FieldClientID:
		return m.OldClientID(ctx)
	case agentstatus.FieldHostname:
		return m.OldHostname(ctx)
	case agentstatus.FieldUpTime:
		return m.OldUpTime(ctx)
	case agentstatus.FieldBootTime:
		return m.OldBootTime(ctx)
	case agentstatus.FieldNumProcs:
		return m.OldNumProcs(ctx)
	case agentstatus.FieldOs:
		return m.OldOs(ctx)
	case agentstatus.FieldHostID:
		return m.OldHostID(ctx)
	case agentstatus.FieldLoad1:
		return m.OldLoad1(ctx)
	case agentstatus.FieldLoad5:
		return m.OldLoad5(ctx)
	case agentstatus.FieldLoad15:
		return m.OldLoad15(ctx)
	case agentstatus.FieldTotalMem:
		return m.OldTotalMem(ctx)
	case agentstatus.FieldFreeMem:
		return m.OldFreeMem(ctx)
	case agentstatus.FieldUsedMem:
		return m.OldUsedMem(ctx)
	case agentstatus.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown AgentStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agentstatus.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case agentstatus.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case agentstatus.FieldUpTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpTime(v)
		return nil
	case agentstatus.FieldBootTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBootTime(v)
		return nil
	case agentstatus.FieldNumProcs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumProcs(v)
		return nil
	case agentstatus.FieldOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case agentstatus.FieldHostID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostID(v)
		return nil
	case agentstatus.FieldLoad1:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoad1(v)
		return nil
	case agentstatus.FieldLoad5:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoad5(v)
		return nil
	case agentstatus.FieldLoad15:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoad15(v)
		return nil
	case agentstatus.FieldTotalMem:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalMem(v)
		return nil
	case agentstatus.FieldFreeMem:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreeMem(v)
		return nil
	case agentstatus.FieldUsedMem:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedMem(v)
		return nil
	case agentstatus.FieldTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown AgentStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentStatusMutation) AddedFields() []string {
	var fields []string
	if m.add_UpTime != nil {
		fields = append(fields, agentstatus.FieldUpTime)
	}
	if m.add_BootTime != nil {
		fields = append(fields, agentstatus.FieldBootTime)
	}
	if m.add_NumProcs != nil {
		fields = append(fields, agentstatus.FieldNumProcs)
	}
	if m.add_Load1 != nil {
		fields = append(fields, agentstatus.FieldLoad1)
	}
	if m.add_Load5 != nil {
		fields = append(fields, agentstatus.FieldLoad5)
	}
	if m.add_Load15 != nil {
		fields = append(fields, agentstatus.FieldLoad15)
	}
	if m.add_TotalMem != nil {
		fields = append(fields, agentstatus.FieldTotalMem)
	}
	if m.add_FreeMem != nil {
		fields = append(fields, agentstatus.FieldFreeMem)
	}
	if m.add_UsedMem != nil {
		fields = append(fields, agentstatus.FieldUsedMem)
	}
	if m.add_Timestamp != nil {
		fields = append(fields, agentstatus.FieldTimestamp)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentStatusMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case agentstatus.FieldUpTime:
		return m.AddedUpTime()
	case agentstatus.FieldBootTime:
		return m.AddedBootTime()
	case agentstatus.FieldNumProcs:
		return m.AddedNumProcs()
	case agentstatus.FieldLoad1:
		return m.AddedLoad1()
	case agentstatus.FieldLoad5:
		return m.AddedLoad5()
	case agentstatus.FieldLoad15:
		return m.AddedLoad15()
	case agentstatus.FieldTotalMem:
		return m.AddedTotalMem()
	case agentstatus.FieldFreeMem:
		return m.AddedFreeMem()
	case agentstatus.FieldUsedMem:
		return m.AddedUsedMem()
	case agentstatus.FieldTimestamp:
		return m.AddedTimestamp()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	case agentstatus.FieldUpTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpTime(v)
		return nil
	case agentstatus.FieldBootTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBootTime(v)
		return nil
	case agentstatus.FieldNumProcs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumProcs(v)
		return nil
	case agentstatus.FieldLoad1:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoad1(v)
		return nil
	case agentstatus.FieldLoad5:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoad5(v)
		return nil
	case agentstatus.FieldLoad15:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoad15(v)
		return nil
	case agentstatus.FieldTotalMem:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalMem(v)
		return nil
	case agentstatus.FieldFreeMem:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFreeMem(v)
		return nil
	case agentstatus.FieldUsedMem:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsedMem(v)
		return nil
	case agentstatus.FieldTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown AgentStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentStatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentStatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AgentStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentStatusMutation) ResetField(name string) error {
	switch name {
	case agentstatus.FieldClientID:
		m.ResetClientID()
		return nil
	case agentstatus.FieldHostname:
		m.ResetHostname()
		return nil
	case agentstatus.FieldUpTime:
		m.ResetUpTime()
		return nil
	case agentstatus.FieldBootTime:
		m.ResetBootTime()
		return nil
	case agentstatus.FieldNumProcs:
		m.ResetNumProcs()
		return nil
	case agentstatus.FieldOs:
		m.ResetOs()
		return nil
	case agentstatus.FieldHostID:
		m.ResetHostID()
		return nil
	case agentstatus.FieldLoad1:
		m.ResetLoad1()
		return nil
	case agentstatus.FieldLoad5:
		m.ResetLoad5()
		return nil
	case agentstatus.FieldLoad15:
		m.ResetLoad15()
		return nil
	case agentstatus.FieldTotalMem:
		m.ResetTotalMem()
		return nil
	case agentstatus.FieldFreeMem:
		m.ResetFreeMem()
		return nil
	case agentstatus.FieldUsedMem:
		m.ResetUsedMem()
		return nil
	case agentstatus.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown AgentStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._ProvisionedHost != nil {
		edges = append(edges, agentstatus.EdgeProvisionedHost)
	}
	if m._ProvisionedNetwork != nil {
		edges = append(edges, agentstatus.EdgeProvisionedNetwork)
	}
	if m._Build != nil {
		edges = append(edges, agentstatus.EdgeBuild)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agentstatus.EdgeProvisionedHost:
		if id := m._ProvisionedHost; id != nil {
			return []ent.Value{*id}
		}
	case agentstatus.EdgeProvisionedNetwork:
		if id := m._ProvisionedNetwork; id != nil {
			return []ent.Value{*id}
		}
	case agentstatus.EdgeBuild:
		if id := m._Build; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentStatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_ProvisionedHost {
		edges = append(edges, agentstatus.EdgeProvisionedHost)
	}
	if m.cleared_ProvisionedNetwork {
		edges = append(edges, agentstatus.EdgeProvisionedNetwork)
	}
	if m.cleared_Build {
		edges = append(edges, agentstatus.EdgeBuild)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case agentstatus.EdgeProvisionedHost:
		return m.cleared_ProvisionedHost
	case agentstatus.EdgeProvisionedNetwork:
		return m.cleared_ProvisionedNetwork
	case agentstatus.EdgeBuild:
		return m.cleared_Build
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentStatusMutation) ClearEdge(name string) error {
	switch name {
	case agentstatus.EdgeProvisionedHost:
		m.ClearProvisionedHost()
		return nil
	case agentstatus.EdgeProvisionedNetwork:
		m.ClearProvisionedNetwork()
		return nil
	case agentstatus.EdgeBuild:
		m.ClearBuild()
		return nil
	}
	return fmt.Errorf("unknown AgentStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentStatusMutation) ResetEdge(name string) error {
	switch name {
	case agentstatus.EdgeProvisionedHost:
		m.ResetProvisionedHost()
		return nil
	case agentstatus.EdgeProvisionedNetwork:
		m.ResetProvisionedNetwork()
		return nil
	case agentstatus.EdgeBuild:
		m.ResetBuild()
		return nil
	}
	return fmt.Errorf("unknown AgentStatus edge %s", name)
}

// AgentTaskMutation represents an operation that mutates the AgentTask nodes in the graph.
type AgentTaskMutation struct {
	config
	op                                Op
	typ                               string
	id                                *uuid.UUID
	command                           *agenttask.Command
	args                              *string
	number                            *int
	addnumber                         *int
	output                            *string
	state                             *agenttask.State
	error_message                     *string
	clearedFields                     map[string]struct{}
	_ProvisioningStep                 *uuid.UUID
	cleared_ProvisioningStep          bool
	_ProvisioningScheduledStep        *uuid.UUID
	cleared_ProvisioningScheduledStep bool
	_ProvisionedHost                  *uuid.UUID
	cleared_ProvisionedHost           bool
	_AdhocPlans                       map[uuid.UUID]struct{}
	removed_AdhocPlans                map[uuid.UUID]struct{}
	cleared_AdhocPlans                bool
	done                              bool
	oldValue                          func(context.Context) (*AgentTask, error)
	predicates                        []predicate.AgentTask
}

var _ ent.Mutation = (*AgentTaskMutation)(nil)

// agenttaskOption allows management of the mutation configuration using functional options.
type agenttaskOption func(*AgentTaskMutation)

// newAgentTaskMutation creates new mutation for the AgentTask entity.
func newAgentTaskMutation(c config, op Op, opts ...agenttaskOption) *AgentTaskMutation {
	m := &AgentTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeAgentTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentTaskID sets the ID field of the mutation.
func withAgentTaskID(id uuid.UUID) agenttaskOption {
	return func(m *AgentTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *AgentTask
		)
		m.oldValue = func(ctx context.Context) (*AgentTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AgentTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgentTask sets the old AgentTask of the mutation.
func withAgentTask(node *AgentTask) agenttaskOption {
	return func(m *AgentTaskMutation) {
		m.oldValue = func(context.Context) (*AgentTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AgentTask entities.
func (m *AgentTaskMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgentTaskMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgentTaskMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AgentTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCommand sets the "command" field.
func (m *AgentTaskMutation) SetCommand(a agenttask.Command) {
	m.command = &a
}

// Command returns the value of the "command" field in the mutation.
func (m *AgentTaskMutation) Command() (r agenttask.Command, exists bool) {
	v := m.command
	if v == nil {
		return
	}
	return *v, true
}

// OldCommand returns the old "command" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldCommand(ctx context.Context) (v agenttask.Command, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommand: %w", err)
	}
	return oldValue.Command, nil
}

// ResetCommand resets all changes to the "command" field.
func (m *AgentTaskMutation) ResetCommand() {
	m.command = nil
}

// SetArgs sets the "args" field.
func (m *AgentTaskMutation) SetArgs(s string) {
	m.args = &s
}

// Args returns the value of the "args" field in the mutation.
func (m *AgentTaskMutation) Args() (r string, exists bool) {
	v := m.args
	if v == nil {
		return
	}
	return *v, true
}

// OldArgs returns the old "args" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldArgs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArgs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArgs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArgs: %w", err)
	}
	return oldValue.Args, nil
}

// ResetArgs resets all changes to the "args" field.
func (m *AgentTaskMutation) ResetArgs() {
	m.args = nil
}

// SetNumber sets the "number" field.
func (m *AgentTaskMutation) SetNumber(i int) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *AgentTaskMutation) Number() (r int, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *AgentTaskMutation) AddNumber(i int) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *AgentTaskMutation) AddedNumber() (r int, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber resets all changes to the "number" field.
func (m *AgentTaskMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
}

// SetOutput sets the "output" field.
func (m *AgentTaskMutation) SetOutput(s string) {
	m.output = &s
}

// Output returns the value of the "output" field in the mutation.
func (m *AgentTaskMutation) Output() (r string, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ResetOutput resets all changes to the "output" field.
func (m *AgentTaskMutation) ResetOutput() {
	m.output = nil
}

// SetState sets the "state" field.
func (m *AgentTaskMutation) SetState(a agenttask.State) {
	m.state = &a
}

// State returns the value of the "state" field in the mutation.
func (m *AgentTaskMutation) State() (r agenttask.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldState(ctx context.Context) (v agenttask.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *AgentTaskMutation) ResetState() {
	m.state = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *AgentTaskMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *AgentTaskMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *AgentTaskMutation) ResetErrorMessage() {
	m.error_message = nil
}

// SetProvisioningStepID sets the "ProvisioningStep" edge to the ProvisioningStep entity by id.
func (m *AgentTaskMutation) SetProvisioningStepID(id uuid.UUID) {
	m._ProvisioningStep = &id
}

// ClearProvisioningStep clears the "ProvisioningStep" edge to the ProvisioningStep entity.
func (m *AgentTaskMutation) ClearProvisioningStep() {
	m.cleared_ProvisioningStep = true
}

// ProvisioningStepCleared reports if the "ProvisioningStep" edge to the ProvisioningStep entity was cleared.
func (m *AgentTaskMutation) ProvisioningStepCleared() bool {
	return m.cleared_ProvisioningStep
}

// ProvisioningStepID returns the "ProvisioningStep" edge ID in the mutation.
func (m *AgentTaskMutation) ProvisioningStepID() (id uuid.UUID, exists bool) {
	if m._ProvisioningStep != nil {
		return *m._ProvisioningStep, true
	}
	return
}

// ProvisioningStepIDs returns the "ProvisioningStep" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisioningStepID instead. It exists only for internal usage by the builders.
func (m *AgentTaskMutation) ProvisioningStepIDs() (ids []uuid.UUID) {
	if id := m._ProvisioningStep; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisioningStep resets all changes to the "ProvisioningStep" edge.
func (m *AgentTaskMutation) ResetProvisioningStep() {
	m._ProvisioningStep = nil
	m.cleared_ProvisioningStep = false
}

// SetProvisioningScheduledStepID sets the "ProvisioningScheduledStep" edge to the ProvisioningScheduledStep entity by id.
func (m *AgentTaskMutation) SetProvisioningScheduledStepID(id uuid.UUID) {
	m._ProvisioningScheduledStep = &id
}

// ClearProvisioningScheduledStep clears the "ProvisioningScheduledStep" edge to the ProvisioningScheduledStep entity.
func (m *AgentTaskMutation) ClearProvisioningScheduledStep() {
	m.cleared_ProvisioningScheduledStep = true
}

// ProvisioningScheduledStepCleared reports if the "ProvisioningScheduledStep" edge to the ProvisioningScheduledStep entity was cleared.
func (m *AgentTaskMutation) ProvisioningScheduledStepCleared() bool {
	return m.cleared_ProvisioningScheduledStep
}

// ProvisioningScheduledStepID returns the "ProvisioningScheduledStep" edge ID in the mutation.
func (m *AgentTaskMutation) ProvisioningScheduledStepID() (id uuid.UUID, exists bool) {
	if m._ProvisioningScheduledStep != nil {
		return *m._ProvisioningScheduledStep, true
	}
	return
}

// ProvisioningScheduledStepIDs returns the "ProvisioningScheduledStep" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisioningScheduledStepID instead. It exists only for internal usage by the builders.
func (m *AgentTaskMutation) ProvisioningScheduledStepIDs() (ids []uuid.UUID) {
	if id := m._ProvisioningScheduledStep; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisioningScheduledStep resets all changes to the "ProvisioningScheduledStep" edge.
func (m *AgentTaskMutation) ResetProvisioningScheduledStep() {
	m._ProvisioningScheduledStep = nil
	m.cleared_ProvisioningScheduledStep = false
}

// SetProvisionedHostID sets the "ProvisionedHost" edge to the ProvisionedHost entity by id.
func (m *AgentTaskMutation) SetProvisionedHostID(id uuid.UUID) {
	m._ProvisionedHost = &id
}

// ClearProvisionedHost clears the "ProvisionedHost" edge to the ProvisionedHost entity.
func (m *AgentTaskMutation) ClearProvisionedHost() {
	m.cleared_ProvisionedHost = true
}

// ProvisionedHostCleared reports if the "ProvisionedHost" edge to the ProvisionedHost entity was cleared.
func (m *AgentTaskMutation) ProvisionedHostCleared() bool {
	return m.cleared_ProvisionedHost
}

// ProvisionedHostID returns the "ProvisionedHost" edge ID in the mutation.
func (m *AgentTaskMutation) ProvisionedHostID() (id uuid.UUID, exists bool) {
	if m._ProvisionedHost != nil {
		return *m._ProvisionedHost, true
	}
	return
}

// ProvisionedHostIDs returns the "ProvisionedHost" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisionedHostID instead. It exists only for internal usage by the builders.
func (m *AgentTaskMutation) ProvisionedHostIDs() (ids []uuid.UUID) {
	if id := m._ProvisionedHost; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisionedHost resets all changes to the "ProvisionedHost" edge.
func (m *AgentTaskMutation) ResetProvisionedHost() {
	m._ProvisionedHost = nil
	m.cleared_ProvisionedHost = false
}

// AddAdhocPlanIDs adds the "AdhocPlans" edge to the AdhocPlan entity by ids.
func (m *AgentTaskMutation) AddAdhocPlanIDs(ids ...uuid.UUID) {
	if m._AdhocPlans == nil {
		m._AdhocPlans = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._AdhocPlans[ids[i]] = struct{}{}
	}
}

// ClearAdhocPlans clears the "AdhocPlans" edge to the AdhocPlan entity.
func (m *AgentTaskMutation) ClearAdhocPlans() {
	m.cleared_AdhocPlans = true
}

// AdhocPlansCleared reports if the "AdhocPlans" edge to the AdhocPlan entity was cleared.
func (m *AgentTaskMutation) AdhocPlansCleared() bool {
	return m.cleared_AdhocPlans
}

// RemoveAdhocPlanIDs removes the "AdhocPlans" edge to the AdhocPlan entity by IDs.
func (m *AgentTaskMutation) RemoveAdhocPlanIDs(ids ...uuid.UUID) {
	if m.removed_AdhocPlans == nil {
		m.removed_AdhocPlans = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._AdhocPlans, ids[i])
		m.removed_AdhocPlans[ids[i]] = struct{}{}
	}
}

// RemovedAdhocPlans returns the removed IDs of the "AdhocPlans" edge to the AdhocPlan entity.
func (m *AgentTaskMutation) RemovedAdhocPlansIDs() (ids []uuid.UUID) {
	for id := range m.removed_AdhocPlans {
		ids = append(ids, id)
	}
	return
}

// AdhocPlansIDs returns the "AdhocPlans" edge IDs in the mutation.
func (m *AgentTaskMutation) AdhocPlansIDs() (ids []uuid.UUID) {
	for id := range m._AdhocPlans {
		ids = append(ids, id)
	}
	return
}

// ResetAdhocPlans resets all changes to the "AdhocPlans" edge.
func (m *AgentTaskMutation) ResetAdhocPlans() {
	m._AdhocPlans = nil
	m.cleared_AdhocPlans = false
	m.removed_AdhocPlans = nil
}

// Where appends a list predicates to the AgentTaskMutation builder.
func (m *AgentTaskMutation) Where(ps ...predicate.AgentTask) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AgentTaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AgentTask).
func (m *AgentTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentTaskMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.command != nil {
		fields = append(fields, agenttask.FieldCommand)
	}
	if m.args != nil {
		fields = append(fields, agenttask.FieldArgs)
	}
	if m.number != nil {
		fields = append(fields, agenttask.FieldNumber)
	}
	if m.output != nil {
		fields = append(fields, agenttask.FieldOutput)
	}
	if m.state != nil {
		fields = append(fields, agenttask.FieldState)
	}
	if m.error_message != nil {
		fields = append(fields, agenttask.FieldErrorMessage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agenttask.FieldCommand:
		return m.Command()
	case agenttask.FieldArgs:
		return m.Args()
	case agenttask.FieldNumber:
		return m.Number()
	case agenttask.FieldOutput:
		return m.Output()
	case agenttask.FieldState:
		return m.State()
	case agenttask.FieldErrorMessage:
		return m.ErrorMessage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agenttask.FieldCommand:
		return m.OldCommand(ctx)
	case agenttask.FieldArgs:
		return m.OldArgs(ctx)
	case agenttask.FieldNumber:
		return m.OldNumber(ctx)
	case agenttask.FieldOutput:
		return m.OldOutput(ctx)
	case agenttask.FieldState:
		return m.OldState(ctx)
	case agenttask.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	}
	return nil, fmt.Errorf("unknown AgentTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agenttask.FieldCommand:
		v, ok := value.(agenttask.Command)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommand(v)
		return nil
	case agenttask.FieldArgs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArgs(v)
		return nil
	case agenttask.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case agenttask.FieldOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case agenttask.FieldState:
		v, ok := value.(agenttask.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case agenttask.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	}
	return fmt.Errorf("unknown AgentTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentTaskMutation) AddedFields() []string {
	var fields []string
	if m.addnumber != nil {
		fields = append(fields, agenttask.FieldNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentTaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case agenttask.FieldNumber:
		return m.AddedNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case agenttask.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	}
	return fmt.Errorf("unknown AgentTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentTaskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentTaskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AgentTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentTaskMutation) ResetField(name string) error {
	switch name {
	case agenttask.FieldCommand:
		m.ResetCommand()
		return nil
	case agenttask.FieldArgs:
		m.ResetArgs()
		return nil
	case agenttask.FieldNumber:
		m.ResetNumber()
		return nil
	case agenttask.FieldOutput:
		m.ResetOutput()
		return nil
	case agenttask.FieldState:
		m.ResetState()
		return nil
	case agenttask.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown AgentTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._ProvisioningStep != nil {
		edges = append(edges, agenttask.EdgeProvisioningStep)
	}
	if m._ProvisioningScheduledStep != nil {
		edges = append(edges, agenttask.EdgeProvisioningScheduledStep)
	}
	if m._ProvisionedHost != nil {
		edges = append(edges, agenttask.EdgeProvisionedHost)
	}
	if m._AdhocPlans != nil {
		edges = append(edges, agenttask.EdgeAdhocPlans)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentTaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agenttask.EdgeProvisioningStep:
		if id := m._ProvisioningStep; id != nil {
			return []ent.Value{*id}
		}
	case agenttask.EdgeProvisioningScheduledStep:
		if id := m._ProvisioningScheduledStep; id != nil {
			return []ent.Value{*id}
		}
	case agenttask.EdgeProvisionedHost:
		if id := m._ProvisionedHost; id != nil {
			return []ent.Value{*id}
		}
	case agenttask.EdgeAdhocPlans:
		ids := make([]ent.Value, 0, len(m._AdhocPlans))
		for id := range m._AdhocPlans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removed_AdhocPlans != nil {
		edges = append(edges, agenttask.EdgeAdhocPlans)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentTaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case agenttask.EdgeAdhocPlans:
		ids := make([]ent.Value, 0, len(m.removed_AdhocPlans))
		for id := range m.removed_AdhocPlans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_ProvisioningStep {
		edges = append(edges, agenttask.EdgeProvisioningStep)
	}
	if m.cleared_ProvisioningScheduledStep {
		edges = append(edges, agenttask.EdgeProvisioningScheduledStep)
	}
	if m.cleared_ProvisionedHost {
		edges = append(edges, agenttask.EdgeProvisionedHost)
	}
	if m.cleared_AdhocPlans {
		edges = append(edges, agenttask.EdgeAdhocPlans)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentTaskMutation) EdgeCleared(name string) bool {
	switch name {
	case agenttask.EdgeProvisioningStep:
		return m.cleared_ProvisioningStep
	case agenttask.EdgeProvisioningScheduledStep:
		return m.cleared_ProvisioningScheduledStep
	case agenttask.EdgeProvisionedHost:
		return m.cleared_ProvisionedHost
	case agenttask.EdgeAdhocPlans:
		return m.cleared_AdhocPlans
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentTaskMutation) ClearEdge(name string) error {
	switch name {
	case agenttask.EdgeProvisioningStep:
		m.ClearProvisioningStep()
		return nil
	case agenttask.EdgeProvisioningScheduledStep:
		m.ClearProvisioningScheduledStep()
		return nil
	case agenttask.EdgeProvisionedHost:
		m.ClearProvisionedHost()
		return nil
	}
	return fmt.Errorf("unknown AgentTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentTaskMutation) ResetEdge(name string) error {
	switch name {
	case agenttask.EdgeProvisioningStep:
		m.ResetProvisioningStep()
		return nil
	case agenttask.EdgeProvisioningScheduledStep:
		m.ResetProvisioningScheduledStep()
		return nil
	case agenttask.EdgeProvisionedHost:
		m.ResetProvisionedHost()
		return nil
	case agenttask.EdgeAdhocPlans:
		m.ResetAdhocPlans()
		return nil
	}
	return fmt.Errorf("unknown AgentTask edge %s", name)
}

// AnsibleMutation represents an operation that mutates the Ansible nodes in the graph.
type AnsibleMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	name                *string
	hcl_id              *string
	description         *string
	source              *string
	playbook_name       *string
	method              *ansible.Method
	inventory           *string
	abs_path            *string
	tags                *map[string]string
	clearedFields       map[string]struct{}
	_Users              map[uuid.UUID]struct{}
	removed_Users       map[uuid.UUID]struct{}
	cleared_Users       bool
	_Environment        *uuid.UUID
	cleared_Environment bool
	done                bool
	oldValue            func(context.Context) (*Ansible, error)
	predicates          []predicate.Ansible
}

var _ ent.Mutation = (*AnsibleMutation)(nil)

// ansibleOption allows management of the mutation configuration using functional options.
type ansibleOption func(*AnsibleMutation)

// newAnsibleMutation creates new mutation for the Ansible entity.
func newAnsibleMutation(c config, op Op, opts ...ansibleOption) *AnsibleMutation {
	m := &AnsibleMutation{
		config:        c,
		op:            op,
		typ:           TypeAnsible,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAnsibleID sets the ID field of the mutation.
func withAnsibleID(id uuid.UUID) ansibleOption {
	return func(m *AnsibleMutation) {
		var (
			err   error
			once  sync.Once
			value *Ansible
		)
		m.oldValue = func(ctx context.Context) (*Ansible, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ansible.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAnsible sets the old Ansible of the mutation.
func withAnsible(node *Ansible) ansibleOption {
	return func(m *AnsibleMutation) {
		m.oldValue = func(context.Context) (*Ansible, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AnsibleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AnsibleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Ansible entities.
func (m *AnsibleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AnsibleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AnsibleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ansible.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AnsibleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AnsibleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Ansible entity.
// If the Ansible object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsibleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AnsibleMutation) ResetName() {
	m.name = nil
}

// SetHclID sets the "hcl_id" field.
func (m *AnsibleMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *AnsibleMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the Ansible entity.
// If the Ansible object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsibleMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *AnsibleMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetDescription sets the "description" field.
func (m *AnsibleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AnsibleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Ansible entity.
// If the Ansible object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsibleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AnsibleMutation) ResetDescription() {
	m.description = nil
}

// SetSource sets the "source" field.
func (m *AnsibleMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *AnsibleMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Ansible entity.
// If the Ansible object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsibleMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *AnsibleMutation) ResetSource() {
	m.source = nil
}

// SetPlaybookName sets the "playbook_name" field.
func (m *AnsibleMutation) SetPlaybookName(s string) {
	m.playbook_name = &s
}

// PlaybookName returns the value of the "playbook_name" field in the mutation.
func (m *AnsibleMutation) PlaybookName() (r string, exists bool) {
	v := m.playbook_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPlaybookName returns the old "playbook_name" field's value of the Ansible entity.
// If the Ansible object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsibleMutation) OldPlaybookName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlaybookName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlaybookName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlaybookName: %w", err)
	}
	return oldValue.PlaybookName, nil
}

// ResetPlaybookName resets all changes to the "playbook_name" field.
func (m *AnsibleMutation) ResetPlaybookName() {
	m.playbook_name = nil
}

// SetMethod sets the "method" field.
func (m *AnsibleMutation) SetMethod(a ansible.Method) {
	m.method = &a
}

// Method returns the value of the "method" field in the mutation.
func (m *AnsibleMutation) Method() (r ansible.Method, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the Ansible entity.
// If the Ansible object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsibleMutation) OldMethod(ctx context.Context) (v ansible.Method, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *AnsibleMutation) ResetMethod() {
	m.method = nil
}

// SetInventory sets the "inventory" field.
func (m *AnsibleMutation) SetInventory(s string) {
	m.inventory = &s
}

// Inventory returns the value of the "inventory" field in the mutation.
func (m *AnsibleMutation) Inventory() (r string, exists bool) {
	v := m.inventory
	if v == nil {
		return
	}
	return *v, true
}

// OldInventory returns the old "inventory" field's value of the Ansible entity.
// If the Ansible object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsibleMutation) OldInventory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInventory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInventory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInventory: %w", err)
	}
	return oldValue.Inventory, nil
}

// ResetInventory resets all changes to the "inventory" field.
func (m *AnsibleMutation) ResetInventory() {
	m.inventory = nil
}

// SetAbsPath sets the "abs_path" field.
func (m *AnsibleMutation) SetAbsPath(s string) {
	m.abs_path = &s
}

// AbsPath returns the value of the "abs_path" field in the mutation.
func (m *AnsibleMutation) AbsPath() (r string, exists bool) {
	v := m.abs_path
	if v == nil {
		return
	}
	return *v, true
}

// OldAbsPath returns the old "abs_path" field's value of the Ansible entity.
// If the Ansible object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsibleMutation) OldAbsPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbsPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbsPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbsPath: %w", err)
	}
	return oldValue.AbsPath, nil
}

// ResetAbsPath resets all changes to the "abs_path" field.
func (m *AnsibleMutation) ResetAbsPath() {
	m.abs_path = nil
}

// SetTags sets the "tags" field.
func (m *AnsibleMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *AnsibleMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Ansible entity.
// If the Ansible object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsibleMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *AnsibleMutation) ResetTags() {
	m.tags = nil
}

// AddUserIDs adds the "Users" edge to the User entity by ids.
func (m *AnsibleMutation) AddUserIDs(ids ...uuid.UUID) {
	if m._Users == nil {
		m._Users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "Users" edge to the User entity.
func (m *AnsibleMutation) ClearUsers() {
	m.cleared_Users = true
}

// UsersCleared reports if the "Users" edge to the User entity was cleared.
func (m *AnsibleMutation) UsersCleared() bool {
	return m.cleared_Users
}

// RemoveUserIDs removes the "Users" edge to the User entity by IDs.
func (m *AnsibleMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removed_Users == nil {
		m.removed_Users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Users, ids[i])
		m.removed_Users[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "Users" edge to the User entity.
func (m *AnsibleMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removed_Users {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "Users" edge IDs in the mutation.
func (m *AnsibleMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m._Users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "Users" edge.
func (m *AnsibleMutation) ResetUsers() {
	m._Users = nil
	m.cleared_Users = false
	m.removed_Users = nil
}

// SetEnvironmentID sets the "Environment" edge to the Environment entity by id.
func (m *AnsibleMutation) SetEnvironmentID(id uuid.UUID) {
	m._Environment = &id
}

// ClearEnvironment clears the "Environment" edge to the Environment entity.
func (m *AnsibleMutation) ClearEnvironment() {
	m.cleared_Environment = true
}

// EnvironmentCleared reports if the "Environment" edge to the Environment entity was cleared.
func (m *AnsibleMutation) EnvironmentCleared() bool {
	return m.cleared_Environment
}

// EnvironmentID returns the "Environment" edge ID in the mutation.
func (m *AnsibleMutation) EnvironmentID() (id uuid.UUID, exists bool) {
	if m._Environment != nil {
		return *m._Environment, true
	}
	return
}

// EnvironmentIDs returns the "Environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *AnsibleMutation) EnvironmentIDs() (ids []uuid.UUID) {
	if id := m._Environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "Environment" edge.
func (m *AnsibleMutation) ResetEnvironment() {
	m._Environment = nil
	m.cleared_Environment = false
}

// Where appends a list predicates to the AnsibleMutation builder.
func (m *AnsibleMutation) Where(ps ...predicate.Ansible) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AnsibleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Ansible).
func (m *AnsibleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AnsibleMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, ansible.FieldName)
	}
	if m.hcl_id != nil {
		fields = append(fields, ansible.FieldHclID)
	}
	if m.description != nil {
		fields = append(fields, ansible.FieldDescription)
	}
	if m.source != nil {
		fields = append(fields, ansible.FieldSource)
	}
	if m.playbook_name != nil {
		fields = append(fields, ansible.FieldPlaybookName)
	}
	if m.method != nil {
		fields = append(fields, ansible.FieldMethod)
	}
	if m.inventory != nil {
		fields = append(fields, ansible.FieldInventory)
	}
	if m.abs_path != nil {
		fields = append(fields, ansible.FieldAbsPath)
	}
	if m.tags != nil {
		fields = append(fields, ansible.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AnsibleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ansible.FieldName:
		return m.Name()
	case ansible.FieldHclID:
		return m.HclID()
	case ansible.FieldDescription:
		return m.Description()
	case ansible.FieldSource:
		return m.Source()
	case ansible.FieldPlaybookName:
		return m.PlaybookName()
	case ansible.FieldMethod:
		return m.Method()
	case ansible.FieldInventory:
		return m.Inventory()
	case ansible.FieldAbsPath:
		return m.AbsPath()
	case ansible.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AnsibleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ansible.FieldName:
		return m.OldName(ctx)
	case ansible.FieldHclID:
		return m.OldHclID(ctx)
	case ansible.FieldDescription:
		return m.OldDescription(ctx)
	case ansible.FieldSource:
		return m.OldSource(ctx)
	case ansible.FieldPlaybookName:
		return m.OldPlaybookName(ctx)
	case ansible.FieldMethod:
		return m.OldMethod(ctx)
	case ansible.FieldInventory:
		return m.OldInventory(ctx)
	case ansible.FieldAbsPath:
		return m.OldAbsPath(ctx)
	case ansible.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Ansible field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnsibleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ansible.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ansible.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case ansible.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case ansible.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case ansible.FieldPlaybookName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlaybookName(v)
		return nil
	case ansible.FieldMethod:
		v, ok := value.(ansible.Method)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case ansible.FieldInventory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInventory(v)
		return nil
	case ansible.FieldAbsPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbsPath(v)
		return nil
	case ansible.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Ansible field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AnsibleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AnsibleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnsibleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Ansible numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AnsibleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AnsibleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AnsibleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Ansible nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AnsibleMutation) ResetField(name string) error {
	switch name {
	case ansible.FieldName:
		m.ResetName()
		return nil
	case ansible.FieldHclID:
		m.ResetHclID()
		return nil
	case ansible.FieldDescription:
		m.ResetDescription()
		return nil
	case ansible.FieldSource:
		m.ResetSource()
		return nil
	case ansible.FieldPlaybookName:
		m.ResetPlaybookName()
		return nil
	case ansible.FieldMethod:
		m.ResetMethod()
		return nil
	case ansible.FieldInventory:
		m.ResetInventory()
		return nil
	case ansible.FieldAbsPath:
		m.ResetAbsPath()
		return nil
	case ansible.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Ansible field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AnsibleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._Users != nil {
		edges = append(edges, ansible.EdgeUsers)
	}
	if m._Environment != nil {
		edges = append(edges, ansible.EdgeEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AnsibleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ansible.EdgeUsers:
		ids := make([]ent.Value, 0, len(m._Users))
		for id := range m._Users {
			ids = append(ids, id)
		}
		return ids
	case ansible.EdgeEnvironment:
		if id := m._Environment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AnsibleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_Users != nil {
		edges = append(edges, ansible.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AnsibleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ansible.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removed_Users))
		for id := range m.removed_Users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AnsibleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_Users {
		edges = append(edges, ansible.EdgeUsers)
	}
	if m.cleared_Environment {
		edges = append(edges, ansible.EdgeEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AnsibleMutation) EdgeCleared(name string) bool {
	switch name {
	case ansible.EdgeUsers:
		return m.cleared_Users
	case ansible.EdgeEnvironment:
		return m.cleared_Environment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AnsibleMutation) ClearEdge(name string) error {
	switch name {
	case ansible.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Ansible unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AnsibleMutation) ResetEdge(name string) error {
	switch name {
	case ansible.EdgeUsers:
		m.ResetUsers()
		return nil
	case ansible.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Ansible edge %s", name)
}

// AuthUserMutation represents an operation that mutates the AuthUser nodes in the graph.
type AuthUserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	username            *string
	password            *string
	first_name          *string
	last_name           *string
	email               *string
	phone               *string
	company             *string
	occupation          *string
	private_key_path    *string
	role                *authuser.Role
	provider            *authuser.Provider
	clearedFields       map[string]struct{}
	_Tokens             map[uuid.UUID]struct{}
	removed_Tokens      map[uuid.UUID]struct{}
	cleared_Tokens      bool
	_ServerTasks        map[uuid.UUID]struct{}
	removed_ServerTasks map[uuid.UUID]struct{}
	cleared_ServerTasks bool
	done                bool
	oldValue            func(context.Context) (*AuthUser, error)
	predicates          []predicate.AuthUser
}

var _ ent.Mutation = (*AuthUserMutation)(nil)

// authuserOption allows management of the mutation configuration using functional options.
type authuserOption func(*AuthUserMutation)

// newAuthUserMutation creates new mutation for the AuthUser entity.
func newAuthUserMutation(c config, op Op, opts ...authuserOption) *AuthUserMutation {
	m := &AuthUserMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthUserID sets the ID field of the mutation.
func withAuthUserID(id uuid.UUID) authuserOption {
	return func(m *AuthUserMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthUser
		)
		m.oldValue = func(ctx context.Context) (*AuthUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthUser sets the old AuthUser of the mutation.
func withAuthUser(node *AuthUser) authuserOption {
	return func(m *AuthUserMutation) {
		m.oldValue = func(context.Context) (*AuthUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthUser entities.
func (m *AuthUserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthUserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthUserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *AuthUserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AuthUserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *AuthUserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *AuthUserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AuthUserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AuthUserMutation) ResetPassword() {
	m.password = nil
}

// SetFirstName sets the "first_name" field.
func (m *AuthUserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *AuthUserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *AuthUserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *AuthUserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *AuthUserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *AuthUserMutation) ResetLastName() {
	m.last_name = nil
}

// SetEmail sets the "email" field.
func (m *AuthUserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AuthUserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AuthUserMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *AuthUserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *AuthUserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *AuthUserMutation) ResetPhone() {
	m.phone = nil
}

// SetCompany sets the "company" field.
func (m *AuthUserMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *AuthUserMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ResetCompany resets all changes to the "company" field.
func (m *AuthUserMutation) ResetCompany() {
	m.company = nil
}

// SetOccupation sets the "occupation" field.
func (m *AuthUserMutation) SetOccupation(s string) {
	m.occupation = &s
}

// Occupation returns the value of the "occupation" field in the mutation.
func (m *AuthUserMutation) Occupation() (r string, exists bool) {
	v := m.occupation
	if v == nil {
		return
	}
	return *v, true
}

// OldOccupation returns the old "occupation" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldOccupation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOccupation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOccupation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOccupation: %w", err)
	}
	return oldValue.Occupation, nil
}

// ResetOccupation resets all changes to the "occupation" field.
func (m *AuthUserMutation) ResetOccupation() {
	m.occupation = nil
}

// SetPrivateKeyPath sets the "private_key_path" field.
func (m *AuthUserMutation) SetPrivateKeyPath(s string) {
	m.private_key_path = &s
}

// PrivateKeyPath returns the value of the "private_key_path" field in the mutation.
func (m *AuthUserMutation) PrivateKeyPath() (r string, exists bool) {
	v := m.private_key_path
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivateKeyPath returns the old "private_key_path" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldPrivateKeyPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivateKeyPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivateKeyPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivateKeyPath: %w", err)
	}
	return oldValue.PrivateKeyPath, nil
}

// ResetPrivateKeyPath resets all changes to the "private_key_path" field.
func (m *AuthUserMutation) ResetPrivateKeyPath() {
	m.private_key_path = nil
}

// SetRole sets the "role" field.
func (m *AuthUserMutation) SetRole(a authuser.Role) {
	m.role = &a
}

// Role returns the value of the "role" field in the mutation.
func (m *AuthUserMutation) Role() (r authuser.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldRole(ctx context.Context) (v authuser.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *AuthUserMutation) ResetRole() {
	m.role = nil
}

// SetProvider sets the "provider" field.
func (m *AuthUserMutation) SetProvider(a authuser.Provider) {
	m.provider = &a
}

// Provider returns the value of the "provider" field in the mutation.
func (m *AuthUserMutation) Provider() (r authuser.Provider, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldProvider(ctx context.Context) (v authuser.Provider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *AuthUserMutation) ResetProvider() {
	m.provider = nil
}

// AddTokenIDs adds the "Tokens" edge to the Token entity by ids.
func (m *AuthUserMutation) AddTokenIDs(ids ...uuid.UUID) {
	if m._Tokens == nil {
		m._Tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Tokens[ids[i]] = struct{}{}
	}
}

// ClearTokens clears the "Tokens" edge to the Token entity.
func (m *AuthUserMutation) ClearTokens() {
	m.cleared_Tokens = true
}

// TokensCleared reports if the "Tokens" edge to the Token entity was cleared.
func (m *AuthUserMutation) TokensCleared() bool {
	return m.cleared_Tokens
}

// RemoveTokenIDs removes the "Tokens" edge to the Token entity by IDs.
func (m *AuthUserMutation) RemoveTokenIDs(ids ...uuid.UUID) {
	if m.removed_Tokens == nil {
		m.removed_Tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Tokens, ids[i])
		m.removed_Tokens[ids[i]] = struct{}{}
	}
}

// RemovedTokens returns the removed IDs of the "Tokens" edge to the Token entity.
func (m *AuthUserMutation) RemovedTokensIDs() (ids []uuid.UUID) {
	for id := range m.removed_Tokens {
		ids = append(ids, id)
	}
	return
}

// TokensIDs returns the "Tokens" edge IDs in the mutation.
func (m *AuthUserMutation) TokensIDs() (ids []uuid.UUID) {
	for id := range m._Tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTokens resets all changes to the "Tokens" edge.
func (m *AuthUserMutation) ResetTokens() {
	m._Tokens = nil
	m.cleared_Tokens = false
	m.removed_Tokens = nil
}

// AddServerTaskIDs adds the "ServerTasks" edge to the ServerTask entity by ids.
func (m *AuthUserMutation) AddServerTaskIDs(ids ...uuid.UUID) {
	if m._ServerTasks == nil {
		m._ServerTasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ServerTasks[ids[i]] = struct{}{}
	}
}

// ClearServerTasks clears the "ServerTasks" edge to the ServerTask entity.
func (m *AuthUserMutation) ClearServerTasks() {
	m.cleared_ServerTasks = true
}

// ServerTasksCleared reports if the "ServerTasks" edge to the ServerTask entity was cleared.
func (m *AuthUserMutation) ServerTasksCleared() bool {
	return m.cleared_ServerTasks
}

// RemoveServerTaskIDs removes the "ServerTasks" edge to the ServerTask entity by IDs.
func (m *AuthUserMutation) RemoveServerTaskIDs(ids ...uuid.UUID) {
	if m.removed_ServerTasks == nil {
		m.removed_ServerTasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._ServerTasks, ids[i])
		m.removed_ServerTasks[ids[i]] = struct{}{}
	}
}

// RemovedServerTasks returns the removed IDs of the "ServerTasks" edge to the ServerTask entity.
func (m *AuthUserMutation) RemovedServerTasksIDs() (ids []uuid.UUID) {
	for id := range m.removed_ServerTasks {
		ids = append(ids, id)
	}
	return
}

// ServerTasksIDs returns the "ServerTasks" edge IDs in the mutation.
func (m *AuthUserMutation) ServerTasksIDs() (ids []uuid.UUID) {
	for id := range m._ServerTasks {
		ids = append(ids, id)
	}
	return
}

// ResetServerTasks resets all changes to the "ServerTasks" edge.
func (m *AuthUserMutation) ResetServerTasks() {
	m._ServerTasks = nil
	m.cleared_ServerTasks = false
	m.removed_ServerTasks = nil
}

// Where appends a list predicates to the AuthUserMutation builder.
func (m *AuthUserMutation) Where(ps ...predicate.AuthUser) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AuthUserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AuthUser).
func (m *AuthUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthUserMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.username != nil {
		fields = append(fields, authuser.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, authuser.FieldPassword)
	}
	if m.first_name != nil {
		fields = append(fields, authuser.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, authuser.FieldLastName)
	}
	if m.email != nil {
		fields = append(fields, authuser.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, authuser.FieldPhone)
	}
	if m.company != nil {
		fields = append(fields, authuser.FieldCompany)
	}
	if m.occupation != nil {
		fields = append(fields, authuser.FieldOccupation)
	}
	if m.private_key_path != nil {
		fields = append(fields, authuser.FieldPrivateKeyPath)
	}
	if m.role != nil {
		fields = append(fields, authuser.FieldRole)
	}
	if m.provider != nil {
		fields = append(fields, authuser.FieldProvider)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authuser.FieldUsername:
		return m.Username()
	case authuser.FieldPassword:
		return m.Password()
	case authuser.FieldFirstName:
		return m.FirstName()
	case authuser.FieldLastName:
		return m.LastName()
	case authuser.FieldEmail:
		return m.Email()
	case authuser.FieldPhone:
		return m.Phone()
	case authuser.FieldCompany:
		return m.Company()
	case authuser.FieldOccupation:
		return m.Occupation()
	case authuser.FieldPrivateKeyPath:
		return m.PrivateKeyPath()
	case authuser.FieldRole:
		return m.Role()
	case authuser.FieldProvider:
		return m.Provider()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authuser.FieldUsername:
		return m.OldUsername(ctx)
	case authuser.FieldPassword:
		return m.OldPassword(ctx)
	case authuser.FieldFirstName:
		return m.OldFirstName(ctx)
	case authuser.FieldLastName:
		return m.OldLastName(ctx)
	case authuser.FieldEmail:
		return m.OldEmail(ctx)
	case authuser.FieldPhone:
		return m.OldPhone(ctx)
	case authuser.FieldCompany:
		return m.OldCompany(ctx)
	case authuser.FieldOccupation:
		return m.OldOccupation(ctx)
	case authuser.FieldPrivateKeyPath:
		return m.OldPrivateKeyPath(ctx)
	case authuser.FieldRole:
		return m.OldRole(ctx)
	case authuser.FieldProvider:
		return m.OldProvider(ctx)
	}
	return nil, fmt.Errorf("unknown AuthUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authuser.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case authuser.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case authuser.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case authuser.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case authuser.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case authuser.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case authuser.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case authuser.FieldOccupation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOccupation(v)
		return nil
	case authuser.FieldPrivateKeyPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivateKeyPath(v)
		return nil
	case authuser.FieldRole:
		v, ok := value.(authuser.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case authuser.FieldProvider:
		v, ok := value.(authuser.Provider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	}
	return fmt.Errorf("unknown AuthUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthUserMutation) ResetField(name string) error {
	switch name {
	case authuser.FieldUsername:
		m.ResetUsername()
		return nil
	case authuser.FieldPassword:
		m.ResetPassword()
		return nil
	case authuser.FieldFirstName:
		m.ResetFirstName()
		return nil
	case authuser.FieldLastName:
		m.ResetLastName()
		return nil
	case authuser.FieldEmail:
		m.ResetEmail()
		return nil
	case authuser.FieldPhone:
		m.ResetPhone()
		return nil
	case authuser.FieldCompany:
		m.ResetCompany()
		return nil
	case authuser.FieldOccupation:
		m.ResetOccupation()
		return nil
	case authuser.FieldPrivateKeyPath:
		m.ResetPrivateKeyPath()
		return nil
	case authuser.FieldRole:
		m.ResetRole()
		return nil
	case authuser.FieldProvider:
		m.ResetProvider()
		return nil
	}
	return fmt.Errorf("unknown AuthUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._Tokens != nil {
		edges = append(edges, authuser.EdgeTokens)
	}
	if m._ServerTasks != nil {
		edges = append(edges, authuser.EdgeServerTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authuser.EdgeTokens:
		ids := make([]ent.Value, 0, len(m._Tokens))
		for id := range m._Tokens {
			ids = append(ids, id)
		}
		return ids
	case authuser.EdgeServerTasks:
		ids := make([]ent.Value, 0, len(m._ServerTasks))
		for id := range m._ServerTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_Tokens != nil {
		edges = append(edges, authuser.EdgeTokens)
	}
	if m.removed_ServerTasks != nil {
		edges = append(edges, authuser.EdgeServerTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case authuser.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.removed_Tokens))
		for id := range m.removed_Tokens {
			ids = append(ids, id)
		}
		return ids
	case authuser.EdgeServerTasks:
		ids := make([]ent.Value, 0, len(m.removed_ServerTasks))
		for id := range m.removed_ServerTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_Tokens {
		edges = append(edges, authuser.EdgeTokens)
	}
	if m.cleared_ServerTasks {
		edges = append(edges, authuser.EdgeServerTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthUserMutation) EdgeCleared(name string) bool {
	switch name {
	case authuser.EdgeTokens:
		return m.cleared_Tokens
	case authuser.EdgeServerTasks:
		return m.cleared_ServerTasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthUserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthUserMutation) ResetEdge(name string) error {
	switch name {
	case authuser.EdgeTokens:
		m.ResetTokens()
		return nil
	case authuser.EdgeServerTasks:
		m.ResetServerTasks()
		return nil
	}
	return fmt.Errorf("unknown AuthUser edge %s", name)
}

// BuildMutation represents an operation that mutates the Build nodes in the graph.
type BuildMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uuid.UUID
	revision                    *int
	addrevision                 *int
	environment_revision        *int
	addenvironment_revision     *int
	vars                        *map[string]string
	completed_plan              *bool
	clearedFields               map[string]struct{}
	_Status                     *uuid.UUID
	cleared_Status              bool
	_Environment                *uuid.UUID
	cleared_Environment         bool
	_Competition                *uuid.UUID
	cleared_Competition         bool
	_LatestBuildCommit          *uuid.UUID
	cleared_LatestBuildCommit   bool
	_RepoCommit                 *uuid.UUID
	cleared_RepoCommit          bool
	_ProvisionedNetworks        map[uuid.UUID]struct{}
	removed_ProvisionedNetworks map[uuid.UUID]struct{}
	cleared_ProvisionedNetworks bool
	_Teams                      map[uuid.UUID]struct{}
	removed_Teams               map[uuid.UUID]struct{}
	cleared_Teams               bool
	_Plans                      map[uuid.UUID]struct{}
	removed_Plans               map[uuid.UUID]struct{}
	cleared_Plans               bool
	_BuildCommits               map[uuid.UUID]struct{}
	removed_BuildCommits        map[uuid.UUID]struct{}
	cleared_BuildCommits        bool
	_AdhocPlans                 map[uuid.UUID]struct{}
	removed_AdhocPlans          map[uuid.UUID]struct{}
	cleared_AdhocPlans          bool
	_AgentStatuses              map[uuid.UUID]struct{}
	removed_AgentStatuses       map[uuid.UUID]struct{}
	cleared_AgentStatuses       bool
	_ServerTasks                map[uuid.UUID]struct{}
	removed_ServerTasks         map[uuid.UUID]struct{}
	cleared_ServerTasks         bool
	done                        bool
	oldValue                    func(context.Context) (*Build, error)
	predicates                  []predicate.Build
}

var _ ent.Mutation = (*BuildMutation)(nil)

// buildOption allows management of the mutation configuration using functional options.
type buildOption func(*BuildMutation)

// newBuildMutation creates new mutation for the Build entity.
func newBuildMutation(c config, op Op, opts ...buildOption) *BuildMutation {
	m := &BuildMutation{
		config:        c,
		op:            op,
		typ:           TypeBuild,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBuildID sets the ID field of the mutation.
func withBuildID(id uuid.UUID) buildOption {
	return func(m *BuildMutation) {
		var (
			err   error
			once  sync.Once
			value *Build
		)
		m.oldValue = func(ctx context.Context) (*Build, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Build.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBuild sets the old Build of the mutation.
func withBuild(node *Build) buildOption {
	return func(m *BuildMutation) {
		m.oldValue = func(context.Context) (*Build, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BuildMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BuildMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Build entities.
func (m *BuildMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BuildMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BuildMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Build.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRevision sets the "revision" field.
func (m *BuildMutation) SetRevision(i int) {
	m.revision = &i
	m.addrevision = nil
}

// Revision returns the value of the "revision" field in the mutation.
func (m *BuildMutation) Revision() (r int, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the Build entity.
// If the Build object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildMutation) OldRevision(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// AddRevision adds i to the "revision" field.
func (m *BuildMutation) AddRevision(i int) {
	if m.addrevision != nil {
		*m.addrevision += i
	} else {
		m.addrevision = &i
	}
}

// AddedRevision returns the value that was added to the "revision" field in this mutation.
func (m *BuildMutation) AddedRevision() (r int, exists bool) {
	v := m.addrevision
	if v == nil {
		return
	}
	return *v, true
}

// ResetRevision resets all changes to the "revision" field.
func (m *BuildMutation) ResetRevision() {
	m.revision = nil
	m.addrevision = nil
}

// SetEnvironmentRevision sets the "environment_revision" field.
func (m *BuildMutation) SetEnvironmentRevision(i int) {
	m.environment_revision = &i
	m.addenvironment_revision = nil
}

// EnvironmentRevision returns the value of the "environment_revision" field in the mutation.
func (m *BuildMutation) EnvironmentRevision() (r int, exists bool) {
	v := m.environment_revision
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvironmentRevision returns the old "environment_revision" field's value of the Build entity.
// If the Build object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildMutation) OldEnvironmentRevision(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvironmentRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvironmentRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvironmentRevision: %w", err)
	}
	return oldValue.EnvironmentRevision, nil
}

// AddEnvironmentRevision adds i to the "environment_revision" field.
func (m *BuildMutation) AddEnvironmentRevision(i int) {
	if m.addenvironment_revision != nil {
		*m.addenvironment_revision += i
	} else {
		m.addenvironment_revision = &i
	}
}

// AddedEnvironmentRevision returns the value that was added to the "environment_revision" field in this mutation.
func (m *BuildMutation) AddedEnvironmentRevision() (r int, exists bool) {
	v := m.addenvironment_revision
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnvironmentRevision resets all changes to the "environment_revision" field.
func (m *BuildMutation) ResetEnvironmentRevision() {
	m.environment_revision = nil
	m.addenvironment_revision = nil
}

// SetVars sets the "vars" field.
func (m *BuildMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *BuildMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the Build entity.
// If the Build object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *BuildMutation) ResetVars() {
	m.vars = nil
}

// SetCompletedPlan sets the "completed_plan" field.
func (m *BuildMutation) SetCompletedPlan(b bool) {
	m.completed_plan = &b
}

// CompletedPlan returns the value of the "completed_plan" field in the mutation.
func (m *BuildMutation) CompletedPlan() (r bool, exists bool) {
	v := m.completed_plan
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedPlan returns the old "completed_plan" field's value of the Build entity.
// If the Build object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildMutation) OldCompletedPlan(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedPlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedPlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedPlan: %w", err)
	}
	return oldValue.CompletedPlan, nil
}

// ResetCompletedPlan resets all changes to the "completed_plan" field.
func (m *BuildMutation) ResetCompletedPlan() {
	m.completed_plan = nil
}

// SetStatusID sets the "Status" edge to the Status entity by id.
func (m *BuildMutation) SetStatusID(id uuid.UUID) {
	m._Status = &id
}

// ClearStatus clears the "Status" edge to the Status entity.
func (m *BuildMutation) ClearStatus() {
	m.cleared_Status = true
}

// StatusCleared reports if the "Status" edge to the Status entity was cleared.
func (m *BuildMutation) StatusCleared() bool {
	return m.cleared_Status
}

// StatusID returns the "Status" edge ID in the mutation.
func (m *BuildMutation) StatusID() (id uuid.UUID, exists bool) {
	if m._Status != nil {
		return *m._Status, true
	}
	return
}

// StatusIDs returns the "Status" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusID instead. It exists only for internal usage by the builders.
func (m *BuildMutation) StatusIDs() (ids []uuid.UUID) {
	if id := m._Status; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatus resets all changes to the "Status" edge.
func (m *BuildMutation) ResetStatus() {
	m._Status = nil
	m.cleared_Status = false
}

// SetEnvironmentID sets the "Environment" edge to the Environment entity by id.
func (m *BuildMutation) SetEnvironmentID(id uuid.UUID) {
	m._Environment = &id
}

// ClearEnvironment clears the "Environment" edge to the Environment entity.
func (m *BuildMutation) ClearEnvironment() {
	m.cleared_Environment = true
}

// EnvironmentCleared reports if the "Environment" edge to the Environment entity was cleared.
func (m *BuildMutation) EnvironmentCleared() bool {
	return m.cleared_Environment
}

// EnvironmentID returns the "Environment" edge ID in the mutation.
func (m *BuildMutation) EnvironmentID() (id uuid.UUID, exists bool) {
	if m._Environment != nil {
		return *m._Environment, true
	}
	return
}

// EnvironmentIDs returns the "Environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *BuildMutation) EnvironmentIDs() (ids []uuid.UUID) {
	if id := m._Environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "Environment" edge.
func (m *BuildMutation) ResetEnvironment() {
	m._Environment = nil
	m.cleared_Environment = false
}

// SetCompetitionID sets the "Competition" edge to the Competition entity by id.
func (m *BuildMutation) SetCompetitionID(id uuid.UUID) {
	m._Competition = &id
}

// ClearCompetition clears the "Competition" edge to the Competition entity.
func (m *BuildMutation) ClearCompetition() {
	m.cleared_Competition = true
}

// CompetitionCleared reports if the "Competition" edge to the Competition entity was cleared.
func (m *BuildMutation) CompetitionCleared() bool {
	return m.cleared_Competition
}

// CompetitionID returns the "Competition" edge ID in the mutation.
func (m *BuildMutation) CompetitionID() (id uuid.UUID, exists bool) {
	if m._Competition != nil {
		return *m._Competition, true
	}
	return
}

// CompetitionIDs returns the "Competition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompetitionID instead. It exists only for internal usage by the builders.
func (m *BuildMutation) CompetitionIDs() (ids []uuid.UUID) {
	if id := m._Competition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompetition resets all changes to the "Competition" edge.
func (m *BuildMutation) ResetCompetition() {
	m._Competition = nil
	m.cleared_Competition = false
}

// SetLatestBuildCommitID sets the "LatestBuildCommit" edge to the BuildCommit entity by id.
func (m *BuildMutation) SetLatestBuildCommitID(id uuid.UUID) {
	m._LatestBuildCommit = &id
}

// ClearLatestBuildCommit clears the "LatestBuildCommit" edge to the BuildCommit entity.
func (m *BuildMutation) ClearLatestBuildCommit() {
	m.cleared_LatestBuildCommit = true
}

// LatestBuildCommitCleared reports if the "LatestBuildCommit" edge to the BuildCommit entity was cleared.
func (m *BuildMutation) LatestBuildCommitCleared() bool {
	return m.cleared_LatestBuildCommit
}

// LatestBuildCommitID returns the "LatestBuildCommit" edge ID in the mutation.
func (m *BuildMutation) LatestBuildCommitID() (id uuid.UUID, exists bool) {
	if m._LatestBuildCommit != nil {
		return *m._LatestBuildCommit, true
	}
	return
}

// LatestBuildCommitIDs returns the "LatestBuildCommit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LatestBuildCommitID instead. It exists only for internal usage by the builders.
func (m *BuildMutation) LatestBuildCommitIDs() (ids []uuid.UUID) {
	if id := m._LatestBuildCommit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLatestBuildCommit resets all changes to the "LatestBuildCommit" edge.
func (m *BuildMutation) ResetLatestBuildCommit() {
	m._LatestBuildCommit = nil
	m.cleared_LatestBuildCommit = false
}

// SetRepoCommitID sets the "RepoCommit" edge to the RepoCommit entity by id.
func (m *BuildMutation) SetRepoCommitID(id uuid.UUID) {
	m._RepoCommit = &id
}

// ClearRepoCommit clears the "RepoCommit" edge to the RepoCommit entity.
func (m *BuildMutation) ClearRepoCommit() {
	m.cleared_RepoCommit = true
}

// RepoCommitCleared reports if the "RepoCommit" edge to the RepoCommit entity was cleared.
func (m *BuildMutation) RepoCommitCleared() bool {
	return m.cleared_RepoCommit
}

// RepoCommitID returns the "RepoCommit" edge ID in the mutation.
func (m *BuildMutation) RepoCommitID() (id uuid.UUID, exists bool) {
	if m._RepoCommit != nil {
		return *m._RepoCommit, true
	}
	return
}

// RepoCommitIDs returns the "RepoCommit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RepoCommitID instead. It exists only for internal usage by the builders.
func (m *BuildMutation) RepoCommitIDs() (ids []uuid.UUID) {
	if id := m._RepoCommit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepoCommit resets all changes to the "RepoCommit" edge.
func (m *BuildMutation) ResetRepoCommit() {
	m._RepoCommit = nil
	m.cleared_RepoCommit = false
}

// AddProvisionedNetworkIDs adds the "ProvisionedNetworks" edge to the ProvisionedNetwork entity by ids.
func (m *BuildMutation) AddProvisionedNetworkIDs(ids ...uuid.UUID) {
	if m._ProvisionedNetworks == nil {
		m._ProvisionedNetworks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ProvisionedNetworks[ids[i]] = struct{}{}
	}
}

// ClearProvisionedNetworks clears the "ProvisionedNetworks" edge to the ProvisionedNetwork entity.
func (m *BuildMutation) ClearProvisionedNetworks() {
	m.cleared_ProvisionedNetworks = true
}

// ProvisionedNetworksCleared reports if the "ProvisionedNetworks" edge to the ProvisionedNetwork entity was cleared.
func (m *BuildMutation) ProvisionedNetworksCleared() bool {
	return m.cleared_ProvisionedNetworks
}

// RemoveProvisionedNetworkIDs removes the "ProvisionedNetworks" edge to the ProvisionedNetwork entity by IDs.
func (m *BuildMutation) RemoveProvisionedNetworkIDs(ids ...uuid.UUID) {
	if m.removed_ProvisionedNetworks == nil {
		m.removed_ProvisionedNetworks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._ProvisionedNetworks, ids[i])
		m.removed_ProvisionedNetworks[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedNetworks returns the removed IDs of the "ProvisionedNetworks" edge to the ProvisionedNetwork entity.
func (m *BuildMutation) RemovedProvisionedNetworksIDs() (ids []uuid.UUID) {
	for id := range m.removed_ProvisionedNetworks {
		ids = append(ids, id)
	}
	return
}

// ProvisionedNetworksIDs returns the "ProvisionedNetworks" edge IDs in the mutation.
func (m *BuildMutation) ProvisionedNetworksIDs() (ids []uuid.UUID) {
	for id := range m._ProvisionedNetworks {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedNetworks resets all changes to the "ProvisionedNetworks" edge.
func (m *BuildMutation) ResetProvisionedNetworks() {
	m._ProvisionedNetworks = nil
	m.cleared_ProvisionedNetworks = false
	m.removed_ProvisionedNetworks = nil
}

// AddTeamIDs adds the "Teams" edge to the Team entity by ids.
func (m *BuildMutation) AddTeamIDs(ids ...uuid.UUID) {
	if m._Teams == nil {
		m._Teams = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "Teams" edge to the Team entity.
func (m *BuildMutation) ClearTeams() {
	m.cleared_Teams = true
}

// TeamsCleared reports if the "Teams" edge to the Team entity was cleared.
func (m *BuildMutation) TeamsCleared() bool {
	return m.cleared_Teams
}

// RemoveTeamIDs removes the "Teams" edge to the Team entity by IDs.
func (m *BuildMutation) RemoveTeamIDs(ids ...uuid.UUID) {
	if m.removed_Teams == nil {
		m.removed_Teams = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Teams, ids[i])
		m.removed_Teams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "Teams" edge to the Team entity.
func (m *BuildMutation) RemovedTeamsIDs() (ids []uuid.UUID) {
	for id := range m.removed_Teams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "Teams" edge IDs in the mutation.
func (m *BuildMutation) TeamsIDs() (ids []uuid.UUID) {
	for id := range m._Teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "Teams" edge.
func (m *BuildMutation) ResetTeams() {
	m._Teams = nil
	m.cleared_Teams = false
	m.removed_Teams = nil
}

// AddPlanIDs adds the "Plans" edge to the Plan entity by ids.
func (m *BuildMutation) AddPlanIDs(ids ...uuid.UUID) {
	if m._Plans == nil {
		m._Plans = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Plans[ids[i]] = struct{}{}
	}
}

// ClearPlans clears the "Plans" edge to the Plan entity.
func (m *BuildMutation) ClearPlans() {
	m.cleared_Plans = true
}

// PlansCleared reports if the "Plans" edge to the Plan entity was cleared.
func (m *BuildMutation) PlansCleared() bool {
	return m.cleared_Plans
}

// RemovePlanIDs removes the "Plans" edge to the Plan entity by IDs.
func (m *BuildMutation) RemovePlanIDs(ids ...uuid.UUID) {
	if m.removed_Plans == nil {
		m.removed_Plans = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Plans, ids[i])
		m.removed_Plans[ids[i]] = struct{}{}
	}
}

// RemovedPlans returns the removed IDs of the "Plans" edge to the Plan entity.
func (m *BuildMutation) RemovedPlansIDs() (ids []uuid.UUID) {
	for id := range m.removed_Plans {
		ids = append(ids, id)
	}
	return
}

// PlansIDs returns the "Plans" edge IDs in the mutation.
func (m *BuildMutation) PlansIDs() (ids []uuid.UUID) {
	for id := range m._Plans {
		ids = append(ids, id)
	}
	return
}

// ResetPlans resets all changes to the "Plans" edge.
func (m *BuildMutation) ResetPlans() {
	m._Plans = nil
	m.cleared_Plans = false
	m.removed_Plans = nil
}

// AddBuildCommitIDs adds the "BuildCommits" edge to the BuildCommit entity by ids.
func (m *BuildMutation) AddBuildCommitIDs(ids ...uuid.UUID) {
	if m._BuildCommits == nil {
		m._BuildCommits = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._BuildCommits[ids[i]] = struct{}{}
	}
}

// ClearBuildCommits clears the "BuildCommits" edge to the BuildCommit entity.
func (m *BuildMutation) ClearBuildCommits() {
	m.cleared_BuildCommits = true
}

// BuildCommitsCleared reports if the "BuildCommits" edge to the BuildCommit entity was cleared.
func (m *BuildMutation) BuildCommitsCleared() bool {
	return m.cleared_BuildCommits
}

// RemoveBuildCommitIDs removes the "BuildCommits" edge to the BuildCommit entity by IDs.
func (m *BuildMutation) RemoveBuildCommitIDs(ids ...uuid.UUID) {
	if m.removed_BuildCommits == nil {
		m.removed_BuildCommits = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._BuildCommits, ids[i])
		m.removed_BuildCommits[ids[i]] = struct{}{}
	}
}

// RemovedBuildCommits returns the removed IDs of the "BuildCommits" edge to the BuildCommit entity.
func (m *BuildMutation) RemovedBuildCommitsIDs() (ids []uuid.UUID) {
	for id := range m.removed_BuildCommits {
		ids = append(ids, id)
	}
	return
}

// BuildCommitsIDs returns the "BuildCommits" edge IDs in the mutation.
func (m *BuildMutation) BuildCommitsIDs() (ids []uuid.UUID) {
	for id := range m._BuildCommits {
		ids = append(ids, id)
	}
	return
}

// ResetBuildCommits resets all changes to the "BuildCommits" edge.
func (m *BuildMutation) ResetBuildCommits() {
	m._BuildCommits = nil
	m.cleared_BuildCommits = false
	m.removed_BuildCommits = nil
}

// AddAdhocPlanIDs adds the "AdhocPlans" edge to the AdhocPlan entity by ids.
func (m *BuildMutation) AddAdhocPlanIDs(ids ...uuid.UUID) {
	if m._AdhocPlans == nil {
		m._AdhocPlans = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._AdhocPlans[ids[i]] = struct{}{}
	}
}

// ClearAdhocPlans clears the "AdhocPlans" edge to the AdhocPlan entity.
func (m *BuildMutation) ClearAdhocPlans() {
	m.cleared_AdhocPlans = true
}

// AdhocPlansCleared reports if the "AdhocPlans" edge to the AdhocPlan entity was cleared.
func (m *BuildMutation) AdhocPlansCleared() bool {
	return m.cleared_AdhocPlans
}

// RemoveAdhocPlanIDs removes the "AdhocPlans" edge to the AdhocPlan entity by IDs.
func (m *BuildMutation) RemoveAdhocPlanIDs(ids ...uuid.UUID) {
	if m.removed_AdhocPlans == nil {
		m.removed_AdhocPlans = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._AdhocPlans, ids[i])
		m.removed_AdhocPlans[ids[i]] = struct{}{}
	}
}

// RemovedAdhocPlans returns the removed IDs of the "AdhocPlans" edge to the AdhocPlan entity.
func (m *BuildMutation) RemovedAdhocPlansIDs() (ids []uuid.UUID) {
	for id := range m.removed_AdhocPlans {
		ids = append(ids, id)
	}
	return
}

// AdhocPlansIDs returns the "AdhocPlans" edge IDs in the mutation.
func (m *BuildMutation) AdhocPlansIDs() (ids []uuid.UUID) {
	for id := range m._AdhocPlans {
		ids = append(ids, id)
	}
	return
}

// ResetAdhocPlans resets all changes to the "AdhocPlans" edge.
func (m *BuildMutation) ResetAdhocPlans() {
	m._AdhocPlans = nil
	m.cleared_AdhocPlans = false
	m.removed_AdhocPlans = nil
}

// AddAgentStatuseIDs adds the "AgentStatuses" edge to the AgentStatus entity by ids.
func (m *BuildMutation) AddAgentStatuseIDs(ids ...uuid.UUID) {
	if m._AgentStatuses == nil {
		m._AgentStatuses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._AgentStatuses[ids[i]] = struct{}{}
	}
}

// ClearAgentStatuses clears the "AgentStatuses" edge to the AgentStatus entity.
func (m *BuildMutation) ClearAgentStatuses() {
	m.cleared_AgentStatuses = true
}

// AgentStatusesCleared reports if the "AgentStatuses" edge to the AgentStatus entity was cleared.
func (m *BuildMutation) AgentStatusesCleared() bool {
	return m.cleared_AgentStatuses
}

// RemoveAgentStatuseIDs removes the "AgentStatuses" edge to the AgentStatus entity by IDs.
func (m *BuildMutation) RemoveAgentStatuseIDs(ids ...uuid.UUID) {
	if m.removed_AgentStatuses == nil {
		m.removed_AgentStatuses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._AgentStatuses, ids[i])
		m.removed_AgentStatuses[ids[i]] = struct{}{}
	}
}

// RemovedAgentStatuses returns the removed IDs of the "AgentStatuses" edge to the AgentStatus entity.
func (m *BuildMutation) RemovedAgentStatusesIDs() (ids []uuid.UUID) {
	for id := range m.removed_AgentStatuses {
		ids = append(ids, id)
	}
	return
}

// AgentStatusesIDs returns the "AgentStatuses" edge IDs in the mutation.
func (m *BuildMutation) AgentStatusesIDs() (ids []uuid.UUID) {
	for id := range m._AgentStatuses {
		ids = append(ids, id)
	}
	return
}

// ResetAgentStatuses resets all changes to the "AgentStatuses" edge.
func (m *BuildMutation) ResetAgentStatuses() {
	m._AgentStatuses = nil
	m.cleared_AgentStatuses = false
	m.removed_AgentStatuses = nil
}

// AddServerTaskIDs adds the "ServerTasks" edge to the ServerTask entity by ids.
func (m *BuildMutation) AddServerTaskIDs(ids ...uuid.UUID) {
	if m._ServerTasks == nil {
		m._ServerTasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ServerTasks[ids[i]] = struct{}{}
	}
}

// ClearServerTasks clears the "ServerTasks" edge to the ServerTask entity.
func (m *BuildMutation) ClearServerTasks() {
	m.cleared_ServerTasks = true
}

// ServerTasksCleared reports if the "ServerTasks" edge to the ServerTask entity was cleared.
func (m *BuildMutation) ServerTasksCleared() bool {
	return m.cleared_ServerTasks
}

// RemoveServerTaskIDs removes the "ServerTasks" edge to the ServerTask entity by IDs.
func (m *BuildMutation) RemoveServerTaskIDs(ids ...uuid.UUID) {
	if m.removed_ServerTasks == nil {
		m.removed_ServerTasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._ServerTasks, ids[i])
		m.removed_ServerTasks[ids[i]] = struct{}{}
	}
}

// RemovedServerTasks returns the removed IDs of the "ServerTasks" edge to the ServerTask entity.
func (m *BuildMutation) RemovedServerTasksIDs() (ids []uuid.UUID) {
	for id := range m.removed_ServerTasks {
		ids = append(ids, id)
	}
	return
}

// ServerTasksIDs returns the "ServerTasks" edge IDs in the mutation.
func (m *BuildMutation) ServerTasksIDs() (ids []uuid.UUID) {
	for id := range m._ServerTasks {
		ids = append(ids, id)
	}
	return
}

// ResetServerTasks resets all changes to the "ServerTasks" edge.
func (m *BuildMutation) ResetServerTasks() {
	m._ServerTasks = nil
	m.cleared_ServerTasks = false
	m.removed_ServerTasks = nil
}

// Where appends a list predicates to the BuildMutation builder.
func (m *BuildMutation) Where(ps ...predicate.Build) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BuildMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Build).
func (m *BuildMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BuildMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.revision != nil {
		fields = append(fields, build.FieldRevision)
	}
	if m.environment_revision != nil {
		fields = append(fields, build.FieldEnvironmentRevision)
	}
	if m.vars != nil {
		fields = append(fields, build.FieldVars)
	}
	if m.completed_plan != nil {
		fields = append(fields, build.FieldCompletedPlan)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BuildMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case build.FieldRevision:
		return m.Revision()
	case build.FieldEnvironmentRevision:
		return m.EnvironmentRevision()
	case build.FieldVars:
		return m.Vars()
	case build.FieldCompletedPlan:
		return m.CompletedPlan()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BuildMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case build.FieldRevision:
		return m.OldRevision(ctx)
	case build.FieldEnvironmentRevision:
		return m.OldEnvironmentRevision(ctx)
	case build.FieldVars:
		return m.OldVars(ctx)
	case build.FieldCompletedPlan:
		return m.OldCompletedPlan(ctx)
	}
	return nil, fmt.Errorf("unknown Build field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuildMutation) SetField(name string, value ent.Value) error {
	switch name {
	case build.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case build.FieldEnvironmentRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvironmentRevision(v)
		return nil
	case build.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	case build.FieldCompletedPlan:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedPlan(v)
		return nil
	}
	return fmt.Errorf("unknown Build field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BuildMutation) AddedFields() []string {
	var fields []string
	if m.addrevision != nil {
		fields = append(fields, build.FieldRevision)
	}
	if m.addenvironment_revision != nil {
		fields = append(fields, build.FieldEnvironmentRevision)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BuildMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case build.FieldRevision:
		return m.AddedRevision()
	case build.FieldEnvironmentRevision:
		return m.AddedEnvironmentRevision()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuildMutation) AddField(name string, value ent.Value) error {
	switch name {
	case build.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevision(v)
		return nil
	case build.FieldEnvironmentRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnvironmentRevision(v)
		return nil
	}
	return fmt.Errorf("unknown Build numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BuildMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BuildMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BuildMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Build nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BuildMutation) ResetField(name string) error {
	switch name {
	case build.FieldRevision:
		m.ResetRevision()
		return nil
	case build.FieldEnvironmentRevision:
		m.ResetEnvironmentRevision()
		return nil
	case build.FieldVars:
		m.ResetVars()
		return nil
	case build.FieldCompletedPlan:
		m.ResetCompletedPlan()
		return nil
	}
	return fmt.Errorf("unknown Build field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BuildMutation) AddedEdges() []string {
	edges := make([]string, 0, 12)
	if m._Status != nil {
		edges = append(edges, build.EdgeStatus)
	}
	if m._Environment != nil {
		edges = append(edges, build.EdgeEnvironment)
	}
	if m._Competition != nil {
		edges = append(edges, build.EdgeCompetition)
	}
	if m._LatestBuildCommit != nil {
		edges = append(edges, build.EdgeLatestBuildCommit)
	}
	if m._RepoCommit != nil {
		edges = append(edges, build.EdgeRepoCommit)
	}
	if m._ProvisionedNetworks != nil {
		edges = append(edges, build.EdgeProvisionedNetworks)
	}
	if m._Teams != nil {
		edges = append(edges, build.EdgeTeams)
	}
	if m._Plans != nil {
		edges = append(edges, build.EdgePlans)
	}
	if m._BuildCommits != nil {
		edges = append(edges, build.EdgeBuildCommits)
	}
	if m._AdhocPlans != nil {
		edges = append(edges, build.EdgeAdhocPlans)
	}
	if m._AgentStatuses != nil {
		edges = append(edges, build.EdgeAgentStatuses)
	}
	if m._ServerTasks != nil {
		edges = append(edges, build.EdgeServerTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BuildMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case build.EdgeStatus:
		if id := m._Status; id != nil {
			return []ent.Value{*id}
		}
	case build.EdgeEnvironment:
		if id := m._Environment; id != nil {
			return []ent.Value{*id}
		}
	case build.EdgeCompetition:
		if id := m._Competition; id != nil {
			return []ent.Value{*id}
		}
	case build.EdgeLatestBuildCommit:
		if id := m._LatestBuildCommit; id != nil {
			return []ent.Value{*id}
		}
	case build.EdgeRepoCommit:
		if id := m._RepoCommit; id != nil {
			return []ent.Value{*id}
		}
	case build.EdgeProvisionedNetworks:
		ids := make([]ent.Value, 0, len(m._ProvisionedNetworks))
		for id := range m._ProvisionedNetworks {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeTeams:
		ids := make([]ent.Value, 0, len(m._Teams))
		for id := range m._Teams {
			ids = append(ids, id)
		}
		return ids
	case build.EdgePlans:
		ids := make([]ent.Value, 0, len(m._Plans))
		for id := range m._Plans {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeBuildCommits:
		ids := make([]ent.Value, 0, len(m._BuildCommits))
		for id := range m._BuildCommits {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeAdhocPlans:
		ids := make([]ent.Value, 0, len(m._AdhocPlans))
		for id := range m._AdhocPlans {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeAgentStatuses:
		ids := make([]ent.Value, 0, len(m._AgentStatuses))
		for id := range m._AgentStatuses {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeServerTasks:
		ids := make([]ent.Value, 0, len(m._ServerTasks))
		for id := range m._ServerTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BuildMutation) RemovedEdges() []string {
	edges := make([]string, 0, 12)
	if m.removed_ProvisionedNetworks != nil {
		edges = append(edges, build.EdgeProvisionedNetworks)
	}
	if m.removed_Teams != nil {
		edges = append(edges, build.EdgeTeams)
	}
	if m.removed_Plans != nil {
		edges = append(edges, build.EdgePlans)
	}
	if m.removed_BuildCommits != nil {
		edges = append(edges, build.EdgeBuildCommits)
	}
	if m.removed_AdhocPlans != nil {
		edges = append(edges, build.EdgeAdhocPlans)
	}
	if m.removed_AgentStatuses != nil {
		edges = append(edges, build.EdgeAgentStatuses)
	}
	if m.removed_ServerTasks != nil {
		edges = append(edges, build.EdgeServerTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BuildMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case build.EdgeProvisionedNetworks:
		ids := make([]ent.Value, 0, len(m.removed_ProvisionedNetworks))
		for id := range m.removed_ProvisionedNetworks {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removed_Teams))
		for id := range m.removed_Teams {
			ids = append(ids, id)
		}
		return ids
	case build.EdgePlans:
		ids := make([]ent.Value, 0, len(m.removed_Plans))
		for id := range m.removed_Plans {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeBuildCommits:
		ids := make([]ent.Value, 0, len(m.removed_BuildCommits))
		for id := range m.removed_BuildCommits {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeAdhocPlans:
		ids := make([]ent.Value, 0, len(m.removed_AdhocPlans))
		for id := range m.removed_AdhocPlans {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeAgentStatuses:
		ids := make([]ent.Value, 0, len(m.removed_AgentStatuses))
		for id := range m.removed_AgentStatuses {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeServerTasks:
		ids := make([]ent.Value, 0, len(m.removed_ServerTasks))
		for id := range m.removed_ServerTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BuildMutation) ClearedEdges() []string {
	edges := make([]string, 0, 12)
	if m.cleared_Status {
		edges = append(edges, build.EdgeStatus)
	}
	if m.cleared_Environment {
		edges = append(edges, build.EdgeEnvironment)
	}
	if m.cleared_Competition {
		edges = append(edges, build.EdgeCompetition)
	}
	if m.cleared_LatestBuildCommit {
		edges = append(edges, build.EdgeLatestBuildCommit)
	}
	if m.cleared_RepoCommit {
		edges = append(edges, build.EdgeRepoCommit)
	}
	if m.cleared_ProvisionedNetworks {
		edges = append(edges, build.EdgeProvisionedNetworks)
	}
	if m.cleared_Teams {
		edges = append(edges, build.EdgeTeams)
	}
	if m.cleared_Plans {
		edges = append(edges, build.EdgePlans)
	}
	if m.cleared_BuildCommits {
		edges = append(edges, build.EdgeBuildCommits)
	}
	if m.cleared_AdhocPlans {
		edges = append(edges, build.EdgeAdhocPlans)
	}
	if m.cleared_AgentStatuses {
		edges = append(edges, build.EdgeAgentStatuses)
	}
	if m.cleared_ServerTasks {
		edges = append(edges, build.EdgeServerTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BuildMutation) EdgeCleared(name string) bool {
	switch name {
	case build.EdgeStatus:
		return m.cleared_Status
	case build.EdgeEnvironment:
		return m.cleared_Environment
	case build.EdgeCompetition:
		return m.cleared_Competition
	case build.EdgeLatestBuildCommit:
		return m.cleared_LatestBuildCommit
	case build.EdgeRepoCommit:
		return m.cleared_RepoCommit
	case build.EdgeProvisionedNetworks:
		return m.cleared_ProvisionedNetworks
	case build.EdgeTeams:
		return m.cleared_Teams
	case build.EdgePlans:
		return m.cleared_Plans
	case build.EdgeBuildCommits:
		return m.cleared_BuildCommits
	case build.EdgeAdhocPlans:
		return m.cleared_AdhocPlans
	case build.EdgeAgentStatuses:
		return m.cleared_AgentStatuses
	case build.EdgeServerTasks:
		return m.cleared_ServerTasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BuildMutation) ClearEdge(name string) error {
	switch name {
	case build.EdgeStatus:
		m.ClearStatus()
		return nil
	case build.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	case build.EdgeCompetition:
		m.ClearCompetition()
		return nil
	case build.EdgeLatestBuildCommit:
		m.ClearLatestBuildCommit()
		return nil
	case build.EdgeRepoCommit:
		m.ClearRepoCommit()
		return nil
	}
	return fmt.Errorf("unknown Build unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BuildMutation) ResetEdge(name string) error {
	switch name {
	case build.EdgeStatus:
		m.ResetStatus()
		return nil
	case build.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	case build.EdgeCompetition:
		m.ResetCompetition()
		return nil
	case build.EdgeLatestBuildCommit:
		m.ResetLatestBuildCommit()
		return nil
	case build.EdgeRepoCommit:
		m.ResetRepoCommit()
		return nil
	case build.EdgeProvisionedNetworks:
		m.ResetProvisionedNetworks()
		return nil
	case build.EdgeTeams:
		m.ResetTeams()
		return nil
	case build.EdgePlans:
		m.ResetPlans()
		return nil
	case build.EdgeBuildCommits:
		m.ResetBuildCommits()
		return nil
	case build.EdgeAdhocPlans:
		m.ResetAdhocPlans()
		return nil
	case build.EdgeAgentStatuses:
		m.ResetAgentStatuses()
		return nil
	case build.EdgeServerTasks:
		m.ResetServerTasks()
		return nil
	}
	return fmt.Errorf("unknown Build edge %s", name)
}

// BuildCommitMutation represents an operation that mutates the BuildCommit nodes in the graph.
type BuildCommitMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	_type               *buildcommit.Type
	revision            *int
	addrevision         *int
	state               *buildcommit.State
	created_at          *time.Time
	clearedFields       map[string]struct{}
	_Build              *uuid.UUID
	cleared_Build       bool
	_ServerTasks        map[uuid.UUID]struct{}
	removed_ServerTasks map[uuid.UUID]struct{}
	cleared_ServerTasks bool
	_PlanDiffs          map[uuid.UUID]struct{}
	removed_PlanDiffs   map[uuid.UUID]struct{}
	cleared_PlanDiffs   bool
	done                bool
	oldValue            func(context.Context) (*BuildCommit, error)
	predicates          []predicate.BuildCommit
}

var _ ent.Mutation = (*BuildCommitMutation)(nil)

// buildcommitOption allows management of the mutation configuration using functional options.
type buildcommitOption func(*BuildCommitMutation)

// newBuildCommitMutation creates new mutation for the BuildCommit entity.
func newBuildCommitMutation(c config, op Op, opts ...buildcommitOption) *BuildCommitMutation {
	m := &BuildCommitMutation{
		config:        c,
		op:            op,
		typ:           TypeBuildCommit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBuildCommitID sets the ID field of the mutation.
func withBuildCommitID(id uuid.UUID) buildcommitOption {
	return func(m *BuildCommitMutation) {
		var (
			err   error
			once  sync.Once
			value *BuildCommit
		)
		m.oldValue = func(ctx context.Context) (*BuildCommit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BuildCommit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBuildCommit sets the old BuildCommit of the mutation.
func withBuildCommit(node *BuildCommit) buildcommitOption {
	return func(m *BuildCommitMutation) {
		m.oldValue = func(context.Context) (*BuildCommit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BuildCommitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BuildCommitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BuildCommit entities.
func (m *BuildCommitMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BuildCommitMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BuildCommitMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BuildCommit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *BuildCommitMutation) SetType(b buildcommit.Type) {
	m._type = &b
}

// GetType returns the value of the "type" field in the mutation.
func (m *BuildCommitMutation) GetType() (r buildcommit.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the BuildCommit entity.
// If the BuildCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildCommitMutation) OldType(ctx context.Context) (v buildcommit.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *BuildCommitMutation) ResetType() {
	m._type = nil
}

// SetRevision sets the "revision" field.
func (m *BuildCommitMutation) SetRevision(i int) {
	m.revision = &i
	m.addrevision = nil
}

// Revision returns the value of the "revision" field in the mutation.
func (m *BuildCommitMutation) Revision() (r int, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the BuildCommit entity.
// If the BuildCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildCommitMutation) OldRevision(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// AddRevision adds i to the "revision" field.
func (m *BuildCommitMutation) AddRevision(i int) {
	if m.addrevision != nil {
		*m.addrevision += i
	} else {
		m.addrevision = &i
	}
}

// AddedRevision returns the value that was added to the "revision" field in this mutation.
func (m *BuildCommitMutation) AddedRevision() (r int, exists bool) {
	v := m.addrevision
	if v == nil {
		return
	}
	return *v, true
}

// ResetRevision resets all changes to the "revision" field.
func (m *BuildCommitMutation) ResetRevision() {
	m.revision = nil
	m.addrevision = nil
}

// SetState sets the "state" field.
func (m *BuildCommitMutation) SetState(b buildcommit.State) {
	m.state = &b
}

// State returns the value of the "state" field in the mutation.
func (m *BuildCommitMutation) State() (r buildcommit.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the BuildCommit entity.
// If the BuildCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildCommitMutation) OldState(ctx context.Context) (v buildcommit.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *BuildCommitMutation) ResetState() {
	m.state = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BuildCommitMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BuildCommitMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BuildCommit entity.
// If the BuildCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildCommitMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BuildCommitMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetBuildID sets the "Build" edge to the Build entity by id.
func (m *BuildCommitMutation) SetBuildID(id uuid.UUID) {
	m._Build = &id
}

// ClearBuild clears the "Build" edge to the Build entity.
func (m *BuildCommitMutation) ClearBuild() {
	m.cleared_Build = true
}

// BuildCleared reports if the "Build" edge to the Build entity was cleared.
func (m *BuildCommitMutation) BuildCleared() bool {
	return m.cleared_Build
}

// BuildID returns the "Build" edge ID in the mutation.
func (m *BuildCommitMutation) BuildID() (id uuid.UUID, exists bool) {
	if m._Build != nil {
		return *m._Build, true
	}
	return
}

// BuildIDs returns the "Build" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuildID instead. It exists only for internal usage by the builders.
func (m *BuildCommitMutation) BuildIDs() (ids []uuid.UUID) {
	if id := m._Build; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuild resets all changes to the "Build" edge.
func (m *BuildCommitMutation) ResetBuild() {
	m._Build = nil
	m.cleared_Build = false
}

// AddServerTaskIDs adds the "ServerTasks" edge to the ServerTask entity by ids.
func (m *BuildCommitMutation) AddServerTaskIDs(ids ...uuid.UUID) {
	if m._ServerTasks == nil {
		m._ServerTasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ServerTasks[ids[i]] = struct{}{}
	}
}

// ClearServerTasks clears the "ServerTasks" edge to the ServerTask entity.
func (m *BuildCommitMutation) ClearServerTasks() {
	m.cleared_ServerTasks = true
}

// ServerTasksCleared reports if the "ServerTasks" edge to the ServerTask entity was cleared.
func (m *BuildCommitMutation) ServerTasksCleared() bool {
	return m.cleared_ServerTasks
}

// RemoveServerTaskIDs removes the "ServerTasks" edge to the ServerTask entity by IDs.
func (m *BuildCommitMutation) RemoveServerTaskIDs(ids ...uuid.UUID) {
	if m.removed_ServerTasks == nil {
		m.removed_ServerTasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._ServerTasks, ids[i])
		m.removed_ServerTasks[ids[i]] = struct{}{}
	}
}

// RemovedServerTasks returns the removed IDs of the "ServerTasks" edge to the ServerTask entity.
func (m *BuildCommitMutation) RemovedServerTasksIDs() (ids []uuid.UUID) {
	for id := range m.removed_ServerTasks {
		ids = append(ids, id)
	}
	return
}

// ServerTasksIDs returns the "ServerTasks" edge IDs in the mutation.
func (m *BuildCommitMutation) ServerTasksIDs() (ids []uuid.UUID) {
	for id := range m._ServerTasks {
		ids = append(ids, id)
	}
	return
}

// ResetServerTasks resets all changes to the "ServerTasks" edge.
func (m *BuildCommitMutation) ResetServerTasks() {
	m._ServerTasks = nil
	m.cleared_ServerTasks = false
	m.removed_ServerTasks = nil
}

// AddPlanDiffIDs adds the "PlanDiffs" edge to the PlanDiff entity by ids.
func (m *BuildCommitMutation) AddPlanDiffIDs(ids ...uuid.UUID) {
	if m._PlanDiffs == nil {
		m._PlanDiffs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._PlanDiffs[ids[i]] = struct{}{}
	}
}

// ClearPlanDiffs clears the "PlanDiffs" edge to the PlanDiff entity.
func (m *BuildCommitMutation) ClearPlanDiffs() {
	m.cleared_PlanDiffs = true
}

// PlanDiffsCleared reports if the "PlanDiffs" edge to the PlanDiff entity was cleared.
func (m *BuildCommitMutation) PlanDiffsCleared() bool {
	return m.cleared_PlanDiffs
}

// RemovePlanDiffIDs removes the "PlanDiffs" edge to the PlanDiff entity by IDs.
func (m *BuildCommitMutation) RemovePlanDiffIDs(ids ...uuid.UUID) {
	if m.removed_PlanDiffs == nil {
		m.removed_PlanDiffs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._PlanDiffs, ids[i])
		m.removed_PlanDiffs[ids[i]] = struct{}{}
	}
}

// RemovedPlanDiffs returns the removed IDs of the "PlanDiffs" edge to the PlanDiff entity.
func (m *BuildCommitMutation) RemovedPlanDiffsIDs() (ids []uuid.UUID) {
	for id := range m.removed_PlanDiffs {
		ids = append(ids, id)
	}
	return
}

// PlanDiffsIDs returns the "PlanDiffs" edge IDs in the mutation.
func (m *BuildCommitMutation) PlanDiffsIDs() (ids []uuid.UUID) {
	for id := range m._PlanDiffs {
		ids = append(ids, id)
	}
	return
}

// ResetPlanDiffs resets all changes to the "PlanDiffs" edge.
func (m *BuildCommitMutation) ResetPlanDiffs() {
	m._PlanDiffs = nil
	m.cleared_PlanDiffs = false
	m.removed_PlanDiffs = nil
}

// Where appends a list predicates to the BuildCommitMutation builder.
func (m *BuildCommitMutation) Where(ps ...predicate.BuildCommit) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BuildCommitMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BuildCommit).
func (m *BuildCommitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BuildCommitMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._type != nil {
		fields = append(fields, buildcommit.FieldType)
	}
	if m.revision != nil {
		fields = append(fields, buildcommit.FieldRevision)
	}
	if m.state != nil {
		fields = append(fields, buildcommit.FieldState)
	}
	if m.created_at != nil {
		fields = append(fields, buildcommit.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BuildCommitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case buildcommit.FieldType:
		return m.GetType()
	case buildcommit.FieldRevision:
		return m.Revision()
	case buildcommit.FieldState:
		return m.State()
	case buildcommit.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BuildCommitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case buildcommit.FieldType:
		return m.OldType(ctx)
	case buildcommit.FieldRevision:
		return m.OldRevision(ctx)
	case buildcommit.FieldState:
		return m.OldState(ctx)
	case buildcommit.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BuildCommit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuildCommitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case buildcommit.FieldType:
		v, ok := value.(buildcommit.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case buildcommit.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case buildcommit.FieldState:
		v, ok := value.(buildcommit.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case buildcommit.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BuildCommit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BuildCommitMutation) AddedFields() []string {
	var fields []string
	if m.addrevision != nil {
		fields = append(fields, buildcommit.FieldRevision)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BuildCommitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case buildcommit.FieldRevision:
		return m.AddedRevision()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuildCommitMutation) AddField(name string, value ent.Value) error {
	switch name {
	case buildcommit.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevision(v)
		return nil
	}
	return fmt.Errorf("unknown BuildCommit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BuildCommitMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BuildCommitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BuildCommitMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BuildCommit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BuildCommitMutation) ResetField(name string) error {
	switch name {
	case buildcommit.FieldType:
		m.ResetType()
		return nil
	case buildcommit.FieldRevision:
		m.ResetRevision()
		return nil
	case buildcommit.FieldState:
		m.ResetState()
		return nil
	case buildcommit.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown BuildCommit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BuildCommitMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Build != nil {
		edges = append(edges, buildcommit.EdgeBuild)
	}
	if m._ServerTasks != nil {
		edges = append(edges, buildcommit.EdgeServerTasks)
	}
	if m._PlanDiffs != nil {
		edges = append(edges, buildcommit.EdgePlanDiffs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BuildCommitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case buildcommit.EdgeBuild:
		if id := m._Build; id != nil {
			return []ent.Value{*id}
		}
	case buildcommit.EdgeServerTasks:
		ids := make([]ent.Value, 0, len(m._ServerTasks))
		for id := range m._ServerTasks {
			ids = append(ids, id)
		}
		return ids
	case buildcommit.EdgePlanDiffs:
		ids := make([]ent.Value, 0, len(m._PlanDiffs))
		for id := range m._PlanDiffs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BuildCommitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_ServerTasks != nil {
		edges = append(edges, buildcommit.EdgeServerTasks)
	}
	if m.removed_PlanDiffs != nil {
		edges = append(edges, buildcommit.EdgePlanDiffs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BuildCommitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case buildcommit.EdgeServerTasks:
		ids := make([]ent.Value, 0, len(m.removed_ServerTasks))
		for id := range m.removed_ServerTasks {
			ids = append(ids, id)
		}
		return ids
	case buildcommit.EdgePlanDiffs:
		ids := make([]ent.Value, 0, len(m.removed_PlanDiffs))
		for id := range m.removed_PlanDiffs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BuildCommitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Build {
		edges = append(edges, buildcommit.EdgeBuild)
	}
	if m.cleared_ServerTasks {
		edges = append(edges, buildcommit.EdgeServerTasks)
	}
	if m.cleared_PlanDiffs {
		edges = append(edges, buildcommit.EdgePlanDiffs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BuildCommitMutation) EdgeCleared(name string) bool {
	switch name {
	case buildcommit.EdgeBuild:
		return m.cleared_Build
	case buildcommit.EdgeServerTasks:
		return m.cleared_ServerTasks
	case buildcommit.EdgePlanDiffs:
		return m.cleared_PlanDiffs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BuildCommitMutation) ClearEdge(name string) error {
	switch name {
	case buildcommit.EdgeBuild:
		m.ClearBuild()
		return nil
	}
	return fmt.Errorf("unknown BuildCommit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BuildCommitMutation) ResetEdge(name string) error {
	switch name {
	case buildcommit.EdgeBuild:
		m.ResetBuild()
		return nil
	case buildcommit.EdgeServerTasks:
		m.ResetServerTasks()
		return nil
	case buildcommit.EdgePlanDiffs:
		m.ResetPlanDiffs()
		return nil
	}
	return fmt.Errorf("unknown BuildCommit edge %s", name)
}

// CommandMutation represents an operation that mutates the Command nodes in the graph.
type CommandMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	hcl_id              *string
	name                *string
	description         *string
	program             *string
	args                *[]string
	ignore_errors       *bool
	disabled            *bool
	cooldown            *int
	addcooldown         *int
	timeout             *int
	addtimeout          *int
	vars                *map[string]string
	tags                *map[string]string
	clearedFields       map[string]struct{}
	_Users              map[uuid.UUID]struct{}
	removed_Users       map[uuid.UUID]struct{}
	cleared_Users       bool
	_Environment        *uuid.UUID
	cleared_Environment bool
	done                bool
	oldValue            func(context.Context) (*Command, error)
	predicates          []predicate.Command
}

var _ ent.Mutation = (*CommandMutation)(nil)

// commandOption allows management of the mutation configuration using functional options.
type commandOption func(*CommandMutation)

// newCommandMutation creates new mutation for the Command entity.
func newCommandMutation(c config, op Op, opts ...commandOption) *CommandMutation {
	m := &CommandMutation{
		config:        c,
		op:            op,
		typ:           TypeCommand,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommandID sets the ID field of the mutation.
func withCommandID(id uuid.UUID) commandOption {
	return func(m *CommandMutation) {
		var (
			err   error
			once  sync.Once
			value *Command
		)
		m.oldValue = func(ctx context.Context) (*Command, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Command.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommand sets the old Command of the mutation.
func withCommand(node *Command) commandOption {
	return func(m *CommandMutation) {
		m.oldValue = func(context.Context) (*Command, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommandMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommandMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Command entities.
func (m *CommandMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommandMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommandMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Command.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHclID sets the "hcl_id" field.
func (m *CommandMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *CommandMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *CommandMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetName sets the "name" field.
func (m *CommandMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CommandMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CommandMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CommandMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CommandMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CommandMutation) ResetDescription() {
	m.description = nil
}

// SetProgram sets the "program" field.
func (m *CommandMutation) SetProgram(s string) {
	m.program = &s
}

// Program returns the value of the "program" field in the mutation.
func (m *CommandMutation) Program() (r string, exists bool) {
	v := m.program
	if v == nil {
		return
	}
	return *v, true
}

// OldProgram returns the old "program" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldProgram(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgram is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgram requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgram: %w", err)
	}
	return oldValue.Program, nil
}

// ResetProgram resets all changes to the "program" field.
func (m *CommandMutation) ResetProgram() {
	m.program = nil
}

// SetArgs sets the "args" field.
func (m *CommandMutation) SetArgs(s []string) {
	m.args = &s
}

// Args returns the value of the "args" field in the mutation.
func (m *CommandMutation) Args() (r []string, exists bool) {
	v := m.args
	if v == nil {
		return
	}
	return *v, true
}

// OldArgs returns the old "args" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldArgs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArgs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArgs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArgs: %w", err)
	}
	return oldValue.Args, nil
}

// ResetArgs resets all changes to the "args" field.
func (m *CommandMutation) ResetArgs() {
	m.args = nil
}

// SetIgnoreErrors sets the "ignore_errors" field.
func (m *CommandMutation) SetIgnoreErrors(b bool) {
	m.ignore_errors = &b
}

// IgnoreErrors returns the value of the "ignore_errors" field in the mutation.
func (m *CommandMutation) IgnoreErrors() (r bool, exists bool) {
	v := m.ignore_errors
	if v == nil {
		return
	}
	return *v, true
}

// OldIgnoreErrors returns the old "ignore_errors" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldIgnoreErrors(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIgnoreErrors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIgnoreErrors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIgnoreErrors: %w", err)
	}
	return oldValue.IgnoreErrors, nil
}

// ResetIgnoreErrors resets all changes to the "ignore_errors" field.
func (m *CommandMutation) ResetIgnoreErrors() {
	m.ignore_errors = nil
}

// SetDisabled sets the "disabled" field.
func (m *CommandMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *CommandMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *CommandMutation) ResetDisabled() {
	m.disabled = nil
}

// SetCooldown sets the "cooldown" field.
func (m *CommandMutation) SetCooldown(i int) {
	m.cooldown = &i
	m.addcooldown = nil
}

// Cooldown returns the value of the "cooldown" field in the mutation.
func (m *CommandMutation) Cooldown() (r int, exists bool) {
	v := m.cooldown
	if v == nil {
		return
	}
	return *v, true
}

// OldCooldown returns the old "cooldown" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldCooldown(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCooldown is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCooldown requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCooldown: %w", err)
	}
	return oldValue.Cooldown, nil
}

// AddCooldown adds i to the "cooldown" field.
func (m *CommandMutation) AddCooldown(i int) {
	if m.addcooldown != nil {
		*m.addcooldown += i
	} else {
		m.addcooldown = &i
	}
}

// AddedCooldown returns the value that was added to the "cooldown" field in this mutation.
func (m *CommandMutation) AddedCooldown() (r int, exists bool) {
	v := m.addcooldown
	if v == nil {
		return
	}
	return *v, true
}

// ResetCooldown resets all changes to the "cooldown" field.
func (m *CommandMutation) ResetCooldown() {
	m.cooldown = nil
	m.addcooldown = nil
}

// SetTimeout sets the "timeout" field.
func (m *CommandMutation) SetTimeout(i int) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *CommandMutation) Timeout() (r int, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to the "timeout" field.
func (m *CommandMutation) AddTimeout(i int) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the "timeout" field in this mutation.
func (m *CommandMutation) AddedTimeout() (r int, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *CommandMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
}

// SetVars sets the "vars" field.
func (m *CommandMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *CommandMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *CommandMutation) ResetVars() {
	m.vars = nil
}

// SetTags sets the "tags" field.
func (m *CommandMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *CommandMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *CommandMutation) ResetTags() {
	m.tags = nil
}

// AddUserIDs adds the "Users" edge to the User entity by ids.
func (m *CommandMutation) AddUserIDs(ids ...uuid.UUID) {
	if m._Users == nil {
		m._Users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "Users" edge to the User entity.
func (m *CommandMutation) ClearUsers() {
	m.cleared_Users = true
}

// UsersCleared reports if the "Users" edge to the User entity was cleared.
func (m *CommandMutation) UsersCleared() bool {
	return m.cleared_Users
}

// RemoveUserIDs removes the "Users" edge to the User entity by IDs.
func (m *CommandMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removed_Users == nil {
		m.removed_Users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Users, ids[i])
		m.removed_Users[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "Users" edge to the User entity.
func (m *CommandMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removed_Users {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "Users" edge IDs in the mutation.
func (m *CommandMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m._Users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "Users" edge.
func (m *CommandMutation) ResetUsers() {
	m._Users = nil
	m.cleared_Users = false
	m.removed_Users = nil
}

// SetEnvironmentID sets the "Environment" edge to the Environment entity by id.
func (m *CommandMutation) SetEnvironmentID(id uuid.UUID) {
	m._Environment = &id
}

// ClearEnvironment clears the "Environment" edge to the Environment entity.
func (m *CommandMutation) ClearEnvironment() {
	m.cleared_Environment = true
}

// EnvironmentCleared reports if the "Environment" edge to the Environment entity was cleared.
func (m *CommandMutation) EnvironmentCleared() bool {
	return m.cleared_Environment
}

// EnvironmentID returns the "Environment" edge ID in the mutation.
func (m *CommandMutation) EnvironmentID() (id uuid.UUID, exists bool) {
	if m._Environment != nil {
		return *m._Environment, true
	}
	return
}

// EnvironmentIDs returns the "Environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *CommandMutation) EnvironmentIDs() (ids []uuid.UUID) {
	if id := m._Environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "Environment" edge.
func (m *CommandMutation) ResetEnvironment() {
	m._Environment = nil
	m.cleared_Environment = false
}

// Where appends a list predicates to the CommandMutation builder.
func (m *CommandMutation) Where(ps ...predicate.Command) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CommandMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Command).
func (m *CommandMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommandMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.hcl_id != nil {
		fields = append(fields, command.FieldHclID)
	}
	if m.name != nil {
		fields = append(fields, command.FieldName)
	}
	if m.description != nil {
		fields = append(fields, command.FieldDescription)
	}
	if m.program != nil {
		fields = append(fields, command.FieldProgram)
	}
	if m.args != nil {
		fields = append(fields, command.FieldArgs)
	}
	if m.ignore_errors != nil {
		fields = append(fields, command.FieldIgnoreErrors)
	}
	if m.disabled != nil {
		fields = append(fields, command.FieldDisabled)
	}
	if m.cooldown != nil {
		fields = append(fields, command.FieldCooldown)
	}
	if m.timeout != nil {
		fields = append(fields, command.FieldTimeout)
	}
	if m.vars != nil {
		fields = append(fields, command.FieldVars)
	}
	if m.tags != nil {
		fields = append(fields, command.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommandMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case command.FieldHclID:
		return m.HclID()
	case command.FieldName:
		return m.Name()
	case command.FieldDescription:
		return m.Description()
	case command.FieldProgram:
		return m.Program()
	case command.FieldArgs:
		return m.Args()
	case command.FieldIgnoreErrors:
		return m.IgnoreErrors()
	case command.FieldDisabled:
		return m.Disabled()
	case command.FieldCooldown:
		return m.Cooldown()
	case command.FieldTimeout:
		return m.Timeout()
	case command.FieldVars:
		return m.Vars()
	case command.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommandMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case command.FieldHclID:
		return m.OldHclID(ctx)
	case command.FieldName:
		return m.OldName(ctx)
	case command.FieldDescription:
		return m.OldDescription(ctx)
	case command.FieldProgram:
		return m.OldProgram(ctx)
	case command.FieldArgs:
		return m.OldArgs(ctx)
	case command.FieldIgnoreErrors:
		return m.OldIgnoreErrors(ctx)
	case command.FieldDisabled:
		return m.OldDisabled(ctx)
	case command.FieldCooldown:
		return m.OldCooldown(ctx)
	case command.FieldTimeout:
		return m.OldTimeout(ctx)
	case command.FieldVars:
		return m.OldVars(ctx)
	case command.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Command field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommandMutation) SetField(name string, value ent.Value) error {
	switch name {
	case command.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case command.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case command.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case command.FieldProgram:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgram(v)
		return nil
	case command.FieldArgs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArgs(v)
		return nil
	case command.FieldIgnoreErrors:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIgnoreErrors(v)
		return nil
	case command.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case command.FieldCooldown:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCooldown(v)
		return nil
	case command.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case command.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	case command.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Command field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommandMutation) AddedFields() []string {
	var fields []string
	if m.addcooldown != nil {
		fields = append(fields, command.FieldCooldown)
	}
	if m.addtimeout != nil {
		fields = append(fields, command.FieldTimeout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommandMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case command.FieldCooldown:
		return m.AddedCooldown()
	case command.FieldTimeout:
		return m.AddedTimeout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommandMutation) AddField(name string, value ent.Value) error {
	switch name {
	case command.FieldCooldown:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCooldown(v)
		return nil
	case command.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown Command numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommandMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommandMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommandMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Command nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommandMutation) ResetField(name string) error {
	switch name {
	case command.FieldHclID:
		m.ResetHclID()
		return nil
	case command.FieldName:
		m.ResetName()
		return nil
	case command.FieldDescription:
		m.ResetDescription()
		return nil
	case command.FieldProgram:
		m.ResetProgram()
		return nil
	case command.FieldArgs:
		m.ResetArgs()
		return nil
	case command.FieldIgnoreErrors:
		m.ResetIgnoreErrors()
		return nil
	case command.FieldDisabled:
		m.ResetDisabled()
		return nil
	case command.FieldCooldown:
		m.ResetCooldown()
		return nil
	case command.FieldTimeout:
		m.ResetTimeout()
		return nil
	case command.FieldVars:
		m.ResetVars()
		return nil
	case command.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Command field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommandMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._Users != nil {
		edges = append(edges, command.EdgeUsers)
	}
	if m._Environment != nil {
		edges = append(edges, command.EdgeEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommandMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case command.EdgeUsers:
		ids := make([]ent.Value, 0, len(m._Users))
		for id := range m._Users {
			ids = append(ids, id)
		}
		return ids
	case command.EdgeEnvironment:
		if id := m._Environment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommandMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_Users != nil {
		edges = append(edges, command.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommandMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case command.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removed_Users))
		for id := range m.removed_Users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommandMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_Users {
		edges = append(edges, command.EdgeUsers)
	}
	if m.cleared_Environment {
		edges = append(edges, command.EdgeEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommandMutation) EdgeCleared(name string) bool {
	switch name {
	case command.EdgeUsers:
		return m.cleared_Users
	case command.EdgeEnvironment:
		return m.cleared_Environment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommandMutation) ClearEdge(name string) error {
	switch name {
	case command.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Command unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommandMutation) ResetEdge(name string) error {
	switch name {
	case command.EdgeUsers:
		m.ResetUsers()
		return nil
	case command.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Command edge %s", name)
}

// CompetitionMutation represents an operation that mutates the Competition nodes in the graph.
type CompetitionMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	hcl_id              *string
	root_password       *string
	start_time          *int64
	addstart_time       *int64
	stop_time           *int64
	addstop_time        *int64
	_config             *map[string]string
	tags                *map[string]string
	clearedFields       map[string]struct{}
	_DNS                map[uuid.UUID]struct{}
	removed_DNS         map[uuid.UUID]struct{}
	cleared_DNS         bool
	_Environment        *uuid.UUID
	cleared_Environment bool
	_Builds             map[uuid.UUID]struct{}
	removed_Builds      map[uuid.UUID]struct{}
	cleared_Builds      bool
	done                bool
	oldValue            func(context.Context) (*Competition, error)
	predicates          []predicate.Competition
}

var _ ent.Mutation = (*CompetitionMutation)(nil)

// competitionOption allows management of the mutation configuration using functional options.
type competitionOption func(*CompetitionMutation)

// newCompetitionMutation creates new mutation for the Competition entity.
func newCompetitionMutation(c config, op Op, opts ...competitionOption) *CompetitionMutation {
	m := &CompetitionMutation{
		config:        c,
		op:            op,
		typ:           TypeCompetition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompetitionID sets the ID field of the mutation.
func withCompetitionID(id uuid.UUID) competitionOption {
	return func(m *CompetitionMutation) {
		var (
			err   error
			once  sync.Once
			value *Competition
		)
		m.oldValue = func(ctx context.Context) (*Competition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Competition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompetition sets the old Competition of the mutation.
func withCompetition(node *Competition) competitionOption {
	return func(m *CompetitionMutation) {
		m.oldValue = func(context.Context) (*Competition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompetitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompetitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Competition entities.
func (m *CompetitionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompetitionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompetitionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Competition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHclID sets the "hcl_id" field.
func (m *CompetitionMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *CompetitionMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *CompetitionMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetRootPassword sets the "root_password" field.
func (m *CompetitionMutation) SetRootPassword(s string) {
	m.root_password = &s
}

// RootPassword returns the value of the "root_password" field in the mutation.
func (m *CompetitionMutation) RootPassword() (r string, exists bool) {
	v := m.root_password
	if v == nil {
		return
	}
	return *v, true
}

// OldRootPassword returns the old "root_password" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldRootPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRootPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRootPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootPassword: %w", err)
	}
	return oldValue.RootPassword, nil
}

// ResetRootPassword resets all changes to the "root_password" field.
func (m *CompetitionMutation) ResetRootPassword() {
	m.root_password = nil
}

// SetStartTime sets the "start_time" field.
func (m *CompetitionMutation) SetStartTime(i int64) {
	m.start_time = &i
	m.addstart_time = nil
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *CompetitionMutation) StartTime() (r int64, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldStartTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// AddStartTime adds i to the "start_time" field.
func (m *CompetitionMutation) AddStartTime(i int64) {
	if m.addstart_time != nil {
		*m.addstart_time += i
	} else {
		m.addstart_time = &i
	}
}

// AddedStartTime returns the value that was added to the "start_time" field in this mutation.
func (m *CompetitionMutation) AddedStartTime() (r int64, exists bool) {
	v := m.addstart_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearStartTime clears the value of the "start_time" field.
func (m *CompetitionMutation) ClearStartTime() {
	m.start_time = nil
	m.addstart_time = nil
	m.clearedFields[competition.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *CompetitionMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[competition.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *CompetitionMutation) ResetStartTime() {
	m.start_time = nil
	m.addstart_time = nil
	delete(m.clearedFields, competition.FieldStartTime)
}

// SetStopTime sets the "stop_time" field.
func (m *CompetitionMutation) SetStopTime(i int64) {
	m.stop_time = &i
	m.addstop_time = nil
}

// StopTime returns the value of the "stop_time" field in the mutation.
func (m *CompetitionMutation) StopTime() (r int64, exists bool) {
	v := m.stop_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStopTime returns the old "stop_time" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldStopTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStopTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStopTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStopTime: %w", err)
	}
	return oldValue.StopTime, nil
}

// AddStopTime adds i to the "stop_time" field.
func (m *CompetitionMutation) AddStopTime(i int64) {
	if m.addstop_time != nil {
		*m.addstop_time += i
	} else {
		m.addstop_time = &i
	}
}

// AddedStopTime returns the value that was added to the "stop_time" field in this mutation.
func (m *CompetitionMutation) AddedStopTime() (r int64, exists bool) {
	v := m.addstop_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearStopTime clears the value of the "stop_time" field.
func (m *CompetitionMutation) ClearStopTime() {
	m.stop_time = nil
	m.addstop_time = nil
	m.clearedFields[competition.FieldStopTime] = struct{}{}
}

// StopTimeCleared returns if the "stop_time" field was cleared in this mutation.
func (m *CompetitionMutation) StopTimeCleared() bool {
	_, ok := m.clearedFields[competition.FieldStopTime]
	return ok
}

// ResetStopTime resets all changes to the "stop_time" field.
func (m *CompetitionMutation) ResetStopTime() {
	m.stop_time = nil
	m.addstop_time = nil
	delete(m.clearedFields, competition.FieldStopTime)
}

// SetConfig sets the "config" field.
func (m *CompetitionMutation) SetConfig(value map[string]string) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *CompetitionMutation) Config() (r map[string]string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldConfig(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *CompetitionMutation) ResetConfig() {
	m._config = nil
}

// SetTags sets the "tags" field.
func (m *CompetitionMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *CompetitionMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *CompetitionMutation) ResetTags() {
	m.tags = nil
}

// AddDNSIDs adds the "DNS" edge to the DNS entity by ids.
func (m *CompetitionMutation) AddDNSIDs(ids ...uuid.UUID) {
	if m._DNS == nil {
		m._DNS = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._DNS[ids[i]] = struct{}{}
	}
}

// ClearDNS clears the "DNS" edge to the DNS entity.
func (m *CompetitionMutation) ClearDNS() {
	m.cleared_DNS = true
}

// DNSCleared reports if the "DNS" edge to the DNS entity was cleared.
func (m *CompetitionMutation) DNSCleared() bool {
	return m.cleared_DNS
}

// RemoveDNSIDs removes the "DNS" edge to the DNS entity by IDs.
func (m *CompetitionMutation) RemoveDNSIDs(ids ...uuid.UUID) {
	if m.removed_DNS == nil {
		m.removed_DNS = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._DNS, ids[i])
		m.removed_DNS[ids[i]] = struct{}{}
	}
}

// RemovedDNS returns the removed IDs of the "DNS" edge to the DNS entity.
func (m *CompetitionMutation) RemovedDNSIDs() (ids []uuid.UUID) {
	for id := range m.removed_DNS {
		ids = append(ids, id)
	}
	return
}

// DNSIDs returns the "DNS" edge IDs in the mutation.
func (m *CompetitionMutation) DNSIDs() (ids []uuid.UUID) {
	for id := range m._DNS {
		ids = append(ids, id)
	}
	return
}

// ResetDNS resets all changes to the "DNS" edge.
func (m *CompetitionMutation) ResetDNS() {
	m._DNS = nil
	m.cleared_DNS = false
	m.removed_DNS = nil
}

// SetEnvironmentID sets the "Environment" edge to the Environment entity by id.
func (m *CompetitionMutation) SetEnvironmentID(id uuid.UUID) {
	m._Environment = &id
}

// ClearEnvironment clears the "Environment" edge to the Environment entity.
func (m *CompetitionMutation) ClearEnvironment() {
	m.cleared_Environment = true
}

// EnvironmentCleared reports if the "Environment" edge to the Environment entity was cleared.
func (m *CompetitionMutation) EnvironmentCleared() bool {
	return m.cleared_Environment
}

// EnvironmentID returns the "Environment" edge ID in the mutation.
func (m *CompetitionMutation) EnvironmentID() (id uuid.UUID, exists bool) {
	if m._Environment != nil {
		return *m._Environment, true
	}
	return
}

// EnvironmentIDs returns the "Environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *CompetitionMutation) EnvironmentIDs() (ids []uuid.UUID) {
	if id := m._Environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "Environment" edge.
func (m *CompetitionMutation) ResetEnvironment() {
	m._Environment = nil
	m.cleared_Environment = false
}

// AddBuildIDs adds the "Builds" edge to the Build entity by ids.
func (m *CompetitionMutation) AddBuildIDs(ids ...uuid.UUID) {
	if m._Builds == nil {
		m._Builds = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Builds[ids[i]] = struct{}{}
	}
}

// ClearBuilds clears the "Builds" edge to the Build entity.
func (m *CompetitionMutation) ClearBuilds() {
	m.cleared_Builds = true
}

// BuildsCleared reports if the "Builds" edge to the Build entity was cleared.
func (m *CompetitionMutation) BuildsCleared() bool {
	return m.cleared_Builds
}

// RemoveBuildIDs removes the "Builds" edge to the Build entity by IDs.
func (m *CompetitionMutation) RemoveBuildIDs(ids ...uuid.UUID) {
	if m.removed_Builds == nil {
		m.removed_Builds = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Builds, ids[i])
		m.removed_Builds[ids[i]] = struct{}{}
	}
}

// RemovedBuilds returns the removed IDs of the "Builds" edge to the Build entity.
func (m *CompetitionMutation) RemovedBuildsIDs() (ids []uuid.UUID) {
	for id := range m.removed_Builds {
		ids = append(ids, id)
	}
	return
}

// BuildsIDs returns the "Builds" edge IDs in the mutation.
func (m *CompetitionMutation) BuildsIDs() (ids []uuid.UUID) {
	for id := range m._Builds {
		ids = append(ids, id)
	}
	return
}

// ResetBuilds resets all changes to the "Builds" edge.
func (m *CompetitionMutation) ResetBuilds() {
	m._Builds = nil
	m.cleared_Builds = false
	m.removed_Builds = nil
}

// Where appends a list predicates to the CompetitionMutation builder.
func (m *CompetitionMutation) Where(ps ...predicate.Competition) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CompetitionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Competition).
func (m *CompetitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompetitionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.hcl_id != nil {
		fields = append(fields, competition.FieldHclID)
	}
	if m.root_password != nil {
		fields = append(fields, competition.FieldRootPassword)
	}
	if m.start_time != nil {
		fields = append(fields, competition.FieldStartTime)
	}
	if m.stop_time != nil {
		fields = append(fields, competition.FieldStopTime)
	}
	if m._config != nil {
		fields = append(fields, competition.FieldConfig)
	}
	if m.tags != nil {
		fields = append(fields, competition.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompetitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case competition.FieldHclID:
		return m.HclID()
	case competition.FieldRootPassword:
		return m.RootPassword()
	case competition.FieldStartTime:
		return m.StartTime()
	case competition.FieldStopTime:
		return m.StopTime()
	case competition.FieldConfig:
		return m.Config()
	case competition.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompetitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case competition.FieldHclID:
		return m.OldHclID(ctx)
	case competition.FieldRootPassword:
		return m.OldRootPassword(ctx)
	case competition.FieldStartTime:
		return m.OldStartTime(ctx)
	case competition.FieldStopTime:
		return m.OldStopTime(ctx)
	case competition.FieldConfig:
		return m.OldConfig(ctx)
	case competition.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Competition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompetitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case competition.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case competition.FieldRootPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootPassword(v)
		return nil
	case competition.FieldStartTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case competition.FieldStopTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStopTime(v)
		return nil
	case competition.FieldConfig:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case competition.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Competition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompetitionMutation) AddedFields() []string {
	var fields []string
	if m.addstart_time != nil {
		fields = append(fields, competition.FieldStartTime)
	}
	if m.addstop_time != nil {
		fields = append(fields, competition.FieldStopTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompetitionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case competition.FieldStartTime:
		return m.AddedStartTime()
	case competition.FieldStopTime:
		return m.AddedStopTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompetitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case competition.FieldStartTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartTime(v)
		return nil
	case competition.FieldStopTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStopTime(v)
		return nil
	}
	return fmt.Errorf("unknown Competition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompetitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(competition.FieldStartTime) {
		fields = append(fields, competition.FieldStartTime)
	}
	if m.FieldCleared(competition.FieldStopTime) {
		fields = append(fields, competition.FieldStopTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompetitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompetitionMutation) ClearField(name string) error {
	switch name {
	case competition.FieldStartTime:
		m.ClearStartTime()
		return nil
	case competition.FieldStopTime:
		m.ClearStopTime()
		return nil
	}
	return fmt.Errorf("unknown Competition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompetitionMutation) ResetField(name string) error {
	switch name {
	case competition.FieldHclID:
		m.ResetHclID()
		return nil
	case competition.FieldRootPassword:
		m.ResetRootPassword()
		return nil
	case competition.FieldStartTime:
		m.ResetStartTime()
		return nil
	case competition.FieldStopTime:
		m.ResetStopTime()
		return nil
	case competition.FieldConfig:
		m.ResetConfig()
		return nil
	case competition.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Competition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompetitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._DNS != nil {
		edges = append(edges, competition.EdgeDNS)
	}
	if m._Environment != nil {
		edges = append(edges, competition.EdgeEnvironment)
	}
	if m._Builds != nil {
		edges = append(edges, competition.EdgeBuilds)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompetitionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case competition.EdgeDNS:
		ids := make([]ent.Value, 0, len(m._DNS))
		for id := range m._DNS {
			ids = append(ids, id)
		}
		return ids
	case competition.EdgeEnvironment:
		if id := m._Environment; id != nil {
			return []ent.Value{*id}
		}
	case competition.EdgeBuilds:
		ids := make([]ent.Value, 0, len(m._Builds))
		for id := range m._Builds {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompetitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_DNS != nil {
		edges = append(edges, competition.EdgeDNS)
	}
	if m.removed_Builds != nil {
		edges = append(edges, competition.EdgeBuilds)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompetitionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case competition.EdgeDNS:
		ids := make([]ent.Value, 0, len(m.removed_DNS))
		for id := range m.removed_DNS {
			ids = append(ids, id)
		}
		return ids
	case competition.EdgeBuilds:
		ids := make([]ent.Value, 0, len(m.removed_Builds))
		for id := range m.removed_Builds {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompetitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_DNS {
		edges = append(edges, competition.EdgeDNS)
	}
	if m.cleared_Environment {
		edges = append(edges, competition.EdgeEnvironment)
	}
	if m.cleared_Builds {
		edges = append(edges, competition.EdgeBuilds)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompetitionMutation) EdgeCleared(name string) bool {
	switch name {
	case competition.EdgeDNS:
		return m.cleared_DNS
	case competition.EdgeEnvironment:
		return m.cleared_Environment
	case competition.EdgeBuilds:
		return m.cleared_Builds
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompetitionMutation) ClearEdge(name string) error {
	switch name {
	case competition.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Competition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompetitionMutation) ResetEdge(name string) error {
	switch name {
	case competition.EdgeDNS:
		m.ResetDNS()
		return nil
	case competition.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	case competition.EdgeBuilds:
		m.ResetBuilds()
		return nil
	}
	return fmt.Errorf("unknown Competition edge %s", name)
}

// DNSMutation represents an operation that mutates the DNS nodes in the graph.
type DNSMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	hcl_id               *string
	_type                *string
	root_domain          *string
	dns_servers          *[]string
	ntp_servers          *[]string
	_config              *map[string]string
	clearedFields        map[string]struct{}
	_Environments        map[uuid.UUID]struct{}
	removed_Environments map[uuid.UUID]struct{}
	cleared_Environments bool
	_Competitions        map[uuid.UUID]struct{}
	removed_Competitions map[uuid.UUID]struct{}
	cleared_Competitions bool
	done                 bool
	oldValue             func(context.Context) (*DNS, error)
	predicates           []predicate.DNS
}

var _ ent.Mutation = (*DNSMutation)(nil)

// dnsOption allows management of the mutation configuration using functional options.
type dnsOption func(*DNSMutation)

// newDNSMutation creates new mutation for the DNS entity.
func newDNSMutation(c config, op Op, opts ...dnsOption) *DNSMutation {
	m := &DNSMutation{
		config:        c,
		op:            op,
		typ:           TypeDNS,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDNSID sets the ID field of the mutation.
func withDNSID(id uuid.UUID) dnsOption {
	return func(m *DNSMutation) {
		var (
			err   error
			once  sync.Once
			value *DNS
		)
		m.oldValue = func(ctx context.Context) (*DNS, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DNS.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDNS sets the old DNS of the mutation.
func withDNS(node *DNS) dnsOption {
	return func(m *DNSMutation) {
		m.oldValue = func(context.Context) (*DNS, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DNSMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DNSMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DNS entities.
func (m *DNSMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DNSMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DNSMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DNS.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHclID sets the "hcl_id" field.
func (m *DNSMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *DNSMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the DNS entity.
// If the DNS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *DNSMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetType sets the "type" field.
func (m *DNSMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *DNSMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DNS entity.
// If the DNS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DNSMutation) ResetType() {
	m._type = nil
}

// SetRootDomain sets the "root_domain" field.
func (m *DNSMutation) SetRootDomain(s string) {
	m.root_domain = &s
}

// RootDomain returns the value of the "root_domain" field in the mutation.
func (m *DNSMutation) RootDomain() (r string, exists bool) {
	v := m.root_domain
	if v == nil {
		return
	}
	return *v, true
}

// OldRootDomain returns the old "root_domain" field's value of the DNS entity.
// If the DNS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSMutation) OldRootDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRootDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRootDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootDomain: %w", err)
	}
	return oldValue.RootDomain, nil
}

// ResetRootDomain resets all changes to the "root_domain" field.
func (m *DNSMutation) ResetRootDomain() {
	m.root_domain = nil
}

// SetDNSServers sets the "dns_servers" field.
func (m *DNSMutation) SetDNSServers(s []string) {
	m.dns_servers = &s
}

// DNSServers returns the value of the "dns_servers" field in the mutation.
func (m *DNSMutation) DNSServers() (r []string, exists bool) {
	v := m.dns_servers
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSServers returns the old "dns_servers" field's value of the DNS entity.
// If the DNS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSMutation) OldDNSServers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDNSServers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDNSServers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSServers: %w", err)
	}
	return oldValue.DNSServers, nil
}

// ResetDNSServers resets all changes to the "dns_servers" field.
func (m *DNSMutation) ResetDNSServers() {
	m.dns_servers = nil
}

// SetNtpServers sets the "ntp_servers" field.
func (m *DNSMutation) SetNtpServers(s []string) {
	m.ntp_servers = &s
}

// NtpServers returns the value of the "ntp_servers" field in the mutation.
func (m *DNSMutation) NtpServers() (r []string, exists bool) {
	v := m.ntp_servers
	if v == nil {
		return
	}
	return *v, true
}

// OldNtpServers returns the old "ntp_servers" field's value of the DNS entity.
// If the DNS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSMutation) OldNtpServers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNtpServers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNtpServers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNtpServers: %w", err)
	}
	return oldValue.NtpServers, nil
}

// ResetNtpServers resets all changes to the "ntp_servers" field.
func (m *DNSMutation) ResetNtpServers() {
	m.ntp_servers = nil
}

// SetConfig sets the "config" field.
func (m *DNSMutation) SetConfig(value map[string]string) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *DNSMutation) Config() (r map[string]string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the DNS entity.
// If the DNS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSMutation) OldConfig(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *DNSMutation) ResetConfig() {
	m._config = nil
}

// AddEnvironmentIDs adds the "Environments" edge to the Environment entity by ids.
func (m *DNSMutation) AddEnvironmentIDs(ids ...uuid.UUID) {
	if m._Environments == nil {
		m._Environments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Environments[ids[i]] = struct{}{}
	}
}

// ClearEnvironments clears the "Environments" edge to the Environment entity.
func (m *DNSMutation) ClearEnvironments() {
	m.cleared_Environments = true
}

// EnvironmentsCleared reports if the "Environments" edge to the Environment entity was cleared.
func (m *DNSMutation) EnvironmentsCleared() bool {
	return m.cleared_Environments
}

// RemoveEnvironmentIDs removes the "Environments" edge to the Environment entity by IDs.
func (m *DNSMutation) RemoveEnvironmentIDs(ids ...uuid.UUID) {
	if m.removed_Environments == nil {
		m.removed_Environments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Environments, ids[i])
		m.removed_Environments[ids[i]] = struct{}{}
	}
}

// RemovedEnvironments returns the removed IDs of the "Environments" edge to the Environment entity.
func (m *DNSMutation) RemovedEnvironmentsIDs() (ids []uuid.UUID) {
	for id := range m.removed_Environments {
		ids = append(ids, id)
	}
	return
}

// EnvironmentsIDs returns the "Environments" edge IDs in the mutation.
func (m *DNSMutation) EnvironmentsIDs() (ids []uuid.UUID) {
	for id := range m._Environments {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironments resets all changes to the "Environments" edge.
func (m *DNSMutation) ResetEnvironments() {
	m._Environments = nil
	m.cleared_Environments = false
	m.removed_Environments = nil
}

// AddCompetitionIDs adds the "Competitions" edge to the Competition entity by ids.
func (m *DNSMutation) AddCompetitionIDs(ids ...uuid.UUID) {
	if m._Competitions == nil {
		m._Competitions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Competitions[ids[i]] = struct{}{}
	}
}

// ClearCompetitions clears the "Competitions" edge to the Competition entity.
func (m *DNSMutation) ClearCompetitions() {
	m.cleared_Competitions = true
}

// CompetitionsCleared reports if the "Competitions" edge to the Competition entity was cleared.
func (m *DNSMutation) CompetitionsCleared() bool {
	return m.cleared_Competitions
}

// RemoveCompetitionIDs removes the "Competitions" edge to the Competition entity by IDs.
func (m *DNSMutation) RemoveCompetitionIDs(ids ...uuid.UUID) {
	if m.removed_Competitions == nil {
		m.removed_Competitions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Competitions, ids[i])
		m.removed_Competitions[ids[i]] = struct{}{}
	}
}

// RemovedCompetitions returns the removed IDs of the "Competitions" edge to the Competition entity.
func (m *DNSMutation) RemovedCompetitionsIDs() (ids []uuid.UUID) {
	for id := range m.removed_Competitions {
		ids = append(ids, id)
	}
	return
}

// CompetitionsIDs returns the "Competitions" edge IDs in the mutation.
func (m *DNSMutation) CompetitionsIDs() (ids []uuid.UUID) {
	for id := range m._Competitions {
		ids = append(ids, id)
	}
	return
}

// ResetCompetitions resets all changes to the "Competitions" edge.
func (m *DNSMutation) ResetCompetitions() {
	m._Competitions = nil
	m.cleared_Competitions = false
	m.removed_Competitions = nil
}

// Where appends a list predicates to the DNSMutation builder.
func (m *DNSMutation) Where(ps ...predicate.DNS) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DNSMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DNS).
func (m *DNSMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DNSMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.hcl_id != nil {
		fields = append(fields, dns.FieldHclID)
	}
	if m._type != nil {
		fields = append(fields, dns.FieldType)
	}
	if m.root_domain != nil {
		fields = append(fields, dns.FieldRootDomain)
	}
	if m.dns_servers != nil {
		fields = append(fields, dns.FieldDNSServers)
	}
	if m.ntp_servers != nil {
		fields = append(fields, dns.FieldNtpServers)
	}
	if m._config != nil {
		fields = append(fields, dns.FieldConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DNSMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dns.FieldHclID:
		return m.HclID()
	case dns.FieldType:
		return m.GetType()
	case dns.FieldRootDomain:
		return m.RootDomain()
	case dns.FieldDNSServers:
		return m.DNSServers()
	case dns.FieldNtpServers:
		return m.NtpServers()
	case dns.FieldConfig:
		return m.Config()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DNSMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dns.FieldHclID:
		return m.OldHclID(ctx)
	case dns.FieldType:
		return m.OldType(ctx)
	case dns.FieldRootDomain:
		return m.OldRootDomain(ctx)
	case dns.FieldDNSServers:
		return m.OldDNSServers(ctx)
	case dns.FieldNtpServers:
		return m.OldNtpServers(ctx)
	case dns.FieldConfig:
		return m.OldConfig(ctx)
	}
	return nil, fmt.Errorf("unknown DNS field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DNSMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dns.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case dns.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case dns.FieldRootDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootDomain(v)
		return nil
	case dns.FieldDNSServers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSServers(v)
		return nil
	case dns.FieldNtpServers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNtpServers(v)
		return nil
	case dns.FieldConfig:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	}
	return fmt.Errorf("unknown DNS field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DNSMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DNSMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DNSMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DNS numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DNSMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DNSMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DNSMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DNS nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DNSMutation) ResetField(name string) error {
	switch name {
	case dns.FieldHclID:
		m.ResetHclID()
		return nil
	case dns.FieldType:
		m.ResetType()
		return nil
	case dns.FieldRootDomain:
		m.ResetRootDomain()
		return nil
	case dns.FieldDNSServers:
		m.ResetDNSServers()
		return nil
	case dns.FieldNtpServers:
		m.ResetNtpServers()
		return nil
	case dns.FieldConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown DNS field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DNSMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._Environments != nil {
		edges = append(edges, dns.EdgeEnvironments)
	}
	if m._Competitions != nil {
		edges = append(edges, dns.EdgeCompetitions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DNSMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dns.EdgeEnvironments:
		ids := make([]ent.Value, 0, len(m._Environments))
		for id := range m._Environments {
			ids = append(ids, id)
		}
		return ids
	case dns.EdgeCompetitions:
		ids := make([]ent.Value, 0, len(m._Competitions))
		for id := range m._Competitions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DNSMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_Environments != nil {
		edges = append(edges, dns.EdgeEnvironments)
	}
	if m.removed_Competitions != nil {
		edges = append(edges, dns.EdgeCompetitions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DNSMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dns.EdgeEnvironments:
		ids := make([]ent.Value, 0, len(m.removed_Environments))
		for id := range m.removed_Environments {
			ids = append(ids, id)
		}
		return ids
	case dns.EdgeCompetitions:
		ids := make([]ent.Value, 0, len(m.removed_Competitions))
		for id := range m.removed_Competitions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DNSMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_Environments {
		edges = append(edges, dns.EdgeEnvironments)
	}
	if m.cleared_Competitions {
		edges = append(edges, dns.EdgeCompetitions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DNSMutation) EdgeCleared(name string) bool {
	switch name {
	case dns.EdgeEnvironments:
		return m.cleared_Environments
	case dns.EdgeCompetitions:
		return m.cleared_Competitions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DNSMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DNS unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DNSMutation) ResetEdge(name string) error {
	switch name {
	case dns.EdgeEnvironments:
		m.ResetEnvironments()
		return nil
	case dns.EdgeCompetitions:
		m.ResetCompetitions()
		return nil
	}
	return fmt.Errorf("unknown DNS edge %s", name)
}

// DNSRecordMutation represents an operation that mutates the DNSRecord nodes in the graph.
type DNSRecordMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	hcl_id              *string
	name                *string
	values              *[]string
	_type               *string
	zone                *string
	vars                *map[string]string
	disabled            *bool
	tags                *map[string]string
	clearedFields       map[string]struct{}
	_Environment        *uuid.UUID
	cleared_Environment bool
	done                bool
	oldValue            func(context.Context) (*DNSRecord, error)
	predicates          []predicate.DNSRecord
}

var _ ent.Mutation = (*DNSRecordMutation)(nil)

// dnsrecordOption allows management of the mutation configuration using functional options.
type dnsrecordOption func(*DNSRecordMutation)

// newDNSRecordMutation creates new mutation for the DNSRecord entity.
func newDNSRecordMutation(c config, op Op, opts ...dnsrecordOption) *DNSRecordMutation {
	m := &DNSRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeDNSRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDNSRecordID sets the ID field of the mutation.
func withDNSRecordID(id uuid.UUID) dnsrecordOption {
	return func(m *DNSRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *DNSRecord
		)
		m.oldValue = func(ctx context.Context) (*DNSRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DNSRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDNSRecord sets the old DNSRecord of the mutation.
func withDNSRecord(node *DNSRecord) dnsrecordOption {
	return func(m *DNSRecordMutation) {
		m.oldValue = func(context.Context) (*DNSRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DNSRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DNSRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DNSRecord entities.
func (m *DNSRecordMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DNSRecordMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DNSRecordMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DNSRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHclID sets the "hcl_id" field.
func (m *DNSRecordMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *DNSRecordMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the DNSRecord entity.
// If the DNSRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSRecordMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *DNSRecordMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetName sets the "name" field.
func (m *DNSRecordMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DNSRecordMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DNSRecord entity.
// If the DNSRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSRecordMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DNSRecordMutation) ResetName() {
	m.name = nil
}

// SetValues sets the "values" field.
func (m *DNSRecordMutation) SetValues(s []string) {
	m.values = &s
}

// Values returns the value of the "values" field in the mutation.
func (m *DNSRecordMutation) Values() (r []string, exists bool) {
	v := m.values
	if v == nil {
		return
	}
	return *v, true
}

// OldValues returns the old "values" field's value of the DNSRecord entity.
// If the DNSRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSRecordMutation) OldValues(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValues: %w", err)
	}
	return oldValue.Values, nil
}

// ResetValues resets all changes to the "values" field.
func (m *DNSRecordMutation) ResetValues() {
	m.values = nil
}

// SetType sets the "type" field.
func (m *DNSRecordMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *DNSRecordMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DNSRecord entity.
// If the DNSRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSRecordMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DNSRecordMutation) ResetType() {
	m._type = nil
}

// SetZone sets the "zone" field.
func (m *DNSRecordMutation) SetZone(s string) {
	m.zone = &s
}

// Zone returns the value of the "zone" field in the mutation.
func (m *DNSRecordMutation) Zone() (r string, exists bool) {
	v := m.zone
	if v == nil {
		return
	}
	return *v, true
}

// OldZone returns the old "zone" field's value of the DNSRecord entity.
// If the DNSRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSRecordMutation) OldZone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZone: %w", err)
	}
	return oldValue.Zone, nil
}

// ResetZone resets all changes to the "zone" field.
func (m *DNSRecordMutation) ResetZone() {
	m.zone = nil
}

// SetVars sets the "vars" field.
func (m *DNSRecordMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *DNSRecordMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the DNSRecord entity.
// If the DNSRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSRecordMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *DNSRecordMutation) ResetVars() {
	m.vars = nil
}

// SetDisabled sets the "disabled" field.
func (m *DNSRecordMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *DNSRecordMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the DNSRecord entity.
// If the DNSRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSRecordMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *DNSRecordMutation) ResetDisabled() {
	m.disabled = nil
}

// SetTags sets the "tags" field.
func (m *DNSRecordMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *DNSRecordMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the DNSRecord entity.
// If the DNSRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSRecordMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *DNSRecordMutation) ResetTags() {
	m.tags = nil
}

// SetEnvironmentID sets the "Environment" edge to the Environment entity by id.
func (m *DNSRecordMutation) SetEnvironmentID(id uuid.UUID) {
	m._Environment = &id
}

// ClearEnvironment clears the "Environment" edge to the Environment entity.
func (m *DNSRecordMutation) ClearEnvironment() {
	m.cleared_Environment = true
}

// EnvironmentCleared reports if the "Environment" edge to the Environment entity was cleared.
func (m *DNSRecordMutation) EnvironmentCleared() bool {
	return m.cleared_Environment
}

// EnvironmentID returns the "Environment" edge ID in the mutation.
func (m *DNSRecordMutation) EnvironmentID() (id uuid.UUID, exists bool) {
	if m._Environment != nil {
		return *m._Environment, true
	}
	return
}

// EnvironmentIDs returns the "Environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *DNSRecordMutation) EnvironmentIDs() (ids []uuid.UUID) {
	if id := m._Environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "Environment" edge.
func (m *DNSRecordMutation) ResetEnvironment() {
	m._Environment = nil
	m.cleared_Environment = false
}

// Where appends a list predicates to the DNSRecordMutation builder.
func (m *DNSRecordMutation) Where(ps ...predicate.DNSRecord) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DNSRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DNSRecord).
func (m *DNSRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DNSRecordMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.hcl_id != nil {
		fields = append(fields, dnsrecord.FieldHclID)
	}
	if m.name != nil {
		fields = append(fields, dnsrecord.FieldName)
	}
	if m.values != nil {
		fields = append(fields, dnsrecord.FieldValues)
	}
	if m._type != nil {
		fields = append(fields, dnsrecord.FieldType)
	}
	if m.zone != nil {
		fields = append(fields, dnsrecord.FieldZone)
	}
	if m.vars != nil {
		fields = append(fields, dnsrecord.FieldVars)
	}
	if m.disabled != nil {
		fields = append(fields, dnsrecord.FieldDisabled)
	}
	if m.tags != nil {
		fields = append(fields, dnsrecord.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DNSRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dnsrecord.FieldHclID:
		return m.HclID()
	case dnsrecord.FieldName:
		return m.Name()
	case dnsrecord.FieldValues:
		return m.Values()
	case dnsrecord.FieldType:
		return m.GetType()
	case dnsrecord.FieldZone:
		return m.Zone()
	case dnsrecord.FieldVars:
		return m.Vars()
	case dnsrecord.FieldDisabled:
		return m.Disabled()
	case dnsrecord.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DNSRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dnsrecord.FieldHclID:
		return m.OldHclID(ctx)
	case dnsrecord.FieldName:
		return m.OldName(ctx)
	case dnsrecord.FieldValues:
		return m.OldValues(ctx)
	case dnsrecord.FieldType:
		return m.OldType(ctx)
	case dnsrecord.FieldZone:
		return m.OldZone(ctx)
	case dnsrecord.FieldVars:
		return m.OldVars(ctx)
	case dnsrecord.FieldDisabled:
		return m.OldDisabled(ctx)
	case dnsrecord.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown DNSRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DNSRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dnsrecord.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case dnsrecord.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dnsrecord.FieldValues:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValues(v)
		return nil
	case dnsrecord.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case dnsrecord.FieldZone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZone(v)
		return nil
	case dnsrecord.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	case dnsrecord.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case dnsrecord.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown DNSRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DNSRecordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DNSRecordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DNSRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DNSRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DNSRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DNSRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DNSRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DNSRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DNSRecordMutation) ResetField(name string) error {
	switch name {
	case dnsrecord.FieldHclID:
		m.ResetHclID()
		return nil
	case dnsrecord.FieldName:
		m.ResetName()
		return nil
	case dnsrecord.FieldValues:
		m.ResetValues()
		return nil
	case dnsrecord.FieldType:
		m.ResetType()
		return nil
	case dnsrecord.FieldZone:
		m.ResetZone()
		return nil
	case dnsrecord.FieldVars:
		m.ResetVars()
		return nil
	case dnsrecord.FieldDisabled:
		m.ResetDisabled()
		return nil
	case dnsrecord.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown DNSRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DNSRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Environment != nil {
		edges = append(edges, dnsrecord.EdgeEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DNSRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dnsrecord.EdgeEnvironment:
		if id := m._Environment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DNSRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DNSRecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DNSRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Environment {
		edges = append(edges, dnsrecord.EdgeEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DNSRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case dnsrecord.EdgeEnvironment:
		return m.cleared_Environment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DNSRecordMutation) ClearEdge(name string) error {
	switch name {
	case dnsrecord.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	}
	return fmt.Errorf("unknown DNSRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DNSRecordMutation) ResetEdge(name string) error {
	switch name {
	case dnsrecord.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	}
	return fmt.Errorf("unknown DNSRecord edge %s", name)
}

// DiskMutation represents an operation that mutates the Disk nodes in the graph.
type DiskMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	size          *int
	addsize       *int
	clearedFields map[string]struct{}
	_Host         *uuid.UUID
	cleared_Host  bool
	done          bool
	oldValue      func(context.Context) (*Disk, error)
	predicates    []predicate.Disk
}

var _ ent.Mutation = (*DiskMutation)(nil)

// diskOption allows management of the mutation configuration using functional options.
type diskOption func(*DiskMutation)

// newDiskMutation creates new mutation for the Disk entity.
func newDiskMutation(c config, op Op, opts ...diskOption) *DiskMutation {
	m := &DiskMutation{
		config:        c,
		op:            op,
		typ:           TypeDisk,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiskID sets the ID field of the mutation.
func withDiskID(id uuid.UUID) diskOption {
	return func(m *DiskMutation) {
		var (
			err   error
			once  sync.Once
			value *Disk
		)
		m.oldValue = func(ctx context.Context) (*Disk, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Disk.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDisk sets the old Disk of the mutation.
func withDisk(node *Disk) diskOption {
	return func(m *DiskMutation) {
		m.oldValue = func(context.Context) (*Disk, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Disk entities.
func (m *DiskMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DiskMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DiskMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Disk.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSize sets the "size" field.
func (m *DiskMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *DiskMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Disk entity.
// If the Disk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiskMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *DiskMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *DiskMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *DiskMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetHostID sets the "Host" edge to the Host entity by id.
func (m *DiskMutation) SetHostID(id uuid.UUID) {
	m._Host = &id
}

// ClearHost clears the "Host" edge to the Host entity.
func (m *DiskMutation) ClearHost() {
	m.cleared_Host = true
}

// HostCleared reports if the "Host" edge to the Host entity was cleared.
func (m *DiskMutation) HostCleared() bool {
	return m.cleared_Host
}

// HostID returns the "Host" edge ID in the mutation.
func (m *DiskMutation) HostID() (id uuid.UUID, exists bool) {
	if m._Host != nil {
		return *m._Host, true
	}
	return
}

// HostIDs returns the "Host" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostID instead. It exists only for internal usage by the builders.
func (m *DiskMutation) HostIDs() (ids []uuid.UUID) {
	if id := m._Host; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHost resets all changes to the "Host" edge.
func (m *DiskMutation) ResetHost() {
	m._Host = nil
	m.cleared_Host = false
}

// Where appends a list predicates to the DiskMutation builder.
func (m *DiskMutation) Where(ps ...predicate.Disk) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DiskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Disk).
func (m *DiskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DiskMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.size != nil {
		fields = append(fields, disk.FieldSize)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DiskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case disk.FieldSize:
		return m.Size()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DiskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case disk.FieldSize:
		return m.OldSize(ctx)
	}
	return nil, fmt.Errorf("unknown Disk field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case disk.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	}
	return fmt.Errorf("unknown Disk field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DiskMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, disk.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DiskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case disk.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case disk.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown Disk numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DiskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DiskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Disk nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DiskMutation) ResetField(name string) error {
	switch name {
	case disk.FieldSize:
		m.ResetSize()
		return nil
	}
	return fmt.Errorf("unknown Disk field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DiskMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Host != nil {
		edges = append(edges, disk.EdgeHost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DiskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case disk.EdgeHost:
		if id := m._Host; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DiskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DiskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DiskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Host {
		edges = append(edges, disk.EdgeHost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DiskMutation) EdgeCleared(name string) bool {
	switch name {
	case disk.EdgeHost:
		return m.cleared_Host
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DiskMutation) ClearEdge(name string) error {
	switch name {
	case disk.EdgeHost:
		m.ClearHost()
		return nil
	}
	return fmt.Errorf("unknown Disk unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DiskMutation) ResetEdge(name string) error {
	switch name {
	case disk.EdgeHost:
		m.ResetHost()
		return nil
	}
	return fmt.Errorf("unknown Disk edge %s", name)
}

// EnvironmentMutation represents an operation that mutates the Environment nodes in the graph.
type EnvironmentMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	hcl_id                   *string
	competition_id           *string
	name                     *string
	description              *string
	builder                  *string
	team_count               *int
	addteam_count            *int
	revision                 *int
	addrevision              *int
	admin_cidrs              *[]string
	exposed_vdi_ports        *[]string
	_config                  *map[string]string
	tags                     *map[string]string
	clearedFields            map[string]struct{}
	_Users                   map[uuid.UUID]struct{}
	removed_Users            map[uuid.UUID]struct{}
	cleared_Users            bool
	_Hosts                   map[uuid.UUID]struct{}
	removed_Hosts            map[uuid.UUID]struct{}
	cleared_Hosts            bool
	_Competitions            map[uuid.UUID]struct{}
	removed_Competitions     map[uuid.UUID]struct{}
	cleared_Competitions     bool
	_Identities              map[uuid.UUID]struct{}
	removed_Identities       map[uuid.UUID]struct{}
	cleared_Identities       bool
	_Commands                map[uuid.UUID]struct{}
	removed_Commands         map[uuid.UUID]struct{}
	cleared_Commands         bool
	_Scripts                 map[uuid.UUID]struct{}
	removed_Scripts          map[uuid.UUID]struct{}
	cleared_Scripts          bool
	_FileDownloads           map[uuid.UUID]struct{}
	removed_FileDownloads    map[uuid.UUID]struct{}
	cleared_FileDownloads    bool
	_FileDeletes             map[uuid.UUID]struct{}
	removed_FileDeletes      map[uuid.UUID]struct{}
	cleared_FileDeletes      bool
	_FileExtracts            map[uuid.UUID]struct{}
	removed_FileExtracts     map[uuid.UUID]struct{}
	cleared_FileExtracts     bool
	_IncludedNetworks        map[uuid.UUID]struct{}
	removed_IncludedNetworks map[uuid.UUID]struct{}
	cleared_IncludedNetworks bool
	_Findings                map[uuid.UUID]struct{}
	removed_Findings         map[uuid.UUID]struct{}
	cleared_Findings         bool
	_DNSRecords              map[uuid.UUID]struct{}
	removed_DNSRecords       map[uuid.UUID]struct{}
	cleared_DNSRecords       bool
	_DNS                     map[uuid.UUID]struct{}
	removed_DNS              map[uuid.UUID]struct{}
	cleared_DNS              bool
	_Networks                map[uuid.UUID]struct{}
	removed_Networks         map[uuid.UUID]struct{}
	cleared_Networks         bool
	_HostDependencies        map[uuid.UUID]struct{}
	removed_HostDependencies map[uuid.UUID]struct{}
	cleared_HostDependencies bool
	_Ansibles                map[uuid.UUID]struct{}
	removed_Ansibles         map[uuid.UUID]struct{}
	cleared_Ansibles         bool
	_ScheduledSteps          map[uuid.UUID]struct{}
	removed_ScheduledSteps   map[uuid.UUID]struct{}
	cleared_ScheduledSteps   bool
	_Builds                  map[uuid.UUID]struct{}
	removed_Builds           map[uuid.UUID]struct{}
	cleared_Builds           bool
	_Repositories            map[uuid.UUID]struct{}
	removed_Repositories     map[uuid.UUID]struct{}
	cleared_Repositories     bool
	_ServerTasks             map[uuid.UUID]struct{}
	removed_ServerTasks      map[uuid.UUID]struct{}
	cleared_ServerTasks      bool
	done                     bool
	oldValue                 func(context.Context) (*Environment, error)
	predicates               []predicate.Environment
}

var _ ent.Mutation = (*EnvironmentMutation)(nil)

// environmentOption allows management of the mutation configuration using functional options.
type environmentOption func(*EnvironmentMutation)

// newEnvironmentMutation creates new mutation for the Environment entity.
func newEnvironmentMutation(c config, op Op, opts ...environmentOption) *EnvironmentMutation {
	m := &EnvironmentMutation{
		config:        c,
		op:            op,
		typ:           TypeEnvironment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnvironmentID sets the ID field of the mutation.
func withEnvironmentID(id uuid.UUID) environmentOption {
	return func(m *EnvironmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Environment
		)
		m.oldValue = func(ctx context.Context) (*Environment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Environment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnvironment sets the old Environment of the mutation.
func withEnvironment(node *Environment) environmentOption {
	return func(m *EnvironmentMutation) {
		m.oldValue = func(context.Context) (*Environment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnvironmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnvironmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Environment entities.
func (m *EnvironmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnvironmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnvironmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Environment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHclID sets the "hcl_id" field.
func (m *EnvironmentMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *EnvironmentMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *EnvironmentMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetCompetitionID sets the "competition_id" field.
func (m *EnvironmentMutation) SetCompetitionID(s string) {
	m.competition_id = &s
}

// CompetitionID returns the value of the "competition_id" field in the mutation.
func (m *EnvironmentMutation) CompetitionID() (r string, exists bool) {
	v := m.competition_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitionID returns the old "competition_id" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldCompetitionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitionID: %w", err)
	}
	return oldValue.CompetitionID, nil
}

// ResetCompetitionID resets all changes to the "competition_id" field.
func (m *EnvironmentMutation) ResetCompetitionID() {
	m.competition_id = nil
}

// SetName sets the "name" field.
func (m *EnvironmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EnvironmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EnvironmentMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *EnvironmentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EnvironmentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *EnvironmentMutation) ResetDescription() {
	m.description = nil
}

// SetBuilder sets the "builder" field.
func (m *EnvironmentMutation) SetBuilder(s string) {
	m.builder = &s
}

// Builder returns the value of the "builder" field in the mutation.
func (m *EnvironmentMutation) Builder() (r string, exists bool) {
	v := m.builder
	if v == nil {
		return
	}
	return *v, true
}

// OldBuilder returns the old "builder" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldBuilder(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuilder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuilder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuilder: %w", err)
	}
	return oldValue.Builder, nil
}

// ResetBuilder resets all changes to the "builder" field.
func (m *EnvironmentMutation) ResetBuilder() {
	m.builder = nil
}

// SetTeamCount sets the "team_count" field.
func (m *EnvironmentMutation) SetTeamCount(i int) {
	m.team_count = &i
	m.addteam_count = nil
}

// TeamCount returns the value of the "team_count" field in the mutation.
func (m *EnvironmentMutation) TeamCount() (r int, exists bool) {
	v := m.team_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamCount returns the old "team_count" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldTeamCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamCount: %w", err)
	}
	return oldValue.TeamCount, nil
}

// AddTeamCount adds i to the "team_count" field.
func (m *EnvironmentMutation) AddTeamCount(i int) {
	if m.addteam_count != nil {
		*m.addteam_count += i
	} else {
		m.addteam_count = &i
	}
}

// AddedTeamCount returns the value that was added to the "team_count" field in this mutation.
func (m *EnvironmentMutation) AddedTeamCount() (r int, exists bool) {
	v := m.addteam_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetTeamCount resets all changes to the "team_count" field.
func (m *EnvironmentMutation) ResetTeamCount() {
	m.team_count = nil
	m.addteam_count = nil
}

// SetRevision sets the "revision" field.
func (m *EnvironmentMutation) SetRevision(i int) {
	m.revision = &i
	m.addrevision = nil
}

// Revision returns the value of the "revision" field in the mutation.
func (m *EnvironmentMutation) Revision() (r int, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldRevision(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// AddRevision adds i to the "revision" field.
func (m *EnvironmentMutation) AddRevision(i int) {
	if m.addrevision != nil {
		*m.addrevision += i
	} else {
		m.addrevision = &i
	}
}

// AddedRevision returns the value that was added to the "revision" field in this mutation.
func (m *EnvironmentMutation) AddedRevision() (r int, exists bool) {
	v := m.addrevision
	if v == nil {
		return
	}
	return *v, true
}

// ResetRevision resets all changes to the "revision" field.
func (m *EnvironmentMutation) ResetRevision() {
	m.revision = nil
	m.addrevision = nil
}

// SetAdminCidrs sets the "admin_cidrs" field.
func (m *EnvironmentMutation) SetAdminCidrs(s []string) {
	m.admin_cidrs = &s
}

// AdminCidrs returns the value of the "admin_cidrs" field in the mutation.
func (m *EnvironmentMutation) AdminCidrs() (r []string, exists bool) {
	v := m.admin_cidrs
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminCidrs returns the old "admin_cidrs" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldAdminCidrs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdminCidrs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdminCidrs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminCidrs: %w", err)
	}
	return oldValue.AdminCidrs, nil
}

// ResetAdminCidrs resets all changes to the "admin_cidrs" field.
func (m *EnvironmentMutation) ResetAdminCidrs() {
	m.admin_cidrs = nil
}

// SetExposedVdiPorts sets the "exposed_vdi_ports" field.
func (m *EnvironmentMutation) SetExposedVdiPorts(s []string) {
	m.exposed_vdi_ports = &s
}

// ExposedVdiPorts returns the value of the "exposed_vdi_ports" field in the mutation.
func (m *EnvironmentMutation) ExposedVdiPorts() (r []string, exists bool) {
	v := m.exposed_vdi_ports
	if v == nil {
		return
	}
	return *v, true
}

// OldExposedVdiPorts returns the old "exposed_vdi_ports" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldExposedVdiPorts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExposedVdiPorts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExposedVdiPorts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExposedVdiPorts: %w", err)
	}
	return oldValue.ExposedVdiPorts, nil
}

// ResetExposedVdiPorts resets all changes to the "exposed_vdi_ports" field.
func (m *EnvironmentMutation) ResetExposedVdiPorts() {
	m.exposed_vdi_ports = nil
}

// SetConfig sets the "config" field.
func (m *EnvironmentMutation) SetConfig(value map[string]string) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *EnvironmentMutation) Config() (r map[string]string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldConfig(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *EnvironmentMutation) ResetConfig() {
	m._config = nil
}

// SetTags sets the "tags" field.
func (m *EnvironmentMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *EnvironmentMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *EnvironmentMutation) ResetTags() {
	m.tags = nil
}

// AddUserIDs adds the "Users" edge to the User entity by ids.
func (m *EnvironmentMutation) AddUserIDs(ids ...uuid.UUID) {
	if m._Users == nil {
		m._Users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "Users" edge to the User entity.
func (m *EnvironmentMutation) ClearUsers() {
	m.cleared_Users = true
}

// UsersCleared reports if the "Users" edge to the User entity was cleared.
func (m *EnvironmentMutation) UsersCleared() bool {
	return m.cleared_Users
}

// RemoveUserIDs removes the "Users" edge to the User entity by IDs.
func (m *EnvironmentMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removed_Users == nil {
		m.removed_Users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Users, ids[i])
		m.removed_Users[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "Users" edge to the User entity.
func (m *EnvironmentMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removed_Users {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "Users" edge IDs in the mutation.
func (m *EnvironmentMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m._Users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "Users" edge.
func (m *EnvironmentMutation) ResetUsers() {
	m._Users = nil
	m.cleared_Users = false
	m.removed_Users = nil
}

// AddHostIDs adds the "Hosts" edge to the Host entity by ids.
func (m *EnvironmentMutation) AddHostIDs(ids ...uuid.UUID) {
	if m._Hosts == nil {
		m._Hosts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Hosts[ids[i]] = struct{}{}
	}
}

// ClearHosts clears the "Hosts" edge to the Host entity.
func (m *EnvironmentMutation) ClearHosts() {
	m.cleared_Hosts = true
}

// HostsCleared reports if the "Hosts" edge to the Host entity was cleared.
func (m *EnvironmentMutation) HostsCleared() bool {
	return m.cleared_Hosts
}

// RemoveHostIDs removes the "Hosts" edge to the Host entity by IDs.
func (m *EnvironmentMutation) RemoveHostIDs(ids ...uuid.UUID) {
	if m.removed_Hosts == nil {
		m.removed_Hosts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Hosts, ids[i])
		m.removed_Hosts[ids[i]] = struct{}{}
	}
}

// RemovedHosts returns the removed IDs of the "Hosts" edge to the Host entity.
func (m *EnvironmentMutation) RemovedHostsIDs() (ids []uuid.UUID) {
	for id := range m.removed_Hosts {
		ids = append(ids, id)
	}
	return
}

// HostsIDs returns the "Hosts" edge IDs in the mutation.
func (m *EnvironmentMutation) HostsIDs() (ids []uuid.UUID) {
	for id := range m._Hosts {
		ids = append(ids, id)
	}
	return
}

// ResetHosts resets all changes to the "Hosts" edge.
func (m *EnvironmentMutation) ResetHosts() {
	m._Hosts = nil
	m.cleared_Hosts = false
	m.removed_Hosts = nil
}

// AddCompetitionIDs adds the "Competitions" edge to the Competition entity by ids.
func (m *EnvironmentMutation) AddCompetitionIDs(ids ...uuid.UUID) {
	if m._Competitions == nil {
		m._Competitions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Competitions[ids[i]] = struct{}{}
	}
}

// ClearCompetitions clears the "Competitions" edge to the Competition entity.
func (m *EnvironmentMutation) ClearCompetitions() {
	m.cleared_Competitions = true
}

// CompetitionsCleared reports if the "Competitions" edge to the Competition entity was cleared.
func (m *EnvironmentMutation) CompetitionsCleared() bool {
	return m.cleared_Competitions
}

// RemoveCompetitionIDs removes the "Competitions" edge to the Competition entity by IDs.
func (m *EnvironmentMutation) RemoveCompetitionIDs(ids ...uuid.UUID) {
	if m.removed_Competitions == nil {
		m.removed_Competitions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Competitions, ids[i])
		m.removed_Competitions[ids[i]] = struct{}{}
	}
}

// RemovedCompetitions returns the removed IDs of the "Competitions" edge to the Competition entity.
func (m *EnvironmentMutation) RemovedCompetitionsIDs() (ids []uuid.UUID) {
	for id := range m.removed_Competitions {
		ids = append(ids, id)
	}
	return
}

// CompetitionsIDs returns the "Competitions" edge IDs in the mutation.
func (m *EnvironmentMutation) CompetitionsIDs() (ids []uuid.UUID) {
	for id := range m._Competitions {
		ids = append(ids, id)
	}
	return
}

// ResetCompetitions resets all changes to the "Competitions" edge.
func (m *EnvironmentMutation) ResetCompetitions() {
	m._Competitions = nil
	m.cleared_Competitions = false
	m.removed_Competitions = nil
}

// AddIdentityIDs adds the "Identities" edge to the Identity entity by ids.
func (m *EnvironmentMutation) AddIdentityIDs(ids ...uuid.UUID) {
	if m._Identities == nil {
		m._Identities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Identities[ids[i]] = struct{}{}
	}
}

// ClearIdentities clears the "Identities" edge to the Identity entity.
func (m *EnvironmentMutation) ClearIdentities() {
	m.cleared_Identities = true
}

// IdentitiesCleared reports if the "Identities" edge to the Identity entity was cleared.
func (m *EnvironmentMutation) IdentitiesCleared() bool {
	return m.cleared_Identities
}

// RemoveIdentityIDs removes the "Identities" edge to the Identity entity by IDs.
func (m *EnvironmentMutation) RemoveIdentityIDs(ids ...uuid.UUID) {
	if m.removed_Identities == nil {
		m.removed_Identities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Identities, ids[i])
		m.removed_Identities[ids[i]] = struct{}{}
	}
}

// RemovedIdentities returns the removed IDs of the "Identities" edge to the Identity entity.
func (m *EnvironmentMutation) RemovedIdentitiesIDs() (ids []uuid.UUID) {
	for id := range m.removed_Identities {
		ids = append(ids, id)
	}
	return
}

// IdentitiesIDs returns the "Identities" edge IDs in the mutation.
func (m *EnvironmentMutation) IdentitiesIDs() (ids []uuid.UUID) {
	for id := range m._Identities {
		ids = append(ids, id)
	}
	return
}

// ResetIdentities resets all changes to the "Identities" edge.
func (m *EnvironmentMutation) ResetIdentities() {
	m._Identities = nil
	m.cleared_Identities = false
	m.removed_Identities = nil
}

// AddCommandIDs adds the "Commands" edge to the Command entity by ids.
func (m *EnvironmentMutation) AddCommandIDs(ids ...uuid.UUID) {
	if m._Commands == nil {
		m._Commands = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Commands[ids[i]] = struct{}{}
	}
}

// ClearCommands clears the "Commands" edge to the Command entity.
func (m *EnvironmentMutation) ClearCommands() {
	m.cleared_Commands = true
}

// CommandsCleared reports if the "Commands" edge to the Command entity was cleared.
func (m *EnvironmentMutation) CommandsCleared() bool {
	return m.cleared_Commands
}

// RemoveCommandIDs removes the "Commands" edge to the Command entity by IDs.
func (m *EnvironmentMutation) RemoveCommandIDs(ids ...uuid.UUID) {
	if m.removed_Commands == nil {
		m.removed_Commands = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Commands, ids[i])
		m.removed_Commands[ids[i]] = struct{}{}
	}
}

// RemovedCommands returns the removed IDs of the "Commands" edge to the Command entity.
func (m *EnvironmentMutation) RemovedCommandsIDs() (ids []uuid.UUID) {
	for id := range m.removed_Commands {
		ids = append(ids, id)
	}
	return
}

// CommandsIDs returns the "Commands" edge IDs in the mutation.
func (m *EnvironmentMutation) CommandsIDs() (ids []uuid.UUID) {
	for id := range m._Commands {
		ids = append(ids, id)
	}
	return
}

// ResetCommands resets all changes to the "Commands" edge.
func (m *EnvironmentMutation) ResetCommands() {
	m._Commands = nil
	m.cleared_Commands = false
	m.removed_Commands = nil
}

// AddScriptIDs adds the "Scripts" edge to the Script entity by ids.
func (m *EnvironmentMutation) AddScriptIDs(ids ...uuid.UUID) {
	if m._Scripts == nil {
		m._Scripts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Scripts[ids[i]] = struct{}{}
	}
}

// ClearScripts clears the "Scripts" edge to the Script entity.
func (m *EnvironmentMutation) ClearScripts() {
	m.cleared_Scripts = true
}

// ScriptsCleared reports if the "Scripts" edge to the Script entity was cleared.
func (m *EnvironmentMutation) ScriptsCleared() bool {
	return m.cleared_Scripts
}

// RemoveScriptIDs removes the "Scripts" edge to the Script entity by IDs.
func (m *EnvironmentMutation) RemoveScriptIDs(ids ...uuid.UUID) {
	if m.removed_Scripts == nil {
		m.removed_Scripts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Scripts, ids[i])
		m.removed_Scripts[ids[i]] = struct{}{}
	}
}

// RemovedScripts returns the removed IDs of the "Scripts" edge to the Script entity.
func (m *EnvironmentMutation) RemovedScriptsIDs() (ids []uuid.UUID) {
	for id := range m.removed_Scripts {
		ids = append(ids, id)
	}
	return
}

// ScriptsIDs returns the "Scripts" edge IDs in the mutation.
func (m *EnvironmentMutation) ScriptsIDs() (ids []uuid.UUID) {
	for id := range m._Scripts {
		ids = append(ids, id)
	}
	return
}

// ResetScripts resets all changes to the "Scripts" edge.
func (m *EnvironmentMutation) ResetScripts() {
	m._Scripts = nil
	m.cleared_Scripts = false
	m.removed_Scripts = nil
}

// AddFileDownloadIDs adds the "FileDownloads" edge to the FileDownload entity by ids.
func (m *EnvironmentMutation) AddFileDownloadIDs(ids ...uuid.UUID) {
	if m._FileDownloads == nil {
		m._FileDownloads = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._FileDownloads[ids[i]] = struct{}{}
	}
}

// ClearFileDownloads clears the "FileDownloads" edge to the FileDownload entity.
func (m *EnvironmentMutation) ClearFileDownloads() {
	m.cleared_FileDownloads = true
}

// FileDownloadsCleared reports if the "FileDownloads" edge to the FileDownload entity was cleared.
func (m *EnvironmentMutation) FileDownloadsCleared() bool {
	return m.cleared_FileDownloads
}

// RemoveFileDownloadIDs removes the "FileDownloads" edge to the FileDownload entity by IDs.
func (m *EnvironmentMutation) RemoveFileDownloadIDs(ids ...uuid.UUID) {
	if m.removed_FileDownloads == nil {
		m.removed_FileDownloads = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._FileDownloads, ids[i])
		m.removed_FileDownloads[ids[i]] = struct{}{}
	}
}

// RemovedFileDownloads returns the removed IDs of the "FileDownloads" edge to the FileDownload entity.
func (m *EnvironmentMutation) RemovedFileDownloadsIDs() (ids []uuid.UUID) {
	for id := range m.removed_FileDownloads {
		ids = append(ids, id)
	}
	return
}

// FileDownloadsIDs returns the "FileDownloads" edge IDs in the mutation.
func (m *EnvironmentMutation) FileDownloadsIDs() (ids []uuid.UUID) {
	for id := range m._FileDownloads {
		ids = append(ids, id)
	}
	return
}

// ResetFileDownloads resets all changes to the "FileDownloads" edge.
func (m *EnvironmentMutation) ResetFileDownloads() {
	m._FileDownloads = nil
	m.cleared_FileDownloads = false
	m.removed_FileDownloads = nil
}

// AddFileDeleteIDs adds the "FileDeletes" edge to the FileDelete entity by ids.
func (m *EnvironmentMutation) AddFileDeleteIDs(ids ...uuid.UUID) {
	if m._FileDeletes == nil {
		m._FileDeletes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._FileDeletes[ids[i]] = struct{}{}
	}
}

// ClearFileDeletes clears the "FileDeletes" edge to the FileDelete entity.
func (m *EnvironmentMutation) ClearFileDeletes() {
	m.cleared_FileDeletes = true
}

// FileDeletesCleared reports if the "FileDeletes" edge to the FileDelete entity was cleared.
func (m *EnvironmentMutation) FileDeletesCleared() bool {
	return m.cleared_FileDeletes
}

// RemoveFileDeleteIDs removes the "FileDeletes" edge to the FileDelete entity by IDs.
func (m *EnvironmentMutation) RemoveFileDeleteIDs(ids ...uuid.UUID) {
	if m.removed_FileDeletes == nil {
		m.removed_FileDeletes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._FileDeletes, ids[i])
		m.removed_FileDeletes[ids[i]] = struct{}{}
	}
}

// RemovedFileDeletes returns the removed IDs of the "FileDeletes" edge to the FileDelete entity.
func (m *EnvironmentMutation) RemovedFileDeletesIDs() (ids []uuid.UUID) {
	for id := range m.removed_FileDeletes {
		ids = append(ids, id)
	}
	return
}

// FileDeletesIDs returns the "FileDeletes" edge IDs in the mutation.
func (m *EnvironmentMutation) FileDeletesIDs() (ids []uuid.UUID) {
	for id := range m._FileDeletes {
		ids = append(ids, id)
	}
	return
}

// ResetFileDeletes resets all changes to the "FileDeletes" edge.
func (m *EnvironmentMutation) ResetFileDeletes() {
	m._FileDeletes = nil
	m.cleared_FileDeletes = false
	m.removed_FileDeletes = nil
}

// AddFileExtractIDs adds the "FileExtracts" edge to the FileExtract entity by ids.
func (m *EnvironmentMutation) AddFileExtractIDs(ids ...uuid.UUID) {
	if m._FileExtracts == nil {
		m._FileExtracts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._FileExtracts[ids[i]] = struct{}{}
	}
}

// ClearFileExtracts clears the "FileExtracts" edge to the FileExtract entity.
func (m *EnvironmentMutation) ClearFileExtracts() {
	m.cleared_FileExtracts = true
}

// FileExtractsCleared reports if the "FileExtracts" edge to the FileExtract entity was cleared.
func (m *EnvironmentMutation) FileExtractsCleared() bool {
	return m.cleared_FileExtracts
}

// RemoveFileExtractIDs removes the "FileExtracts" edge to the FileExtract entity by IDs.
func (m *EnvironmentMutation) RemoveFileExtractIDs(ids ...uuid.UUID) {
	if m.removed_FileExtracts == nil {
		m.removed_FileExtracts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._FileExtracts, ids[i])
		m.removed_FileExtracts[ids[i]] = struct{}{}
	}
}

// RemovedFileExtracts returns the removed IDs of the "FileExtracts" edge to the FileExtract entity.
func (m *EnvironmentMutation) RemovedFileExtractsIDs() (ids []uuid.UUID) {
	for id := range m.removed_FileExtracts {
		ids = append(ids, id)
	}
	return
}

// FileExtractsIDs returns the "FileExtracts" edge IDs in the mutation.
func (m *EnvironmentMutation) FileExtractsIDs() (ids []uuid.UUID) {
	for id := range m._FileExtracts {
		ids = append(ids, id)
	}
	return
}

// ResetFileExtracts resets all changes to the "FileExtracts" edge.
func (m *EnvironmentMutation) ResetFileExtracts() {
	m._FileExtracts = nil
	m.cleared_FileExtracts = false
	m.removed_FileExtracts = nil
}

// AddIncludedNetworkIDs adds the "IncludedNetworks" edge to the IncludedNetwork entity by ids.
func (m *EnvironmentMutation) AddIncludedNetworkIDs(ids ...uuid.UUID) {
	if m._IncludedNetworks == nil {
		m._IncludedNetworks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._IncludedNetworks[ids[i]] = struct{}{}
	}
}

// ClearIncludedNetworks clears the "IncludedNetworks" edge to the IncludedNetwork entity.
func (m *EnvironmentMutation) ClearIncludedNetworks() {
	m.cleared_IncludedNetworks = true
}

// IncludedNetworksCleared reports if the "IncludedNetworks" edge to the IncludedNetwork entity was cleared.
func (m *EnvironmentMutation) IncludedNetworksCleared() bool {
	return m.cleared_IncludedNetworks
}

// RemoveIncludedNetworkIDs removes the "IncludedNetworks" edge to the IncludedNetwork entity by IDs.
func (m *EnvironmentMutation) RemoveIncludedNetworkIDs(ids ...uuid.UUID) {
	if m.removed_IncludedNetworks == nil {
		m.removed_IncludedNetworks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._IncludedNetworks, ids[i])
		m.removed_IncludedNetworks[ids[i]] = struct{}{}
	}
}

// RemovedIncludedNetworks returns the removed IDs of the "IncludedNetworks" edge to the IncludedNetwork entity.
func (m *EnvironmentMutation) RemovedIncludedNetworksIDs() (ids []uuid.UUID) {
	for id := range m.removed_IncludedNetworks {
		ids = append(ids, id)
	}
	return
}

// IncludedNetworksIDs returns the "IncludedNetworks" edge IDs in the mutation.
func (m *EnvironmentMutation) IncludedNetworksIDs() (ids []uuid.UUID) {
	for id := range m._IncludedNetworks {
		ids = append(ids, id)
	}
	return
}

// ResetIncludedNetworks resets all changes to the "IncludedNetworks" edge.
func (m *EnvironmentMutation) ResetIncludedNetworks() {
	m._IncludedNetworks = nil
	m.cleared_IncludedNetworks = false
	m.removed_IncludedNetworks = nil
}

// AddFindingIDs adds the "Findings" edge to the Finding entity by ids.
func (m *EnvironmentMutation) AddFindingIDs(ids ...uuid.UUID) {
	if m._Findings == nil {
		m._Findings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Findings[ids[i]] = struct{}{}
	}
}

// ClearFindings clears the "Findings" edge to the Finding entity.
func (m *EnvironmentMutation) ClearFindings() {
	m.cleared_Findings = true
}

// FindingsCleared reports if the "Findings" edge to the Finding entity was cleared.
func (m *EnvironmentMutation) FindingsCleared() bool {
	return m.cleared_Findings
}

// RemoveFindingIDs removes the "Findings" edge to the Finding entity by IDs.
func (m *EnvironmentMutation) RemoveFindingIDs(ids ...uuid.UUID) {
	if m.removed_Findings == nil {
		m.removed_Findings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Findings, ids[i])
		m.removed_Findings[ids[i]] = struct{}{}
	}
}

// RemovedFindings returns the removed IDs of the "Findings" edge to the Finding entity.
func (m *EnvironmentMutation) RemovedFindingsIDs() (ids []uuid.UUID) {
	for id := range m.removed_Findings {
		ids = append(ids, id)
	}
	return
}

// FindingsIDs returns the "Findings" edge IDs in the mutation.
func (m *EnvironmentMutation) FindingsIDs() (ids []uuid.UUID) {
	for id := range m._Findings {
		ids = append(ids, id)
	}
	return
}

// ResetFindings resets all changes to the "Findings" edge.
func (m *EnvironmentMutation) ResetFindings() {
	m._Findings = nil
	m.cleared_Findings = false
	m.removed_Findings = nil
}

// AddDNSRecordIDs adds the "DNSRecords" edge to the DNSRecord entity by ids.
func (m *EnvironmentMutation) AddDNSRecordIDs(ids ...uuid.UUID) {
	if m._DNSRecords == nil {
		m._DNSRecords = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._DNSRecords[ids[i]] = struct{}{}
	}
}

// ClearDNSRecords clears the "DNSRecords" edge to the DNSRecord entity.
func (m *EnvironmentMutation) ClearDNSRecords() {
	m.cleared_DNSRecords = true
}

// DNSRecordsCleared reports if the "DNSRecords" edge to the DNSRecord entity was cleared.
func (m *EnvironmentMutation) DNSRecordsCleared() bool {
	return m.cleared_DNSRecords
}

// RemoveDNSRecordIDs removes the "DNSRecords" edge to the DNSRecord entity by IDs.
func (m *EnvironmentMutation) RemoveDNSRecordIDs(ids ...uuid.UUID) {
	if m.removed_DNSRecords == nil {
		m.removed_DNSRecords = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._DNSRecords, ids[i])
		m.removed_DNSRecords[ids[i]] = struct{}{}
	}
}

// RemovedDNSRecords returns the removed IDs of the "DNSRecords" edge to the DNSRecord entity.
func (m *EnvironmentMutation) RemovedDNSRecordsIDs() (ids []uuid.UUID) {
	for id := range m.removed_DNSRecords {
		ids = append(ids, id)
	}
	return
}

// DNSRecordsIDs returns the "DNSRecords" edge IDs in the mutation.
func (m *EnvironmentMutation) DNSRecordsIDs() (ids []uuid.UUID) {
	for id := range m._DNSRecords {
		ids = append(ids, id)
	}
	return
}

// ResetDNSRecords resets all changes to the "DNSRecords" edge.
func (m *EnvironmentMutation) ResetDNSRecords() {
	m._DNSRecords = nil
	m.cleared_DNSRecords = false
	m.removed_DNSRecords = nil
}

// AddDNSIDs adds the "DNS" edge to the DNS entity by ids.
func (m *EnvironmentMutation) AddDNSIDs(ids ...uuid.UUID) {
	if m._DNS == nil {
		m._DNS = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._DNS[ids[i]] = struct{}{}
	}
}

// ClearDNS clears the "DNS" edge to the DNS entity.
func (m *EnvironmentMutation) ClearDNS() {
	m.cleared_DNS = true
}

// DNSCleared reports if the "DNS" edge to the DNS entity was cleared.
func (m *EnvironmentMutation) DNSCleared() bool {
	return m.cleared_DNS
}

// RemoveDNSIDs removes the "DNS" edge to the DNS entity by IDs.
func (m *EnvironmentMutation) RemoveDNSIDs(ids ...uuid.UUID) {
	if m.removed_DNS == nil {
		m.removed_DNS = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._DNS, ids[i])
		m.removed_DNS[ids[i]] = struct{}{}
	}
}

// RemovedDNS returns the removed IDs of the "DNS" edge to the DNS entity.
func (m *EnvironmentMutation) RemovedDNSIDs() (ids []uuid.UUID) {
	for id := range m.removed_DNS {
		ids = append(ids, id)
	}
	return
}

// DNSIDs returns the "DNS" edge IDs in the mutation.
func (m *EnvironmentMutation) DNSIDs() (ids []uuid.UUID) {
	for id := range m._DNS {
		ids = append(ids, id)
	}
	return
}

// ResetDNS resets all changes to the "DNS" edge.
func (m *EnvironmentMutation) ResetDNS() {
	m._DNS = nil
	m.cleared_DNS = false
	m.removed_DNS = nil
}

// AddNetworkIDs adds the "Networks" edge to the Network entity by ids.
func (m *EnvironmentMutation) AddNetworkIDs(ids ...uuid.UUID) {
	if m._Networks == nil {
		m._Networks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Networks[ids[i]] = struct{}{}
	}
}

// ClearNetworks clears the "Networks" edge to the Network entity.
func (m *EnvironmentMutation) ClearNetworks() {
	m.cleared_Networks = true
}

// NetworksCleared reports if the "Networks" edge to the Network entity was cleared.
func (m *EnvironmentMutation) NetworksCleared() bool {
	return m.cleared_Networks
}

// RemoveNetworkIDs removes the "Networks" edge to the Network entity by IDs.
func (m *EnvironmentMutation) RemoveNetworkIDs(ids ...uuid.UUID) {
	if m.removed_Networks == nil {
		m.removed_Networks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Networks, ids[i])
		m.removed_Networks[ids[i]] = struct{}{}
	}
}

// RemovedNetworks returns the removed IDs of the "Networks" edge to the Network entity.
func (m *EnvironmentMutation) RemovedNetworksIDs() (ids []uuid.UUID) {
	for id := range m.removed_Networks {
		ids = append(ids, id)
	}
	return
}

// NetworksIDs returns the "Networks" edge IDs in the mutation.
func (m *EnvironmentMutation) NetworksIDs() (ids []uuid.UUID) {
	for id := range m._Networks {
		ids = append(ids, id)
	}
	return
}

// ResetNetworks resets all changes to the "Networks" edge.
func (m *EnvironmentMutation) ResetNetworks() {
	m._Networks = nil
	m.cleared_Networks = false
	m.removed_Networks = nil
}

// AddHostDependencyIDs adds the "HostDependencies" edge to the HostDependency entity by ids.
func (m *EnvironmentMutation) AddHostDependencyIDs(ids ...uuid.UUID) {
	if m._HostDependencies == nil {
		m._HostDependencies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._HostDependencies[ids[i]] = struct{}{}
	}
}

// ClearHostDependencies clears the "HostDependencies" edge to the HostDependency entity.
func (m *EnvironmentMutation) ClearHostDependencies() {
	m.cleared_HostDependencies = true
}

// HostDependenciesCleared reports if the "HostDependencies" edge to the HostDependency entity was cleared.
func (m *EnvironmentMutation) HostDependenciesCleared() bool {
	return m.cleared_HostDependencies
}

// RemoveHostDependencyIDs removes the "HostDependencies" edge to the HostDependency entity by IDs.
func (m *EnvironmentMutation) RemoveHostDependencyIDs(ids ...uuid.UUID) {
	if m.removed_HostDependencies == nil {
		m.removed_HostDependencies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._HostDependencies, ids[i])
		m.removed_HostDependencies[ids[i]] = struct{}{}
	}
}

// RemovedHostDependencies returns the removed IDs of the "HostDependencies" edge to the HostDependency entity.
func (m *EnvironmentMutation) RemovedHostDependenciesIDs() (ids []uuid.UUID) {
	for id := range m.removed_HostDependencies {
		ids = append(ids, id)
	}
	return
}

// HostDependenciesIDs returns the "HostDependencies" edge IDs in the mutation.
func (m *EnvironmentMutation) HostDependenciesIDs() (ids []uuid.UUID) {
	for id := range m._HostDependencies {
		ids = append(ids, id)
	}
	return
}

// ResetHostDependencies resets all changes to the "HostDependencies" edge.
func (m *EnvironmentMutation) ResetHostDependencies() {
	m._HostDependencies = nil
	m.cleared_HostDependencies = false
	m.removed_HostDependencies = nil
}

// AddAnsibleIDs adds the "Ansibles" edge to the Ansible entity by ids.
func (m *EnvironmentMutation) AddAnsibleIDs(ids ...uuid.UUID) {
	if m._Ansibles == nil {
		m._Ansibles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Ansibles[ids[i]] = struct{}{}
	}
}

// ClearAnsibles clears the "Ansibles" edge to the Ansible entity.
func (m *EnvironmentMutation) ClearAnsibles() {
	m.cleared_Ansibles = true
}

// AnsiblesCleared reports if the "Ansibles" edge to the Ansible entity was cleared.
func (m *EnvironmentMutation) AnsiblesCleared() bool {
	return m.cleared_Ansibles
}

// RemoveAnsibleIDs removes the "Ansibles" edge to the Ansible entity by IDs.
func (m *EnvironmentMutation) RemoveAnsibleIDs(ids ...uuid.UUID) {
	if m.removed_Ansibles == nil {
		m.removed_Ansibles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Ansibles, ids[i])
		m.removed_Ansibles[ids[i]] = struct{}{}
	}
}

// RemovedAnsibles returns the removed IDs of the "Ansibles" edge to the Ansible entity.
func (m *EnvironmentMutation) RemovedAnsiblesIDs() (ids []uuid.UUID) {
	for id := range m.removed_Ansibles {
		ids = append(ids, id)
	}
	return
}

// AnsiblesIDs returns the "Ansibles" edge IDs in the mutation.
func (m *EnvironmentMutation) AnsiblesIDs() (ids []uuid.UUID) {
	for id := range m._Ansibles {
		ids = append(ids, id)
	}
	return
}

// ResetAnsibles resets all changes to the "Ansibles" edge.
func (m *EnvironmentMutation) ResetAnsibles() {
	m._Ansibles = nil
	m.cleared_Ansibles = false
	m.removed_Ansibles = nil
}

// AddScheduledStepIDs adds the "ScheduledSteps" edge to the ScheduledStep entity by ids.
func (m *EnvironmentMutation) AddScheduledStepIDs(ids ...uuid.UUID) {
	if m._ScheduledSteps == nil {
		m._ScheduledSteps = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ScheduledSteps[ids[i]] = struct{}{}
	}
}

// ClearScheduledSteps clears the "ScheduledSteps" edge to the ScheduledStep entity.
func (m *EnvironmentMutation) ClearScheduledSteps() {
	m.cleared_ScheduledSteps = true
}

// ScheduledStepsCleared reports if the "ScheduledSteps" edge to the ScheduledStep entity was cleared.
func (m *EnvironmentMutation) ScheduledStepsCleared() bool {
	return m.cleared_ScheduledSteps
}

// RemoveScheduledStepIDs removes the "ScheduledSteps" edge to the ScheduledStep entity by IDs.
func (m *EnvironmentMutation) RemoveScheduledStepIDs(ids ...uuid.UUID) {
	if m.removed_ScheduledSteps == nil {
		m.removed_ScheduledSteps = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._ScheduledSteps, ids[i])
		m.removed_ScheduledSteps[ids[i]] = struct{}{}
	}
}

// RemovedScheduledSteps returns the removed IDs of the "ScheduledSteps" edge to the ScheduledStep entity.
func (m *EnvironmentMutation) RemovedScheduledStepsIDs() (ids []uuid.UUID) {
	for id := range m.removed_ScheduledSteps {
		ids = append(ids, id)
	}
	return
}

// ScheduledStepsIDs returns the "ScheduledSteps" edge IDs in the mutation.
func (m *EnvironmentMutation) ScheduledStepsIDs() (ids []uuid.UUID) {
	for id := range m._ScheduledSteps {
		ids = append(ids, id)
	}
	return
}

// ResetScheduledSteps resets all changes to the "ScheduledSteps" edge.
func (m *EnvironmentMutation) ResetScheduledSteps() {
	m._ScheduledSteps = nil
	m.cleared_ScheduledSteps = false
	m.removed_ScheduledSteps = nil
}

// AddBuildIDs adds the "Builds" edge to the Build entity by ids.
func (m *EnvironmentMutation) AddBuildIDs(ids ...uuid.UUID) {
	if m._Builds == nil {
		m._Builds = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Builds[ids[i]] = struct{}{}
	}
}

// ClearBuilds clears the "Builds" edge to the Build entity.
func (m *EnvironmentMutation) ClearBuilds() {
	m.cleared_Builds = true
}

// BuildsCleared reports if the "Builds" edge to the Build entity was cleared.
func (m *EnvironmentMutation) BuildsCleared() bool {
	return m.cleared_Builds
}

// RemoveBuildIDs removes the "Builds" edge to the Build entity by IDs.
func (m *EnvironmentMutation) RemoveBuildIDs(ids ...uuid.UUID) {
	if m.removed_Builds == nil {
		m.removed_Builds = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Builds, ids[i])
		m.removed_Builds[ids[i]] = struct{}{}
	}
}

// RemovedBuilds returns the removed IDs of the "Builds" edge to the Build entity.
func (m *EnvironmentMutation) RemovedBuildsIDs() (ids []uuid.UUID) {
	for id := range m.removed_Builds {
		ids = append(ids, id)
	}
	return
}

// BuildsIDs returns the "Builds" edge IDs in the mutation.
func (m *EnvironmentMutation) BuildsIDs() (ids []uuid.UUID) {
	for id := range m._Builds {
		ids = append(ids, id)
	}
	return
}

// ResetBuilds resets all changes to the "Builds" edge.
func (m *EnvironmentMutation) ResetBuilds() {
	m._Builds = nil
	m.cleared_Builds = false
	m.removed_Builds = nil
}

// AddRepositoryIDs adds the "Repositories" edge to the Repository entity by ids.
func (m *EnvironmentMutation) AddRepositoryIDs(ids ...uuid.UUID) {
	if m._Repositories == nil {
		m._Repositories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Repositories[ids[i]] = struct{}{}
	}
}

// ClearRepositories clears the "Repositories" edge to the Repository entity.
func (m *EnvironmentMutation) ClearRepositories() {
	m.cleared_Repositories = true
}

// RepositoriesCleared reports if the "Repositories" edge to the Repository entity was cleared.
func (m *EnvironmentMutation) RepositoriesCleared() bool {
	return m.cleared_Repositories
}

// RemoveRepositoryIDs removes the "Repositories" edge to the Repository entity by IDs.
func (m *EnvironmentMutation) RemoveRepositoryIDs(ids ...uuid.UUID) {
	if m.removed_Repositories == nil {
		m.removed_Repositories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Repositories, ids[i])
		m.removed_Repositories[ids[i]] = struct{}{}
	}
}

// RemovedRepositories returns the removed IDs of the "Repositories" edge to the Repository entity.
func (m *EnvironmentMutation) RemovedRepositoriesIDs() (ids []uuid.UUID) {
	for id := range m.removed_Repositories {
		ids = append(ids, id)
	}
	return
}

// RepositoriesIDs returns the "Repositories" edge IDs in the mutation.
func (m *EnvironmentMutation) RepositoriesIDs() (ids []uuid.UUID) {
	for id := range m._Repositories {
		ids = append(ids, id)
	}
	return
}

// ResetRepositories resets all changes to the "Repositories" edge.
func (m *EnvironmentMutation) ResetRepositories() {
	m._Repositories = nil
	m.cleared_Repositories = false
	m.removed_Repositories = nil
}

// AddServerTaskIDs adds the "ServerTasks" edge to the ServerTask entity by ids.
func (m *EnvironmentMutation) AddServerTaskIDs(ids ...uuid.UUID) {
	if m._ServerTasks == nil {
		m._ServerTasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ServerTasks[ids[i]] = struct{}{}
	}
}

// ClearServerTasks clears the "ServerTasks" edge to the ServerTask entity.
func (m *EnvironmentMutation) ClearServerTasks() {
	m.cleared_ServerTasks = true
}

// ServerTasksCleared reports if the "ServerTasks" edge to the ServerTask entity was cleared.
func (m *EnvironmentMutation) ServerTasksCleared() bool {
	return m.cleared_ServerTasks
}

// RemoveServerTaskIDs removes the "ServerTasks" edge to the ServerTask entity by IDs.
func (m *EnvironmentMutation) RemoveServerTaskIDs(ids ...uuid.UUID) {
	if m.removed_ServerTasks == nil {
		m.removed_ServerTasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._ServerTasks, ids[i])
		m.removed_ServerTasks[ids[i]] = struct{}{}
	}
}

// RemovedServerTasks returns the removed IDs of the "ServerTasks" edge to the ServerTask entity.
func (m *EnvironmentMutation) RemovedServerTasksIDs() (ids []uuid.UUID) {
	for id := range m.removed_ServerTasks {
		ids = append(ids, id)
	}
	return
}

// ServerTasksIDs returns the "ServerTasks" edge IDs in the mutation.
func (m *EnvironmentMutation) ServerTasksIDs() (ids []uuid.UUID) {
	for id := range m._ServerTasks {
		ids = append(ids, id)
	}
	return
}

// ResetServerTasks resets all changes to the "ServerTasks" edge.
func (m *EnvironmentMutation) ResetServerTasks() {
	m._ServerTasks = nil
	m.cleared_ServerTasks = false
	m.removed_ServerTasks = nil
}

// Where appends a list predicates to the EnvironmentMutation builder.
func (m *EnvironmentMutation) Where(ps ...predicate.Environment) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EnvironmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Environment).
func (m *EnvironmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnvironmentMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.hcl_id != nil {
		fields = append(fields, environment.FieldHclID)
	}
	if m.competition_id != nil {
		fields = append(fields, environment.FieldCompetitionID)
	}
	if m.name != nil {
		fields = append(fields, environment.FieldName)
	}
	if m.description != nil {
		fields = append(fields, environment.FieldDescription)
	}
	if m.builder != nil {
		fields = append(fields, environment.FieldBuilder)
	}
	if m.team_count != nil {
		fields = append(fields, environment.FieldTeamCount)
	}
	if m.revision != nil {
		fields = append(fields, environment.FieldRevision)
	}
	if m.admin_cidrs != nil {
		fields = append(fields, environment.FieldAdminCidrs)
	}
	if m.exposed_vdi_ports != nil {
		fields = append(fields, environment.FieldExposedVdiPorts)
	}
	if m._config != nil {
		fields = append(fields, environment.FieldConfig)
	}
	if m.tags != nil {
		fields = append(fields, environment.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnvironmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case environment.FieldHclID:
		return m.HclID()
	case environment.FieldCompetitionID:
		return m.CompetitionID()
	case environment.FieldName:
		return m.Name()
	case environment.FieldDescription:
		return m.Description()
	case environment.FieldBuilder:
		return m.Builder()
	case environment.FieldTeamCount:
		return m.TeamCount()
	case environment.FieldRevision:
		return m.Revision()
	case environment.FieldAdminCidrs:
		return m.AdminCidrs()
	case environment.FieldExposedVdiPorts:
		return m.ExposedVdiPorts()
	case environment.FieldConfig:
		return m.Config()
	case environment.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnvironmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case environment.FieldHclID:
		return m.OldHclID(ctx)
	case environment.FieldCompetitionID:
		return m.OldCompetitionID(ctx)
	case environment.FieldName:
		return m.OldName(ctx)
	case environment.FieldDescription:
		return m.OldDescription(ctx)
	case environment.FieldBuilder:
		return m.OldBuilder(ctx)
	case environment.FieldTeamCount:
		return m.OldTeamCount(ctx)
	case environment.FieldRevision:
		return m.OldRevision(ctx)
	case environment.FieldAdminCidrs:
		return m.OldAdminCidrs(ctx)
	case environment.FieldExposedVdiPorts:
		return m.OldExposedVdiPorts(ctx)
	case environment.FieldConfig:
		return m.OldConfig(ctx)
	case environment.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Environment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvironmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case environment.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case environment.FieldCompetitionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitionID(v)
		return nil
	case environment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case environment.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case environment.FieldBuilder:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuilder(v)
		return nil
	case environment.FieldTeamCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamCount(v)
		return nil
	case environment.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case environment.FieldAdminCidrs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminCidrs(v)
		return nil
	case environment.FieldExposedVdiPorts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExposedVdiPorts(v)
		return nil
	case environment.FieldConfig:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case environment.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Environment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnvironmentMutation) AddedFields() []string {
	var fields []string
	if m.addteam_count != nil {
		fields = append(fields, environment.FieldTeamCount)
	}
	if m.addrevision != nil {
		fields = append(fields, environment.FieldRevision)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnvironmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case environment.FieldTeamCount:
		return m.AddedTeamCount()
	case environment.FieldRevision:
		return m.AddedRevision()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvironmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case environment.FieldTeamCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTeamCount(v)
		return nil
	case environment.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevision(v)
		return nil
	}
	return fmt.Errorf("unknown Environment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnvironmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnvironmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnvironmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Environment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnvironmentMutation) ResetField(name string) error {
	switch name {
	case environment.FieldHclID:
		m.ResetHclID()
		return nil
	case environment.FieldCompetitionID:
		m.ResetCompetitionID()
		return nil
	case environment.FieldName:
		m.ResetName()
		return nil
	case environment.FieldDescription:
		m.ResetDescription()
		return nil
	case environment.FieldBuilder:
		m.ResetBuilder()
		return nil
	case environment.FieldTeamCount:
		m.ResetTeamCount()
		return nil
	case environment.FieldRevision:
		m.ResetRevision()
		return nil
	case environment.FieldAdminCidrs:
		m.ResetAdminCidrs()
		return nil
	case environment.FieldExposedVdiPorts:
		m.ResetExposedVdiPorts()
		return nil
	case environment.FieldConfig:
		m.ResetConfig()
		return nil
	case environment.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Environment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnvironmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 20)
	if m._Users != nil {
		edges = append(edges, environment.EdgeUsers)
	}
	if m._Hosts != nil {
		edges = append(edges, environment.EdgeHosts)
	}
	if m._Competitions != nil {
		edges = append(edges, environment.EdgeCompetitions)
	}
	if m._Identities != nil {
		edges = append(edges, environment.EdgeIdentities)
	}
	if m._Commands != nil {
		edges = append(edges, environment.EdgeCommands)
	}
	if m._Scripts != nil {
		edges = append(edges, environment.EdgeScripts)
	}
	if m._FileDownloads != nil {
		edges = append(edges, environment.EdgeFileDownloads)
	}
	if m._FileDeletes != nil {
		edges = append(edges, environment.EdgeFileDeletes)
	}
	if m._FileExtracts != nil {
		edges = append(edges, environment.EdgeFileExtracts)
	}
	if m._IncludedNetworks != nil {
		edges = append(edges, environment.EdgeIncludedNetworks)
	}
	if m._Findings != nil {
		edges = append(edges, environment.EdgeFindings)
	}
	if m._DNSRecords != nil {
		edges = append(edges, environment.EdgeDNSRecords)
	}
	if m._DNS != nil {
		edges = append(edges, environment.EdgeDNS)
	}
	if m._Networks != nil {
		edges = append(edges, environment.EdgeNetworks)
	}
	if m._HostDependencies != nil {
		edges = append(edges, environment.EdgeHostDependencies)
	}
	if m._Ansibles != nil {
		edges = append(edges, environment.EdgeAnsibles)
	}
	if m._ScheduledSteps != nil {
		edges = append(edges, environment.EdgeScheduledSteps)
	}
	if m._Builds != nil {
		edges = append(edges, environment.EdgeBuilds)
	}
	if m._Repositories != nil {
		edges = append(edges, environment.EdgeRepositories)
	}
	if m._ServerTasks != nil {
		edges = append(edges, environment.EdgeServerTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnvironmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case environment.EdgeUsers:
		ids := make([]ent.Value, 0, len(m._Users))
		for id := range m._Users {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeHosts:
		ids := make([]ent.Value, 0, len(m._Hosts))
		for id := range m._Hosts {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeCompetitions:
		ids := make([]ent.Value, 0, len(m._Competitions))
		for id := range m._Competitions {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeIdentities:
		ids := make([]ent.Value, 0, len(m._Identities))
		for id := range m._Identities {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeCommands:
		ids := make([]ent.Value, 0, len(m._Commands))
		for id := range m._Commands {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeScripts:
		ids := make([]ent.Value, 0, len(m._Scripts))
		for id := range m._Scripts {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeFileDownloads:
		ids := make([]ent.Value, 0, len(m._FileDownloads))
		for id := range m._FileDownloads {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeFileDeletes:
		ids := make([]ent.Value, 0, len(m._FileDeletes))
		for id := range m._FileDeletes {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeFileExtracts:
		ids := make([]ent.Value, 0, len(m._FileExtracts))
		for id := range m._FileExtracts {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeIncludedNetworks:
		ids := make([]ent.Value, 0, len(m._IncludedNetworks))
		for id := range m._IncludedNetworks {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeFindings:
		ids := make([]ent.Value, 0, len(m._Findings))
		for id := range m._Findings {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeDNSRecords:
		ids := make([]ent.Value, 0, len(m._DNSRecords))
		for id := range m._DNSRecords {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeDNS:
		ids := make([]ent.Value, 0, len(m._DNS))
		for id := range m._DNS {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeNetworks:
		ids := make([]ent.Value, 0, len(m._Networks))
		for id := range m._Networks {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeHostDependencies:
		ids := make([]ent.Value, 0, len(m._HostDependencies))
		for id := range m._HostDependencies {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeAnsibles:
		ids := make([]ent.Value, 0, len(m._Ansibles))
		for id := range m._Ansibles {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeScheduledSteps:
		ids := make([]ent.Value, 0, len(m._ScheduledSteps))
		for id := range m._ScheduledSteps {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeBuilds:
		ids := make([]ent.Value, 0, len(m._Builds))
		for id := range m._Builds {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeRepositories:
		ids := make([]ent.Value, 0, len(m._Repositories))
		for id := range m._Repositories {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeServerTasks:
		ids := make([]ent.Value, 0, len(m._ServerTasks))
		for id := range m._ServerTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnvironmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 20)
	if m.removed_Users != nil {
		edges = append(edges, environment.EdgeUsers)
	}
	if m.removed_Hosts != nil {
		edges = append(edges, environment.EdgeHosts)
	}
	if m.removed_Competitions != nil {
		edges = append(edges, environment.EdgeCompetitions)
	}
	if m.removed_Identities != nil {
		edges = append(edges, environment.EdgeIdentities)
	}
	if m.removed_Commands != nil {
		edges = append(edges, environment.EdgeCommands)
	}
	if m.removed_Scripts != nil {
		edges = append(edges, environment.EdgeScripts)
	}
	if m.removed_FileDownloads != nil {
		edges = append(edges, environment.EdgeFileDownloads)
	}
	if m.removed_FileDeletes != nil {
		edges = append(edges, environment.EdgeFileDeletes)
	}
	if m.removed_FileExtracts != nil {
		edges = append(edges, environment.EdgeFileExtracts)
	}
	if m.removed_IncludedNetworks != nil {
		edges = append(edges, environment.EdgeIncludedNetworks)
	}
	if m.removed_Findings != nil {
		edges = append(edges, environment.EdgeFindings)
	}
	if m.removed_DNSRecords != nil {
		edges = append(edges, environment.EdgeDNSRecords)
	}
	if m.removed_DNS != nil {
		edges = append(edges, environment.EdgeDNS)
	}
	if m.removed_Networks != nil {
		edges = append(edges, environment.EdgeNetworks)
	}
	if m.removed_HostDependencies != nil {
		edges = append(edges, environment.EdgeHostDependencies)
	}
	if m.removed_Ansibles != nil {
		edges = append(edges, environment.EdgeAnsibles)
	}
	if m.removed_ScheduledSteps != nil {
		edges = append(edges, environment.EdgeScheduledSteps)
	}
	if m.removed_Builds != nil {
		edges = append(edges, environment.EdgeBuilds)
	}
	if m.removed_Repositories != nil {
		edges = append(edges, environment.EdgeRepositories)
	}
	if m.removed_ServerTasks != nil {
		edges = append(edges, environment.EdgeServerTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnvironmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case environment.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removed_Users))
		for id := range m.removed_Users {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeHosts:
		ids := make([]ent.Value, 0, len(m.removed_Hosts))
		for id := range m.removed_Hosts {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeCompetitions:
		ids := make([]ent.Value, 0, len(m.removed_Competitions))
		for id := range m.removed_Competitions {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeIdentities:
		ids := make([]ent.Value, 0, len(m.removed_Identities))
		for id := range m.removed_Identities {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeCommands:
		ids := make([]ent.Value, 0, len(m.removed_Commands))
		for id := range m.removed_Commands {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeScripts:
		ids := make([]ent.Value, 0, len(m.removed_Scripts))
		for id := range m.removed_Scripts {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeFileDownloads:
		ids := make([]ent.Value, 0, len(m.removed_FileDownloads))
		for id := range m.removed_FileDownloads {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeFileDeletes:
		ids := make([]ent.Value, 0, len(m.removed_FileDeletes))
		for id := range m.removed_FileDeletes {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeFileExtracts:
		ids := make([]ent.Value, 0, len(m.removed_FileExtracts))
		for id := range m.removed_FileExtracts {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeIncludedNetworks:
		ids := make([]ent.Value, 0, len(m.removed_IncludedNetworks))
		for id := range m.removed_IncludedNetworks {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeFindings:
		ids := make([]ent.Value, 0, len(m.removed_Findings))
		for id := range m.removed_Findings {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeDNSRecords:
		ids := make([]ent.Value, 0, len(m.removed_DNSRecords))
		for id := range m.removed_DNSRecords {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeDNS:
		ids := make([]ent.Value, 0, len(m.removed_DNS))
		for id := range m.removed_DNS {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeNetworks:
		ids := make([]ent.Value, 0, len(m.removed_Networks))
		for id := range m.removed_Networks {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeHostDependencies:
		ids := make([]ent.Value, 0, len(m.removed_HostDependencies))
		for id := range m.removed_HostDependencies {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeAnsibles:
		ids := make([]ent.Value, 0, len(m.removed_Ansibles))
		for id := range m.removed_Ansibles {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeScheduledSteps:
		ids := make([]ent.Value, 0, len(m.removed_ScheduledSteps))
		for id := range m.removed_ScheduledSteps {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeBuilds:
		ids := make([]ent.Value, 0, len(m.removed_Builds))
		for id := range m.removed_Builds {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeRepositories:
		ids := make([]ent.Value, 0, len(m.removed_Repositories))
		for id := range m.removed_Repositories {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeServerTasks:
		ids := make([]ent.Value, 0, len(m.removed_ServerTasks))
		for id := range m.removed_ServerTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnvironmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 20)
	if m.cleared_Users {
		edges = append(edges, environment.EdgeUsers)
	}
	if m.cleared_Hosts {
		edges = append(edges, environment.EdgeHosts)
	}
	if m.cleared_Competitions {
		edges = append(edges, environment.EdgeCompetitions)
	}
	if m.cleared_Identities {
		edges = append(edges, environment.EdgeIdentities)
	}
	if m.cleared_Commands {
		edges = append(edges, environment.EdgeCommands)
	}
	if m.cleared_Scripts {
		edges = append(edges, environment.EdgeScripts)
	}
	if m.cleared_FileDownloads {
		edges = append(edges, environment.EdgeFileDownloads)
	}
	if m.cleared_FileDeletes {
		edges = append(edges, environment.EdgeFileDeletes)
	}
	if m.cleared_FileExtracts {
		edges = append(edges, environment.EdgeFileExtracts)
	}
	if m.cleared_IncludedNetworks {
		edges = append(edges, environment.EdgeIncludedNetworks)
	}
	if m.cleared_Findings {
		edges = append(edges, environment.EdgeFindings)
	}
	if m.cleared_DNSRecords {
		edges = append(edges, environment.EdgeDNSRecords)
	}
	if m.cleared_DNS {
		edges = append(edges, environment.EdgeDNS)
	}
	if m.cleared_Networks {
		edges = append(edges, environment.EdgeNetworks)
	}
	if m.cleared_HostDependencies {
		edges = append(edges, environment.EdgeHostDependencies)
	}
	if m.cleared_Ansibles {
		edges = append(edges, environment.EdgeAnsibles)
	}
	if m.cleared_ScheduledSteps {
		edges = append(edges, environment.EdgeScheduledSteps)
	}
	if m.cleared_Builds {
		edges = append(edges, environment.EdgeBuilds)
	}
	if m.cleared_Repositories {
		edges = append(edges, environment.EdgeRepositories)
	}
	if m.cleared_ServerTasks {
		edges = append(edges, environment.EdgeServerTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnvironmentMutation) EdgeCleared(name string) bool {
	switch name {
	case environment.EdgeUsers:
		return m.cleared_Users
	case environment.EdgeHosts:
		return m.cleared_Hosts
	case environment.EdgeCompetitions:
		return m.cleared_Competitions
	case environment.EdgeIdentities:
		return m.cleared_Identities
	case environment.EdgeCommands:
		return m.cleared_Commands
	case environment.EdgeScripts:
		return m.cleared_Scripts
	case environment.EdgeFileDownloads:
		return m.cleared_FileDownloads
	case environment.EdgeFileDeletes:
		return m.cleared_FileDeletes
	case environment.EdgeFileExtracts:
		return m.cleared_FileExtracts
	case environment.EdgeIncludedNetworks:
		return m.cleared_IncludedNetworks
	case environment.EdgeFindings:
		return m.cleared_Findings
	case environment.EdgeDNSRecords:
		return m.cleared_DNSRecords
	case environment.EdgeDNS:
		return m.cleared_DNS
	case environment.EdgeNetworks:
		return m.cleared_Networks
	case environment.EdgeHostDependencies:
		return m.cleared_HostDependencies
	case environment.EdgeAnsibles:
		return m.cleared_Ansibles
	case environment.EdgeScheduledSteps:
		return m.cleared_ScheduledSteps
	case environment.EdgeBuilds:
		return m.cleared_Builds
	case environment.EdgeRepositories:
		return m.cleared_Repositories
	case environment.EdgeServerTasks:
		return m.cleared_ServerTasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnvironmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Environment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnvironmentMutation) ResetEdge(name string) error {
	switch name {
	case environment.EdgeUsers:
		m.ResetUsers()
		return nil
	case environment.EdgeHosts:
		m.ResetHosts()
		return nil
	case environment.EdgeCompetitions:
		m.ResetCompetitions()
		return nil
	case environment.EdgeIdentities:
		m.ResetIdentities()
		return nil
	case environment.EdgeCommands:
		m.ResetCommands()
		return nil
	case environment.EdgeScripts:
		m.ResetScripts()
		return nil
	case environment.EdgeFileDownloads:
		m.ResetFileDownloads()
		return nil
	case environment.EdgeFileDeletes:
		m.ResetFileDeletes()
		return nil
	case environment.EdgeFileExtracts:
		m.ResetFileExtracts()
		return nil
	case environment.EdgeIncludedNetworks:
		m.ResetIncludedNetworks()
		return nil
	case environment.EdgeFindings:
		m.ResetFindings()
		return nil
	case environment.EdgeDNSRecords:
		m.ResetDNSRecords()
		return nil
	case environment.EdgeDNS:
		m.ResetDNS()
		return nil
	case environment.EdgeNetworks:
		m.ResetNetworks()
		return nil
	case environment.EdgeHostDependencies:
		m.ResetHostDependencies()
		return nil
	case environment.EdgeAnsibles:
		m.ResetAnsibles()
		return nil
	case environment.EdgeScheduledSteps:
		m.ResetScheduledSteps()
		return nil
	case environment.EdgeBuilds:
		m.ResetBuilds()
		return nil
	case environment.EdgeRepositories:
		m.ResetRepositories()
		return nil
	case environment.EdgeServerTasks:
		m.ResetServerTasks()
		return nil
	}
	return fmt.Errorf("unknown Environment edge %s", name)
}

// FileDeleteMutation represents an operation that mutates the FileDelete nodes in the graph.
type FileDeleteMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	hcl_id              *string
	_path               *string
	tags                *map[string]string
	clearedFields       map[string]struct{}
	_Environment        *uuid.UUID
	cleared_Environment bool
	done                bool
	oldValue            func(context.Context) (*FileDelete, error)
	predicates          []predicate.FileDelete
}

var _ ent.Mutation = (*FileDeleteMutation)(nil)

// filedeleteOption allows management of the mutation configuration using functional options.
type filedeleteOption func(*FileDeleteMutation)

// newFileDeleteMutation creates new mutation for the FileDelete entity.
func newFileDeleteMutation(c config, op Op, opts ...filedeleteOption) *FileDeleteMutation {
	m := &FileDeleteMutation{
		config:        c,
		op:            op,
		typ:           TypeFileDelete,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileDeleteID sets the ID field of the mutation.
func withFileDeleteID(id uuid.UUID) filedeleteOption {
	return func(m *FileDeleteMutation) {
		var (
			err   error
			once  sync.Once
			value *FileDelete
		)
		m.oldValue = func(ctx context.Context) (*FileDelete, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileDelete.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileDelete sets the old FileDelete of the mutation.
func withFileDelete(node *FileDelete) filedeleteOption {
	return func(m *FileDeleteMutation) {
		m.oldValue = func(context.Context) (*FileDelete, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileDeleteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileDeleteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FileDelete entities.
func (m *FileDeleteMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileDeleteMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileDeleteMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FileDelete.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHclID sets the "hcl_id" field.
func (m *FileDeleteMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *FileDeleteMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the FileDelete entity.
// If the FileDelete object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDeleteMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *FileDeleteMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetPath sets the "path" field.
func (m *FileDeleteMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *FileDeleteMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the FileDelete entity.
// If the FileDelete object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDeleteMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *FileDeleteMutation) ResetPath() {
	m._path = nil
}

// SetTags sets the "tags" field.
func (m *FileDeleteMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *FileDeleteMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the FileDelete entity.
// If the FileDelete object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDeleteMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *FileDeleteMutation) ResetTags() {
	m.tags = nil
}

// SetEnvironmentID sets the "Environment" edge to the Environment entity by id.
func (m *FileDeleteMutation) SetEnvironmentID(id uuid.UUID) {
	m._Environment = &id
}

// ClearEnvironment clears the "Environment" edge to the Environment entity.
func (m *FileDeleteMutation) ClearEnvironment() {
	m.cleared_Environment = true
}

// EnvironmentCleared reports if the "Environment" edge to the Environment entity was cleared.
func (m *FileDeleteMutation) EnvironmentCleared() bool {
	return m.cleared_Environment
}

// EnvironmentID returns the "Environment" edge ID in the mutation.
func (m *FileDeleteMutation) EnvironmentID() (id uuid.UUID, exists bool) {
	if m._Environment != nil {
		return *m._Environment, true
	}
	return
}

// EnvironmentIDs returns the "Environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *FileDeleteMutation) EnvironmentIDs() (ids []uuid.UUID) {
	if id := m._Environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "Environment" edge.
func (m *FileDeleteMutation) ResetEnvironment() {
	m._Environment = nil
	m.cleared_Environment = false
}

// Where appends a list predicates to the FileDeleteMutation builder.
func (m *FileDeleteMutation) Where(ps ...predicate.FileDelete) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FileDeleteMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FileDelete).
func (m *FileDeleteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileDeleteMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.hcl_id != nil {
		fields = append(fields, filedelete.FieldHclID)
	}
	if m._path != nil {
		fields = append(fields, filedelete.FieldPath)
	}
	if m.tags != nil {
		fields = append(fields, filedelete.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileDeleteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filedelete.FieldHclID:
		return m.HclID()
	case filedelete.FieldPath:
		return m.Path()
	case filedelete.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileDeleteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filedelete.FieldHclID:
		return m.OldHclID(ctx)
	case filedelete.FieldPath:
		return m.OldPath(ctx)
	case filedelete.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown FileDelete field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileDeleteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filedelete.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case filedelete.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case filedelete.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown FileDelete field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileDeleteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileDeleteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileDeleteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FileDelete numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileDeleteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileDeleteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileDeleteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FileDelete nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileDeleteMutation) ResetField(name string) error {
	switch name {
	case filedelete.FieldHclID:
		m.ResetHclID()
		return nil
	case filedelete.FieldPath:
		m.ResetPath()
		return nil
	case filedelete.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown FileDelete field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileDeleteMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Environment != nil {
		edges = append(edges, filedelete.EdgeEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileDeleteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case filedelete.EdgeEnvironment:
		if id := m._Environment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileDeleteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileDeleteMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileDeleteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Environment {
		edges = append(edges, filedelete.EdgeEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileDeleteMutation) EdgeCleared(name string) bool {
	switch name {
	case filedelete.EdgeEnvironment:
		return m.cleared_Environment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileDeleteMutation) ClearEdge(name string) error {
	switch name {
	case filedelete.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	}
	return fmt.Errorf("unknown FileDelete unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileDeleteMutation) ResetEdge(name string) error {
	switch name {
	case filedelete.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	}
	return fmt.Errorf("unknown FileDelete edge %s", name)
}

// FileDownloadMutation represents an operation that mutates the FileDownload nodes in the graph.
type FileDownloadMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	hcl_id              *string
	source_type         *string
	source              *string
	destination         *string
	template            *bool
	perms               *string
	disabled            *bool
	md5                 *string
	abs_path            *string
	is_txt              *bool
	tags                *map[string]string
	clearedFields       map[string]struct{}
	_Environment        *uuid.UUID
	cleared_Environment bool
	done                bool
	oldValue            func(context.Context) (*FileDownload, error)
	predicates          []predicate.FileDownload
}

var _ ent.Mutation = (*FileDownloadMutation)(nil)

// filedownloadOption allows management of the mutation configuration using functional options.
type filedownloadOption func(*FileDownloadMutation)

// newFileDownloadMutation creates new mutation for the FileDownload entity.
func newFileDownloadMutation(c config, op Op, opts ...filedownloadOption) *FileDownloadMutation {
	m := &FileDownloadMutation{
		config:        c,
		op:            op,
		typ:           TypeFileDownload,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileDownloadID sets the ID field of the mutation.
func withFileDownloadID(id uuid.UUID) filedownloadOption {
	return func(m *FileDownloadMutation) {
		var (
			err   error
			once  sync.Once
			value *FileDownload
		)
		m.oldValue = func(ctx context.Context) (*FileDownload, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileDownload.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileDownload sets the old FileDownload of the mutation.
func withFileDownload(node *FileDownload) filedownloadOption {
	return func(m *FileDownloadMutation) {
		m.oldValue = func(context.Context) (*FileDownload, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileDownloadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileDownloadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FileDownload entities.
func (m *FileDownloadMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileDownloadMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileDownloadMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FileDownload.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHclID sets the "hcl_id" field.
func (m *FileDownloadMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *FileDownloadMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *FileDownloadMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetSourceType sets the "source_type" field.
func (m *FileDownloadMutation) SetSourceType(s string) {
	m.source_type = &s
}

// SourceType returns the value of the "source_type" field in the mutation.
func (m *FileDownloadMutation) SourceType() (r string, exists bool) {
	v := m.source_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceType returns the old "source_type" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldSourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceType: %w", err)
	}
	return oldValue.SourceType, nil
}

// ResetSourceType resets all changes to the "source_type" field.
func (m *FileDownloadMutation) ResetSourceType() {
	m.source_type = nil
}

// SetSource sets the "source" field.
func (m *FileDownloadMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *FileDownloadMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *FileDownloadMutation) ResetSource() {
	m.source = nil
}

// SetDestination sets the "destination" field.
func (m *FileDownloadMutation) SetDestination(s string) {
	m.destination = &s
}

// Destination returns the value of the "destination" field in the mutation.
func (m *FileDownloadMutation) Destination() (r string, exists bool) {
	v := m.destination
	if v == nil {
		return
	}
	return *v, true
}

// OldDestination returns the old "destination" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldDestination(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestination is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestination requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestination: %w", err)
	}
	return oldValue.Destination, nil
}

// ResetDestination resets all changes to the "destination" field.
func (m *FileDownloadMutation) ResetDestination() {
	m.destination = nil
}

// SetTemplate sets the "template" field.
func (m *FileDownloadMutation) SetTemplate(b bool) {
	m.template = &b
}

// Template returns the value of the "template" field in the mutation.
func (m *FileDownloadMutation) Template() (r bool, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplate returns the old "template" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldTemplate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplate: %w", err)
	}
	return oldValue.Template, nil
}

// ResetTemplate resets all changes to the "template" field.
func (m *FileDownloadMutation) ResetTemplate() {
	m.template = nil
}

// SetPerms sets the "perms" field.
func (m *FileDownloadMutation) SetPerms(s string) {
	m.perms = &s
}

// Perms returns the value of the "perms" field in the mutation.
func (m *FileDownloadMutation) Perms() (r string, exists bool) {
	v := m.perms
	if v == nil {
		return
	}
	return *v, true
}

// OldPerms returns the old "perms" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldPerms(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPerms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPerms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPerms: %w", err)
	}
	return oldValue.Perms, nil
}

// ResetPerms resets all changes to the "perms" field.
func (m *FileDownloadMutation) ResetPerms() {
	m.perms = nil
}

// SetDisabled sets the "disabled" field.
func (m *FileDownloadMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *FileDownloadMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *FileDownloadMutation) ResetDisabled() {
	m.disabled = nil
}

// SetMd5 sets the "md5" field.
func (m *FileDownloadMutation) SetMd5(s string) {
	m.md5 = &s
}

// Md5 returns the value of the "md5" field in the mutation.
func (m *FileDownloadMutation) Md5() (r string, exists bool) {
	v := m.md5
	if v == nil {
		return
	}
	return *v, true
}

// OldMd5 returns the old "md5" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldMd5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMd5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMd5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMd5: %w", err)
	}
	return oldValue.Md5, nil
}

// ResetMd5 resets all changes to the "md5" field.
func (m *FileDownloadMutation) ResetMd5() {
	m.md5 = nil
}

// SetAbsPath sets the "abs_path" field.
func (m *FileDownloadMutation) SetAbsPath(s string) {
	m.abs_path = &s
}

// AbsPath returns the value of the "abs_path" field in the mutation.
func (m *FileDownloadMutation) AbsPath() (r string, exists bool) {
	v := m.abs_path
	if v == nil {
		return
	}
	return *v, true
}

// OldAbsPath returns the old "abs_path" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldAbsPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbsPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbsPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbsPath: %w", err)
	}
	return oldValue.AbsPath, nil
}

// ResetAbsPath resets all changes to the "abs_path" field.
func (m *FileDownloadMutation) ResetAbsPath() {
	m.abs_path = nil
}

// SetIsTxt sets the "is_txt" field.
func (m *FileDownloadMutation) SetIsTxt(b bool) {
	m.is_txt = &b
}

// IsTxt returns the value of the "is_txt" field in the mutation.
func (m *FileDownloadMutation) IsTxt() (r bool, exists bool) {
	v := m.is_txt
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTxt returns the old "is_txt" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldIsTxt(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTxt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTxt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTxt: %w", err)
	}
	return oldValue.IsTxt, nil
}

// ResetIsTxt resets all changes to the "is_txt" field.
func (m *FileDownloadMutation) ResetIsTxt() {
	m.is_txt = nil
}

// SetTags sets the "tags" field.
func (m *FileDownloadMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *FileDownloadMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *FileDownloadMutation) ResetTags() {
	m.tags = nil
}

// SetEnvironmentID sets the "Environment" edge to the Environment entity by id.
func (m *FileDownloadMutation) SetEnvironmentID(id uuid.UUID) {
	m._Environment = &id
}

// ClearEnvironment clears the "Environment" edge to the Environment entity.
func (m *FileDownloadMutation) ClearEnvironment() {
	m.cleared_Environment = true
}

// EnvironmentCleared reports if the "Environment" edge to the Environment entity was cleared.
func (m *FileDownloadMutation) EnvironmentCleared() bool {
	return m.cleared_Environment
}

// EnvironmentID returns the "Environment" edge ID in the mutation.
func (m *FileDownloadMutation) EnvironmentID() (id uuid.UUID, exists bool) {
	if m._Environment != nil {
		return *m._Environment, true
	}
	return
}

// EnvironmentIDs returns the "Environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *FileDownloadMutation) EnvironmentIDs() (ids []uuid.UUID) {
	if id := m._Environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "Environment" edge.
func (m *FileDownloadMutation) ResetEnvironment() {
	m._Environment = nil
	m.cleared_Environment = false
}

// Where appends a list predicates to the FileDownloadMutation builder.
func (m *FileDownloadMutation) Where(ps ...predicate.FileDownload) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FileDownloadMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FileDownload).
func (m *FileDownloadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileDownloadMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.hcl_id != nil {
		fields = append(fields, filedownload.FieldHclID)
	}
	if m.source_type != nil {
		fields = append(fields, filedownload.FieldSourceType)
	}
	if m.source != nil {
		fields = append(fields, filedownload.FieldSource)
	}
	if m.destination != nil {
		fields = append(fields, filedownload.FieldDestination)
	}
	if m.template != nil {
		fields = append(fields, filedownload.FieldTemplate)
	}
	if m.perms != nil {
		fields = append(fields, filedownload.FieldPerms)
	}
	if m.disabled != nil {
		fields = append(fields, filedownload.FieldDisabled)
	}
	if m.md5 != nil {
		fields = append(fields, filedownload.FieldMd5)
	}
	if m.abs_path != nil {
		fields = append(fields, filedownload.FieldAbsPath)
	}
	if m.is_txt != nil {
		fields = append(fields, filedownload.FieldIsTxt)
	}
	if m.tags != nil {
		fields = append(fields, filedownload.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileDownloadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filedownload.FieldHclID:
		return m.HclID()
	case filedownload.FieldSourceType:
		return m.SourceType()
	case filedownload.FieldSource:
		return m.Source()
	case filedownload.FieldDestination:
		return m.Destination()
	case filedownload.FieldTemplate:
		return m.Template()
	case filedownload.FieldPerms:
		return m.Perms()
	case filedownload.FieldDisabled:
		return m.Disabled()
	case filedownload.FieldMd5:
		return m.Md5()
	case filedownload.FieldAbsPath:
		return m.AbsPath()
	case filedownload.FieldIsTxt:
		return m.IsTxt()
	case filedownload.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileDownloadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filedownload.FieldHclID:
		return m.OldHclID(ctx)
	case filedownload.FieldSourceType:
		return m.OldSourceType(ctx)
	case filedownload.FieldSource:
		return m.OldSource(ctx)
	case filedownload.FieldDestination:
		return m.OldDestination(ctx)
	case filedownload.FieldTemplate:
		return m.OldTemplate(ctx)
	case filedownload.FieldPerms:
		return m.OldPerms(ctx)
	case filedownload.FieldDisabled:
		return m.OldDisabled(ctx)
	case filedownload.FieldMd5:
		return m.OldMd5(ctx)
	case filedownload.FieldAbsPath:
		return m.OldAbsPath(ctx)
	case filedownload.FieldIsTxt:
		return m.OldIsTxt(ctx)
	case filedownload.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown FileDownload field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileDownloadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filedownload.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case filedownload.FieldSourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceType(v)
		return nil
	case filedownload.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case filedownload.FieldDestination:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestination(v)
		return nil
	case filedownload.FieldTemplate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplate(v)
		return nil
	case filedownload.FieldPerms:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPerms(v)
		return nil
	case filedownload.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case filedownload.FieldMd5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMd5(v)
		return nil
	case filedownload.FieldAbsPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbsPath(v)
		return nil
	case filedownload.FieldIsTxt:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTxt(v)
		return nil
	case filedownload.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown FileDownload field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileDownloadMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileDownloadMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileDownloadMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FileDownload numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileDownloadMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileDownloadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileDownloadMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FileDownload nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileDownloadMutation) ResetField(name string) error {
	switch name {
	case filedownload.FieldHclID:
		m.ResetHclID()
		return nil
	case filedownload.FieldSourceType:
		m.ResetSourceType()
		return nil
	case filedownload.FieldSource:
		m.ResetSource()
		return nil
	case filedownload.FieldDestination:
		m.ResetDestination()
		return nil
	case filedownload.FieldTemplate:
		m.ResetTemplate()
		return nil
	case filedownload.FieldPerms:
		m.ResetPerms()
		return nil
	case filedownload.FieldDisabled:
		m.ResetDisabled()
		return nil
	case filedownload.FieldMd5:
		m.ResetMd5()
		return nil
	case filedownload.FieldAbsPath:
		m.ResetAbsPath()
		return nil
	case filedownload.FieldIsTxt:
		m.ResetIsTxt()
		return nil
	case filedownload.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown FileDownload field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileDownloadMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Environment != nil {
		edges = append(edges, filedownload.EdgeEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileDownloadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case filedownload.EdgeEnvironment:
		if id := m._Environment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileDownloadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileDownloadMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileDownloadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Environment {
		edges = append(edges, filedownload.EdgeEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileDownloadMutation) EdgeCleared(name string) bool {
	switch name {
	case filedownload.EdgeEnvironment:
		return m.cleared_Environment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileDownloadMutation) ClearEdge(name string) error {
	switch name {
	case filedownload.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	}
	return fmt.Errorf("unknown FileDownload unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileDownloadMutation) ResetEdge(name string) error {
	switch name {
	case filedownload.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	}
	return fmt.Errorf("unknown FileDownload edge %s", name)
}

// FileExtractMutation represents an operation that mutates the FileExtract nodes in the graph.
type FileExtractMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	hcl_id              *string
	source              *string
	destination         *string
	_type               *string
	tags                *map[string]string
	clearedFields       map[string]struct{}
	_Environment        *uuid.UUID
	cleared_Environment bool
	done                bool
	oldValue            func(context.Context) (*FileExtract, error)
	predicates          []predicate.FileExtract
}

var _ ent.Mutation = (*FileExtractMutation)(nil)

// fileextractOption allows management of the mutation configuration using functional options.
type fileextractOption func(*FileExtractMutation)

// newFileExtractMutation creates new mutation for the FileExtract entity.
func newFileExtractMutation(c config, op Op, opts ...fileextractOption) *FileExtractMutation {
	m := &FileExtractMutation{
		config:        c,
		op:            op,
		typ:           TypeFileExtract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileExtractID sets the ID field of the mutation.
func withFileExtractID(id uuid.UUID) fileextractOption {
	return func(m *FileExtractMutation) {
		var (
			err   error
			once  sync.Once
			value *FileExtract
		)
		m.oldValue = func(ctx context.Context) (*FileExtract, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileExtract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileExtract sets the old FileExtract of the mutation.
func withFileExtract(node *FileExtract) fileextractOption {
	return func(m *FileExtractMutation) {
		m.oldValue = func(context.Context) (*FileExtract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileExtractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileExtractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FileExtract entities.
func (m *FileExtractMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileExtractMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileExtractMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FileExtract.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHclID sets the "hcl_id" field.
func (m *FileExtractMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *FileExtractMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the FileExtract entity.
// If the FileExtract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileExtractMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *FileExtractMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetSource sets the "source" field.
func (m *FileExtractMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *FileExtractMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the FileExtract entity.
// If the FileExtract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileExtractMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *FileExtractMutation) ResetSource() {
	m.source = nil
}

// SetDestination sets the "destination" field.
func (m *FileExtractMutation) SetDestination(s string) {
	m.destination = &s
}

// Destination returns the value of the "destination" field in the mutation.
func (m *FileExtractMutation) Destination() (r string, exists bool) {
	v := m.destination
	if v == nil {
		return
	}
	return *v, true
}

// OldDestination returns the old "destination" field's value of the FileExtract entity.
// If the FileExtract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileExtractMutation) OldDestination(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestination is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestination requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestination: %w", err)
	}
	return oldValue.Destination, nil
}

// ResetDestination resets all changes to the "destination" field.
func (m *FileExtractMutation) ResetDestination() {
	m.destination = nil
}

// SetType sets the "type" field.
func (m *FileExtractMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *FileExtractMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the FileExtract entity.
// If the FileExtract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileExtractMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FileExtractMutation) ResetType() {
	m._type = nil
}

// SetTags sets the "tags" field.
func (m *FileExtractMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *FileExtractMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the FileExtract entity.
// If the FileExtract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileExtractMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *FileExtractMutation) ResetTags() {
	m.tags = nil
}

// SetEnvironmentID sets the "Environment" edge to the Environment entity by id.
func (m *FileExtractMutation) SetEnvironmentID(id uuid.UUID) {
	m._Environment = &id
}

// ClearEnvironment clears the "Environment" edge to the Environment entity.
func (m *FileExtractMutation) ClearEnvironment() {
	m.cleared_Environment = true
}

// EnvironmentCleared reports if the "Environment" edge to the Environment entity was cleared.
func (m *FileExtractMutation) EnvironmentCleared() bool {
	return m.cleared_Environment
}

// EnvironmentID returns the "Environment" edge ID in the mutation.
func (m *FileExtractMutation) EnvironmentID() (id uuid.UUID, exists bool) {
	if m._Environment != nil {
		return *m._Environment, true
	}
	return
}

// EnvironmentIDs returns the "Environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *FileExtractMutation) EnvironmentIDs() (ids []uuid.UUID) {
	if id := m._Environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "Environment" edge.
func (m *FileExtractMutation) ResetEnvironment() {
	m._Environment = nil
	m.cleared_Environment = false
}

// Where appends a list predicates to the FileExtractMutation builder.
func (m *FileExtractMutation) Where(ps ...predicate.FileExtract) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FileExtractMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FileExtract).
func (m *FileExtractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileExtractMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.hcl_id != nil {
		fields = append(fields, fileextract.FieldHclID)
	}
	if m.source != nil {
		fields = append(fields, fileextract.FieldSource)
	}
	if m.destination != nil {
		fields = append(fields, fileextract.FieldDestination)
	}
	if m._type != nil {
		fields = append(fields, fileextract.FieldType)
	}
	if m.tags != nil {
		fields = append(fields, fileextract.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileExtractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fileextract.FieldHclID:
		return m.HclID()
	case fileextract.FieldSource:
		return m.Source()
	case fileextract.FieldDestination:
		return m.Destination()
	case fileextract.FieldType:
		return m.GetType()
	case fileextract.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileExtractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fileextract.FieldHclID:
		return m.OldHclID(ctx)
	case fileextract.FieldSource:
		return m.OldSource(ctx)
	case fileextract.FieldDestination:
		return m.OldDestination(ctx)
	case fileextract.FieldType:
		return m.OldType(ctx)
	case fileextract.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown FileExtract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileExtractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fileextract.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case fileextract.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case fileextract.FieldDestination:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestination(v)
		return nil
	case fileextract.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case fileextract.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown FileExtract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileExtractMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileExtractMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileExtractMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FileExtract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileExtractMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileExtractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileExtractMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FileExtract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileExtractMutation) ResetField(name string) error {
	switch name {
	case fileextract.FieldHclID:
		m.ResetHclID()
		return nil
	case fileextract.FieldSource:
		m.ResetSource()
		return nil
	case fileextract.FieldDestination:
		m.ResetDestination()
		return nil
	case fileextract.FieldType:
		m.ResetType()
		return nil
	case fileextract.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown FileExtract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileExtractMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Environment != nil {
		edges = append(edges, fileextract.EdgeEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileExtractMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fileextract.EdgeEnvironment:
		if id := m._Environment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileExtractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileExtractMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileExtractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Environment {
		edges = append(edges, fileextract.EdgeEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileExtractMutation) EdgeCleared(name string) bool {
	switch name {
	case fileextract.EdgeEnvironment:
		return m.cleared_Environment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileExtractMutation) ClearEdge(name string) error {
	switch name {
	case fileextract.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	}
	return fmt.Errorf("unknown FileExtract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileExtractMutation) ResetEdge(name string) error {
	switch name {
	case fileextract.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	}
	return fmt.Errorf("unknown FileExtract edge %s", name)
}

// FindingMutation represents an operation that mutates the Finding nodes in the graph.
type FindingMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	name                *string
	description         *string
	severity            *finding.Severity
	difficulty          *finding.Difficulty
	tags                *map[string]string
	clearedFields       map[string]struct{}
	_Users              map[uuid.UUID]struct{}
	removed_Users       map[uuid.UUID]struct{}
	cleared_Users       bool
	_Host               *uuid.UUID
	cleared_Host        bool
	_Script             *uuid.UUID
	cleared_Script      bool
	_Environment        *uuid.UUID
	cleared_Environment bool
	done                bool
	oldValue            func(context.Context) (*Finding, error)
	predicates          []predicate.Finding
}

var _ ent.Mutation = (*FindingMutation)(nil)

// findingOption allows management of the mutation configuration using functional options.
type findingOption func(*FindingMutation)

// newFindingMutation creates new mutation for the Finding entity.
func newFindingMutation(c config, op Op, opts ...findingOption) *FindingMutation {
	m := &FindingMutation{
		config:        c,
		op:            op,
		typ:           TypeFinding,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFindingID sets the ID field of the mutation.
func withFindingID(id uuid.UUID) findingOption {
	return func(m *FindingMutation) {
		var (
			err   error
			once  sync.Once
			value *Finding
		)
		m.oldValue = func(ctx context.Context) (*Finding, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Finding.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFinding sets the old Finding of the mutation.
func withFinding(node *Finding) findingOption {
	return func(m *FindingMutation) {
		m.oldValue = func(context.Context) (*Finding, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FindingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FindingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Finding entities.
func (m *FindingMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FindingMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FindingMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Finding.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *FindingMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FindingMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Finding entity.
// If the Finding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FindingMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *FindingMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FindingMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Finding entity.
// If the Finding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *FindingMutation) ResetDescription() {
	m.description = nil
}

// SetSeverity sets the "severity" field.
func (m *FindingMutation) SetSeverity(f finding.Severity) {
	m.severity = &f
}

// Severity returns the value of the "severity" field in the mutation.
func (m *FindingMutation) Severity() (r finding.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the Finding entity.
// If the Finding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingMutation) OldSeverity(ctx context.Context) (v finding.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *FindingMutation) ResetSeverity() {
	m.severity = nil
}

// SetDifficulty sets the "difficulty" field.
func (m *FindingMutation) SetDifficulty(f finding.Difficulty) {
	m.difficulty = &f
}

// Difficulty returns the value of the "difficulty" field in the mutation.
func (m *FindingMutation) Difficulty() (r finding.Difficulty, exists bool) {
	v := m.difficulty
	if v == nil {
		return
	}
	return *v, true
}

// OldDifficulty returns the old "difficulty" field's value of the Finding entity.
// If the Finding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingMutation) OldDifficulty(ctx context.Context) (v finding.Difficulty, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDifficulty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDifficulty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDifficulty: %w", err)
	}
	return oldValue.Difficulty, nil
}

// ResetDifficulty resets all changes to the "difficulty" field.
func (m *FindingMutation) ResetDifficulty() {
	m.difficulty = nil
}

// SetTags sets the "tags" field.
func (m *FindingMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *FindingMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Finding entity.
// If the Finding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *FindingMutation) ResetTags() {
	m.tags = nil
}

// AddUserIDs adds the "Users" edge to the User entity by ids.
func (m *FindingMutation) AddUserIDs(ids ...uuid.UUID) {
	if m._Users == nil {
		m._Users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "Users" edge to the User entity.
func (m *FindingMutation) ClearUsers() {
	m.cleared_Users = true
}

// UsersCleared reports if the "Users" edge to the User entity was cleared.
func (m *FindingMutation) UsersCleared() bool {
	return m.cleared_Users
}

// RemoveUserIDs removes the "Users" edge to the User entity by IDs.
func (m *FindingMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removed_Users == nil {
		m.removed_Users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Users, ids[i])
		m.removed_Users[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "Users" edge to the User entity.
func (m *FindingMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removed_Users {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "Users" edge IDs in the mutation.
func (m *FindingMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m._Users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "Users" edge.
func (m *FindingMutation) ResetUsers() {
	m._Users = nil
	m.cleared_Users = false
	m.removed_Users = nil
}

// SetHostID sets the "Host" edge to the Host entity by id.
func (m *FindingMutation) SetHostID(id uuid.UUID) {
	m._Host = &id
}

// ClearHost clears the "Host" edge to the Host entity.
func (m *FindingMutation) ClearHost() {
	m.cleared_Host = true
}

// HostCleared reports if the "Host" edge to the Host entity was cleared.
func (m *FindingMutation) HostCleared() bool {
	return m.cleared_Host
}

// HostID returns the "Host" edge ID in the mutation.
func (m *FindingMutation) HostID() (id uuid.UUID, exists bool) {
	if m._Host != nil {
		return *m._Host, true
	}
	return
}

// HostIDs returns the "Host" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostID instead. It exists only for internal usage by the builders.
func (m *FindingMutation) HostIDs() (ids []uuid.UUID) {
	if id := m._Host; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHost resets all changes to the "Host" edge.
func (m *FindingMutation) ResetHost() {
	m._Host = nil
	m.cleared_Host = false
}

// SetScriptID sets the "Script" edge to the Script entity by id.
func (m *FindingMutation) SetScriptID(id uuid.UUID) {
	m._Script = &id
}

// ClearScript clears the "Script" edge to the Script entity.
func (m *FindingMutation) ClearScript() {
	m.cleared_Script = true
}

// ScriptCleared reports if the "Script" edge to the Script entity was cleared.
func (m *FindingMutation) ScriptCleared() bool {
	return m.cleared_Script
}

// ScriptID returns the "Script" edge ID in the mutation.
func (m *FindingMutation) ScriptID() (id uuid.UUID, exists bool) {
	if m._Script != nil {
		return *m._Script, true
	}
	return
}

// ScriptIDs returns the "Script" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScriptID instead. It exists only for internal usage by the builders.
func (m *FindingMutation) ScriptIDs() (ids []uuid.UUID) {
	if id := m._Script; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetScript resets all changes to the "Script" edge.
func (m *FindingMutation) ResetScript() {
	m._Script = nil
	m.cleared_Script = false
}

// SetEnvironmentID sets the "Environment" edge to the Environment entity by id.
func (m *FindingMutation) SetEnvironmentID(id uuid.UUID) {
	m._Environment = &id
}

// ClearEnvironment clears the "Environment" edge to the Environment entity.
func (m *FindingMutation) ClearEnvironment() {
	m.cleared_Environment = true
}

// EnvironmentCleared reports if the "Environment" edge to the Environment entity was cleared.
func (m *FindingMutation) EnvironmentCleared() bool {
	return m.cleared_Environment
}

// EnvironmentID returns the "Environment" edge ID in the mutation.
func (m *FindingMutation) EnvironmentID() (id uuid.UUID, exists bool) {
	if m._Environment != nil {
		return *m._Environment, true
	}
	return
}

// EnvironmentIDs returns the "Environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *FindingMutation) EnvironmentIDs() (ids []uuid.UUID) {
	if id := m._Environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "Environment" edge.
func (m *FindingMutation) ResetEnvironment() {
	m._Environment = nil
	m.cleared_Environment = false
}

// Where appends a list predicates to the FindingMutation builder.
func (m *FindingMutation) Where(ps ...predicate.Finding) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FindingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Finding).
func (m *FindingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FindingMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, finding.FieldName)
	}
	if m.description != nil {
		fields = append(fields, finding.FieldDescription)
	}
	if m.severity != nil {
		fields = append(fields, finding.FieldSeverity)
	}
	if m.difficulty != nil {
		fields = append(fields, finding.FieldDifficulty)
	}
	if m.tags != nil {
		fields = append(fields, finding.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FindingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case finding.FieldName:
		return m.Name()
	case finding.FieldDescription:
		return m.Description()
	case finding.FieldSeverity:
		return m.Severity()
	case finding.FieldDifficulty:
		return m.Difficulty()
	case finding.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FindingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case finding.FieldName:
		return m.OldName(ctx)
	case finding.FieldDescription:
		return m.OldDescription(ctx)
	case finding.FieldSeverity:
		return m.OldSeverity(ctx)
	case finding.FieldDifficulty:
		return m.OldDifficulty(ctx)
	case finding.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Finding field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FindingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case finding.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case finding.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case finding.FieldSeverity:
		v, ok := value.(finding.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case finding.FieldDifficulty:
		v, ok := value.(finding.Difficulty)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDifficulty(v)
		return nil
	case finding.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Finding field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FindingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FindingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FindingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Finding numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FindingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FindingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FindingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Finding nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FindingMutation) ResetField(name string) error {
	switch name {
	case finding.FieldName:
		m.ResetName()
		return nil
	case finding.FieldDescription:
		m.ResetDescription()
		return nil
	case finding.FieldSeverity:
		m.ResetSeverity()
		return nil
	case finding.FieldDifficulty:
		m.ResetDifficulty()
		return nil
	case finding.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Finding field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FindingMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._Users != nil {
		edges = append(edges, finding.EdgeUsers)
	}
	if m._Host != nil {
		edges = append(edges, finding.EdgeHost)
	}
	if m._Script != nil {
		edges = append(edges, finding.EdgeScript)
	}
	if m._Environment != nil {
		edges = append(edges, finding.EdgeEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FindingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case finding.EdgeUsers:
		ids := make([]ent.Value, 0, len(m._Users))
		for id := range m._Users {
			ids = append(ids, id)
		}
		return ids
	case finding.EdgeHost:
		if id := m._Host; id != nil {
			return []ent.Value{*id}
		}
	case finding.EdgeScript:
		if id := m._Script; id != nil {
			return []ent.Value{*id}
		}
	case finding.EdgeEnvironment:
		if id := m._Environment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FindingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removed_Users != nil {
		edges = append(edges, finding.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FindingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case finding.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removed_Users))
		for id := range m.removed_Users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FindingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_Users {
		edges = append(edges, finding.EdgeUsers)
	}
	if m.cleared_Host {
		edges = append(edges, finding.EdgeHost)
	}
	if m.cleared_Script {
		edges = append(edges, finding.EdgeScript)
	}
	if m.cleared_Environment {
		edges = append(edges, finding.EdgeEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FindingMutation) EdgeCleared(name string) bool {
	switch name {
	case finding.EdgeUsers:
		return m.cleared_Users
	case finding.EdgeHost:
		return m.cleared_Host
	case finding.EdgeScript:
		return m.cleared_Script
	case finding.EdgeEnvironment:
		return m.cleared_Environment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FindingMutation) ClearEdge(name string) error {
	switch name {
	case finding.EdgeHost:
		m.ClearHost()
		return nil
	case finding.EdgeScript:
		m.ClearScript()
		return nil
	case finding.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Finding unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FindingMutation) ResetEdge(name string) error {
	switch name {
	case finding.EdgeUsers:
		m.ResetUsers()
		return nil
	case finding.EdgeHost:
		m.ResetHost()
		return nil
	case finding.EdgeScript:
		m.ResetScript()
		return nil
	case finding.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Finding edge %s", name)
}

// GinFileMiddlewareMutation represents an operation that mutates the GinFileMiddleware nodes in the graph.
type GinFileMiddlewareMutation struct {
	config
	op                                Op
	typ                               string
	id                                *uuid.UUID
	url_id                            *string
	file_path                         *string
	accessed                          *bool
	clearedFields                     map[string]struct{}
	_ProvisionedHost                  *uuid.UUID
	cleared_ProvisionedHost           bool
	_ProvisioningStep                 *uuid.UUID
	cleared_ProvisioningStep          bool
	_ProvisioningScheduledStep        *uuid.UUID
	cleared_ProvisioningScheduledStep bool
	done                              bool
	oldValue                          func(context.Context) (*GinFileMiddleware, error)
	predicates                        []predicate.GinFileMiddleware
}

var _ ent.Mutation = (*GinFileMiddlewareMutation)(nil)

// ginfilemiddlewareOption allows management of the mutation configuration using functional options.
type ginfilemiddlewareOption func(*GinFileMiddlewareMutation)

// newGinFileMiddlewareMutation creates new mutation for the GinFileMiddleware entity.
func newGinFileMiddlewareMutation(c config, op Op, opts ...ginfilemiddlewareOption) *GinFileMiddlewareMutation {
	m := &GinFileMiddlewareMutation{
		config:        c,
		op:            op,
		typ:           TypeGinFileMiddleware,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGinFileMiddlewareID sets the ID field of the mutation.
func withGinFileMiddlewareID(id uuid.UUID) ginfilemiddlewareOption {
	return func(m *GinFileMiddlewareMutation) {
		var (
			err   error
			once  sync.Once
			value *GinFileMiddleware
		)
		m.oldValue = func(ctx context.Context) (*GinFileMiddleware, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GinFileMiddleware.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGinFileMiddleware sets the old GinFileMiddleware of the mutation.
func withGinFileMiddleware(node *GinFileMiddleware) ginfilemiddlewareOption {
	return func(m *GinFileMiddlewareMutation) {
		m.oldValue = func(context.Context) (*GinFileMiddleware, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GinFileMiddlewareMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GinFileMiddlewareMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GinFileMiddleware entities.
func (m *GinFileMiddlewareMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GinFileMiddlewareMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GinFileMiddlewareMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GinFileMiddleware.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetURLID sets the "url_id" field.
func (m *GinFileMiddlewareMutation) SetURLID(s string) {
	m.url_id = &s
}

// URLID returns the value of the "url_id" field in the mutation.
func (m *GinFileMiddlewareMutation) URLID() (r string, exists bool) {
	v := m.url_id
	if v == nil {
		return
	}
	return *v, true
}

// OldURLID returns the old "url_id" field's value of the GinFileMiddleware entity.
// If the GinFileMiddleware object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinFileMiddlewareMutation) OldURLID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURLID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURLID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURLID: %w", err)
	}
	return oldValue.URLID, nil
}

// ResetURLID resets all changes to the "url_id" field.
func (m *GinFileMiddlewareMutation) ResetURLID() {
	m.url_id = nil
}

// SetFilePath sets the "file_path" field.
func (m *GinFileMiddlewareMutation) SetFilePath(s string) {
	m.file_path = &s
}

// FilePath returns the value of the "file_path" field in the mutation.
func (m *GinFileMiddlewareMutation) FilePath() (r string, exists bool) {
	v := m.file_path
	if v == nil {
		return
	}
	return *v, true
}

// OldFilePath returns the old "file_path" field's value of the GinFileMiddleware entity.
// If the GinFileMiddleware object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinFileMiddlewareMutation) OldFilePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilePath: %w", err)
	}
	return oldValue.FilePath, nil
}

// ResetFilePath resets all changes to the "file_path" field.
func (m *GinFileMiddlewareMutation) ResetFilePath() {
	m.file_path = nil
}

// SetAccessed sets the "accessed" field.
func (m *GinFileMiddlewareMutation) SetAccessed(b bool) {
	m.accessed = &b
}

// Accessed returns the value of the "accessed" field in the mutation.
func (m *GinFileMiddlewareMutation) Accessed() (r bool, exists bool) {
	v := m.accessed
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessed returns the old "accessed" field's value of the GinFileMiddleware entity.
// If the GinFileMiddleware object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinFileMiddlewareMutation) OldAccessed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessed: %w", err)
	}
	return oldValue.Accessed, nil
}

// ResetAccessed resets all changes to the "accessed" field.
func (m *GinFileMiddlewareMutation) ResetAccessed() {
	m.accessed = nil
}

// SetProvisionedHostID sets the "ProvisionedHost" edge to the ProvisionedHost entity by id.
func (m *GinFileMiddlewareMutation) SetProvisionedHostID(id uuid.UUID) {
	m._ProvisionedHost = &id
}

// ClearProvisionedHost clears the "ProvisionedHost" edge to the ProvisionedHost entity.
func (m *GinFileMiddlewareMutation) ClearProvisionedHost() {
	m.cleared_ProvisionedHost = true
}

// ProvisionedHostCleared reports if the "ProvisionedHost" edge to the ProvisionedHost entity was cleared.
func (m *GinFileMiddlewareMutation) ProvisionedHostCleared() bool {
	return m.cleared_ProvisionedHost
}

// ProvisionedHostID returns the "ProvisionedHost" edge ID in the mutation.
func (m *GinFileMiddlewareMutation) ProvisionedHostID() (id uuid.UUID, exists bool) {
	if m._ProvisionedHost != nil {
		return *m._ProvisionedHost, true
	}
	return
}

// ProvisionedHostIDs returns the "ProvisionedHost" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisionedHostID instead. It exists only for internal usage by the builders.
func (m *GinFileMiddlewareMutation) ProvisionedHostIDs() (ids []uuid.UUID) {
	if id := m._ProvisionedHost; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisionedHost resets all changes to the "ProvisionedHost" edge.
func (m *GinFileMiddlewareMutation) ResetProvisionedHost() {
	m._ProvisionedHost = nil
	m.cleared_ProvisionedHost = false
}

// SetProvisioningStepID sets the "ProvisioningStep" edge to the ProvisioningStep entity by id.
func (m *GinFileMiddlewareMutation) SetProvisioningStepID(id uuid.UUID) {
	m._ProvisioningStep = &id
}

// ClearProvisioningStep clears the "ProvisioningStep" edge to the ProvisioningStep entity.
func (m *GinFileMiddlewareMutation) ClearProvisioningStep() {
	m.cleared_ProvisioningStep = true
}

// ProvisioningStepCleared reports if the "ProvisioningStep" edge to the ProvisioningStep entity was cleared.
func (m *GinFileMiddlewareMutation) ProvisioningStepCleared() bool {
	return m.cleared_ProvisioningStep
}

// ProvisioningStepID returns the "ProvisioningStep" edge ID in the mutation.
func (m *GinFileMiddlewareMutation) ProvisioningStepID() (id uuid.UUID, exists bool) {
	if m._ProvisioningStep != nil {
		return *m._ProvisioningStep, true
	}
	return
}

// ProvisioningStepIDs returns the "ProvisioningStep" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisioningStepID instead. It exists only for internal usage by the builders.
func (m *GinFileMiddlewareMutation) ProvisioningStepIDs() (ids []uuid.UUID) {
	if id := m._ProvisioningStep; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisioningStep resets all changes to the "ProvisioningStep" edge.
func (m *GinFileMiddlewareMutation) ResetProvisioningStep() {
	m._ProvisioningStep = nil
	m.cleared_ProvisioningStep = false
}

// SetProvisioningScheduledStepID sets the "ProvisioningScheduledStep" edge to the ProvisioningScheduledStep entity by id.
func (m *GinFileMiddlewareMutation) SetProvisioningScheduledStepID(id uuid.UUID) {
	m._ProvisioningScheduledStep = &id
}

// ClearProvisioningScheduledStep clears the "ProvisioningScheduledStep" edge to the ProvisioningScheduledStep entity.
func (m *GinFileMiddlewareMutation) ClearProvisioningScheduledStep() {
	m.cleared_ProvisioningScheduledStep = true
}

// ProvisioningScheduledStepCleared reports if the "ProvisioningScheduledStep" edge to the ProvisioningScheduledStep entity was cleared.
func (m *GinFileMiddlewareMutation) ProvisioningScheduledStepCleared() bool {
	return m.cleared_ProvisioningScheduledStep
}

// ProvisioningScheduledStepID returns the "ProvisioningScheduledStep" edge ID in the mutation.
func (m *GinFileMiddlewareMutation) ProvisioningScheduledStepID() (id uuid.UUID, exists bool) {
	if m._ProvisioningScheduledStep != nil {
		return *m._ProvisioningScheduledStep, true
	}
	return
}

// ProvisioningScheduledStepIDs returns the "ProvisioningScheduledStep" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisioningScheduledStepID instead. It exists only for internal usage by the builders.
func (m *GinFileMiddlewareMutation) ProvisioningScheduledStepIDs() (ids []uuid.UUID) {
	if id := m._ProvisioningScheduledStep; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisioningScheduledStep resets all changes to the "ProvisioningScheduledStep" edge.
func (m *GinFileMiddlewareMutation) ResetProvisioningScheduledStep() {
	m._ProvisioningScheduledStep = nil
	m.cleared_ProvisioningScheduledStep = false
}

// Where appends a list predicates to the GinFileMiddlewareMutation builder.
func (m *GinFileMiddlewareMutation) Where(ps ...predicate.GinFileMiddleware) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GinFileMiddlewareMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GinFileMiddleware).
func (m *GinFileMiddlewareMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GinFileMiddlewareMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.url_id != nil {
		fields = append(fields, ginfilemiddleware.FieldURLID)
	}
	if m.file_path != nil {
		fields = append(fields, ginfilemiddleware.FieldFilePath)
	}
	if m.accessed != nil {
		fields = append(fields, ginfilemiddleware.FieldAccessed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GinFileMiddlewareMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ginfilemiddleware.FieldURLID:
		return m.URLID()
	case ginfilemiddleware.FieldFilePath:
		return m.FilePath()
	case ginfilemiddleware.FieldAccessed:
		return m.Accessed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GinFileMiddlewareMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ginfilemiddleware.FieldURLID:
		return m.OldURLID(ctx)
	case ginfilemiddleware.FieldFilePath:
		return m.OldFilePath(ctx)
	case ginfilemiddleware.FieldAccessed:
		return m.OldAccessed(ctx)
	}
	return nil, fmt.Errorf("unknown GinFileMiddleware field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GinFileMiddlewareMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ginfilemiddleware.FieldURLID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURLID(v)
		return nil
	case ginfilemiddleware.FieldFilePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilePath(v)
		return nil
	case ginfilemiddleware.FieldAccessed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessed(v)
		return nil
	}
	return fmt.Errorf("unknown GinFileMiddleware field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GinFileMiddlewareMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GinFileMiddlewareMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GinFileMiddlewareMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GinFileMiddleware numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GinFileMiddlewareMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GinFileMiddlewareMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GinFileMiddlewareMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GinFileMiddleware nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GinFileMiddlewareMutation) ResetField(name string) error {
	switch name {
	case ginfilemiddleware.FieldURLID:
		m.ResetURLID()
		return nil
	case ginfilemiddleware.FieldFilePath:
		m.ResetFilePath()
		return nil
	case ginfilemiddleware.FieldAccessed:
		m.ResetAccessed()
		return nil
	}
	return fmt.Errorf("unknown GinFileMiddleware field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GinFileMiddlewareMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._ProvisionedHost != nil {
		edges = append(edges, ginfilemiddleware.EdgeProvisionedHost)
	}
	if m._ProvisioningStep != nil {
		edges = append(edges, ginfilemiddleware.EdgeProvisioningStep)
	}
	if m._ProvisioningScheduledStep != nil {
		edges = append(edges, ginfilemiddleware.EdgeProvisioningScheduledStep)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GinFileMiddlewareMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ginfilemiddleware.EdgeProvisionedHost:
		if id := m._ProvisionedHost; id != nil {
			return []ent.Value{*id}
		}
	case ginfilemiddleware.EdgeProvisioningStep:
		if id := m._ProvisioningStep; id != nil {
			return []ent.Value{*id}
		}
	case ginfilemiddleware.EdgeProvisioningScheduledStep:
		if id := m._ProvisioningScheduledStep; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GinFileMiddlewareMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GinFileMiddlewareMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GinFileMiddlewareMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_ProvisionedHost {
		edges = append(edges, ginfilemiddleware.EdgeProvisionedHost)
	}
	if m.cleared_ProvisioningStep {
		edges = append(edges, ginfilemiddleware.EdgeProvisioningStep)
	}
	if m.cleared_ProvisioningScheduledStep {
		edges = append(edges, ginfilemiddleware.EdgeProvisioningScheduledStep)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GinFileMiddlewareMutation) EdgeCleared(name string) bool {
	switch name {
	case ginfilemiddleware.EdgeProvisionedHost:
		return m.cleared_ProvisionedHost
	case ginfilemiddleware.EdgeProvisioningStep:
		return m.cleared_ProvisioningStep
	case ginfilemiddleware.EdgeProvisioningScheduledStep:
		return m.cleared_ProvisioningScheduledStep
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GinFileMiddlewareMutation) ClearEdge(name string) error {
	switch name {
	case ginfilemiddleware.EdgeProvisionedHost:
		m.ClearProvisionedHost()
		return nil
	case ginfilemiddleware.EdgeProvisioningStep:
		m.ClearProvisioningStep()
		return nil
	case ginfilemiddleware.EdgeProvisioningScheduledStep:
		m.ClearProvisioningScheduledStep()
		return nil
	}
	return fmt.Errorf("unknown GinFileMiddleware unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GinFileMiddlewareMutation) ResetEdge(name string) error {
	switch name {
	case ginfilemiddleware.EdgeProvisionedHost:
		m.ResetProvisionedHost()
		return nil
	case ginfilemiddleware.EdgeProvisioningStep:
		m.ResetProvisioningStep()
		return nil
	case ginfilemiddleware.EdgeProvisioningScheduledStep:
		m.ResetProvisioningScheduledStep()
		return nil
	}
	return fmt.Errorf("unknown GinFileMiddleware edge %s", name)
}

// HostMutation represents an operation that mutates the Host nodes in the graph.
type HostMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *uuid.UUID
	hcl_id                             *string
	hostname                           *string
	description                        *string
	_OS                                *string
	last_octet                         *int
	addlast_octet                      *int
	instance_size                      *string
	allow_mac_changes                  *bool
	exposed_tcp_ports                  *[]string
	exposed_udp_ports                  *[]string
	override_password                  *string
	vars                               *map[string]string
	user_groups                        *[]string
	provision_steps                    *[]string
	scheduled_steps                    *[]string
	tags                               *map[string]string
	clearedFields                      map[string]struct{}
	_Disk                              *uuid.UUID
	cleared_Disk                       bool
	_Users                             map[uuid.UUID]struct{}
	removed_Users                      map[uuid.UUID]struct{}
	cleared_Users                      bool
	_Environment                       *uuid.UUID
	cleared_Environment                bool
	_IncludedNetworks                  map[uuid.UUID]struct{}
	removed_IncludedNetworks           map[uuid.UUID]struct{}
	cleared_IncludedNetworks           bool
	_DependOnHostDependencies          map[uuid.UUID]struct{}
	removed_DependOnHostDependencies   map[uuid.UUID]struct{}
	cleared_DependOnHostDependencies   bool
	_RequiredByHostDependencies        map[uuid.UUID]struct{}
	removed_RequiredByHostDependencies map[uuid.UUID]struct{}
	cleared_RequiredByHostDependencies bool
	done                               bool
	oldValue                           func(context.Context) (*Host, error)
	predicates                         []predicate.Host
}

var _ ent.Mutation = (*HostMutation)(nil)

// hostOption allows management of the mutation configuration using functional options.
type hostOption func(*HostMutation)

// newHostMutation creates new mutation for the Host entity.
func newHostMutation(c config, op Op, opts ...hostOption) *HostMutation {
	m := &HostMutation{
		config:        c,
		op:            op,
		typ:           TypeHost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHostID sets the ID field of the mutation.
func withHostID(id uuid.UUID) hostOption {
	return func(m *HostMutation) {
		var (
			err   error
			once  sync.Once
			value *Host
		)
		m.oldValue = func(ctx context.Context) (*Host, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Host.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHost sets the old Host of the mutation.
func withHost(node *Host) hostOption {
	return func(m *HostMutation) {
		m.oldValue = func(context.Context) (*Host, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Host entities.
func (m *HostMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HostMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HostMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Host.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHclID sets the "hcl_id" field.
func (m *HostMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *HostMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *HostMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetHostname sets the "hostname" field.
func (m *HostMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *HostMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname resets all changes to the "hostname" field.
func (m *HostMutation) ResetHostname() {
	m.hostname = nil
}

// SetDescription sets the "description" field.
func (m *HostMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *HostMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *HostMutation) ResetDescription() {
	m.description = nil
}

// SetOS sets the "OS" field.
func (m *HostMutation) SetOS(s string) {
	m._OS = &s
}

// OS returns the value of the "OS" field in the mutation.
func (m *HostMutation) OS() (r string, exists bool) {
	v := m._OS
	if v == nil {
		return
	}
	return *v, true
}

// OldOS returns the old "OS" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldOS(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOS: %w", err)
	}
	return oldValue.OS, nil
}

// ResetOS resets all changes to the "OS" field.
func (m *HostMutation) ResetOS() {
	m._OS = nil
}

// SetLastOctet sets the "last_octet" field.
func (m *HostMutation) SetLastOctet(i int) {
	m.last_octet = &i
	m.addlast_octet = nil
}

// LastOctet returns the value of the "last_octet" field in the mutation.
func (m *HostMutation) LastOctet() (r int, exists bool) {
	v := m.last_octet
	if v == nil {
		return
	}
	return *v, true
}

// OldLastOctet returns the old "last_octet" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldLastOctet(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastOctet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastOctet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastOctet: %w", err)
	}
	return oldValue.LastOctet, nil
}

// AddLastOctet adds i to the "last_octet" field.
func (m *HostMutation) AddLastOctet(i int) {
	if m.addlast_octet != nil {
		*m.addlast_octet += i
	} else {
		m.addlast_octet = &i
	}
}

// AddedLastOctet returns the value that was added to the "last_octet" field in this mutation.
func (m *HostMutation) AddedLastOctet() (r int, exists bool) {
	v := m.addlast_octet
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastOctet resets all changes to the "last_octet" field.
func (m *HostMutation) ResetLastOctet() {
	m.last_octet = nil
	m.addlast_octet = nil
}

// SetInstanceSize sets the "instance_size" field.
func (m *HostMutation) SetInstanceSize(s string) {
	m.instance_size = &s
}

// InstanceSize returns the value of the "instance_size" field in the mutation.
func (m *HostMutation) InstanceSize() (r string, exists bool) {
	v := m.instance_size
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceSize returns the old "instance_size" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldInstanceSize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstanceSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstanceSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceSize: %w", err)
	}
	return oldValue.InstanceSize, nil
}

// ResetInstanceSize resets all changes to the "instance_size" field.
func (m *HostMutation) ResetInstanceSize() {
	m.instance_size = nil
}

// SetAllowMACChanges sets the "allow_mac_changes" field.
func (m *HostMutation) SetAllowMACChanges(b bool) {
	m.allow_mac_changes = &b
}

// AllowMACChanges returns the value of the "allow_mac_changes" field in the mutation.
func (m *HostMutation) AllowMACChanges() (r bool, exists bool) {
	v := m.allow_mac_changes
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowMACChanges returns the old "allow_mac_changes" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldAllowMACChanges(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowMACChanges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowMACChanges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowMACChanges: %w", err)
	}
	return oldValue.AllowMACChanges, nil
}

// ResetAllowMACChanges resets all changes to the "allow_mac_changes" field.
func (m *HostMutation) ResetAllowMACChanges() {
	m.allow_mac_changes = nil
}

// SetExposedTCPPorts sets the "exposed_tcp_ports" field.
func (m *HostMutation) SetExposedTCPPorts(s []string) {
	m.exposed_tcp_ports = &s
}

// ExposedTCPPorts returns the value of the "exposed_tcp_ports" field in the mutation.
func (m *HostMutation) ExposedTCPPorts() (r []string, exists bool) {
	v := m.exposed_tcp_ports
	if v == nil {
		return
	}
	return *v, true
}

// OldExposedTCPPorts returns the old "exposed_tcp_ports" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldExposedTCPPorts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExposedTCPPorts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExposedTCPPorts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExposedTCPPorts: %w", err)
	}
	return oldValue.ExposedTCPPorts, nil
}

// ResetExposedTCPPorts resets all changes to the "exposed_tcp_ports" field.
func (m *HostMutation) ResetExposedTCPPorts() {
	m.exposed_tcp_ports = nil
}

// SetExposedUDPPorts sets the "exposed_udp_ports" field.
func (m *HostMutation) SetExposedUDPPorts(s []string) {
	m.exposed_udp_ports = &s
}

// ExposedUDPPorts returns the value of the "exposed_udp_ports" field in the mutation.
func (m *HostMutation) ExposedUDPPorts() (r []string, exists bool) {
	v := m.exposed_udp_ports
	if v == nil {
		return
	}
	return *v, true
}

// OldExposedUDPPorts returns the old "exposed_udp_ports" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldExposedUDPPorts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExposedUDPPorts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExposedUDPPorts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExposedUDPPorts: %w", err)
	}
	return oldValue.ExposedUDPPorts, nil
}

// ResetExposedUDPPorts resets all changes to the "exposed_udp_ports" field.
func (m *HostMutation) ResetExposedUDPPorts() {
	m.exposed_udp_ports = nil
}

// SetOverridePassword sets the "override_password" field.
func (m *HostMutation) SetOverridePassword(s string) {
	m.override_password = &s
}

// OverridePassword returns the value of the "override_password" field in the mutation.
func (m *HostMutation) OverridePassword() (r string, exists bool) {
	v := m.override_password
	if v == nil {
		return
	}
	return *v, true
}

// OldOverridePassword returns the old "override_password" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldOverridePassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverridePassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverridePassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverridePassword: %w", err)
	}
	return oldValue.OverridePassword, nil
}

// ResetOverridePassword resets all changes to the "override_password" field.
func (m *HostMutation) ResetOverridePassword() {
	m.override_password = nil
}

// SetVars sets the "vars" field.
func (m *HostMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *HostMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *HostMutation) ResetVars() {
	m.vars = nil
}

// SetUserGroups sets the "user_groups" field.
func (m *HostMutation) SetUserGroups(s []string) {
	m.user_groups = &s
}

// UserGroups returns the value of the "user_groups" field in the mutation.
func (m *HostMutation) UserGroups() (r []string, exists bool) {
	v := m.user_groups
	if v == nil {
		return
	}
	return *v, true
}

// OldUserGroups returns the old "user_groups" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldUserGroups(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserGroups is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserGroups requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserGroups: %w", err)
	}
	return oldValue.UserGroups, nil
}

// ResetUserGroups resets all changes to the "user_groups" field.
func (m *HostMutation) ResetUserGroups() {
	m.user_groups = nil
}

// SetProvisionSteps sets the "provision_steps" field.
func (m *HostMutation) SetProvisionSteps(s []string) {
	m.provision_steps = &s
}

// ProvisionSteps returns the value of the "provision_steps" field in the mutation.
func (m *HostMutation) ProvisionSteps() (r []string, exists bool) {
	v := m.provision_steps
	if v == nil {
		return
	}
	return *v, true
}

// OldProvisionSteps returns the old "provision_steps" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldProvisionSteps(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvisionSteps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvisionSteps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvisionSteps: %w", err)
	}
	return oldValue.ProvisionSteps, nil
}

// ClearProvisionSteps clears the value of the "provision_steps" field.
func (m *HostMutation) ClearProvisionSteps() {
	m.provision_steps = nil
	m.clearedFields[host.FieldProvisionSteps] = struct{}{}
}

// ProvisionStepsCleared returns if the "provision_steps" field was cleared in this mutation.
func (m *HostMutation) ProvisionStepsCleared() bool {
	_, ok := m.clearedFields[host.FieldProvisionSteps]
	return ok
}

// ResetProvisionSteps resets all changes to the "provision_steps" field.
func (m *HostMutation) ResetProvisionSteps() {
	m.provision_steps = nil
	delete(m.clearedFields, host.FieldProvisionSteps)
}

// SetScheduledSteps sets the "scheduled_steps" field.
func (m *HostMutation) SetScheduledSteps(s []string) {
	m.scheduled_steps = &s
}

// ScheduledSteps returns the value of the "scheduled_steps" field in the mutation.
func (m *HostMutation) ScheduledSteps() (r []string, exists bool) {
	v := m.scheduled_steps
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduledSteps returns the old "scheduled_steps" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldScheduledSteps(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduledSteps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduledSteps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduledSteps: %w", err)
	}
	return oldValue.ScheduledSteps, nil
}

// ClearScheduledSteps clears the value of the "scheduled_steps" field.
func (m *HostMutation) ClearScheduledSteps() {
	m.scheduled_steps = nil
	m.clearedFields[host.FieldScheduledSteps] = struct{}{}
}

// ScheduledStepsCleared returns if the "scheduled_steps" field was cleared in this mutation.
func (m *HostMutation) ScheduledStepsCleared() bool {
	_, ok := m.clearedFields[host.FieldScheduledSteps]
	return ok
}

// ResetScheduledSteps resets all changes to the "scheduled_steps" field.
func (m *HostMutation) ResetScheduledSteps() {
	m.scheduled_steps = nil
	delete(m.clearedFields, host.FieldScheduledSteps)
}

// SetTags sets the "tags" field.
func (m *HostMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *HostMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *HostMutation) ResetTags() {
	m.tags = nil
}

// SetDiskID sets the "Disk" edge to the Disk entity by id.
func (m *HostMutation) SetDiskID(id uuid.UUID) {
	m._Disk = &id
}

// ClearDisk clears the "Disk" edge to the Disk entity.
func (m *HostMutation) ClearDisk() {
	m.cleared_Disk = true
}

// DiskCleared reports if the "Disk" edge to the Disk entity was cleared.
func (m *HostMutation) DiskCleared() bool {
	return m.cleared_Disk
}

// DiskID returns the "Disk" edge ID in the mutation.
func (m *HostMutation) DiskID() (id uuid.UUID, exists bool) {
	if m._Disk != nil {
		return *m._Disk, true
	}
	return
}

// DiskIDs returns the "Disk" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DiskID instead. It exists only for internal usage by the builders.
func (m *HostMutation) DiskIDs() (ids []uuid.UUID) {
	if id := m._Disk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDisk resets all changes to the "Disk" edge.
func (m *HostMutation) ResetDisk() {
	m._Disk = nil
	m.cleared_Disk = false
}

// AddUserIDs adds the "Users" edge to the User entity by ids.
func (m *HostMutation) AddUserIDs(ids ...uuid.UUID) {
	if m._Users == nil {
		m._Users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "Users" edge to the User entity.
func (m *HostMutation) ClearUsers() {
	m.cleared_Users = true
}

// UsersCleared reports if the "Users" edge to the User entity was cleared.
func (m *HostMutation) UsersCleared() bool {
	return m.cleared_Users
}

// RemoveUserIDs removes the "Users" edge to the User entity by IDs.
func (m *HostMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removed_Users == nil {
		m.removed_Users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Users, ids[i])
		m.removed_Users[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "Users" edge to the User entity.
func (m *HostMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removed_Users {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "Users" edge IDs in the mutation.
func (m *HostMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m._Users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "Users" edge.
func (m *HostMutation) ResetUsers() {
	m._Users = nil
	m.cleared_Users = false
	m.removed_Users = nil
}

// SetEnvironmentID sets the "Environment" edge to the Environment entity by id.
func (m *HostMutation) SetEnvironmentID(id uuid.UUID) {
	m._Environment = &id
}

// ClearEnvironment clears the "Environment" edge to the Environment entity.
func (m *HostMutation) ClearEnvironment() {
	m.cleared_Environment = true
}

// EnvironmentCleared reports if the "Environment" edge to the Environment entity was cleared.
func (m *HostMutation) EnvironmentCleared() bool {
	return m.cleared_Environment
}

// EnvironmentID returns the "Environment" edge ID in the mutation.
func (m *HostMutation) EnvironmentID() (id uuid.UUID, exists bool) {
	if m._Environment != nil {
		return *m._Environment, true
	}
	return
}

// EnvironmentIDs returns the "Environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *HostMutation) EnvironmentIDs() (ids []uuid.UUID) {
	if id := m._Environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "Environment" edge.
func (m *HostMutation) ResetEnvironment() {
	m._Environment = nil
	m.cleared_Environment = false
}

// AddIncludedNetworkIDs adds the "IncludedNetworks" edge to the IncludedNetwork entity by ids.
func (m *HostMutation) AddIncludedNetworkIDs(ids ...uuid.UUID) {
	if m._IncludedNetworks == nil {
		m._IncludedNetworks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._IncludedNetworks[ids[i]] = struct{}{}
	}
}

// ClearIncludedNetworks clears the "IncludedNetworks" edge to the IncludedNetwork entity.
func (m *HostMutation) ClearIncludedNetworks() {
	m.cleared_IncludedNetworks = true
}

// IncludedNetworksCleared reports if the "IncludedNetworks" edge to the IncludedNetwork entity was cleared.
func (m *HostMutation) IncludedNetworksCleared() bool {
	return m.cleared_IncludedNetworks
}

// RemoveIncludedNetworkIDs removes the "IncludedNetworks" edge to the IncludedNetwork entity by IDs.
func (m *HostMutation) RemoveIncludedNetworkIDs(ids ...uuid.UUID) {
	if m.removed_IncludedNetworks == nil {
		m.removed_IncludedNetworks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._IncludedNetworks, ids[i])
		m.removed_IncludedNetworks[ids[i]] = struct{}{}
	}
}

// RemovedIncludedNetworks returns the removed IDs of the "IncludedNetworks" edge to the IncludedNetwork entity.
func (m *HostMutation) RemovedIncludedNetworksIDs() (ids []uuid.UUID) {
	for id := range m.removed_IncludedNetworks {
		ids = append(ids, id)
	}
	return
}

// IncludedNetworksIDs returns the "IncludedNetworks" edge IDs in the mutation.
func (m *HostMutation) IncludedNetworksIDs() (ids []uuid.UUID) {
	for id := range m._IncludedNetworks {
		ids = append(ids, id)
	}
	return
}

// ResetIncludedNetworks resets all changes to the "IncludedNetworks" edge.
func (m *HostMutation) ResetIncludedNetworks() {
	m._IncludedNetworks = nil
	m.cleared_IncludedNetworks = false
	m.removed_IncludedNetworks = nil
}

// AddDependOnHostDependencyIDs adds the "DependOnHostDependencies" edge to the HostDependency entity by ids.
func (m *HostMutation) AddDependOnHostDependencyIDs(ids ...uuid.UUID) {
	if m._DependOnHostDependencies == nil {
		m._DependOnHostDependencies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._DependOnHostDependencies[ids[i]] = struct{}{}
	}
}

// ClearDependOnHostDependencies clears the "DependOnHostDependencies" edge to the HostDependency entity.
func (m *HostMutation) ClearDependOnHostDependencies() {
	m.cleared_DependOnHostDependencies = true
}

// DependOnHostDependenciesCleared reports if the "DependOnHostDependencies" edge to the HostDependency entity was cleared.
func (m *HostMutation) DependOnHostDependenciesCleared() bool {
	return m.cleared_DependOnHostDependencies
}

// RemoveDependOnHostDependencyIDs removes the "DependOnHostDependencies" edge to the HostDependency entity by IDs.
func (m *HostMutation) RemoveDependOnHostDependencyIDs(ids ...uuid.UUID) {
	if m.removed_DependOnHostDependencies == nil {
		m.removed_DependOnHostDependencies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._DependOnHostDependencies, ids[i])
		m.removed_DependOnHostDependencies[ids[i]] = struct{}{}
	}
}

// RemovedDependOnHostDependencies returns the removed IDs of the "DependOnHostDependencies" edge to the HostDependency entity.
func (m *HostMutation) RemovedDependOnHostDependenciesIDs() (ids []uuid.UUID) {
	for id := range m.removed_DependOnHostDependencies {
		ids = append(ids, id)
	}
	return
}

// DependOnHostDependenciesIDs returns the "DependOnHostDependencies" edge IDs in the mutation.
func (m *HostMutation) DependOnHostDependenciesIDs() (ids []uuid.UUID) {
	for id := range m._DependOnHostDependencies {
		ids = append(ids, id)
	}
	return
}

// ResetDependOnHostDependencies resets all changes to the "DependOnHostDependencies" edge.
func (m *HostMutation) ResetDependOnHostDependencies() {
	m._DependOnHostDependencies = nil
	m.cleared_DependOnHostDependencies = false
	m.removed_DependOnHostDependencies = nil
}

// AddRequiredByHostDependencyIDs adds the "RequiredByHostDependencies" edge to the HostDependency entity by ids.
func (m *HostMutation) AddRequiredByHostDependencyIDs(ids ...uuid.UUID) {
	if m._RequiredByHostDependencies == nil {
		m._RequiredByHostDependencies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._RequiredByHostDependencies[ids[i]] = struct{}{}
	}
}

// ClearRequiredByHostDependencies clears the "RequiredByHostDependencies" edge to the HostDependency entity.
func (m *HostMutation) ClearRequiredByHostDependencies() {
	m.cleared_RequiredByHostDependencies = true
}

// RequiredByHostDependenciesCleared reports if the "RequiredByHostDependencies" edge to the HostDependency entity was cleared.
func (m *HostMutation) RequiredByHostDependenciesCleared() bool {
	return m.cleared_RequiredByHostDependencies
}

// RemoveRequiredByHostDependencyIDs removes the "RequiredByHostDependencies" edge to the HostDependency entity by IDs.
func (m *HostMutation) RemoveRequiredByHostDependencyIDs(ids ...uuid.UUID) {
	if m.removed_RequiredByHostDependencies == nil {
		m.removed_RequiredByHostDependencies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._RequiredByHostDependencies, ids[i])
		m.removed_RequiredByHostDependencies[ids[i]] = struct{}{}
	}
}

// RemovedRequiredByHostDependencies returns the removed IDs of the "RequiredByHostDependencies" edge to the HostDependency entity.
func (m *HostMutation) RemovedRequiredByHostDependenciesIDs() (ids []uuid.UUID) {
	for id := range m.removed_RequiredByHostDependencies {
		ids = append(ids, id)
	}
	return
}

// RequiredByHostDependenciesIDs returns the "RequiredByHostDependencies" edge IDs in the mutation.
func (m *HostMutation) RequiredByHostDependenciesIDs() (ids []uuid.UUID) {
	for id := range m._RequiredByHostDependencies {
		ids = append(ids, id)
	}
	return
}

// ResetRequiredByHostDependencies resets all changes to the "RequiredByHostDependencies" edge.
func (m *HostMutation) ResetRequiredByHostDependencies() {
	m._RequiredByHostDependencies = nil
	m.cleared_RequiredByHostDependencies = false
	m.removed_RequiredByHostDependencies = nil
}

// Where appends a list predicates to the HostMutation builder.
func (m *HostMutation) Where(ps ...predicate.Host) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *HostMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Host).
func (m *HostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HostMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.hcl_id != nil {
		fields = append(fields, host.FieldHclID)
	}
	if m.hostname != nil {
		fields = append(fields, host.FieldHostname)
	}
	if m.description != nil {
		fields = append(fields, host.FieldDescription)
	}
	if m._OS != nil {
		fields = append(fields, host.FieldOS)
	}
	if m.last_octet != nil {
		fields = append(fields, host.FieldLastOctet)
	}
	if m.instance_size != nil {
		fields = append(fields, host.FieldInstanceSize)
	}
	if m.allow_mac_changes != nil {
		fields = append(fields, host.FieldAllowMACChanges)
	}
	if m.exposed_tcp_ports != nil {
		fields = append(fields, host.FieldExposedTCPPorts)
	}
	if m.exposed_udp_ports != nil {
		fields = append(fields, host.FieldExposedUDPPorts)
	}
	if m.override_password != nil {
		fields = append(fields, host.FieldOverridePassword)
	}
	if m.vars != nil {
		fields = append(fields, host.FieldVars)
	}
	if m.user_groups != nil {
		fields = append(fields, host.FieldUserGroups)
	}
	if m.provision_steps != nil {
		fields = append(fields, host.FieldProvisionSteps)
	}
	if m.scheduled_steps != nil {
		fields = append(fields, host.FieldScheduledSteps)
	}
	if m.tags != nil {
		fields = append(fields, host.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case host.FieldHclID:
		return m.HclID()
	case host.FieldHostname:
		return m.Hostname()
	case host.FieldDescription:
		return m.Description()
	case host.FieldOS:
		return m.OS()
	case host.FieldLastOctet:
		return m.LastOctet()
	case host.FieldInstanceSize:
		return m.InstanceSize()
	case host.FieldAllowMACChanges:
		return m.AllowMACChanges()
	case host.FieldExposedTCPPorts:
		return m.ExposedTCPPorts()
	case host.FieldExposedUDPPorts:
		return m.ExposedUDPPorts()
	case host.FieldOverridePassword:
		return m.OverridePassword()
	case host.FieldVars:
		return m.Vars()
	case host.FieldUserGroups:
		return m.UserGroups()
	case host.FieldProvisionSteps:
		return m.ProvisionSteps()
	case host.FieldScheduledSteps:
		return m.ScheduledSteps()
	case host.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case host.FieldHclID:
		return m.OldHclID(ctx)
	case host.FieldHostname:
		return m.OldHostname(ctx)
	case host.FieldDescription:
		return m.OldDescription(ctx)
	case host.FieldOS:
		return m.OldOS(ctx)
	case host.FieldLastOctet:
		return m.OldLastOctet(ctx)
	case host.FieldInstanceSize:
		return m.OldInstanceSize(ctx)
	case host.FieldAllowMACChanges:
		return m.OldAllowMACChanges(ctx)
	case host.FieldExposedTCPPorts:
		return m.OldExposedTCPPorts(ctx)
	case host.FieldExposedUDPPorts:
		return m.OldExposedUDPPorts(ctx)
	case host.FieldOverridePassword:
		return m.OldOverridePassword(ctx)
	case host.FieldVars:
		return m.OldVars(ctx)
	case host.FieldUserGroups:
		return m.OldUserGroups(ctx)
	case host.FieldProvisionSteps:
		return m.OldProvisionSteps(ctx)
	case host.FieldScheduledSteps:
		return m.OldScheduledSteps(ctx)
	case host.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Host field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case host.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case host.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case host.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case host.FieldOS:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOS(v)
		return nil
	case host.FieldLastOctet:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastOctet(v)
		return nil
	case host.FieldInstanceSize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceSize(v)
		return nil
	case host.FieldAllowMACChanges:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowMACChanges(v)
		return nil
	case host.FieldExposedTCPPorts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExposedTCPPorts(v)
		return nil
	case host.FieldExposedUDPPorts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExposedUDPPorts(v)
		return nil
	case host.FieldOverridePassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverridePassword(v)
		return nil
	case host.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	case host.FieldUserGroups:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserGroups(v)
		return nil
	case host.FieldProvisionSteps:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvisionSteps(v)
		return nil
	case host.FieldScheduledSteps:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduledSteps(v)
		return nil
	case host.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Host field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HostMutation) AddedFields() []string {
	var fields []string
	if m.addlast_octet != nil {
		fields = append(fields, host.FieldLastOctet)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case host.FieldLastOctet:
		return m.AddedLastOctet()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case host.FieldLastOctet:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastOctet(v)
		return nil
	}
	return fmt.Errorf("unknown Host numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(host.FieldProvisionSteps) {
		fields = append(fields, host.FieldProvisionSteps)
	}
	if m.FieldCleared(host.FieldScheduledSteps) {
		fields = append(fields, host.FieldScheduledSteps)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HostMutation) ClearField(name string) error {
	switch name {
	case host.FieldProvisionSteps:
		m.ClearProvisionSteps()
		return nil
	case host.FieldScheduledSteps:
		m.ClearScheduledSteps()
		return nil
	}
	return fmt.Errorf("unknown Host nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HostMutation) ResetField(name string) error {
	switch name {
	case host.FieldHclID:
		m.ResetHclID()
		return nil
	case host.FieldHostname:
		m.ResetHostname()
		return nil
	case host.FieldDescription:
		m.ResetDescription()
		return nil
	case host.FieldOS:
		m.ResetOS()
		return nil
	case host.FieldLastOctet:
		m.ResetLastOctet()
		return nil
	case host.FieldInstanceSize:
		m.ResetInstanceSize()
		return nil
	case host.FieldAllowMACChanges:
		m.ResetAllowMACChanges()
		return nil
	case host.FieldExposedTCPPorts:
		m.ResetExposedTCPPorts()
		return nil
	case host.FieldExposedUDPPorts:
		m.ResetExposedUDPPorts()
		return nil
	case host.FieldOverridePassword:
		m.ResetOverridePassword()
		return nil
	case host.FieldVars:
		m.ResetVars()
		return nil
	case host.FieldUserGroups:
		m.ResetUserGroups()
		return nil
	case host.FieldProvisionSteps:
		m.ResetProvisionSteps()
		return nil
	case host.FieldScheduledSteps:
		m.ResetScheduledSteps()
		return nil
	case host.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Host field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HostMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m._Disk != nil {
		edges = append(edges, host.EdgeDisk)
	}
	if m._Users != nil {
		edges = append(edges, host.EdgeUsers)
	}
	if m._Environment != nil {
		edges = append(edges, host.EdgeEnvironment)
	}
	if m._IncludedNetworks != nil {
		edges = append(edges, host.EdgeIncludedNetworks)
	}
	if m._DependOnHostDependencies != nil {
		edges = append(edges, host.EdgeDependOnHostDependencies)
	}
	if m._RequiredByHostDependencies != nil {
		edges = append(edges, host.EdgeRequiredByHostDependencies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case host.EdgeDisk:
		if id := m._Disk; id != nil {
			return []ent.Value{*id}
		}
	case host.EdgeUsers:
		ids := make([]ent.Value, 0, len(m._Users))
		for id := range m._Users {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeEnvironment:
		if id := m._Environment; id != nil {
			return []ent.Value{*id}
		}
	case host.EdgeIncludedNetworks:
		ids := make([]ent.Value, 0, len(m._IncludedNetworks))
		for id := range m._IncludedNetworks {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeDependOnHostDependencies:
		ids := make([]ent.Value, 0, len(m._DependOnHostDependencies))
		for id := range m._DependOnHostDependencies {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeRequiredByHostDependencies:
		ids := make([]ent.Value, 0, len(m._RequiredByHostDependencies))
		for id := range m._RequiredByHostDependencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removed_Users != nil {
		edges = append(edges, host.EdgeUsers)
	}
	if m.removed_IncludedNetworks != nil {
		edges = append(edges, host.EdgeIncludedNetworks)
	}
	if m.removed_DependOnHostDependencies != nil {
		edges = append(edges, host.EdgeDependOnHostDependencies)
	}
	if m.removed_RequiredByHostDependencies != nil {
		edges = append(edges, host.EdgeRequiredByHostDependencies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case host.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removed_Users))
		for id := range m.removed_Users {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeIncludedNetworks:
		ids := make([]ent.Value, 0, len(m.removed_IncludedNetworks))
		for id := range m.removed_IncludedNetworks {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeDependOnHostDependencies:
		ids := make([]ent.Value, 0, len(m.removed_DependOnHostDependencies))
		for id := range m.removed_DependOnHostDependencies {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeRequiredByHostDependencies:
		ids := make([]ent.Value, 0, len(m.removed_RequiredByHostDependencies))
		for id := range m.removed_RequiredByHostDependencies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleared_Disk {
		edges = append(edges, host.EdgeDisk)
	}
	if m.cleared_Users {
		edges = append(edges, host.EdgeUsers)
	}
	if m.cleared_Environment {
		edges = append(edges, host.EdgeEnvironment)
	}
	if m.cleared_IncludedNetworks {
		edges = append(edges, host.EdgeIncludedNetworks)
	}
	if m.cleared_DependOnHostDependencies {
		edges = append(edges, host.EdgeDependOnHostDependencies)
	}
	if m.cleared_RequiredByHostDependencies {
		edges = append(edges, host.EdgeRequiredByHostDependencies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HostMutation) EdgeCleared(name string) bool {
	switch name {
	case host.EdgeDisk:
		return m.cleared_Disk
	case host.EdgeUsers:
		return m.cleared_Users
	case host.EdgeEnvironment:
		return m.cleared_Environment
	case host.EdgeIncludedNetworks:
		return m.cleared_IncludedNetworks
	case host.EdgeDependOnHostDependencies:
		return m.cleared_DependOnHostDependencies
	case host.EdgeRequiredByHostDependencies:
		return m.cleared_RequiredByHostDependencies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HostMutation) ClearEdge(name string) error {
	switch name {
	case host.EdgeDisk:
		m.ClearDisk()
		return nil
	case host.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Host unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HostMutation) ResetEdge(name string) error {
	switch name {
	case host.EdgeDisk:
		m.ResetDisk()
		return nil
	case host.EdgeUsers:
		m.ResetUsers()
		return nil
	case host.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	case host.EdgeIncludedNetworks:
		m.ResetIncludedNetworks()
		return nil
	case host.EdgeDependOnHostDependencies:
		m.ResetDependOnHostDependencies()
		return nil
	case host.EdgeRequiredByHostDependencies:
		m.ResetRequiredByHostDependencies()
		return nil
	}
	return fmt.Errorf("unknown Host edge %s", name)
}

// HostDependencyMutation represents an operation that mutates the HostDependency nodes in the graph.
type HostDependencyMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	host_id                 *string
	network_id              *string
	clearedFields           map[string]struct{}
	_RequiredBy             *uuid.UUID
	cleared_RequiredBy      bool
	_DependOnHost           *uuid.UUID
	cleared_DependOnHost    bool
	_DependOnNetwork        *uuid.UUID
	cleared_DependOnNetwork bool
	_Environment            *uuid.UUID
	cleared_Environment     bool
	done                    bool
	oldValue                func(context.Context) (*HostDependency, error)
	predicates              []predicate.HostDependency
}

var _ ent.Mutation = (*HostDependencyMutation)(nil)

// hostdependencyOption allows management of the mutation configuration using functional options.
type hostdependencyOption func(*HostDependencyMutation)

// newHostDependencyMutation creates new mutation for the HostDependency entity.
func newHostDependencyMutation(c config, op Op, opts ...hostdependencyOption) *HostDependencyMutation {
	m := &HostDependencyMutation{
		config:        c,
		op:            op,
		typ:           TypeHostDependency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHostDependencyID sets the ID field of the mutation.
func withHostDependencyID(id uuid.UUID) hostdependencyOption {
	return func(m *HostDependencyMutation) {
		var (
			err   error
			once  sync.Once
			value *HostDependency
		)
		m.oldValue = func(ctx context.Context) (*HostDependency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HostDependency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHostDependency sets the old HostDependency of the mutation.
func withHostDependency(node *HostDependency) hostdependencyOption {
	return func(m *HostDependencyMutation) {
		m.oldValue = func(context.Context) (*HostDependency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HostDependencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HostDependencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HostDependency entities.
func (m *HostDependencyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HostDependencyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HostDependencyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HostDependency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHostID sets the "host_id" field.
func (m *HostDependencyMutation) SetHostID(s string) {
	m.host_id = &s
}

// HostID returns the value of the "host_id" field in the mutation.
func (m *HostDependencyMutation) HostID() (r string, exists bool) {
	v := m.host_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHostID returns the old "host_id" field's value of the HostDependency entity.
// If the HostDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostDependencyMutation) OldHostID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostID: %w", err)
	}
	return oldValue.HostID, nil
}

// ResetHostID resets all changes to the "host_id" field.
func (m *HostDependencyMutation) ResetHostID() {
	m.host_id = nil
}

// SetNetworkID sets the "network_id" field.
func (m *HostDependencyMutation) SetNetworkID(s string) {
	m.network_id = &s
}

// NetworkID returns the value of the "network_id" field in the mutation.
func (m *HostDependencyMutation) NetworkID() (r string, exists bool) {
	v := m.network_id
	if v == nil {
		return
	}
	return *v, true
}

// OldNetworkID returns the old "network_id" field's value of the HostDependency entity.
// If the HostDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostDependencyMutation) OldNetworkID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetworkID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetworkID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetworkID: %w", err)
	}
	return oldValue.NetworkID, nil
}

// ResetNetworkID resets all changes to the "network_id" field.
func (m *HostDependencyMutation) ResetNetworkID() {
	m.network_id = nil
}

// SetRequiredByID sets the "RequiredBy" edge to the Host entity by id.
func (m *HostDependencyMutation) SetRequiredByID(id uuid.UUID) {
	m._RequiredBy = &id
}

// ClearRequiredBy clears the "RequiredBy" edge to the Host entity.
func (m *HostDependencyMutation) ClearRequiredBy() {
	m.cleared_RequiredBy = true
}

// RequiredByCleared reports if the "RequiredBy" edge to the Host entity was cleared.
func (m *HostDependencyMutation) RequiredByCleared() bool {
	return m.cleared_RequiredBy
}

// RequiredByID returns the "RequiredBy" edge ID in the mutation.
func (m *HostDependencyMutation) RequiredByID() (id uuid.UUID, exists bool) {
	if m._RequiredBy != nil {
		return *m._RequiredBy, true
	}
	return
}

// RequiredByIDs returns the "RequiredBy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequiredByID instead. It exists only for internal usage by the builders.
func (m *HostDependencyMutation) RequiredByIDs() (ids []uuid.UUID) {
	if id := m._RequiredBy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequiredBy resets all changes to the "RequiredBy" edge.
func (m *HostDependencyMutation) ResetRequiredBy() {
	m._RequiredBy = nil
	m.cleared_RequiredBy = false
}

// SetDependOnHostID sets the "DependOnHost" edge to the Host entity by id.
func (m *HostDependencyMutation) SetDependOnHostID(id uuid.UUID) {
	m._DependOnHost = &id
}

// ClearDependOnHost clears the "DependOnHost" edge to the Host entity.
func (m *HostDependencyMutation) ClearDependOnHost() {
	m.cleared_DependOnHost = true
}

// DependOnHostCleared reports if the "DependOnHost" edge to the Host entity was cleared.
func (m *HostDependencyMutation) DependOnHostCleared() bool {
	return m.cleared_DependOnHost
}

// DependOnHostID returns the "DependOnHost" edge ID in the mutation.
func (m *HostDependencyMutation) DependOnHostID() (id uuid.UUID, exists bool) {
	if m._DependOnHost != nil {
		return *m._DependOnHost, true
	}
	return
}

// DependOnHostIDs returns the "DependOnHost" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DependOnHostID instead. It exists only for internal usage by the builders.
func (m *HostDependencyMutation) DependOnHostIDs() (ids []uuid.UUID) {
	if id := m._DependOnHost; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDependOnHost resets all changes to the "DependOnHost" edge.
func (m *HostDependencyMutation) ResetDependOnHost() {
	m._DependOnHost = nil
	m.cleared_DependOnHost = false
}

// SetDependOnNetworkID sets the "DependOnNetwork" edge to the Network entity by id.
func (m *HostDependencyMutation) SetDependOnNetworkID(id uuid.UUID) {
	m._DependOnNetwork = &id
}

// ClearDependOnNetwork clears the "DependOnNetwork" edge to the Network entity.
func (m *HostDependencyMutation) ClearDependOnNetwork() {
	m.cleared_DependOnNetwork = true
}

// DependOnNetworkCleared reports if the "DependOnNetwork" edge to the Network entity was cleared.
func (m *HostDependencyMutation) DependOnNetworkCleared() bool {
	return m.cleared_DependOnNetwork
}

// DependOnNetworkID returns the "DependOnNetwork" edge ID in the mutation.
func (m *HostDependencyMutation) DependOnNetworkID() (id uuid.UUID, exists bool) {
	if m._DependOnNetwork != nil {
		return *m._DependOnNetwork, true
	}
	return
}

// DependOnNetworkIDs returns the "DependOnNetwork" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DependOnNetworkID instead. It exists only for internal usage by the builders.
func (m *HostDependencyMutation) DependOnNetworkIDs() (ids []uuid.UUID) {
	if id := m._DependOnNetwork; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDependOnNetwork resets all changes to the "DependOnNetwork" edge.
func (m *HostDependencyMutation) ResetDependOnNetwork() {
	m._DependOnNetwork = nil
	m.cleared_DependOnNetwork = false
}

// SetEnvironmentID sets the "Environment" edge to the Environment entity by id.
func (m *HostDependencyMutation) SetEnvironmentID(id uuid.UUID) {
	m._Environment = &id
}

// ClearEnvironment clears the "Environment" edge to the Environment entity.
func (m *HostDependencyMutation) ClearEnvironment() {
	m.cleared_Environment = true
}

// EnvironmentCleared reports if the "Environment" edge to the Environment entity was cleared.
func (m *HostDependencyMutation) EnvironmentCleared() bool {
	return m.cleared_Environment
}

// EnvironmentID returns the "Environment" edge ID in the mutation.
func (m *HostDependencyMutation) EnvironmentID() (id uuid.UUID, exists bool) {
	if m._Environment != nil {
		return *m._Environment, true
	}
	return
}

// EnvironmentIDs returns the "Environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *HostDependencyMutation) EnvironmentIDs() (ids []uuid.UUID) {
	if id := m._Environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "Environment" edge.
func (m *HostDependencyMutation) ResetEnvironment() {
	m._Environment = nil
	m.cleared_Environment = false
}

// Where appends a list predicates to the HostDependencyMutation builder.
func (m *HostDependencyMutation) Where(ps ...predicate.HostDependency) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *HostDependencyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (HostDependency).
func (m *HostDependencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HostDependencyMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.host_id != nil {
		fields = append(fields, hostdependency.FieldHostID)
	}
	if m.network_id != nil {
		fields = append(fields, hostdependency.FieldNetworkID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HostDependencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hostdependency.FieldHostID:
		return m.HostID()
	case hostdependency.FieldNetworkID:
		return m.NetworkID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HostDependencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hostdependency.FieldHostID:
		return m.OldHostID(ctx)
	case hostdependency.FieldNetworkID:
		return m.OldNetworkID(ctx)
	}
	return nil, fmt.Errorf("unknown HostDependency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostDependencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hostdependency.FieldHostID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostID(v)
		return nil
	case hostdependency.FieldNetworkID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetworkID(v)
		return nil
	}
	return fmt.Errorf("unknown HostDependency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HostDependencyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HostDependencyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostDependencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HostDependency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HostDependencyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HostDependencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HostDependencyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HostDependency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HostDependencyMutation) ResetField(name string) error {
	switch name {
	case hostdependency.FieldHostID:
		m.ResetHostID()
		return nil
	case hostdependency.FieldNetworkID:
		m.ResetNetworkID()
		return nil
	}
	return fmt.Errorf("unknown HostDependency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HostDependencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._RequiredBy != nil {
		edges = append(edges, hostdependency.EdgeRequiredBy)
	}
	if m._DependOnHost != nil {
		edges = append(edges, hostdependency.EdgeDependOnHost)
	}
	if m._DependOnNetwork != nil {
		edges = append(edges, hostdependency.EdgeDependOnNetwork)
	}
	if m._Environment != nil {
		edges = append(edges, hostdependency.EdgeEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HostDependencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hostdependency.EdgeRequiredBy:
		if id := m._RequiredBy; id != nil {
			return []ent.Value{*id}
		}
	case hostdependency.EdgeDependOnHost:
		if id := m._DependOnHost; id != nil {
			return []ent.Value{*id}
		}
	case hostdependency.EdgeDependOnNetwork:
		if id := m._DependOnNetwork; id != nil {
			return []ent.Value{*id}
		}
	case hostdependency.EdgeEnvironment:
		if id := m._Environment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HostDependencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HostDependencyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HostDependencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_RequiredBy {
		edges = append(edges, hostdependency.EdgeRequiredBy)
	}
	if m.cleared_DependOnHost {
		edges = append(edges, hostdependency.EdgeDependOnHost)
	}
	if m.cleared_DependOnNetwork {
		edges = append(edges, hostdependency.EdgeDependOnNetwork)
	}
	if m.cleared_Environment {
		edges = append(edges, hostdependency.EdgeEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HostDependencyMutation) EdgeCleared(name string) bool {
	switch name {
	case hostdependency.EdgeRequiredBy:
		return m.cleared_RequiredBy
	case hostdependency.EdgeDependOnHost:
		return m.cleared_DependOnHost
	case hostdependency.EdgeDependOnNetwork:
		return m.cleared_DependOnNetwork
	case hostdependency.EdgeEnvironment:
		return m.cleared_Environment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HostDependencyMutation) ClearEdge(name string) error {
	switch name {
	case hostdependency.EdgeRequiredBy:
		m.ClearRequiredBy()
		return nil
	case hostdependency.EdgeDependOnHost:
		m.ClearDependOnHost()
		return nil
	case hostdependency.EdgeDependOnNetwork:
		m.ClearDependOnNetwork()
		return nil
	case hostdependency.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	}
	return fmt.Errorf("unknown HostDependency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HostDependencyMutation) ResetEdge(name string) error {
	switch name {
	case hostdependency.EdgeRequiredBy:
		m.ResetRequiredBy()
		return nil
	case hostdependency.EdgeDependOnHost:
		m.ResetDependOnHost()
		return nil
	case hostdependency.EdgeDependOnNetwork:
		m.ResetDependOnNetwork()
		return nil
	case hostdependency.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	}
	return fmt.Errorf("unknown HostDependency edge %s", name)
}

// IdentityMutation represents an operation that mutates the Identity nodes in the graph.
type IdentityMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	hcl_id              *string
	first_name          *string
	last_name           *string
	email               *string
	password            *string
	description         *string
	avatar_file         *string
	vars                *map[string]string
	tags                *map[string]string
	clearedFields       map[string]struct{}
	_Environment        *uuid.UUID
	cleared_Environment bool
	done                bool
	oldValue            func(context.Context) (*Identity, error)
	predicates          []predicate.Identity
}

var _ ent.Mutation = (*IdentityMutation)(nil)

// identityOption allows management of the mutation configuration using functional options.
type identityOption func(*IdentityMutation)

// newIdentityMutation creates new mutation for the Identity entity.
func newIdentityMutation(c config, op Op, opts ...identityOption) *IdentityMutation {
	m := &IdentityMutation{
		config:        c,
		op:            op,
		typ:           TypeIdentity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIdentityID sets the ID field of the mutation.
func withIdentityID(id uuid.UUID) identityOption {
	return func(m *IdentityMutation) {
		var (
			err   error
			once  sync.Once
			value *Identity
		)
		m.oldValue = func(ctx context.Context) (*Identity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Identity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIdentity sets the old Identity of the mutation.
func withIdentity(node *Identity) identityOption {
	return func(m *IdentityMutation) {
		m.oldValue = func(context.Context) (*Identity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IdentityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IdentityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Identity entities.
func (m *IdentityMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IdentityMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IdentityMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Identity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHclID sets the "hcl_id" field.
func (m *IdentityMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *IdentityMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *IdentityMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetFirstName sets the "first_name" field.
func (m *IdentityMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *IdentityMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *IdentityMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *IdentityMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *IdentityMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *IdentityMutation) ResetLastName() {
	m.last_name = nil
}

// SetEmail sets the "email" field.
func (m *IdentityMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *IdentityMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *IdentityMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *IdentityMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *IdentityMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *IdentityMutation) ResetPassword() {
	m.password = nil
}

// SetDescription sets the "description" field.
func (m *IdentityMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IdentityMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *IdentityMutation) ResetDescription() {
	m.description = nil
}

// SetAvatarFile sets the "avatar_file" field.
func (m *IdentityMutation) SetAvatarFile(s string) {
	m.avatar_file = &s
}

// AvatarFile returns the value of the "avatar_file" field in the mutation.
func (m *IdentityMutation) AvatarFile() (r string, exists bool) {
	v := m.avatar_file
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarFile returns the old "avatar_file" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldAvatarFile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarFile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarFile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarFile: %w", err)
	}
	return oldValue.AvatarFile, nil
}

// ResetAvatarFile resets all changes to the "avatar_file" field.
func (m *IdentityMutation) ResetAvatarFile() {
	m.avatar_file = nil
}

// SetVars sets the "vars" field.
func (m *IdentityMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *IdentityMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *IdentityMutation) ResetVars() {
	m.vars = nil
}

// SetTags sets the "tags" field.
func (m *IdentityMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *IdentityMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *IdentityMutation) ResetTags() {
	m.tags = nil
}

// SetEnvironmentID sets the "Environment" edge to the Environment entity by id.
func (m *IdentityMutation) SetEnvironmentID(id uuid.UUID) {
	m._Environment = &id
}

// ClearEnvironment clears the "Environment" edge to the Environment entity.
func (m *IdentityMutation) ClearEnvironment() {
	m.cleared_Environment = true
}

// EnvironmentCleared reports if the "Environment" edge to the Environment entity was cleared.
func (m *IdentityMutation) EnvironmentCleared() bool {
	return m.cleared_Environment
}

// EnvironmentID returns the "Environment" edge ID in the mutation.
func (m *IdentityMutation) EnvironmentID() (id uuid.UUID, exists bool) {
	if m._Environment != nil {
		return *m._Environment, true
	}
	return
}

// EnvironmentIDs returns the "Environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *IdentityMutation) EnvironmentIDs() (ids []uuid.UUID) {
	if id := m._Environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "Environment" edge.
func (m *IdentityMutation) ResetEnvironment() {
	m._Environment = nil
	m.cleared_Environment = false
}

// Where appends a list predicates to the IdentityMutation builder.
func (m *IdentityMutation) Where(ps ...predicate.Identity) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *IdentityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Identity).
func (m *IdentityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IdentityMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.hcl_id != nil {
		fields = append(fields, identity.FieldHclID)
	}
	if m.first_name != nil {
		fields = append(fields, identity.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, identity.FieldLastName)
	}
	if m.email != nil {
		fields = append(fields, identity.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, identity.FieldPassword)
	}
	if m.description != nil {
		fields = append(fields, identity.FieldDescription)
	}
	if m.avatar_file != nil {
		fields = append(fields, identity.FieldAvatarFile)
	}
	if m.vars != nil {
		fields = append(fields, identity.FieldVars)
	}
	if m.tags != nil {
		fields = append(fields, identity.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IdentityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case identity.FieldHclID:
		return m.HclID()
	case identity.FieldFirstName:
		return m.FirstName()
	case identity.FieldLastName:
		return m.LastName()
	case identity.FieldEmail:
		return m.Email()
	case identity.FieldPassword:
		return m.Password()
	case identity.FieldDescription:
		return m.Description()
	case identity.FieldAvatarFile:
		return m.AvatarFile()
	case identity.FieldVars:
		return m.Vars()
	case identity.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IdentityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case identity.FieldHclID:
		return m.OldHclID(ctx)
	case identity.FieldFirstName:
		return m.OldFirstName(ctx)
	case identity.FieldLastName:
		return m.OldLastName(ctx)
	case identity.FieldEmail:
		return m.OldEmail(ctx)
	case identity.FieldPassword:
		return m.OldPassword(ctx)
	case identity.FieldDescription:
		return m.OldDescription(ctx)
	case identity.FieldAvatarFile:
		return m.OldAvatarFile(ctx)
	case identity.FieldVars:
		return m.OldVars(ctx)
	case identity.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Identity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdentityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case identity.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case identity.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case identity.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case identity.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case identity.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case identity.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case identity.FieldAvatarFile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarFile(v)
		return nil
	case identity.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	case identity.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Identity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IdentityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IdentityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdentityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Identity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IdentityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IdentityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IdentityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Identity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IdentityMutation) ResetField(name string) error {
	switch name {
	case identity.FieldHclID:
		m.ResetHclID()
		return nil
	case identity.FieldFirstName:
		m.ResetFirstName()
		return nil
	case identity.FieldLastName:
		m.ResetLastName()
		return nil
	case identity.FieldEmail:
		m.ResetEmail()
		return nil
	case identity.FieldPassword:
		m.ResetPassword()
		return nil
	case identity.FieldDescription:
		m.ResetDescription()
		return nil
	case identity.FieldAvatarFile:
		m.ResetAvatarFile()
		return nil
	case identity.FieldVars:
		m.ResetVars()
		return nil
	case identity.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Identity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IdentityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Environment != nil {
		edges = append(edges, identity.EdgeEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IdentityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case identity.EdgeEnvironment:
		if id := m._Environment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IdentityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IdentityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IdentityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Environment {
		edges = append(edges, identity.EdgeEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IdentityMutation) EdgeCleared(name string) bool {
	switch name {
	case identity.EdgeEnvironment:
		return m.cleared_Environment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IdentityMutation) ClearEdge(name string) error {
	switch name {
	case identity.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Identity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IdentityMutation) ResetEdge(name string) error {
	switch name {
	case identity.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Identity edge %s", name)
}

// IncludedNetworkMutation represents an operation that mutates the IncludedNetwork nodes in the graph.
type IncludedNetworkMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	name                 *string
	included_hosts       *[]string
	clearedFields        map[string]struct{}
	_Tags                map[uuid.UUID]struct{}
	removed_Tags         map[uuid.UUID]struct{}
	cleared_Tags         bool
	_Hosts               map[uuid.UUID]struct{}
	removed_Hosts        map[uuid.UUID]struct{}
	cleared_Hosts        bool
	_Network             *uuid.UUID
	cleared_Network      bool
	_Environments        map[uuid.UUID]struct{}
	removed_Environments map[uuid.UUID]struct{}
	cleared_Environments bool
	done                 bool
	oldValue             func(context.Context) (*IncludedNetwork, error)
	predicates           []predicate.IncludedNetwork
}

var _ ent.Mutation = (*IncludedNetworkMutation)(nil)

// includednetworkOption allows management of the mutation configuration using functional options.
type includednetworkOption func(*IncludedNetworkMutation)

// newIncludedNetworkMutation creates new mutation for the IncludedNetwork entity.
func newIncludedNetworkMutation(c config, op Op, opts ...includednetworkOption) *IncludedNetworkMutation {
	m := &IncludedNetworkMutation{
		config:        c,
		op:            op,
		typ:           TypeIncludedNetwork,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncludedNetworkID sets the ID field of the mutation.
func withIncludedNetworkID(id uuid.UUID) includednetworkOption {
	return func(m *IncludedNetworkMutation) {
		var (
			err   error
			once  sync.Once
			value *IncludedNetwork
		)
		m.oldValue = func(ctx context.Context) (*IncludedNetwork, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncludedNetwork.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncludedNetwork sets the old IncludedNetwork of the mutation.
func withIncludedNetwork(node *IncludedNetwork) includednetworkOption {
	return func(m *IncludedNetworkMutation) {
		m.oldValue = func(context.Context) (*IncludedNetwork, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncludedNetworkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncludedNetworkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncludedNetwork entities.
func (m *IncludedNetworkMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncludedNetworkMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncludedNetworkMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncludedNetwork.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *IncludedNetworkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IncludedNetworkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the IncludedNetwork entity.
// If the IncludedNetwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncludedNetworkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IncludedNetworkMutation) ResetName() {
	m.name = nil
}

// SetIncludedHosts sets the "included_hosts" field.
func (m *IncludedNetworkMutation) SetIncludedHosts(s []string) {
	m.included_hosts = &s
}

// IncludedHosts returns the value of the "included_hosts" field in the mutation.
func (m *IncludedNetworkMutation) IncludedHosts() (r []string, exists bool) {
	v := m.included_hosts
	if v == nil {
		return
	}
	return *v, true
}

// OldIncludedHosts returns the old "included_hosts" field's value of the IncludedNetwork entity.
// If the IncludedNetwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncludedNetworkMutation) OldIncludedHosts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncludedHosts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncludedHosts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncludedHosts: %w", err)
	}
	return oldValue.IncludedHosts, nil
}

// ResetIncludedHosts resets all changes to the "included_hosts" field.
func (m *IncludedNetworkMutation) ResetIncludedHosts() {
	m.included_hosts = nil
}

// AddTagIDs adds the "Tags" edge to the Tag entity by ids.
func (m *IncludedNetworkMutation) AddTagIDs(ids ...uuid.UUID) {
	if m._Tags == nil {
		m._Tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "Tags" edge to the Tag entity.
func (m *IncludedNetworkMutation) ClearTags() {
	m.cleared_Tags = true
}

// TagsCleared reports if the "Tags" edge to the Tag entity was cleared.
func (m *IncludedNetworkMutation) TagsCleared() bool {
	return m.cleared_Tags
}

// RemoveTagIDs removes the "Tags" edge to the Tag entity by IDs.
func (m *IncludedNetworkMutation) RemoveTagIDs(ids ...uuid.UUID) {
	if m.removed_Tags == nil {
		m.removed_Tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Tags, ids[i])
		m.removed_Tags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "Tags" edge to the Tag entity.
func (m *IncludedNetworkMutation) RemovedTagsIDs() (ids []uuid.UUID) {
	for id := range m.removed_Tags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "Tags" edge IDs in the mutation.
func (m *IncludedNetworkMutation) TagsIDs() (ids []uuid.UUID) {
	for id := range m._Tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "Tags" edge.
func (m *IncludedNetworkMutation) ResetTags() {
	m._Tags = nil
	m.cleared_Tags = false
	m.removed_Tags = nil
}

// AddHostIDs adds the "Hosts" edge to the Host entity by ids.
func (m *IncludedNetworkMutation) AddHostIDs(ids ...uuid.UUID) {
	if m._Hosts == nil {
		m._Hosts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Hosts[ids[i]] = struct{}{}
	}
}

// ClearHosts clears the "Hosts" edge to the Host entity.
func (m *IncludedNetworkMutation) ClearHosts() {
	m.cleared_Hosts = true
}

// HostsCleared reports if the "Hosts" edge to the Host entity was cleared.
func (m *IncludedNetworkMutation) HostsCleared() bool {
	return m.cleared_Hosts
}

// RemoveHostIDs removes the "Hosts" edge to the Host entity by IDs.
func (m *IncludedNetworkMutation) RemoveHostIDs(ids ...uuid.UUID) {
	if m.removed_Hosts == nil {
		m.removed_Hosts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Hosts, ids[i])
		m.removed_Hosts[ids[i]] = struct{}{}
	}
}

// RemovedHosts returns the removed IDs of the "Hosts" edge to the Host entity.
func (m *IncludedNetworkMutation) RemovedHostsIDs() (ids []uuid.UUID) {
	for id := range m.removed_Hosts {
		ids = append(ids, id)
	}
	return
}

// HostsIDs returns the "Hosts" edge IDs in the mutation.
func (m *IncludedNetworkMutation) HostsIDs() (ids []uuid.UUID) {
	for id := range m._Hosts {
		ids = append(ids, id)
	}
	return
}

// ResetHosts resets all changes to the "Hosts" edge.
func (m *IncludedNetworkMutation) ResetHosts() {
	m._Hosts = nil
	m.cleared_Hosts = false
	m.removed_Hosts = nil
}

// SetNetworkID sets the "Network" edge to the Network entity by id.
func (m *IncludedNetworkMutation) SetNetworkID(id uuid.UUID) {
	m._Network = &id
}

// ClearNetwork clears the "Network" edge to the Network entity.
func (m *IncludedNetworkMutation) ClearNetwork() {
	m.cleared_Network = true
}

// NetworkCleared reports if the "Network" edge to the Network entity was cleared.
func (m *IncludedNetworkMutation) NetworkCleared() bool {
	return m.cleared_Network
}

// NetworkID returns the "Network" edge ID in the mutation.
func (m *IncludedNetworkMutation) NetworkID() (id uuid.UUID, exists bool) {
	if m._Network != nil {
		return *m._Network, true
	}
	return
}

// NetworkIDs returns the "Network" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NetworkID instead. It exists only for internal usage by the builders.
func (m *IncludedNetworkMutation) NetworkIDs() (ids []uuid.UUID) {
	if id := m._Network; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNetwork resets all changes to the "Network" edge.
func (m *IncludedNetworkMutation) ResetNetwork() {
	m._Network = nil
	m.cleared_Network = false
}

// AddEnvironmentIDs adds the "Environments" edge to the Environment entity by ids.
func (m *IncludedNetworkMutation) AddEnvironmentIDs(ids ...uuid.UUID) {
	if m._Environments == nil {
		m._Environments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Environments[ids[i]] = struct{}{}
	}
}

// ClearEnvironments clears the "Environments" edge to the Environment entity.
func (m *IncludedNetworkMutation) ClearEnvironments() {
	m.cleared_Environments = true
}

// EnvironmentsCleared reports if the "Environments" edge to the Environment entity was cleared.
func (m *IncludedNetworkMutation) EnvironmentsCleared() bool {
	return m.cleared_Environments
}

// RemoveEnvironmentIDs removes the "Environments" edge to the Environment entity by IDs.
func (m *IncludedNetworkMutation) RemoveEnvironmentIDs(ids ...uuid.UUID) {
	if m.removed_Environments == nil {
		m.removed_Environments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Environments, ids[i])
		m.removed_Environments[ids[i]] = struct{}{}
	}
}

// RemovedEnvironments returns the removed IDs of the "Environments" edge to the Environment entity.
func (m *IncludedNetworkMutation) RemovedEnvironmentsIDs() (ids []uuid.UUID) {
	for id := range m.removed_Environments {
		ids = append(ids, id)
	}
	return
}

// EnvironmentsIDs returns the "Environments" edge IDs in the mutation.
func (m *IncludedNetworkMutation) EnvironmentsIDs() (ids []uuid.UUID) {
	for id := range m._Environments {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironments resets all changes to the "Environments" edge.
func (m *IncludedNetworkMutation) ResetEnvironments() {
	m._Environments = nil
	m.cleared_Environments = false
	m.removed_Environments = nil
}

// Where appends a list predicates to the IncludedNetworkMutation builder.
func (m *IncludedNetworkMutation) Where(ps ...predicate.IncludedNetwork) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *IncludedNetworkMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (IncludedNetwork).
func (m *IncludedNetworkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncludedNetworkMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, includednetwork.FieldName)
	}
	if m.included_hosts != nil {
		fields = append(fields, includednetwork.FieldIncludedHosts)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncludedNetworkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case includednetwork.FieldName:
		return m.Name()
	case includednetwork.FieldIncludedHosts:
		return m.IncludedHosts()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncludedNetworkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case includednetwork.FieldName:
		return m.OldName(ctx)
	case includednetwork.FieldIncludedHosts:
		return m.OldIncludedHosts(ctx)
	}
	return nil, fmt.Errorf("unknown IncludedNetwork field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncludedNetworkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case includednetwork.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case includednetwork.FieldIncludedHosts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncludedHosts(v)
		return nil
	}
	return fmt.Errorf("unknown IncludedNetwork field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncludedNetworkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncludedNetworkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncludedNetworkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncludedNetwork numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncludedNetworkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncludedNetworkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncludedNetworkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IncludedNetwork nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncludedNetworkMutation) ResetField(name string) error {
	switch name {
	case includednetwork.FieldName:
		m.ResetName()
		return nil
	case includednetwork.FieldIncludedHosts:
		m.ResetIncludedHosts()
		return nil
	}
	return fmt.Errorf("unknown IncludedNetwork field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncludedNetworkMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._Tags != nil {
		edges = append(edges, includednetwork.EdgeTags)
	}
	if m._Hosts != nil {
		edges = append(edges, includednetwork.EdgeHosts)
	}
	if m._Network != nil {
		edges = append(edges, includednetwork.EdgeNetwork)
	}
	if m._Environments != nil {
		edges = append(edges, includednetwork.EdgeEnvironments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncludedNetworkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case includednetwork.EdgeTags:
		ids := make([]ent.Value, 0, len(m._Tags))
		for id := range m._Tags {
			ids = append(ids, id)
		}
		return ids
	case includednetwork.EdgeHosts:
		ids := make([]ent.Value, 0, len(m._Hosts))
		for id := range m._Hosts {
			ids = append(ids, id)
		}
		return ids
	case includednetwork.EdgeNetwork:
		if id := m._Network; id != nil {
			return []ent.Value{*id}
		}
	case includednetwork.EdgeEnvironments:
		ids := make([]ent.Value, 0, len(m._Environments))
		for id := range m._Environments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncludedNetworkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removed_Tags != nil {
		edges = append(edges, includednetwork.EdgeTags)
	}
	if m.removed_Hosts != nil {
		edges = append(edges, includednetwork.EdgeHosts)
	}
	if m.removed_Environments != nil {
		edges = append(edges, includednetwork.EdgeEnvironments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncludedNetworkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case includednetwork.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removed_Tags))
		for id := range m.removed_Tags {
			ids = append(ids, id)
		}
		return ids
	case includednetwork.EdgeHosts:
		ids := make([]ent.Value, 0, len(m.removed_Hosts))
		for id := range m.removed_Hosts {
			ids = append(ids, id)
		}
		return ids
	case includednetwork.EdgeEnvironments:
		ids := make([]ent.Value, 0, len(m.removed_Environments))
		for id := range m.removed_Environments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncludedNetworkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_Tags {
		edges = append(edges, includednetwork.EdgeTags)
	}
	if m.cleared_Hosts {
		edges = append(edges, includednetwork.EdgeHosts)
	}
	if m.cleared_Network {
		edges = append(edges, includednetwork.EdgeNetwork)
	}
	if m.cleared_Environments {
		edges = append(edges, includednetwork.EdgeEnvironments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncludedNetworkMutation) EdgeCleared(name string) bool {
	switch name {
	case includednetwork.EdgeTags:
		return m.cleared_Tags
	case includednetwork.EdgeHosts:
		return m.cleared_Hosts
	case includednetwork.EdgeNetwork:
		return m.cleared_Network
	case includednetwork.EdgeEnvironments:
		return m.cleared_Environments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncludedNetworkMutation) ClearEdge(name string) error {
	switch name {
	case includednetwork.EdgeNetwork:
		m.ClearNetwork()
		return nil
	}
	return fmt.Errorf("unknown IncludedNetwork unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncludedNetworkMutation) ResetEdge(name string) error {
	switch name {
	case includednetwork.EdgeTags:
		m.ResetTags()
		return nil
	case includednetwork.EdgeHosts:
		m.ResetHosts()
		return nil
	case includednetwork.EdgeNetwork:
		m.ResetNetwork()
		return nil
	case includednetwork.EdgeEnvironments:
		m.ResetEnvironments()
		return nil
	}
	return fmt.Errorf("unknown IncludedNetwork edge %s", name)
}

// NetworkMutation represents an operation that mutates the Network nodes in the graph.
type NetworkMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	hcl_id                   *string
	name                     *string
	cidr                     *string
	vdi_visible              *bool
	vars                     *map[string]string
	tags                     *map[string]string
	clearedFields            map[string]struct{}
	_Environment             *uuid.UUID
	cleared_Environment      bool
	_HostDependencies        map[uuid.UUID]struct{}
	removed_HostDependencies map[uuid.UUID]struct{}
	cleared_HostDependencies bool
	_IncludedNetworks        map[uuid.UUID]struct{}
	removed_IncludedNetworks map[uuid.UUID]struct{}
	cleared_IncludedNetworks bool
	done                     bool
	oldValue                 func(context.Context) (*Network, error)
	predicates               []predicate.Network
}

var _ ent.Mutation = (*NetworkMutation)(nil)

// networkOption allows management of the mutation configuration using functional options.
type networkOption func(*NetworkMutation)

// newNetworkMutation creates new mutation for the Network entity.
func newNetworkMutation(c config, op Op, opts ...networkOption) *NetworkMutation {
	m := &NetworkMutation{
		config:        c,
		op:            op,
		typ:           TypeNetwork,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetworkID sets the ID field of the mutation.
func withNetworkID(id uuid.UUID) networkOption {
	return func(m *NetworkMutation) {
		var (
			err   error
			once  sync.Once
			value *Network
		)
		m.oldValue = func(ctx context.Context) (*Network, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Network.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetwork sets the old Network of the mutation.
func withNetwork(node *Network) networkOption {
	return func(m *NetworkMutation) {
		m.oldValue = func(context.Context) (*Network, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetworkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetworkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Network entities.
func (m *NetworkMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NetworkMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NetworkMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Network.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHclID sets the "hcl_id" field.
func (m *NetworkMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *NetworkMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *NetworkMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetName sets the "name" field.
func (m *NetworkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NetworkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NetworkMutation) ResetName() {
	m.name = nil
}

// SetCidr sets the "cidr" field.
func (m *NetworkMutation) SetCidr(s string) {
	m.cidr = &s
}

// Cidr returns the value of the "cidr" field in the mutation.
func (m *NetworkMutation) Cidr() (r string, exists bool) {
	v := m.cidr
	if v == nil {
		return
	}
	return *v, true
}

// OldCidr returns the old "cidr" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldCidr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCidr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCidr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCidr: %w", err)
	}
	return oldValue.Cidr, nil
}

// ResetCidr resets all changes to the "cidr" field.
func (m *NetworkMutation) ResetCidr() {
	m.cidr = nil
}

// SetVdiVisible sets the "vdi_visible" field.
func (m *NetworkMutation) SetVdiVisible(b bool) {
	m.vdi_visible = &b
}

// VdiVisible returns the value of the "vdi_visible" field in the mutation.
func (m *NetworkMutation) VdiVisible() (r bool, exists bool) {
	v := m.vdi_visible
	if v == nil {
		return
	}
	return *v, true
}

// OldVdiVisible returns the old "vdi_visible" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldVdiVisible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVdiVisible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVdiVisible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVdiVisible: %w", err)
	}
	return oldValue.VdiVisible, nil
}

// ResetVdiVisible resets all changes to the "vdi_visible" field.
func (m *NetworkMutation) ResetVdiVisible() {
	m.vdi_visible = nil
}

// SetVars sets the "vars" field.
func (m *NetworkMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *NetworkMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *NetworkMutation) ResetVars() {
	m.vars = nil
}

// SetTags sets the "tags" field.
func (m *NetworkMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *NetworkMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *NetworkMutation) ResetTags() {
	m.tags = nil
}

// SetEnvironmentID sets the "Environment" edge to the Environment entity by id.
func (m *NetworkMutation) SetEnvironmentID(id uuid.UUID) {
	m._Environment = &id
}

// ClearEnvironment clears the "Environment" edge to the Environment entity.
func (m *NetworkMutation) ClearEnvironment() {
	m.cleared_Environment = true
}

// EnvironmentCleared reports if the "Environment" edge to the Environment entity was cleared.
func (m *NetworkMutation) EnvironmentCleared() bool {
	return m.cleared_Environment
}

// EnvironmentID returns the "Environment" edge ID in the mutation.
func (m *NetworkMutation) EnvironmentID() (id uuid.UUID, exists bool) {
	if m._Environment != nil {
		return *m._Environment, true
	}
	return
}

// EnvironmentIDs returns the "Environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *NetworkMutation) EnvironmentIDs() (ids []uuid.UUID) {
	if id := m._Environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "Environment" edge.
func (m *NetworkMutation) ResetEnvironment() {
	m._Environment = nil
	m.cleared_Environment = false
}

// AddHostDependencyIDs adds the "HostDependencies" edge to the HostDependency entity by ids.
func (m *NetworkMutation) AddHostDependencyIDs(ids ...uuid.UUID) {
	if m._HostDependencies == nil {
		m._HostDependencies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._HostDependencies[ids[i]] = struct{}{}
	}
}

// ClearHostDependencies clears the "HostDependencies" edge to the HostDependency entity.
func (m *NetworkMutation) ClearHostDependencies() {
	m.cleared_HostDependencies = true
}

// HostDependenciesCleared reports if the "HostDependencies" edge to the HostDependency entity was cleared.
func (m *NetworkMutation) HostDependenciesCleared() bool {
	return m.cleared_HostDependencies
}

// RemoveHostDependencyIDs removes the "HostDependencies" edge to the HostDependency entity by IDs.
func (m *NetworkMutation) RemoveHostDependencyIDs(ids ...uuid.UUID) {
	if m.removed_HostDependencies == nil {
		m.removed_HostDependencies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._HostDependencies, ids[i])
		m.removed_HostDependencies[ids[i]] = struct{}{}
	}
}

// RemovedHostDependencies returns the removed IDs of the "HostDependencies" edge to the HostDependency entity.
func (m *NetworkMutation) RemovedHostDependenciesIDs() (ids []uuid.UUID) {
	for id := range m.removed_HostDependencies {
		ids = append(ids, id)
	}
	return
}

// HostDependenciesIDs returns the "HostDependencies" edge IDs in the mutation.
func (m *NetworkMutation) HostDependenciesIDs() (ids []uuid.UUID) {
	for id := range m._HostDependencies {
		ids = append(ids, id)
	}
	return
}

// ResetHostDependencies resets all changes to the "HostDependencies" edge.
func (m *NetworkMutation) ResetHostDependencies() {
	m._HostDependencies = nil
	m.cleared_HostDependencies = false
	m.removed_HostDependencies = nil
}

// AddIncludedNetworkIDs adds the "IncludedNetworks" edge to the IncludedNetwork entity by ids.
func (m *NetworkMutation) AddIncludedNetworkIDs(ids ...uuid.UUID) {
	if m._IncludedNetworks == nil {
		m._IncludedNetworks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._IncludedNetworks[ids[i]] = struct{}{}
	}
}

// ClearIncludedNetworks clears the "IncludedNetworks" edge to the IncludedNetwork entity.
func (m *NetworkMutation) ClearIncludedNetworks() {
	m.cleared_IncludedNetworks = true
}

// IncludedNetworksCleared reports if the "IncludedNetworks" edge to the IncludedNetwork entity was cleared.
func (m *NetworkMutation) IncludedNetworksCleared() bool {
	return m.cleared_IncludedNetworks
}

// RemoveIncludedNetworkIDs removes the "IncludedNetworks" edge to the IncludedNetwork entity by IDs.
func (m *NetworkMutation) RemoveIncludedNetworkIDs(ids ...uuid.UUID) {
	if m.removed_IncludedNetworks == nil {
		m.removed_IncludedNetworks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._IncludedNetworks, ids[i])
		m.removed_IncludedNetworks[ids[i]] = struct{}{}
	}
}

// RemovedIncludedNetworks returns the removed IDs of the "IncludedNetworks" edge to the IncludedNetwork entity.
func (m *NetworkMutation) RemovedIncludedNetworksIDs() (ids []uuid.UUID) {
	for id := range m.removed_IncludedNetworks {
		ids = append(ids, id)
	}
	return
}

// IncludedNetworksIDs returns the "IncludedNetworks" edge IDs in the mutation.
func (m *NetworkMutation) IncludedNetworksIDs() (ids []uuid.UUID) {
	for id := range m._IncludedNetworks {
		ids = append(ids, id)
	}
	return
}

// ResetIncludedNetworks resets all changes to the "IncludedNetworks" edge.
func (m *NetworkMutation) ResetIncludedNetworks() {
	m._IncludedNetworks = nil
	m.cleared_IncludedNetworks = false
	m.removed_IncludedNetworks = nil
}

// Where appends a list predicates to the NetworkMutation builder.
func (m *NetworkMutation) Where(ps ...predicate.Network) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NetworkMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Network).
func (m *NetworkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetworkMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.hcl_id != nil {
		fields = append(fields, network.FieldHclID)
	}
	if m.name != nil {
		fields = append(fields, network.FieldName)
	}
	if m.cidr != nil {
		fields = append(fields, network.FieldCidr)
	}
	if m.vdi_visible != nil {
		fields = append(fields, network.FieldVdiVisible)
	}
	if m.vars != nil {
		fields = append(fields, network.FieldVars)
	}
	if m.tags != nil {
		fields = append(fields, network.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetworkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case network.FieldHclID:
		return m.HclID()
	case network.FieldName:
		return m.Name()
	case network.FieldCidr:
		return m.Cidr()
	case network.FieldVdiVisible:
		return m.VdiVisible()
	case network.FieldVars:
		return m.Vars()
	case network.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetworkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case network.FieldHclID:
		return m.OldHclID(ctx)
	case network.FieldName:
		return m.OldName(ctx)
	case network.FieldCidr:
		return m.OldCidr(ctx)
	case network.FieldVdiVisible:
		return m.OldVdiVisible(ctx)
	case network.FieldVars:
		return m.OldVars(ctx)
	case network.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Network field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case network.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case network.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case network.FieldCidr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCidr(v)
		return nil
	case network.FieldVdiVisible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVdiVisible(v)
		return nil
	case network.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	case network.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Network field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetworkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetworkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Network numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetworkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetworkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetworkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Network nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetworkMutation) ResetField(name string) error {
	switch name {
	case network.FieldHclID:
		m.ResetHclID()
		return nil
	case network.FieldName:
		m.ResetName()
		return nil
	case network.FieldCidr:
		m.ResetCidr()
		return nil
	case network.FieldVdiVisible:
		m.ResetVdiVisible()
		return nil
	case network.FieldVars:
		m.ResetVars()
		return nil
	case network.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Network field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetworkMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Environment != nil {
		edges = append(edges, network.EdgeEnvironment)
	}
	if m._HostDependencies != nil {
		edges = append(edges, network.EdgeHostDependencies)
	}
	if m._IncludedNetworks != nil {
		edges = append(edges, network.EdgeIncludedNetworks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetworkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case network.EdgeEnvironment:
		if id := m._Environment; id != nil {
			return []ent.Value{*id}
		}
	case network.EdgeHostDependencies:
		ids := make([]ent.Value, 0, len(m._HostDependencies))
		for id := range m._HostDependencies {
			ids = append(ids, id)
		}
		return ids
	case network.EdgeIncludedNetworks:
		ids := make([]ent.Value, 0, len(m._IncludedNetworks))
		for id := range m._IncludedNetworks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetworkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_HostDependencies != nil {
		edges = append(edges, network.EdgeHostDependencies)
	}
	if m.removed_IncludedNetworks != nil {
		edges = append(edges, network.EdgeIncludedNetworks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetworkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case network.EdgeHostDependencies:
		ids := make([]ent.Value, 0, len(m.removed_HostDependencies))
		for id := range m.removed_HostDependencies {
			ids = append(ids, id)
		}
		return ids
	case network.EdgeIncludedNetworks:
		ids := make([]ent.Value, 0, len(m.removed_IncludedNetworks))
		for id := range m.removed_IncludedNetworks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetworkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Environment {
		edges = append(edges, network.EdgeEnvironment)
	}
	if m.cleared_HostDependencies {
		edges = append(edges, network.EdgeHostDependencies)
	}
	if m.cleared_IncludedNetworks {
		edges = append(edges, network.EdgeIncludedNetworks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetworkMutation) EdgeCleared(name string) bool {
	switch name {
	case network.EdgeEnvironment:
		return m.cleared_Environment
	case network.EdgeHostDependencies:
		return m.cleared_HostDependencies
	case network.EdgeIncludedNetworks:
		return m.cleared_IncludedNetworks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetworkMutation) ClearEdge(name string) error {
	switch name {
	case network.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Network unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetworkMutation) ResetEdge(name string) error {
	switch name {
	case network.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	case network.EdgeHostDependencies:
		m.ResetHostDependencies()
		return nil
	case network.EdgeIncludedNetworks:
		m.ResetIncludedNetworks()
		return nil
	}
	return fmt.Errorf("unknown Network edge %s", name)
}

// PlanMutation represents an operation that mutates the Plan nodes in the graph.
type PlanMutation struct {
	config
	op                                Op
	typ                               string
	id                                *uuid.UUID
	step_number                       *int
	addstep_number                    *int
	_type                             *plan.Type
	clearedFields                     map[string]struct{}
	_PrevPlans                        map[uuid.UUID]struct{}
	removed_PrevPlans                 map[uuid.UUID]struct{}
	cleared_PrevPlans                 bool
	_NextPlans                        map[uuid.UUID]struct{}
	removed_NextPlans                 map[uuid.UUID]struct{}
	cleared_NextPlans                 bool
	_Build                            *uuid.UUID
	cleared_Build                     bool
	_Team                             *uuid.UUID
	cleared_Team                      bool
	_ProvisionedNetwork               *uuid.UUID
	cleared_ProvisionedNetwork        bool
	_ProvisionedHost                  *uuid.UUID
	cleared_ProvisionedHost           bool
	_ProvisioningStep                 *uuid.UUID
	cleared_ProvisioningStep          bool
	_ProvisioningScheduledStep        *uuid.UUID
	cleared_ProvisioningScheduledStep bool
	_Status                           *uuid.UUID
	cleared_Status                    bool
	_PlanDiffs                        map[uuid.UUID]struct{}
	removed_PlanDiffs                 map[uuid.UUID]struct{}
	cleared_PlanDiffs                 bool
	done                              bool
	oldValue                          func(context.Context) (*Plan, error)
	predicates                        []predicate.Plan
}

var _ ent.Mutation = (*PlanMutation)(nil)

// planOption allows management of the mutation configuration using functional options.
type planOption func(*PlanMutation)

// newPlanMutation creates new mutation for the Plan entity.
func newPlanMutation(c config, op Op, opts ...planOption) *PlanMutation {
	m := &PlanMutation{
		config:        c,
		op:            op,
		typ:           TypePlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlanID sets the ID field of the mutation.
func withPlanID(id uuid.UUID) planOption {
	return func(m *PlanMutation) {
		var (
			err   error
			once  sync.Once
			value *Plan
		)
		m.oldValue = func(ctx context.Context) (*Plan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Plan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlan sets the old Plan of the mutation.
func withPlan(node *Plan) planOption {
	return func(m *PlanMutation) {
		m.oldValue = func(context.Context) (*Plan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Plan entities.
func (m *PlanMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlanMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlanMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Plan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStepNumber sets the "step_number" field.
func (m *PlanMutation) SetStepNumber(i int) {
	m.step_number = &i
	m.addstep_number = nil
}

// StepNumber returns the value of the "step_number" field in the mutation.
func (m *PlanMutation) StepNumber() (r int, exists bool) {
	v := m.step_number
	if v == nil {
		return
	}
	return *v, true
}

// OldStepNumber returns the old "step_number" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldStepNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepNumber: %w", err)
	}
	return oldValue.StepNumber, nil
}

// AddStepNumber adds i to the "step_number" field.
func (m *PlanMutation) AddStepNumber(i int) {
	if m.addstep_number != nil {
		*m.addstep_number += i
	} else {
		m.addstep_number = &i
	}
}

// AddedStepNumber returns the value that was added to the "step_number" field in this mutation.
func (m *PlanMutation) AddedStepNumber() (r int, exists bool) {
	v := m.addstep_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetStepNumber resets all changes to the "step_number" field.
func (m *PlanMutation) ResetStepNumber() {
	m.step_number = nil
	m.addstep_number = nil
}

// SetType sets the "type" field.
func (m *PlanMutation) SetType(pl plan.Type) {
	m._type = &pl
}

// GetType returns the value of the "type" field in the mutation.
func (m *PlanMutation) GetType() (r plan.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldType(ctx context.Context) (v plan.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PlanMutation) ResetType() {
	m._type = nil
}

// AddPrevPlanIDs adds the "PrevPlans" edge to the Plan entity by ids.
func (m *PlanMutation) AddPrevPlanIDs(ids ...uuid.UUID) {
	if m._PrevPlans == nil {
		m._PrevPlans = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._PrevPlans[ids[i]] = struct{}{}
	}
}

// ClearPrevPlans clears the "PrevPlans" edge to the Plan entity.
func (m *PlanMutation) ClearPrevPlans() {
	m.cleared_PrevPlans = true
}

// PrevPlansCleared reports if the "PrevPlans" edge to the Plan entity was cleared.
func (m *PlanMutation) PrevPlansCleared() bool {
	return m.cleared_PrevPlans
}

// RemovePrevPlanIDs removes the "PrevPlans" edge to the Plan entity by IDs.
func (m *PlanMutation) RemovePrevPlanIDs(ids ...uuid.UUID) {
	if m.removed_PrevPlans == nil {
		m.removed_PrevPlans = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._PrevPlans, ids[i])
		m.removed_PrevPlans[ids[i]] = struct{}{}
	}
}

// RemovedPrevPlans returns the removed IDs of the "PrevPlans" edge to the Plan entity.
func (m *PlanMutation) RemovedPrevPlansIDs() (ids []uuid.UUID) {
	for id := range m.removed_PrevPlans {
		ids = append(ids, id)
	}
	return
}

// PrevPlansIDs returns the "PrevPlans" edge IDs in the mutation.
func (m *PlanMutation) PrevPlansIDs() (ids []uuid.UUID) {
	for id := range m._PrevPlans {
		ids = append(ids, id)
	}
	return
}

// ResetPrevPlans resets all changes to the "PrevPlans" edge.
func (m *PlanMutation) ResetPrevPlans() {
	m._PrevPlans = nil
	m.cleared_PrevPlans = false
	m.removed_PrevPlans = nil
}

// AddNextPlanIDs adds the "NextPlans" edge to the Plan entity by ids.
func (m *PlanMutation) AddNextPlanIDs(ids ...uuid.UUID) {
	if m._NextPlans == nil {
		m._NextPlans = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._NextPlans[ids[i]] = struct{}{}
	}
}

// ClearNextPlans clears the "NextPlans" edge to the Plan entity.
func (m *PlanMutation) ClearNextPlans() {
	m.cleared_NextPlans = true
}

// NextPlansCleared reports if the "NextPlans" edge to the Plan entity was cleared.
func (m *PlanMutation) NextPlansCleared() bool {
	return m.cleared_NextPlans
}

// RemoveNextPlanIDs removes the "NextPlans" edge to the Plan entity by IDs.
func (m *PlanMutation) RemoveNextPlanIDs(ids ...uuid.UUID) {
	if m.removed_NextPlans == nil {
		m.removed_NextPlans = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._NextPlans, ids[i])
		m.removed_NextPlans[ids[i]] = struct{}{}
	}
}

// RemovedNextPlans returns the removed IDs of the "NextPlans" edge to the Plan entity.
func (m *PlanMutation) RemovedNextPlansIDs() (ids []uuid.UUID) {
	for id := range m.removed_NextPlans {
		ids = append(ids, id)
	}
	return
}

// NextPlansIDs returns the "NextPlans" edge IDs in the mutation.
func (m *PlanMutation) NextPlansIDs() (ids []uuid.UUID) {
	for id := range m._NextPlans {
		ids = append(ids, id)
	}
	return
}

// ResetNextPlans resets all changes to the "NextPlans" edge.
func (m *PlanMutation) ResetNextPlans() {
	m._NextPlans = nil
	m.cleared_NextPlans = false
	m.removed_NextPlans = nil
}

// SetBuildID sets the "Build" edge to the Build entity by id.
func (m *PlanMutation) SetBuildID(id uuid.UUID) {
	m._Build = &id
}

// ClearBuild clears the "Build" edge to the Build entity.
func (m *PlanMutation) ClearBuild() {
	m.cleared_Build = true
}

// BuildCleared reports if the "Build" edge to the Build entity was cleared.
func (m *PlanMutation) BuildCleared() bool {
	return m.cleared_Build
}

// BuildID returns the "Build" edge ID in the mutation.
func (m *PlanMutation) BuildID() (id uuid.UUID, exists bool) {
	if m._Build != nil {
		return *m._Build, true
	}
	return
}

// BuildIDs returns the "Build" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuildID instead. It exists only for internal usage by the builders.
func (m *PlanMutation) BuildIDs() (ids []uuid.UUID) {
	if id := m._Build; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuild resets all changes to the "Build" edge.
func (m *PlanMutation) ResetBuild() {
	m._Build = nil
	m.cleared_Build = false
}

// SetTeamID sets the "Team" edge to the Team entity by id.
func (m *PlanMutation) SetTeamID(id uuid.UUID) {
	m._Team = &id
}

// ClearTeam clears the "Team" edge to the Team entity.
func (m *PlanMutation) ClearTeam() {
	m.cleared_Team = true
}

// TeamCleared reports if the "Team" edge to the Team entity was cleared.
func (m *PlanMutation) TeamCleared() bool {
	return m.cleared_Team
}

// TeamID returns the "Team" edge ID in the mutation.
func (m *PlanMutation) TeamID() (id uuid.UUID, exists bool) {
	if m._Team != nil {
		return *m._Team, true
	}
	return
}

// TeamIDs returns the "Team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *PlanMutation) TeamIDs() (ids []uuid.UUID) {
	if id := m._Team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "Team" edge.
func (m *PlanMutation) ResetTeam() {
	m._Team = nil
	m.cleared_Team = false
}

// SetProvisionedNetworkID sets the "ProvisionedNetwork" edge to the ProvisionedNetwork entity by id.
func (m *PlanMutation) SetProvisionedNetworkID(id uuid.UUID) {
	m._ProvisionedNetwork = &id
}

// ClearProvisionedNetwork clears the "ProvisionedNetwork" edge to the ProvisionedNetwork entity.
func (m *PlanMutation) ClearProvisionedNetwork() {
	m.cleared_ProvisionedNetwork = true
}

// ProvisionedNetworkCleared reports if the "ProvisionedNetwork" edge to the ProvisionedNetwork entity was cleared.
func (m *PlanMutation) ProvisionedNetworkCleared() bool {
	return m.cleared_ProvisionedNetwork
}

// ProvisionedNetworkID returns the "ProvisionedNetwork" edge ID in the mutation.
func (m *PlanMutation) ProvisionedNetworkID() (id uuid.UUID, exists bool) {
	if m._ProvisionedNetwork != nil {
		return *m._ProvisionedNetwork, true
	}
	return
}

// ProvisionedNetworkIDs returns the "ProvisionedNetwork" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisionedNetworkID instead. It exists only for internal usage by the builders.
func (m *PlanMutation) ProvisionedNetworkIDs() (ids []uuid.UUID) {
	if id := m._ProvisionedNetwork; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisionedNetwork resets all changes to the "ProvisionedNetwork" edge.
func (m *PlanMutation) ResetProvisionedNetwork() {
	m._ProvisionedNetwork = nil
	m.cleared_ProvisionedNetwork = false
}

// SetProvisionedHostID sets the "ProvisionedHost" edge to the ProvisionedHost entity by id.
func (m *PlanMutation) SetProvisionedHostID(id uuid.UUID) {
	m._ProvisionedHost = &id
}

// ClearProvisionedHost clears the "ProvisionedHost" edge to the ProvisionedHost entity.
func (m *PlanMutation) ClearProvisionedHost() {
	m.cleared_ProvisionedHost = true
}

// ProvisionedHostCleared reports if the "ProvisionedHost" edge to the ProvisionedHost entity was cleared.
func (m *PlanMutation) ProvisionedHostCleared() bool {
	return m.cleared_ProvisionedHost
}

// ProvisionedHostID returns the "ProvisionedHost" edge ID in the mutation.
func (m *PlanMutation) ProvisionedHostID() (id uuid.UUID, exists bool) {
	if m._ProvisionedHost != nil {
		return *m._ProvisionedHost, true
	}
	return
}

// ProvisionedHostIDs returns the "ProvisionedHost" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisionedHostID instead. It exists only for internal usage by the builders.
func (m *PlanMutation) ProvisionedHostIDs() (ids []uuid.UUID) {
	if id := m._ProvisionedHost; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisionedHost resets all changes to the "ProvisionedHost" edge.
func (m *PlanMutation) ResetProvisionedHost() {
	m._ProvisionedHost = nil
	m.cleared_ProvisionedHost = false
}

// SetProvisioningStepID sets the "ProvisioningStep" edge to the ProvisioningStep entity by id.
func (m *PlanMutation) SetProvisioningStepID(id uuid.UUID) {
	m._ProvisioningStep = &id
}

// ClearProvisioningStep clears the "ProvisioningStep" edge to the ProvisioningStep entity.
func (m *PlanMutation) ClearProvisioningStep() {
	m.cleared_ProvisioningStep = true
}

// ProvisioningStepCleared reports if the "ProvisioningStep" edge to the ProvisioningStep entity was cleared.
func (m *PlanMutation) ProvisioningStepCleared() bool {
	return m.cleared_ProvisioningStep
}

// ProvisioningStepID returns the "ProvisioningStep" edge ID in the mutation.
func (m *PlanMutation) ProvisioningStepID() (id uuid.UUID, exists bool) {
	if m._ProvisioningStep != nil {
		return *m._ProvisioningStep, true
	}
	return
}

// ProvisioningStepIDs returns the "ProvisioningStep" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisioningStepID instead. It exists only for internal usage by the builders.
func (m *PlanMutation) ProvisioningStepIDs() (ids []uuid.UUID) {
	if id := m._ProvisioningStep; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisioningStep resets all changes to the "ProvisioningStep" edge.
func (m *PlanMutation) ResetProvisioningStep() {
	m._ProvisioningStep = nil
	m.cleared_ProvisioningStep = false
}

// SetProvisioningScheduledStepID sets the "ProvisioningScheduledStep" edge to the ProvisioningScheduledStep entity by id.
func (m *PlanMutation) SetProvisioningScheduledStepID(id uuid.UUID) {
	m._ProvisioningScheduledStep = &id
}

// ClearProvisioningScheduledStep clears the "ProvisioningScheduledStep" edge to the ProvisioningScheduledStep entity.
func (m *PlanMutation) ClearProvisioningScheduledStep() {
	m.cleared_ProvisioningScheduledStep = true
}

// ProvisioningScheduledStepCleared reports if the "ProvisioningScheduledStep" edge to the ProvisioningScheduledStep entity was cleared.
func (m *PlanMutation) ProvisioningScheduledStepCleared() bool {
	return m.cleared_ProvisioningScheduledStep
}

// ProvisioningScheduledStepID returns the "ProvisioningScheduledStep" edge ID in the mutation.
func (m *PlanMutation) ProvisioningScheduledStepID() (id uuid.UUID, exists bool) {
	if m._ProvisioningScheduledStep != nil {
		return *m._ProvisioningScheduledStep, true
	}
	return
}

// ProvisioningScheduledStepIDs returns the "ProvisioningScheduledStep" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisioningScheduledStepID instead. It exists only for internal usage by the builders.
func (m *PlanMutation) ProvisioningScheduledStepIDs() (ids []uuid.UUID) {
	if id := m._ProvisioningScheduledStep; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisioningScheduledStep resets all changes to the "ProvisioningScheduledStep" edge.
func (m *PlanMutation) ResetProvisioningScheduledStep() {
	m._ProvisioningScheduledStep = nil
	m.cleared_ProvisioningScheduledStep = false
}

// SetStatusID sets the "Status" edge to the Status entity by id.
func (m *PlanMutation) SetStatusID(id uuid.UUID) {
	m._Status = &id
}

// ClearStatus clears the "Status" edge to the Status entity.
func (m *PlanMutation) ClearStatus() {
	m.cleared_Status = true
}

// StatusCleared reports if the "Status" edge to the Status entity was cleared.
func (m *PlanMutation) StatusCleared() bool {
	return m.cleared_Status
}

// StatusID returns the "Status" edge ID in the mutation.
func (m *PlanMutation) StatusID() (id uuid.UUID, exists bool) {
	if m._Status != nil {
		return *m._Status, true
	}
	return
}

// StatusIDs returns the "Status" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusID instead. It exists only for internal usage by the builders.
func (m *PlanMutation) StatusIDs() (ids []uuid.UUID) {
	if id := m._Status; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatus resets all changes to the "Status" edge.
func (m *PlanMutation) ResetStatus() {
	m._Status = nil
	m.cleared_Status = false
}

// AddPlanDiffIDs adds the "PlanDiffs" edge to the PlanDiff entity by ids.
func (m *PlanMutation) AddPlanDiffIDs(ids ...uuid.UUID) {
	if m._PlanDiffs == nil {
		m._PlanDiffs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._PlanDiffs[ids[i]] = struct{}{}
	}
}

// ClearPlanDiffs clears the "PlanDiffs" edge to the PlanDiff entity.
func (m *PlanMutation) ClearPlanDiffs() {
	m.cleared_PlanDiffs = true
}

// PlanDiffsCleared reports if the "PlanDiffs" edge to the PlanDiff entity was cleared.
func (m *PlanMutation) PlanDiffsCleared() bool {
	return m.cleared_PlanDiffs
}

// RemovePlanDiffIDs removes the "PlanDiffs" edge to the PlanDiff entity by IDs.
func (m *PlanMutation) RemovePlanDiffIDs(ids ...uuid.UUID) {
	if m.removed_PlanDiffs == nil {
		m.removed_PlanDiffs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._PlanDiffs, ids[i])
		m.removed_PlanDiffs[ids[i]] = struct{}{}
	}
}

// RemovedPlanDiffs returns the removed IDs of the "PlanDiffs" edge to the PlanDiff entity.
func (m *PlanMutation) RemovedPlanDiffsIDs() (ids []uuid.UUID) {
	for id := range m.removed_PlanDiffs {
		ids = append(ids, id)
	}
	return
}

// PlanDiffsIDs returns the "PlanDiffs" edge IDs in the mutation.
func (m *PlanMutation) PlanDiffsIDs() (ids []uuid.UUID) {
	for id := range m._PlanDiffs {
		ids = append(ids, id)
	}
	return
}

// ResetPlanDiffs resets all changes to the "PlanDiffs" edge.
func (m *PlanMutation) ResetPlanDiffs() {
	m._PlanDiffs = nil
	m.cleared_PlanDiffs = false
	m.removed_PlanDiffs = nil
}

// Where appends a list predicates to the PlanMutation builder.
func (m *PlanMutation) Where(ps ...predicate.Plan) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PlanMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Plan).
func (m *PlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlanMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.step_number != nil {
		fields = append(fields, plan.FieldStepNumber)
	}
	if m._type != nil {
		fields = append(fields, plan.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case plan.FieldStepNumber:
		return m.StepNumber()
	case plan.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case plan.FieldStepNumber:
		return m.OldStepNumber(ctx)
	case plan.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Plan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case plan.FieldStepNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepNumber(v)
		return nil
	case plan.FieldType:
		v, ok := value.(plan.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Plan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlanMutation) AddedFields() []string {
	var fields []string
	if m.addstep_number != nil {
		fields = append(fields, plan.FieldStepNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case plan.FieldStepNumber:
		return m.AddedStepNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case plan.FieldStepNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStepNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Plan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlanMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Plan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlanMutation) ResetField(name string) error {
	switch name {
	case plan.FieldStepNumber:
		m.ResetStepNumber()
		return nil
	case plan.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Plan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m._PrevPlans != nil {
		edges = append(edges, plan.EdgePrevPlans)
	}
	if m._NextPlans != nil {
		edges = append(edges, plan.EdgeNextPlans)
	}
	if m._Build != nil {
		edges = append(edges, plan.EdgeBuild)
	}
	if m._Team != nil {
		edges = append(edges, plan.EdgeTeam)
	}
	if m._ProvisionedNetwork != nil {
		edges = append(edges, plan.EdgeProvisionedNetwork)
	}
	if m._ProvisionedHost != nil {
		edges = append(edges, plan.EdgeProvisionedHost)
	}
	if m._ProvisioningStep != nil {
		edges = append(edges, plan.EdgeProvisioningStep)
	}
	if m._ProvisioningScheduledStep != nil {
		edges = append(edges, plan.EdgeProvisioningScheduledStep)
	}
	if m._Status != nil {
		edges = append(edges, plan.EdgeStatus)
	}
	if m._PlanDiffs != nil {
		edges = append(edges, plan.EdgePlanDiffs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case plan.EdgePrevPlans:
		ids := make([]ent.Value, 0, len(m._PrevPlans))
		for id := range m._PrevPlans {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeNextPlans:
		ids := make([]ent.Value, 0, len(m._NextPlans))
		for id := range m._NextPlans {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeBuild:
		if id := m._Build; id != nil {
			return []ent.Value{*id}
		}
	case plan.EdgeTeam:
		if id := m._Team; id != nil {
			return []ent.Value{*id}
		}
	case plan.EdgeProvisionedNetwork:
		if id := m._ProvisionedNetwork; id != nil {
			return []ent.Value{*id}
		}
	case plan.EdgeProvisionedHost:
		if id := m._ProvisionedHost; id != nil {
			return []ent.Value{*id}
		}
	case plan.EdgeProvisioningStep:
		if id := m._ProvisioningStep; id != nil {
			return []ent.Value{*id}
		}
	case plan.EdgeProvisioningScheduledStep:
		if id := m._ProvisioningScheduledStep; id != nil {
			return []ent.Value{*id}
		}
	case plan.EdgeStatus:
		if id := m._Status; id != nil {
			return []ent.Value{*id}
		}
	case plan.EdgePlanDiffs:
		ids := make([]ent.Value, 0, len(m._PlanDiffs))
		for id := range m._PlanDiffs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removed_PrevPlans != nil {
		edges = append(edges, plan.EdgePrevPlans)
	}
	if m.removed_NextPlans != nil {
		edges = append(edges, plan.EdgeNextPlans)
	}
	if m.removed_PlanDiffs != nil {
		edges = append(edges, plan.EdgePlanDiffs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case plan.EdgePrevPlans:
		ids := make([]ent.Value, 0, len(m.removed_PrevPlans))
		for id := range m.removed_PrevPlans {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeNextPlans:
		ids := make([]ent.Value, 0, len(m.removed_NextPlans))
		for id := range m.removed_NextPlans {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgePlanDiffs:
		ids := make([]ent.Value, 0, len(m.removed_PlanDiffs))
		for id := range m.removed_PlanDiffs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.cleared_PrevPlans {
		edges = append(edges, plan.EdgePrevPlans)
	}
	if m.cleared_NextPlans {
		edges = append(edges, plan.EdgeNextPlans)
	}
	if m.cleared_Build {
		edges = append(edges, plan.EdgeBuild)
	}
	if m.cleared_Team {
		edges = append(edges, plan.EdgeTeam)
	}
	if m.cleared_ProvisionedNetwork {
		edges = append(edges, plan.EdgeProvisionedNetwork)
	}
	if m.cleared_ProvisionedHost {
		edges = append(edges, plan.EdgeProvisionedHost)
	}
	if m.cleared_ProvisioningStep {
		edges = append(edges, plan.EdgeProvisioningStep)
	}
	if m.cleared_ProvisioningScheduledStep {
		edges = append(edges, plan.EdgeProvisioningScheduledStep)
	}
	if m.cleared_Status {
		edges = append(edges, plan.EdgeStatus)
	}
	if m.cleared_PlanDiffs {
		edges = append(edges, plan.EdgePlanDiffs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlanMutation) EdgeCleared(name string) bool {
	switch name {
	case plan.EdgePrevPlans:
		return m.cleared_PrevPlans
	case plan.EdgeNextPlans:
		return m.cleared_NextPlans
	case plan.EdgeBuild:
		return m.cleared_Build
	case plan.EdgeTeam:
		return m.cleared_Team
	case plan.EdgeProvisionedNetwork:
		return m.cleared_ProvisionedNetwork
	case plan.EdgeProvisionedHost:
		return m.cleared_ProvisionedHost
	case plan.EdgeProvisioningStep:
		return m.cleared_ProvisioningStep
	case plan.EdgeProvisioningScheduledStep:
		return m.cleared_ProvisioningScheduledStep
	case plan.EdgeStatus:
		return m.cleared_Status
	case plan.EdgePlanDiffs:
		return m.cleared_PlanDiffs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlanMutation) ClearEdge(name string) error {
	switch name {
	case plan.EdgeBuild:
		m.ClearBuild()
		return nil
	case plan.EdgeTeam:
		m.ClearTeam()
		return nil
	case plan.EdgeProvisionedNetwork:
		m.ClearProvisionedNetwork()
		return nil
	case plan.EdgeProvisionedHost:
		m.ClearProvisionedHost()
		return nil
	case plan.EdgeProvisioningStep:
		m.ClearProvisioningStep()
		return nil
	case plan.EdgeProvisioningScheduledStep:
		m.ClearProvisioningScheduledStep()
		return nil
	case plan.EdgeStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Plan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlanMutation) ResetEdge(name string) error {
	switch name {
	case plan.EdgePrevPlans:
		m.ResetPrevPlans()
		return nil
	case plan.EdgeNextPlans:
		m.ResetNextPlans()
		return nil
	case plan.EdgeBuild:
		m.ResetBuild()
		return nil
	case plan.EdgeTeam:
		m.ResetTeam()
		return nil
	case plan.EdgeProvisionedNetwork:
		m.ResetProvisionedNetwork()
		return nil
	case plan.EdgeProvisionedHost:
		m.ResetProvisionedHost()
		return nil
	case plan.EdgeProvisioningStep:
		m.ResetProvisioningStep()
		return nil
	case plan.EdgeProvisioningScheduledStep:
		m.ResetProvisioningScheduledStep()
		return nil
	case plan.EdgeStatus:
		m.ResetStatus()
		return nil
	case plan.EdgePlanDiffs:
		m.ResetPlanDiffs()
		return nil
	}
	return fmt.Errorf("unknown Plan edge %s", name)
}

// PlanDiffMutation represents an operation that mutates the PlanDiff nodes in the graph.
type PlanDiffMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	revision            *int
	addrevision         *int
	new_state           *plandiff.NewState
	clearedFields       map[string]struct{}
	_BuildCommit        *uuid.UUID
	cleared_BuildCommit bool
	_Plan               *uuid.UUID
	cleared_Plan        bool
	done                bool
	oldValue            func(context.Context) (*PlanDiff, error)
	predicates          []predicate.PlanDiff
}

var _ ent.Mutation = (*PlanDiffMutation)(nil)

// plandiffOption allows management of the mutation configuration using functional options.
type plandiffOption func(*PlanDiffMutation)

// newPlanDiffMutation creates new mutation for the PlanDiff entity.
func newPlanDiffMutation(c config, op Op, opts ...plandiffOption) *PlanDiffMutation {
	m := &PlanDiffMutation{
		config:        c,
		op:            op,
		typ:           TypePlanDiff,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlanDiffID sets the ID field of the mutation.
func withPlanDiffID(id uuid.UUID) plandiffOption {
	return func(m *PlanDiffMutation) {
		var (
			err   error
			once  sync.Once
			value *PlanDiff
		)
		m.oldValue = func(ctx context.Context) (*PlanDiff, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlanDiff.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlanDiff sets the old PlanDiff of the mutation.
func withPlanDiff(node *PlanDiff) plandiffOption {
	return func(m *PlanDiffMutation) {
		m.oldValue = func(context.Context) (*PlanDiff, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanDiffMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanDiffMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PlanDiff entities.
func (m *PlanDiffMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlanDiffMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlanDiffMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlanDiff.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRevision sets the "revision" field.
func (m *PlanDiffMutation) SetRevision(i int) {
	m.revision = &i
	m.addrevision = nil
}

// Revision returns the value of the "revision" field in the mutation.
func (m *PlanDiffMutation) Revision() (r int, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the PlanDiff entity.
// If the PlanDiff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanDiffMutation) OldRevision(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// AddRevision adds i to the "revision" field.
func (m *PlanDiffMutation) AddRevision(i int) {
	if m.addrevision != nil {
		*m.addrevision += i
	} else {
		m.addrevision = &i
	}
}

// AddedRevision returns the value that was added to the "revision" field in this mutation.
func (m *PlanDiffMutation) AddedRevision() (r int, exists bool) {
	v := m.addrevision
	if v == nil {
		return
	}
	return *v, true
}

// ResetRevision resets all changes to the "revision" field.
func (m *PlanDiffMutation) ResetRevision() {
	m.revision = nil
	m.addrevision = nil
}

// SetNewState sets the "new_state" field.
func (m *PlanDiffMutation) SetNewState(ps plandiff.NewState) {
	m.new_state = &ps
}

// NewState returns the value of the "new_state" field in the mutation.
func (m *PlanDiffMutation) NewState() (r plandiff.NewState, exists bool) {
	v := m.new_state
	if v == nil {
		return
	}
	return *v, true
}

// OldNewState returns the old "new_state" field's value of the PlanDiff entity.
// If the PlanDiff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanDiffMutation) OldNewState(ctx context.Context) (v plandiff.NewState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNewState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNewState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNewState: %w", err)
	}
	return oldValue.NewState, nil
}

// ResetNewState resets all changes to the "new_state" field.
func (m *PlanDiffMutation) ResetNewState() {
	m.new_state = nil
}

// SetBuildCommitID sets the "BuildCommit" edge to the BuildCommit entity by id.
func (m *PlanDiffMutation) SetBuildCommitID(id uuid.UUID) {
	m._BuildCommit = &id
}

// ClearBuildCommit clears the "BuildCommit" edge to the BuildCommit entity.
func (m *PlanDiffMutation) ClearBuildCommit() {
	m.cleared_BuildCommit = true
}

// BuildCommitCleared reports if the "BuildCommit" edge to the BuildCommit entity was cleared.
func (m *PlanDiffMutation) BuildCommitCleared() bool {
	return m.cleared_BuildCommit
}

// BuildCommitID returns the "BuildCommit" edge ID in the mutation.
func (m *PlanDiffMutation) BuildCommitID() (id uuid.UUID, exists bool) {
	if m._BuildCommit != nil {
		return *m._BuildCommit, true
	}
	return
}

// BuildCommitIDs returns the "BuildCommit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuildCommitID instead. It exists only for internal usage by the builders.
func (m *PlanDiffMutation) BuildCommitIDs() (ids []uuid.UUID) {
	if id := m._BuildCommit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuildCommit resets all changes to the "BuildCommit" edge.
func (m *PlanDiffMutation) ResetBuildCommit() {
	m._BuildCommit = nil
	m.cleared_BuildCommit = false
}

// SetPlanID sets the "Plan" edge to the Plan entity by id.
func (m *PlanDiffMutation) SetPlanID(id uuid.UUID) {
	m._Plan = &id
}

// ClearPlan clears the "Plan" edge to the Plan entity.
func (m *PlanDiffMutation) ClearPlan() {
	m.cleared_Plan = true
}

// PlanCleared reports if the "Plan" edge to the Plan entity was cleared.
func (m *PlanDiffMutation) PlanCleared() bool {
	return m.cleared_Plan
}

// PlanID returns the "Plan" edge ID in the mutation.
func (m *PlanDiffMutation) PlanID() (id uuid.UUID, exists bool) {
	if m._Plan != nil {
		return *m._Plan, true
	}
	return
}

// PlanIDs returns the "Plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *PlanDiffMutation) PlanIDs() (ids []uuid.UUID) {
	if id := m._Plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "Plan" edge.
func (m *PlanDiffMutation) ResetPlan() {
	m._Plan = nil
	m.cleared_Plan = false
}

// Where appends a list predicates to the PlanDiffMutation builder.
func (m *PlanDiffMutation) Where(ps ...predicate.PlanDiff) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PlanDiffMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PlanDiff).
func (m *PlanDiffMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlanDiffMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.revision != nil {
		fields = append(fields, plandiff.FieldRevision)
	}
	if m.new_state != nil {
		fields = append(fields, plandiff.FieldNewState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlanDiffMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case plandiff.FieldRevision:
		return m.Revision()
	case plandiff.FieldNewState:
		return m.NewState()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlanDiffMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case plandiff.FieldRevision:
		return m.OldRevision(ctx)
	case plandiff.FieldNewState:
		return m.OldNewState(ctx)
	}
	return nil, fmt.Errorf("unknown PlanDiff field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanDiffMutation) SetField(name string, value ent.Value) error {
	switch name {
	case plandiff.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case plandiff.FieldNewState:
		v, ok := value.(plandiff.NewState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNewState(v)
		return nil
	}
	return fmt.Errorf("unknown PlanDiff field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlanDiffMutation) AddedFields() []string {
	var fields []string
	if m.addrevision != nil {
		fields = append(fields, plandiff.FieldRevision)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlanDiffMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case plandiff.FieldRevision:
		return m.AddedRevision()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanDiffMutation) AddField(name string, value ent.Value) error {
	switch name {
	case plandiff.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevision(v)
		return nil
	}
	return fmt.Errorf("unknown PlanDiff numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlanDiffMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlanDiffMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanDiffMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PlanDiff nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlanDiffMutation) ResetField(name string) error {
	switch name {
	case plandiff.FieldRevision:
		m.ResetRevision()
		return nil
	case plandiff.FieldNewState:
		m.ResetNewState()
		return nil
	}
	return fmt.Errorf("unknown PlanDiff field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlanDiffMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._BuildCommit != nil {
		edges = append(edges, plandiff.EdgeBuildCommit)
	}
	if m._Plan != nil {
		edges = append(edges, plandiff.EdgePlan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlanDiffMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case plandiff.EdgeBuildCommit:
		if id := m._BuildCommit; id != nil {
			return []ent.Value{*id}
		}
	case plandiff.EdgePlan:
		if id := m._Plan; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlanDiffMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlanDiffMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlanDiffMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_BuildCommit {
		edges = append(edges, plandiff.EdgeBuildCommit)
	}
	if m.cleared_Plan {
		edges = append(edges, plandiff.EdgePlan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlanDiffMutation) EdgeCleared(name string) bool {
	switch name {
	case plandiff.EdgeBuildCommit:
		return m.cleared_BuildCommit
	case plandiff.EdgePlan:
		return m.cleared_Plan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlanDiffMutation) ClearEdge(name string) error {
	switch name {
	case plandiff.EdgeBuildCommit:
		m.ClearBuildCommit()
		return nil
	case plandiff.EdgePlan:
		m.ClearPlan()
		return nil
	}
	return fmt.Errorf("unknown PlanDiff unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlanDiffMutation) ResetEdge(name string) error {
	switch name {
	case plandiff.EdgeBuildCommit:
		m.ResetBuildCommit()
		return nil
	case plandiff.EdgePlan:
		m.ResetPlan()
		return nil
	}
	return fmt.Errorf("unknown PlanDiff edge %s", name)
}

// ProvisionedHostMutation represents an operation that mutates the ProvisionedHost nodes in the graph.
type ProvisionedHostMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *uuid.UUID
	subnet_ip                          *string
	addon_type                         *provisionedhost.AddonType
	vars                               *map[string]string
	clearedFields                      map[string]struct{}
	_Status                            *uuid.UUID
	cleared_Status                     bool
	_ProvisionedNetwork                *uuid.UUID
	cleared_ProvisionedNetwork         bool
	_Host                              *uuid.UUID
	cleared_Host                       bool
	_EndStepPlan                       *uuid.UUID
	cleared_EndStepPlan                bool
	_Build                             *uuid.UUID
	cleared_Build                      bool
	_ProvisioningSteps                 map[uuid.UUID]struct{}
	removed_ProvisioningSteps          map[uuid.UUID]struct{}
	cleared_ProvisioningSteps          bool
	_ProvisioningScheduledSteps        map[uuid.UUID]struct{}
	removed_ProvisioningScheduledSteps map[uuid.UUID]struct{}
	cleared_ProvisioningScheduledSteps bool
	_AgentStatuses                     map[uuid.UUID]struct{}
	removed_AgentStatuses              map[uuid.UUID]struct{}
	cleared_AgentStatuses              bool
	_AgentTasks                        map[uuid.UUID]struct{}
	removed_AgentTasks                 map[uuid.UUID]struct{}
	cleared_AgentTasks                 bool
	_Plan                              *uuid.UUID
	cleared_Plan                       bool
	_GinFileMiddleware                 *uuid.UUID
	cleared_GinFileMiddleware          bool
	done                               bool
	oldValue                           func(context.Context) (*ProvisionedHost, error)
	predicates                         []predicate.ProvisionedHost
}

var _ ent.Mutation = (*ProvisionedHostMutation)(nil)

// provisionedhostOption allows management of the mutation configuration using functional options.
type provisionedhostOption func(*ProvisionedHostMutation)

// newProvisionedHostMutation creates new mutation for the ProvisionedHost entity.
func newProvisionedHostMutation(c config, op Op, opts ...provisionedhostOption) *ProvisionedHostMutation {
	m := &ProvisionedHostMutation{
		config:        c,
		op:            op,
		typ:           TypeProvisionedHost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProvisionedHostID sets the ID field of the mutation.
func withProvisionedHostID(id uuid.UUID) provisionedhostOption {
	return func(m *ProvisionedHostMutation) {
		var (
			err   error
			once  sync.Once
			value *ProvisionedHost
		)
		m.oldValue = func(ctx context.Context) (*ProvisionedHost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProvisionedHost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvisionedHost sets the old ProvisionedHost of the mutation.
func withProvisionedHost(node *ProvisionedHost) provisionedhostOption {
	return func(m *ProvisionedHostMutation) {
		m.oldValue = func(context.Context) (*ProvisionedHost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProvisionedHostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProvisionedHostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProvisionedHost entities.
func (m *ProvisionedHostMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProvisionedHostMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProvisionedHostMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProvisionedHost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSubnetIP sets the "subnet_ip" field.
func (m *ProvisionedHostMutation) SetSubnetIP(s string) {
	m.subnet_ip = &s
}

// SubnetIP returns the value of the "subnet_ip" field in the mutation.
func (m *ProvisionedHostMutation) SubnetIP() (r string, exists bool) {
	v := m.subnet_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldSubnetIP returns the old "subnet_ip" field's value of the ProvisionedHost entity.
// If the ProvisionedHost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvisionedHostMutation) OldSubnetIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubnetIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubnetIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubnetIP: %w", err)
	}
	return oldValue.SubnetIP, nil
}

// ResetSubnetIP resets all changes to the "subnet_ip" field.
func (m *ProvisionedHostMutation) ResetSubnetIP() {
	m.subnet_ip = nil
}

// SetAddonType sets the "addon_type" field.
func (m *ProvisionedHostMutation) SetAddonType(pt provisionedhost.AddonType) {
	m.addon_type = &pt
}

// AddonType returns the value of the "addon_type" field in the mutation.
func (m *ProvisionedHostMutation) AddonType() (r provisionedhost.AddonType, exists bool) {
	v := m.addon_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAddonType returns the old "addon_type" field's value of the ProvisionedHost entity.
// If the ProvisionedHost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvisionedHostMutation) OldAddonType(ctx context.Context) (v *provisionedhost.AddonType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddonType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddonType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddonType: %w", err)
	}
	return oldValue.AddonType, nil
}

// ClearAddonType clears the value of the "addon_type" field.
func (m *ProvisionedHostMutation) ClearAddonType() {
	m.addon_type = nil
	m.clearedFields[provisionedhost.FieldAddonType] = struct{}{}
}

// AddonTypeCleared returns if the "addon_type" field was cleared in this mutation.
func (m *ProvisionedHostMutation) AddonTypeCleared() bool {
	_, ok := m.clearedFields[provisionedhost.FieldAddonType]
	return ok
}

// ResetAddonType resets all changes to the "addon_type" field.
func (m *ProvisionedHostMutation) ResetAddonType() {
	m.addon_type = nil
	delete(m.clearedFields, provisionedhost.FieldAddonType)
}

// SetVars sets the "vars" field.
func (m *ProvisionedHostMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *ProvisionedHostMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the ProvisionedHost entity.
// If the ProvisionedHost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvisionedHostMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *ProvisionedHostMutation) ResetVars() {
	m.vars = nil
}

// SetStatusID sets the "Status" edge to the Status entity by id.
func (m *ProvisionedHostMutation) SetStatusID(id uuid.UUID) {
	m._Status = &id
}

// ClearStatus clears the "Status" edge to the Status entity.
func (m *ProvisionedHostMutation) ClearStatus() {
	m.cleared_Status = true
}

// StatusCleared reports if the "Status" edge to the Status entity was cleared.
func (m *ProvisionedHostMutation) StatusCleared() bool {
	return m.cleared_Status
}

// StatusID returns the "Status" edge ID in the mutation.
func (m *ProvisionedHostMutation) StatusID() (id uuid.UUID, exists bool) {
	if m._Status != nil {
		return *m._Status, true
	}
	return
}

// StatusIDs returns the "Status" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusID instead. It exists only for internal usage by the builders.
func (m *ProvisionedHostMutation) StatusIDs() (ids []uuid.UUID) {
	if id := m._Status; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatus resets all changes to the "Status" edge.
func (m *ProvisionedHostMutation) ResetStatus() {
	m._Status = nil
	m.cleared_Status = false
}

// SetProvisionedNetworkID sets the "ProvisionedNetwork" edge to the ProvisionedNetwork entity by id.
func (m *ProvisionedHostMutation) SetProvisionedNetworkID(id uuid.UUID) {
	m._ProvisionedNetwork = &id
}

// ClearProvisionedNetwork clears the "ProvisionedNetwork" edge to the ProvisionedNetwork entity.
func (m *ProvisionedHostMutation) ClearProvisionedNetwork() {
	m.cleared_ProvisionedNetwork = true
}

// ProvisionedNetworkCleared reports if the "ProvisionedNetwork" edge to the ProvisionedNetwork entity was cleared.
func (m *ProvisionedHostMutation) ProvisionedNetworkCleared() bool {
	return m.cleared_ProvisionedNetwork
}

// ProvisionedNetworkID returns the "ProvisionedNetwork" edge ID in the mutation.
func (m *ProvisionedHostMutation) ProvisionedNetworkID() (id uuid.UUID, exists bool) {
	if m._ProvisionedNetwork != nil {
		return *m._ProvisionedNetwork, true
	}
	return
}

// ProvisionedNetworkIDs returns the "ProvisionedNetwork" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisionedNetworkID instead. It exists only for internal usage by the builders.
func (m *ProvisionedHostMutation) ProvisionedNetworkIDs() (ids []uuid.UUID) {
	if id := m._ProvisionedNetwork; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisionedNetwork resets all changes to the "ProvisionedNetwork" edge.
func (m *ProvisionedHostMutation) ResetProvisionedNetwork() {
	m._ProvisionedNetwork = nil
	m.cleared_ProvisionedNetwork = false
}

// SetHostID sets the "Host" edge to the Host entity by id.
func (m *ProvisionedHostMutation) SetHostID(id uuid.UUID) {
	m._Host = &id
}

// ClearHost clears the "Host" edge to the Host entity.
func (m *ProvisionedHostMutation) ClearHost() {
	m.cleared_Host = true
}

// HostCleared reports if the "Host" edge to the Host entity was cleared.
func (m *ProvisionedHostMutation) HostCleared() bool {
	return m.cleared_Host
}

// HostID returns the "Host" edge ID in the mutation.
func (m *ProvisionedHostMutation) HostID() (id uuid.UUID, exists bool) {
	if m._Host != nil {
		return *m._Host, true
	}
	return
}

// HostIDs returns the "Host" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostID instead. It exists only for internal usage by the builders.
func (m *ProvisionedHostMutation) HostIDs() (ids []uuid.UUID) {
	if id := m._Host; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHost resets all changes to the "Host" edge.
func (m *ProvisionedHostMutation) ResetHost() {
	m._Host = nil
	m.cleared_Host = false
}

// SetEndStepPlanID sets the "EndStepPlan" edge to the Plan entity by id.
func (m *ProvisionedHostMutation) SetEndStepPlanID(id uuid.UUID) {
	m._EndStepPlan = &id
}

// ClearEndStepPlan clears the "EndStepPlan" edge to the Plan entity.
func (m *ProvisionedHostMutation) ClearEndStepPlan() {
	m.cleared_EndStepPlan = true
}

// EndStepPlanCleared reports if the "EndStepPlan" edge to the Plan entity was cleared.
func (m *ProvisionedHostMutation) EndStepPlanCleared() bool {
	return m.cleared_EndStepPlan
}

// EndStepPlanID returns the "EndStepPlan" edge ID in the mutation.
func (m *ProvisionedHostMutation) EndStepPlanID() (id uuid.UUID, exists bool) {
	if m._EndStepPlan != nil {
		return *m._EndStepPlan, true
	}
	return
}

// EndStepPlanIDs returns the "EndStepPlan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EndStepPlanID instead. It exists only for internal usage by the builders.
func (m *ProvisionedHostMutation) EndStepPlanIDs() (ids []uuid.UUID) {
	if id := m._EndStepPlan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEndStepPlan resets all changes to the "EndStepPlan" edge.
func (m *ProvisionedHostMutation) ResetEndStepPlan() {
	m._EndStepPlan = nil
	m.cleared_EndStepPlan = false
}

// SetBuildID sets the "Build" edge to the Build entity by id.
func (m *ProvisionedHostMutation) SetBuildID(id uuid.UUID) {
	m._Build = &id
}

// ClearBuild clears the "Build" edge to the Build entity.
func (m *ProvisionedHostMutation) ClearBuild() {
	m.cleared_Build = true
}

// BuildCleared reports if the "Build" edge to the Build entity was cleared.
func (m *ProvisionedHostMutation) BuildCleared() bool {
	return m.cleared_Build
}

// BuildID returns the "Build" edge ID in the mutation.
func (m *ProvisionedHostMutation) BuildID() (id uuid.UUID, exists bool) {
	if m._Build != nil {
		return *m._Build, true
	}
	return
}

// BuildIDs returns the "Build" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuildID instead. It exists only for internal usage by the builders.
func (m *ProvisionedHostMutation) BuildIDs() (ids []uuid.UUID) {
	if id := m._Build; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuild resets all changes to the "Build" edge.
func (m *ProvisionedHostMutation) ResetBuild() {
	m._Build = nil
	m.cleared_Build = false
}

// AddProvisioningStepIDs adds the "ProvisioningSteps" edge to the ProvisioningStep entity by ids.
func (m *ProvisionedHostMutation) AddProvisioningStepIDs(ids ...uuid.UUID) {
	if m._ProvisioningSteps == nil {
		m._ProvisioningSteps = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ProvisioningSteps[ids[i]] = struct{}{}
	}
}

// ClearProvisioningSteps clears the "ProvisioningSteps" edge to the ProvisioningStep entity.
func (m *ProvisionedHostMutation) ClearProvisioningSteps() {
	m.cleared_ProvisioningSteps = true
}

// ProvisioningStepsCleared reports if the "ProvisioningSteps" edge to the ProvisioningStep entity was cleared.
func (m *ProvisionedHostMutation) ProvisioningStepsCleared() bool {
	return m.cleared_ProvisioningSteps
}

// RemoveProvisioningStepIDs removes the "ProvisioningSteps" edge to the ProvisioningStep entity by IDs.
func (m *ProvisionedHostMutation) RemoveProvisioningStepIDs(ids ...uuid.UUID) {
	if m.removed_ProvisioningSteps == nil {
		m.removed_ProvisioningSteps = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._ProvisioningSteps, ids[i])
		m.removed_ProvisioningSteps[ids[i]] = struct{}{}
	}
}

// RemovedProvisioningSteps returns the removed IDs of the "ProvisioningSteps" edge to the ProvisioningStep entity.
func (m *ProvisionedHostMutation) RemovedProvisioningStepsIDs() (ids []uuid.UUID) {
	for id := range m.removed_ProvisioningSteps {
		ids = append(ids, id)
	}
	return
}

// ProvisioningStepsIDs returns the "ProvisioningSteps" edge IDs in the mutation.
func (m *ProvisionedHostMutation) ProvisioningStepsIDs() (ids []uuid.UUID) {
	for id := range m._ProvisioningSteps {
		ids = append(ids, id)
	}
	return
}

// ResetProvisioningSteps resets all changes to the "ProvisioningSteps" edge.
func (m *ProvisionedHostMutation) ResetProvisioningSteps() {
	m._ProvisioningSteps = nil
	m.cleared_ProvisioningSteps = false
	m.removed_ProvisioningSteps = nil
}

// AddProvisioningScheduledStepIDs adds the "ProvisioningScheduledSteps" edge to the ProvisioningScheduledStep entity by ids.
func (m *ProvisionedHostMutation) AddProvisioningScheduledStepIDs(ids ...uuid.UUID) {
	if m._ProvisioningScheduledSteps == nil {
		m._ProvisioningScheduledSteps = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ProvisioningScheduledSteps[ids[i]] = struct{}{}
	}
}

// ClearProvisioningScheduledSteps clears the "ProvisioningScheduledSteps" edge to the ProvisioningScheduledStep entity.
func (m *ProvisionedHostMutation) ClearProvisioningScheduledSteps() {
	m.cleared_ProvisioningScheduledSteps = true
}

// ProvisioningScheduledStepsCleared reports if the "ProvisioningScheduledSteps" edge to the ProvisioningScheduledStep entity was cleared.
func (m *ProvisionedHostMutation) ProvisioningScheduledStepsCleared() bool {
	return m.cleared_ProvisioningScheduledSteps
}

// RemoveProvisioningScheduledStepIDs removes the "ProvisioningScheduledSteps" edge to the ProvisioningScheduledStep entity by IDs.
func (m *ProvisionedHostMutation) RemoveProvisioningScheduledStepIDs(ids ...uuid.UUID) {
	if m.removed_ProvisioningScheduledSteps == nil {
		m.removed_ProvisioningScheduledSteps = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._ProvisioningScheduledSteps, ids[i])
		m.removed_ProvisioningScheduledSteps[ids[i]] = struct{}{}
	}
}

// RemovedProvisioningScheduledSteps returns the removed IDs of the "ProvisioningScheduledSteps" edge to the ProvisioningScheduledStep entity.
func (m *ProvisionedHostMutation) RemovedProvisioningScheduledStepsIDs() (ids []uuid.UUID) {
	for id := range m.removed_ProvisioningScheduledSteps {
		ids = append(ids, id)
	}
	return
}

// ProvisioningScheduledStepsIDs returns the "ProvisioningScheduledSteps" edge IDs in the mutation.
func (m *ProvisionedHostMutation) ProvisioningScheduledStepsIDs() (ids []uuid.UUID) {
	for id := range m._ProvisioningScheduledSteps {
		ids = append(ids, id)
	}
	return
}

// ResetProvisioningScheduledSteps resets all changes to the "ProvisioningScheduledSteps" edge.
func (m *ProvisionedHostMutation) ResetProvisioningScheduledSteps() {
	m._ProvisioningScheduledSteps = nil
	m.cleared_ProvisioningScheduledSteps = false
	m.removed_ProvisioningScheduledSteps = nil
}

// AddAgentStatuseIDs adds the "AgentStatuses" edge to the AgentStatus entity by ids.
func (m *ProvisionedHostMutation) AddAgentStatuseIDs(ids ...uuid.UUID) {
	if m._AgentStatuses == nil {
		m._AgentStatuses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._AgentStatuses[ids[i]] = struct{}{}
	}
}

// ClearAgentStatuses clears the "AgentStatuses" edge to the AgentStatus entity.
func (m *ProvisionedHostMutation) ClearAgentStatuses() {
	m.cleared_AgentStatuses = true
}

// AgentStatusesCleared reports if the "AgentStatuses" edge to the AgentStatus entity was cleared.
func (m *ProvisionedHostMutation) AgentStatusesCleared() bool {
	return m.cleared_AgentStatuses
}

// RemoveAgentStatuseIDs removes the "AgentStatuses" edge to the AgentStatus entity by IDs.
func (m *ProvisionedHostMutation) RemoveAgentStatuseIDs(ids ...uuid.UUID) {
	if m.removed_AgentStatuses == nil {
		m.removed_AgentStatuses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._AgentStatuses, ids[i])
		m.removed_AgentStatuses[ids[i]] = struct{}{}
	}
}

// RemovedAgentStatuses returns the removed IDs of the "AgentStatuses" edge to the AgentStatus entity.
func (m *ProvisionedHostMutation) RemovedAgentStatusesIDs() (ids []uuid.UUID) {
	for id := range m.removed_AgentStatuses {
		ids = append(ids, id)
	}
	return
}

// AgentStatusesIDs returns the "AgentStatuses" edge IDs in the mutation.
func (m *ProvisionedHostMutation) AgentStatusesIDs() (ids []uuid.UUID) {
	for id := range m._AgentStatuses {
		ids = append(ids, id)
	}
	return
}

// ResetAgentStatuses resets all changes to the "AgentStatuses" edge.
func (m *ProvisionedHostMutation) ResetAgentStatuses() {
	m._AgentStatuses = nil
	m.cleared_AgentStatuses = false
	m.removed_AgentStatuses = nil
}

// AddAgentTaskIDs adds the "AgentTasks" edge to the AgentTask entity by ids.
func (m *ProvisionedHostMutation) AddAgentTaskIDs(ids ...uuid.UUID) {
	if m._AgentTasks == nil {
		m._AgentTasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._AgentTasks[ids[i]] = struct{}{}
	}
}

// ClearAgentTasks clears the "AgentTasks" edge to the AgentTask entity.
func (m *ProvisionedHostMutation) ClearAgentTasks() {
	m.cleared_AgentTasks = true
}

// AgentTasksCleared reports if the "AgentTasks" edge to the AgentTask entity was cleared.
func (m *ProvisionedHostMutation) AgentTasksCleared() bool {
	return m.cleared_AgentTasks
}

// RemoveAgentTaskIDs removes the "AgentTasks" edge to the AgentTask entity by IDs.
func (m *ProvisionedHostMutation) RemoveAgentTaskIDs(ids ...uuid.UUID) {
	if m.removed_AgentTasks == nil {
		m.removed_AgentTasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._AgentTasks, ids[i])
		m.removed_AgentTasks[ids[i]] = struct{}{}
	}
}

// RemovedAgentTasks returns the removed IDs of the "AgentTasks" edge to the AgentTask entity.
func (m *ProvisionedHostMutation) RemovedAgentTasksIDs() (ids []uuid.UUID) {
	for id := range m.removed_AgentTasks {
		ids = append(ids, id)
	}
	return
}

// AgentTasksIDs returns the "AgentTasks" edge IDs in the mutation.
func (m *ProvisionedHostMutation) AgentTasksIDs() (ids []uuid.UUID) {
	for id := range m._AgentTasks {
		ids = append(ids, id)
	}
	return
}

// ResetAgentTasks resets all changes to the "AgentTasks" edge.
func (m *ProvisionedHostMutation) ResetAgentTasks() {
	m._AgentTasks = nil
	m.cleared_AgentTasks = false
	m.removed_AgentTasks = nil
}

// SetPlanID sets the "Plan" edge to the Plan entity by id.
func (m *ProvisionedHostMutation) SetPlanID(id uuid.UUID) {
	m._Plan = &id
}

// ClearPlan clears the "Plan" edge to the Plan entity.
func (m *ProvisionedHostMutation) ClearPlan() {
	m.cleared_Plan = true
}

// PlanCleared reports if the "Plan" edge to the Plan entity was cleared.
func (m *ProvisionedHostMutation) PlanCleared() bool {
	return m.cleared_Plan
}

// PlanID returns the "Plan" edge ID in the mutation.
func (m *ProvisionedHostMutation) PlanID() (id uuid.UUID, exists bool) {
	if m._Plan != nil {
		return *m._Plan, true
	}
	return
}

// PlanIDs returns the "Plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *ProvisionedHostMutation) PlanIDs() (ids []uuid.UUID) {
	if id := m._Plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "Plan" edge.
func (m *ProvisionedHostMutation) ResetPlan() {
	m._Plan = nil
	m.cleared_Plan = false
}

// SetGinFileMiddlewareID sets the "GinFileMiddleware" edge to the GinFileMiddleware entity by id.
func (m *ProvisionedHostMutation) SetGinFileMiddlewareID(id uuid.UUID) {
	m._GinFileMiddleware = &id
}

// ClearGinFileMiddleware clears the "GinFileMiddleware" edge to the GinFileMiddleware entity.
func (m *ProvisionedHostMutation) ClearGinFileMiddleware() {
	m.cleared_GinFileMiddleware = true
}

// GinFileMiddlewareCleared reports if the "GinFileMiddleware" edge to the GinFileMiddleware entity was cleared.
func (m *ProvisionedHostMutation) GinFileMiddlewareCleared() bool {
	return m.cleared_GinFileMiddleware
}

// GinFileMiddlewareID returns the "GinFileMiddleware" edge ID in the mutation.
func (m *ProvisionedHostMutation) GinFileMiddlewareID() (id uuid.UUID, exists bool) {
	if m._GinFileMiddleware != nil {
		return *m._GinFileMiddleware, true
	}
	return
}

// GinFileMiddlewareIDs returns the "GinFileMiddleware" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GinFileMiddlewareID instead. It exists only for internal usage by the builders.
func (m *ProvisionedHostMutation) GinFileMiddlewareIDs() (ids []uuid.UUID) {
	if id := m._GinFileMiddleware; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGinFileMiddleware resets all changes to the "GinFileMiddleware" edge.
func (m *ProvisionedHostMutation) ResetGinFileMiddleware() {
	m._GinFileMiddleware = nil
	m.cleared_GinFileMiddleware = false
}

// Where appends a list predicates to the ProvisionedHostMutation builder.
func (m *ProvisionedHostMutation) Where(ps ...predicate.ProvisionedHost) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProvisionedHostMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProvisionedHost).
func (m *ProvisionedHostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProvisionedHostMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.subnet_ip != nil {
		fields = append(fields, provisionedhost.FieldSubnetIP)
	}
	if m.addon_type != nil {
		fields = append(fields, provisionedhost.FieldAddonType)
	}
	if m.vars != nil {
		fields = append(fields, provisionedhost.FieldVars)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProvisionedHostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case provisionedhost.FieldSubnetIP:
		return m.SubnetIP()
	case provisionedhost.FieldAddonType:
		return m.AddonType()
	case provisionedhost.FieldVars:
		return m.Vars()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProvisionedHostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case provisionedhost.FieldSubnetIP:
		return m.OldSubnetIP(ctx)
	case provisionedhost.FieldAddonType:
		return m.OldAddonType(ctx)
	case provisionedhost.FieldVars:
		return m.OldVars(ctx)
	}
	return nil, fmt.Errorf("unknown ProvisionedHost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvisionedHostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case provisionedhost.FieldSubnetIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubnetIP(v)
		return nil
	case provisionedhost.FieldAddonType:
		v, ok := value.(provisionedhost.AddonType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddonType(v)
		return nil
	case provisionedhost.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	}
	return fmt.Errorf("unknown ProvisionedHost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProvisionedHostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProvisionedHostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvisionedHostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProvisionedHost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProvisionedHostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(provisionedhost.FieldAddonType) {
		fields = append(fields, provisionedhost.FieldAddonType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProvisionedHostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProvisionedHostMutation) ClearField(name string) error {
	switch name {
	case provisionedhost.FieldAddonType:
		m.ClearAddonType()
		return nil
	}
	return fmt.Errorf("unknown ProvisionedHost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProvisionedHostMutation) ResetField(name string) error {
	switch name {
	case provisionedhost.FieldSubnetIP:
		m.ResetSubnetIP()
		return nil
	case provisionedhost.FieldAddonType:
		m.ResetAddonType()
		return nil
	case provisionedhost.FieldVars:
		m.ResetVars()
		return nil
	}
	return fmt.Errorf("unknown ProvisionedHost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProvisionedHostMutation) AddedEdges() []string {
	edges := make([]string, 0, 11)
	if m._Status != nil {
		edges = append(edges, provisionedhost.EdgeStatus)
	}
	if m._ProvisionedNetwork != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedNetwork)
	}
	if m._Host != nil {
		edges = append(edges, provisionedhost.EdgeHost)
	}
	if m._EndStepPlan != nil {
		edges = append(edges, provisionedhost.EdgeEndStepPlan)
	}
	if m._Build != nil {
		edges = append(edges, provisionedhost.EdgeBuild)
	}
	if m._ProvisioningSteps != nil {
		edges = append(edges, provisionedhost.EdgeProvisioningSteps)
	}
	if m._ProvisioningScheduledSteps != nil {
		edges = append(edges, provisionedhost.EdgeProvisioningScheduledSteps)
	}
	if m._AgentStatuses != nil {
		edges = append(edges, provisionedhost.EdgeAgentStatuses)
	}
	if m._AgentTasks != nil {
		edges = append(edges, provisionedhost.EdgeAgentTasks)
	}
	if m._Plan != nil {
		edges = append(edges, provisionedhost.EdgePlan)
	}
	if m._GinFileMiddleware != nil {
		edges = append(edges, provisionedhost.EdgeGinFileMiddleware)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProvisionedHostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case provisionedhost.EdgeStatus:
		if id := m._Status; id != nil {
			return []ent.Value{*id}
		}
	case provisionedhost.EdgeProvisionedNetwork:
		if id := m._ProvisionedNetwork; id != nil {
			return []ent.Value{*id}
		}
	case provisionedhost.EdgeHost:
		if id := m._Host; id != nil {
			return []ent.Value{*id}
		}
	case provisionedhost.EdgeEndStepPlan:
		if id := m._EndStepPlan; id != nil {
			return []ent.Value{*id}
		}
	case provisionedhost.EdgeBuild:
		if id := m._Build; id != nil {
			return []ent.Value{*id}
		}
	case provisionedhost.EdgeProvisioningSteps:
		ids := make([]ent.Value, 0, len(m._ProvisioningSteps))
		for id := range m._ProvisioningSteps {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeProvisioningScheduledSteps:
		ids := make([]ent.Value, 0, len(m._ProvisioningScheduledSteps))
		for id := range m._ProvisioningScheduledSteps {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeAgentStatuses:
		ids := make([]ent.Value, 0, len(m._AgentStatuses))
		for id := range m._AgentStatuses {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeAgentTasks:
		ids := make([]ent.Value, 0, len(m._AgentTasks))
		for id := range m._AgentTasks {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgePlan:
		if id := m._Plan; id != nil {
			return []ent.Value{*id}
		}
	case provisionedhost.EdgeGinFileMiddleware:
		if id := m._GinFileMiddleware; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProvisionedHostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 11)
	if m.removed_ProvisioningSteps != nil {
		edges = append(edges, provisionedhost.EdgeProvisioningSteps)
	}
	if m.removed_ProvisioningScheduledSteps != nil {
		edges = append(edges, provisionedhost.EdgeProvisioningScheduledSteps)
	}
	if m.removed_AgentStatuses != nil {
		edges = append(edges, provisionedhost.EdgeAgentStatuses)
	}
	if m.removed_AgentTasks != nil {
		edges = append(edges, provisionedhost.EdgeAgentTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProvisionedHostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case provisionedhost.EdgeProvisioningSteps:
		ids := make([]ent.Value, 0, len(m.removed_ProvisioningSteps))
		for id := range m.removed_ProvisioningSteps {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeProvisioningScheduledSteps:
		ids := make([]ent.Value, 0, len(m.removed_ProvisioningScheduledSteps))
		for id := range m.removed_ProvisioningScheduledSteps {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeAgentStatuses:
		ids := make([]ent.Value, 0, len(m.removed_AgentStatuses))
		for id := range m.removed_AgentStatuses {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeAgentTasks:
		ids := make([]ent.Value, 0, len(m.removed_AgentTasks))
		for id := range m.removed_AgentTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProvisionedHostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 11)
	if m.cleared_Status {
		edges = append(edges, provisionedhost.EdgeStatus)
	}
	if m.cleared_ProvisionedNetwork {
		edges = append(edges, provisionedhost.EdgeProvisionedNetwork)
	}
	if m.cleared_Host {
		edges = append(edges, provisionedhost.EdgeHost)
	}
	if m.cleared_EndStepPlan {
		edges = append(edges, provisionedhost.EdgeEndStepPlan)
	}
	if m.cleared_Build {
		edges = append(edges, provisionedhost.EdgeBuild)
	}
	if m.cleared_ProvisioningSteps {
		edges = append(edges, provisionedhost.EdgeProvisioningSteps)
	}
	if m.cleared_ProvisioningScheduledSteps {
		edges = append(edges, provisionedhost.EdgeProvisioningScheduledSteps)
	}
	if m.cleared_AgentStatuses {
		edges = append(edges, provisionedhost.EdgeAgentStatuses)
	}
	if m.cleared_AgentTasks {
		edges = append(edges, provisionedhost.EdgeAgentTasks)
	}
	if m.cleared_Plan {
		edges = append(edges, provisionedhost.EdgePlan)
	}
	if m.cleared_GinFileMiddleware {
		edges = append(edges, provisionedhost.EdgeGinFileMiddleware)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProvisionedHostMutation) EdgeCleared(name string) bool {
	switch name {
	case provisionedhost.EdgeStatus:
		return m.cleared_Status
	case provisionedhost.EdgeProvisionedNetwork:
		return m.cleared_ProvisionedNetwork
	case provisionedhost.EdgeHost:
		return m.cleared_Host
	case provisionedhost.EdgeEndStepPlan:
		return m.cleared_EndStepPlan
	case provisionedhost.EdgeBuild:
		return m.cleared_Build
	case provisionedhost.EdgeProvisioningSteps:
		return m.cleared_ProvisioningSteps
	case provisionedhost.EdgeProvisioningScheduledSteps:
		return m.cleared_ProvisioningScheduledSteps
	case provisionedhost.EdgeAgentStatuses:
		return m.cleared_AgentStatuses
	case provisionedhost.EdgeAgentTasks:
		return m.cleared_AgentTasks
	case provisionedhost.EdgePlan:
		return m.cleared_Plan
	case provisionedhost.EdgeGinFileMiddleware:
		return m.cleared_GinFileMiddleware
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProvisionedHostMutation) ClearEdge(name string) error {
	switch name {
	case provisionedhost.EdgeStatus:
		m.ClearStatus()
		return nil
	case provisionedhost.EdgeProvisionedNetwork:
		m.ClearProvisionedNetwork()
		return nil
	case provisionedhost.EdgeHost:
		m.ClearHost()
		return nil
	case provisionedhost.EdgeEndStepPlan:
		m.ClearEndStepPlan()
		return nil
	case provisionedhost.EdgeBuild:
		m.ClearBuild()
		return nil
	case provisionedhost.EdgePlan:
		m.ClearPlan()
		return nil
	case provisionedhost.EdgeGinFileMiddleware:
		m.ClearGinFileMiddleware()
		return nil
	}
	return fmt.Errorf("unknown ProvisionedHost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProvisionedHostMutation) ResetEdge(name string) error {
	switch name {
	case provisionedhost.EdgeStatus:
		m.ResetStatus()
		return nil
	case provisionedhost.EdgeProvisionedNetwork:
		m.ResetProvisionedNetwork()
		return nil
	case provisionedhost.EdgeHost:
		m.ResetHost()
		return nil
	case provisionedhost.EdgeEndStepPlan:
		m.ResetEndStepPlan()
		return nil
	case provisionedhost.EdgeBuild:
		m.ResetBuild()
		return nil
	case provisionedhost.EdgeProvisioningSteps:
		m.ResetProvisioningSteps()
		return nil
	case provisionedhost.EdgeProvisioningScheduledSteps:
		m.ResetProvisioningScheduledSteps()
		return nil
	case provisionedhost.EdgeAgentStatuses:
		m.ResetAgentStatuses()
		return nil
	case provisionedhost.EdgeAgentTasks:
		m.ResetAgentTasks()
		return nil
	case provisionedhost.EdgePlan:
		m.ResetPlan()
		return nil
	case provisionedhost.EdgeGinFileMiddleware:
		m.ResetGinFileMiddleware()
		return nil
	}
	return fmt.Errorf("unknown ProvisionedHost edge %s", name)
}

// ProvisionedNetworkMutation represents an operation that mutates the ProvisionedNetwork nodes in the graph.
type ProvisionedNetworkMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	name                     *string
	cidr                     *string
	vars                     *map[string]string
	clearedFields            map[string]struct{}
	_Status                  *uuid.UUID
	cleared_Status           bool
	_Network                 *uuid.UUID
	cleared_Network          bool
	_Build                   *uuid.UUID
	cleared_Build            bool
	_Team                    *uuid.UUID
	cleared_Team             bool
	_ProvisionedHosts        map[uuid.UUID]struct{}
	removed_ProvisionedHosts map[uuid.UUID]struct{}
	cleared_ProvisionedHosts bool
	_Plan                    *uuid.UUID
	cleared_Plan             bool
	done                     bool
	oldValue                 func(context.Context) (*ProvisionedNetwork, error)
	predicates               []predicate.ProvisionedNetwork
}

var _ ent.Mutation = (*ProvisionedNetworkMutation)(nil)

// provisionednetworkOption allows management of the mutation configuration using functional options.
type provisionednetworkOption func(*ProvisionedNetworkMutation)

// newProvisionedNetworkMutation creates new mutation for the ProvisionedNetwork entity.
func newProvisionedNetworkMutation(c config, op Op, opts ...provisionednetworkOption) *ProvisionedNetworkMutation {
	m := &ProvisionedNetworkMutation{
		config:        c,
		op:            op,
		typ:           TypeProvisionedNetwork,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProvisionedNetworkID sets the ID field of the mutation.
func withProvisionedNetworkID(id uuid.UUID) provisionednetworkOption {
	return func(m *ProvisionedNetworkMutation) {
		var (
			err   error
			once  sync.Once
			value *ProvisionedNetwork
		)
		m.oldValue = func(ctx context.Context) (*ProvisionedNetwork, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProvisionedNetwork.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvisionedNetwork sets the old ProvisionedNetwork of the mutation.
func withProvisionedNetwork(node *ProvisionedNetwork) provisionednetworkOption {
	return func(m *ProvisionedNetworkMutation) {
		m.oldValue = func(context.Context) (*ProvisionedNetwork, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProvisionedNetworkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProvisionedNetworkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProvisionedNetwork entities.
func (m *ProvisionedNetworkMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProvisionedNetworkMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProvisionedNetworkMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProvisionedNetwork.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProvisionedNetworkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProvisionedNetworkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProvisionedNetwork entity.
// If the ProvisionedNetwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvisionedNetworkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProvisionedNetworkMutation) ResetName() {
	m.name = nil
}

// SetCidr sets the "cidr" field.
func (m *ProvisionedNetworkMutation) SetCidr(s string) {
	m.cidr = &s
}

// Cidr returns the value of the "cidr" field in the mutation.
func (m *ProvisionedNetworkMutation) Cidr() (r string, exists bool) {
	v := m.cidr
	if v == nil {
		return
	}
	return *v, true
}

// OldCidr returns the old "cidr" field's value of the ProvisionedNetwork entity.
// If the ProvisionedNetwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvisionedNetworkMutation) OldCidr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCidr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCidr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCidr: %w", err)
	}
	return oldValue.Cidr, nil
}

// ResetCidr resets all changes to the "cidr" field.
func (m *ProvisionedNetworkMutation) ResetCidr() {
	m.cidr = nil
}

// SetVars sets the "vars" field.
func (m *ProvisionedNetworkMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *ProvisionedNetworkMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the ProvisionedNetwork entity.
// If the ProvisionedNetwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvisionedNetworkMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *ProvisionedNetworkMutation) ResetVars() {
	m.vars = nil
}

// SetStatusID sets the "Status" edge to the Status entity by id.
func (m *ProvisionedNetworkMutation) SetStatusID(id uuid.UUID) {
	m._Status = &id
}

// ClearStatus clears the "Status" edge to the Status entity.
func (m *ProvisionedNetworkMutation) ClearStatus() {
	m.cleared_Status = true
}

// StatusCleared reports if the "Status" edge to the Status entity was cleared.
func (m *ProvisionedNetworkMutation) StatusCleared() bool {
	return m.cleared_Status
}

// StatusID returns the "Status" edge ID in the mutation.
func (m *ProvisionedNetworkMutation) StatusID() (id uuid.UUID, exists bool) {
	if m._Status != nil {
		return *m._Status, true
	}
	return
}

// StatusIDs returns the "Status" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusID instead. It exists only for internal usage by the builders.
func (m *ProvisionedNetworkMutation) StatusIDs() (ids []uuid.UUID) {
	if id := m._Status; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatus resets all changes to the "Status" edge.
func (m *ProvisionedNetworkMutation) ResetStatus() {
	m._Status = nil
	m.cleared_Status = false
}

// SetNetworkID sets the "Network" edge to the Network entity by id.
func (m *ProvisionedNetworkMutation) SetNetworkID(id uuid.UUID) {
	m._Network = &id
}

// ClearNetwork clears the "Network" edge to the Network entity.
func (m *ProvisionedNetworkMutation) ClearNetwork() {
	m.cleared_Network = true
}

// NetworkCleared reports if the "Network" edge to the Network entity was cleared.
func (m *ProvisionedNetworkMutation) NetworkCleared() bool {
	return m.cleared_Network
}

// NetworkID returns the "Network" edge ID in the mutation.
func (m *ProvisionedNetworkMutation) NetworkID() (id uuid.UUID, exists bool) {
	if m._Network != nil {
		return *m._Network, true
	}
	return
}

// NetworkIDs returns the "Network" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NetworkID instead. It exists only for internal usage by the builders.
func (m *ProvisionedNetworkMutation) NetworkIDs() (ids []uuid.UUID) {
	if id := m._Network; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNetwork resets all changes to the "Network" edge.
func (m *ProvisionedNetworkMutation) ResetNetwork() {
	m._Network = nil
	m.cleared_Network = false
}

// SetBuildID sets the "Build" edge to the Build entity by id.
func (m *ProvisionedNetworkMutation) SetBuildID(id uuid.UUID) {
	m._Build = &id
}

// ClearBuild clears the "Build" edge to the Build entity.
func (m *ProvisionedNetworkMutation) ClearBuild() {
	m.cleared_Build = true
}

// BuildCleared reports if the "Build" edge to the Build entity was cleared.
func (m *ProvisionedNetworkMutation) BuildCleared() bool {
	return m.cleared_Build
}

// BuildID returns the "Build" edge ID in the mutation.
func (m *ProvisionedNetworkMutation) BuildID() (id uuid.UUID, exists bool) {
	if m._Build != nil {
		return *m._Build, true
	}
	return
}

// BuildIDs returns the "Build" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuildID instead. It exists only for internal usage by the builders.
func (m *ProvisionedNetworkMutation) BuildIDs() (ids []uuid.UUID) {
	if id := m._Build; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuild resets all changes to the "Build" edge.
func (m *ProvisionedNetworkMutation) ResetBuild() {
	m._Build = nil
	m.cleared_Build = false
}

// SetTeamID sets the "Team" edge to the Team entity by id.
func (m *ProvisionedNetworkMutation) SetTeamID(id uuid.UUID) {
	m._Team = &id
}

// ClearTeam clears the "Team" edge to the Team entity.
func (m *ProvisionedNetworkMutation) ClearTeam() {
	m.cleared_Team = true
}

// TeamCleared reports if the "Team" edge to the Team entity was cleared.
func (m *ProvisionedNetworkMutation) TeamCleared() bool {
	return m.cleared_Team
}

// TeamID returns the "Team" edge ID in the mutation.
func (m *ProvisionedNetworkMutation) TeamID() (id uuid.UUID, exists bool) {
	if m._Team != nil {
		return *m._Team, true
	}
	return
}

// TeamIDs returns the "Team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *ProvisionedNetworkMutation) TeamIDs() (ids []uuid.UUID) {
	if id := m._Team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "Team" edge.
func (m *ProvisionedNetworkMutation) ResetTeam() {
	m._Team = nil
	m.cleared_Team = false
}

// AddProvisionedHostIDs adds the "ProvisionedHosts" edge to the ProvisionedHost entity by ids.
func (m *ProvisionedNetworkMutation) AddProvisionedHostIDs(ids ...uuid.UUID) {
	if m._ProvisionedHosts == nil {
		m._ProvisionedHosts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ProvisionedHosts[ids[i]] = struct{}{}
	}
}

// ClearProvisionedHosts clears the "ProvisionedHosts" edge to the ProvisionedHost entity.
func (m *ProvisionedNetworkMutation) ClearProvisionedHosts() {
	m.cleared_ProvisionedHosts = true
}

// ProvisionedHostsCleared reports if the "ProvisionedHosts" edge to the ProvisionedHost entity was cleared.
func (m *ProvisionedNetworkMutation) ProvisionedHostsCleared() bool {
	return m.cleared_ProvisionedHosts
}

// RemoveProvisionedHostIDs removes the "ProvisionedHosts" edge to the ProvisionedHost entity by IDs.
func (m *ProvisionedNetworkMutation) RemoveProvisionedHostIDs(ids ...uuid.UUID) {
	if m.removed_ProvisionedHosts == nil {
		m.removed_ProvisionedHosts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._ProvisionedHosts, ids[i])
		m.removed_ProvisionedHosts[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedHosts returns the removed IDs of the "ProvisionedHosts" edge to the ProvisionedHost entity.
func (m *ProvisionedNetworkMutation) RemovedProvisionedHostsIDs() (ids []uuid.UUID) {
	for id := range m.removed_ProvisionedHosts {
		ids = append(ids, id)
	}
	return
}

// ProvisionedHostsIDs returns the "ProvisionedHosts" edge IDs in the mutation.
func (m *ProvisionedNetworkMutation) ProvisionedHostsIDs() (ids []uuid.UUID) {
	for id := range m._ProvisionedHosts {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedHosts resets all changes to the "ProvisionedHosts" edge.
func (m *ProvisionedNetworkMutation) ResetProvisionedHosts() {
	m._ProvisionedHosts = nil
	m.cleared_ProvisionedHosts = false
	m.removed_ProvisionedHosts = nil
}

// SetPlanID sets the "Plan" edge to the Plan entity by id.
func (m *ProvisionedNetworkMutation) SetPlanID(id uuid.UUID) {
	m._Plan = &id
}

// ClearPlan clears the "Plan" edge to the Plan entity.
func (m *ProvisionedNetworkMutation) ClearPlan() {
	m.cleared_Plan = true
}

// PlanCleared reports if the "Plan" edge to the Plan entity was cleared.
func (m *ProvisionedNetworkMutation) PlanCleared() bool {
	return m.cleared_Plan
}

// PlanID returns the "Plan" edge ID in the mutation.
func (m *ProvisionedNetworkMutation) PlanID() (id uuid.UUID, exists bool) {
	if m._Plan != nil {
		return *m._Plan, true
	}
	return
}

// PlanIDs returns the "Plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *ProvisionedNetworkMutation) PlanIDs() (ids []uuid.UUID) {
	if id := m._Plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "Plan" edge.
func (m *ProvisionedNetworkMutation) ResetPlan() {
	m._Plan = nil
	m.cleared_Plan = false
}

// Where appends a list predicates to the ProvisionedNetworkMutation builder.
func (m *ProvisionedNetworkMutation) Where(ps ...predicate.ProvisionedNetwork) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProvisionedNetworkMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProvisionedNetwork).
func (m *ProvisionedNetworkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProvisionedNetworkMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, provisionednetwork.FieldName)
	}
	if m.cidr != nil {
		fields = append(fields, provisionednetwork.FieldCidr)
	}
	if m.vars != nil {
		fields = append(fields, provisionednetwork.FieldVars)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProvisionedNetworkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case provisionednetwork.FieldName:
		return m.Name()
	case provisionednetwork.FieldCidr:
		return m.Cidr()
	case provisionednetwork.FieldVars:
		return m.Vars()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProvisionedNetworkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case provisionednetwork.FieldName:
		return m.OldName(ctx)
	case provisionednetwork.FieldCidr:
		return m.OldCidr(ctx)
	case provisionednetwork.FieldVars:
		return m.OldVars(ctx)
	}
	return nil, fmt.Errorf("unknown ProvisionedNetwork field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvisionedNetworkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case provisionednetwork.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case provisionednetwork.FieldCidr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCidr(v)
		return nil
	case provisionednetwork.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	}
	return fmt.Errorf("unknown ProvisionedNetwork field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProvisionedNetworkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProvisionedNetworkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvisionedNetworkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProvisionedNetwork numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProvisionedNetworkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProvisionedNetworkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProvisionedNetworkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProvisionedNetwork nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProvisionedNetworkMutation) ResetField(name string) error {
	switch name {
	case provisionednetwork.FieldName:
		m.ResetName()
		return nil
	case provisionednetwork.FieldCidr:
		m.ResetCidr()
		return nil
	case provisionednetwork.FieldVars:
		m.ResetVars()
		return nil
	}
	return fmt.Errorf("unknown ProvisionedNetwork field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProvisionedNetworkMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m._Status != nil {
		edges = append(edges, provisionednetwork.EdgeStatus)
	}
	if m._Network != nil {
		edges = append(edges, provisionednetwork.EdgeNetwork)
	}
	if m._Build != nil {
		edges = append(edges, provisionednetwork.EdgeBuild)
	}
	if m._Team != nil {
		edges = append(edges, provisionednetwork.EdgeTeam)
	}
	if m._ProvisionedHosts != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedHosts)
	}
	if m._Plan != nil {
		edges = append(edges, provisionednetwork.EdgePlan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProvisionedNetworkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case provisionednetwork.EdgeStatus:
		if id := m._Status; id != nil {
			return []ent.Value{*id}
		}
	case provisionednetwork.EdgeNetwork:
		if id := m._Network; id != nil {
			return []ent.Value{*id}
		}
	case provisionednetwork.EdgeBuild:
		if id := m._Build; id != nil {
			return []ent.Value{*id}
		}
	case provisionednetwork.EdgeTeam:
		if id := m._Team; id != nil {
			return []ent.Value{*id}
		}
	case provisionednetwork.EdgeProvisionedHosts:
		ids := make([]ent.Value, 0, len(m._ProvisionedHosts))
		for id := range m._ProvisionedHosts {
			ids = append(ids, id)
		}
		return ids
	case provisionednetwork.EdgePlan:
		if id := m._Plan; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProvisionedNetworkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removed_ProvisionedHosts != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedHosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProvisionedNetworkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case provisionednetwork.EdgeProvisionedHosts:
		ids := make([]ent.Value, 0, len(m.removed_ProvisionedHosts))
		for id := range m.removed_ProvisionedHosts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProvisionedNetworkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleared_Status {
		edges = append(edges, provisionednetwork.EdgeStatus)
	}
	if m.cleared_Network {
		edges = append(edges, provisionednetwork.EdgeNetwork)
	}
	if m.cleared_Build {
		edges = append(edges, provisionednetwork.EdgeBuild)
	}
	if m.cleared_Team {
		edges = append(edges, provisionednetwork.EdgeTeam)
	}
	if m.cleared_ProvisionedHosts {
		edges = append(edges, provisionednetwork.EdgeProvisionedHosts)
	}
	if m.cleared_Plan {
		edges = append(edges, provisionednetwork.EdgePlan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProvisionedNetworkMutation) EdgeCleared(name string) bool {
	switch name {
	case provisionednetwork.EdgeStatus:
		return m.cleared_Status
	case provisionednetwork.EdgeNetwork:
		return m.cleared_Network
	case provisionednetwork.EdgeBuild:
		return m.cleared_Build
	case provisionednetwork.EdgeTeam:
		return m.cleared_Team
	case provisionednetwork.EdgeProvisionedHosts:
		return m.cleared_ProvisionedHosts
	case provisionednetwork.EdgePlan:
		return m.cleared_Plan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProvisionedNetworkMutation) ClearEdge(name string) error {
	switch name {
	case provisionednetwork.EdgeStatus:
		m.ClearStatus()
		return nil
	case provisionednetwork.EdgeNetwork:
		m.ClearNetwork()
		return nil
	case provisionednetwork.EdgeBuild:
		m.ClearBuild()
		return nil
	case provisionednetwork.EdgeTeam:
		m.ClearTeam()
		return nil
	case provisionednetwork.EdgePlan:
		m.ClearPlan()
		return nil
	}
	return fmt.Errorf("unknown ProvisionedNetwork unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProvisionedNetworkMutation) ResetEdge(name string) error {
	switch name {
	case provisionednetwork.EdgeStatus:
		m.ResetStatus()
		return nil
	case provisionednetwork.EdgeNetwork:
		m.ResetNetwork()
		return nil
	case provisionednetwork.EdgeBuild:
		m.ResetBuild()
		return nil
	case provisionednetwork.EdgeTeam:
		m.ResetTeam()
		return nil
	case provisionednetwork.EdgeProvisionedHosts:
		m.ResetProvisionedHosts()
		return nil
	case provisionednetwork.EdgePlan:
		m.ResetPlan()
		return nil
	}
	return fmt.Errorf("unknown ProvisionedNetwork edge %s", name)
}

// ProvisioningScheduledStepMutation represents an operation that mutates the ProvisioningScheduledStep nodes in the graph.
type ProvisioningScheduledStepMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	_type                     *provisioningscheduledstep.Type
	run_time                  *time.Time
	clearedFields             map[string]struct{}
	_Status                   *uuid.UUID
	cleared_Status            bool
	_ScheduledStep            *uuid.UUID
	cleared_ScheduledStep     bool
	_ProvisionedHost          *uuid.UUID
	cleared_ProvisionedHost   bool
	_Script                   *uuid.UUID
	cleared_Script            bool
	_Command                  *uuid.UUID
	cleared_Command           bool
	_DNSRecord                *uuid.UUID
	cleared_DNSRecord         bool
	_FileDelete               *uuid.UUID
	cleared_FileDelete        bool
	_FileDownload             *uuid.UUID
	cleared_FileDownload      bool
	_FileExtract              *uuid.UUID
	cleared_FileExtract       bool
	_Ansible                  *uuid.UUID
	cleared_Ansible           bool
	_AgentTasks               map[uuid.UUID]struct{}
	removed_AgentTasks        map[uuid.UUID]struct{}
	cleared_AgentTasks        bool
	_Plan                     *uuid.UUID
	cleared_Plan              bool
	_GinFileMiddleware        *uuid.UUID
	cleared_GinFileMiddleware bool
	done                      bool
	oldValue                  func(context.Context) (*ProvisioningScheduledStep, error)
	predicates                []predicate.ProvisioningScheduledStep
}

var _ ent.Mutation = (*ProvisioningScheduledStepMutation)(nil)

// provisioningscheduledstepOption allows management of the mutation configuration using functional options.
type provisioningscheduledstepOption func(*ProvisioningScheduledStepMutation)

// newProvisioningScheduledStepMutation creates new mutation for the ProvisioningScheduledStep entity.
func newProvisioningScheduledStepMutation(c config, op Op, opts ...provisioningscheduledstepOption) *ProvisioningScheduledStepMutation {
	m := &ProvisioningScheduledStepMutation{
		config:        c,
		op:            op,
		typ:           TypeProvisioningScheduledStep,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProvisioningScheduledStepID sets the ID field of the mutation.
func withProvisioningScheduledStepID(id uuid.UUID) provisioningscheduledstepOption {
	return func(m *ProvisioningScheduledStepMutation) {
		var (
			err   error
			once  sync.Once
			value *ProvisioningScheduledStep
		)
		m.oldValue = func(ctx context.Context) (*ProvisioningScheduledStep, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProvisioningScheduledStep.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvisioningScheduledStep sets the old ProvisioningScheduledStep of the mutation.
func withProvisioningScheduledStep(node *ProvisioningScheduledStep) provisioningscheduledstepOption {
	return func(m *ProvisioningScheduledStepMutation) {
		m.oldValue = func(context.Context) (*ProvisioningScheduledStep, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProvisioningScheduledStepMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProvisioningScheduledStepMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProvisioningScheduledStep entities.
func (m *ProvisioningScheduledStepMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProvisioningScheduledStepMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProvisioningScheduledStepMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProvisioningScheduledStep.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *ProvisioningScheduledStepMutation) SetType(pr provisioningscheduledstep.Type) {
	m._type = &pr
}

// GetType returns the value of the "type" field in the mutation.
func (m *ProvisioningScheduledStepMutation) GetType() (r provisioningscheduledstep.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ProvisioningScheduledStep entity.
// If the ProvisioningScheduledStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvisioningScheduledStepMutation) OldType(ctx context.Context) (v provisioningscheduledstep.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ProvisioningScheduledStepMutation) ResetType() {
	m._type = nil
}

// SetRunTime sets the "run_time" field.
func (m *ProvisioningScheduledStepMutation) SetRunTime(t time.Time) {
	m.run_time = &t
}

// RunTime returns the value of the "run_time" field in the mutation.
func (m *ProvisioningScheduledStepMutation) RunTime() (r time.Time, exists bool) {
	v := m.run_time
	if v == nil {
		return
	}
	return *v, true
}

// OldRunTime returns the old "run_time" field's value of the ProvisioningScheduledStep entity.
// If the ProvisioningScheduledStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvisioningScheduledStepMutation) OldRunTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunTime: %w", err)
	}
	return oldValue.RunTime, nil
}

// ResetRunTime resets all changes to the "run_time" field.
func (m *ProvisioningScheduledStepMutation) ResetRunTime() {
	m.run_time = nil
}

// SetStatusID sets the "Status" edge to the Status entity by id.
func (m *ProvisioningScheduledStepMutation) SetStatusID(id uuid.UUID) {
	m._Status = &id
}

// ClearStatus clears the "Status" edge to the Status entity.
func (m *ProvisioningScheduledStepMutation) ClearStatus() {
	m.cleared_Status = true
}

// StatusCleared reports if the "Status" edge to the Status entity was cleared.
func (m *ProvisioningScheduledStepMutation) StatusCleared() bool {
	return m.cleared_Status
}

// StatusID returns the "Status" edge ID in the mutation.
func (m *ProvisioningScheduledStepMutation) StatusID() (id uuid.UUID, exists bool) {
	if m._Status != nil {
		return *m._Status, true
	}
	return
}

// StatusIDs returns the "Status" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusID instead. It exists only for internal usage by the builders.
func (m *ProvisioningScheduledStepMutation) StatusIDs() (ids []uuid.UUID) {
	if id := m._Status; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatus resets all changes to the "Status" edge.
func (m *ProvisioningScheduledStepMutation) ResetStatus() {
	m._Status = nil
	m.cleared_Status = false
}

// SetScheduledStepID sets the "ScheduledStep" edge to the ScheduledStep entity by id.
func (m *ProvisioningScheduledStepMutation) SetScheduledStepID(id uuid.UUID) {
	m._ScheduledStep = &id
}

// ClearScheduledStep clears the "ScheduledStep" edge to the ScheduledStep entity.
func (m *ProvisioningScheduledStepMutation) ClearScheduledStep() {
	m.cleared_ScheduledStep = true
}

// ScheduledStepCleared reports if the "ScheduledStep" edge to the ScheduledStep entity was cleared.
func (m *ProvisioningScheduledStepMutation) ScheduledStepCleared() bool {
	return m.cleared_ScheduledStep
}

// ScheduledStepID returns the "ScheduledStep" edge ID in the mutation.
func (m *ProvisioningScheduledStepMutation) ScheduledStepID() (id uuid.UUID, exists bool) {
	if m._ScheduledStep != nil {
		return *m._ScheduledStep, true
	}
	return
}

// ScheduledStepIDs returns the "ScheduledStep" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScheduledStepID instead. It exists only for internal usage by the builders.
func (m *ProvisioningScheduledStepMutation) ScheduledStepIDs() (ids []uuid.UUID) {
	if id := m._ScheduledStep; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetScheduledStep resets all changes to the "ScheduledStep" edge.
func (m *ProvisioningScheduledStepMutation) ResetScheduledStep() {
	m._ScheduledStep = nil
	m.cleared_ScheduledStep = false
}

// SetProvisionedHostID sets the "ProvisionedHost" edge to the ProvisionedHost entity by id.
func (m *ProvisioningScheduledStepMutation) SetProvisionedHostID(id uuid.UUID) {
	m._ProvisionedHost = &id
}

// ClearProvisionedHost clears the "ProvisionedHost" edge to the ProvisionedHost entity.
func (m *ProvisioningScheduledStepMutation) ClearProvisionedHost() {
	m.cleared_ProvisionedHost = true
}

// ProvisionedHostCleared reports if the "ProvisionedHost" edge to the ProvisionedHost entity was cleared.
func (m *ProvisioningScheduledStepMutation) ProvisionedHostCleared() bool {
	return m.cleared_ProvisionedHost
}

// ProvisionedHostID returns the "ProvisionedHost" edge ID in the mutation.
func (m *ProvisioningScheduledStepMutation) ProvisionedHostID() (id uuid.UUID, exists bool) {
	if m._ProvisionedHost != nil {
		return *m._ProvisionedHost, true
	}
	return
}

// ProvisionedHostIDs returns the "ProvisionedHost" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisionedHostID instead. It exists only for internal usage by the builders.
func (m *ProvisioningScheduledStepMutation) ProvisionedHostIDs() (ids []uuid.UUID) {
	if id := m._ProvisionedHost; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisionedHost resets all changes to the "ProvisionedHost" edge.
func (m *ProvisioningScheduledStepMutation) ResetProvisionedHost() {
	m._ProvisionedHost = nil
	m.cleared_ProvisionedHost = false
}

// SetScriptID sets the "Script" edge to the Script entity by id.
func (m *ProvisioningScheduledStepMutation) SetScriptID(id uuid.UUID) {
	m._Script = &id
}

// ClearScript clears the "Script" edge to the Script entity.
func (m *ProvisioningScheduledStepMutation) ClearScript() {
	m.cleared_Script = true
}

// ScriptCleared reports if the "Script" edge to the Script entity was cleared.
func (m *ProvisioningScheduledStepMutation) ScriptCleared() bool {
	return m.cleared_Script
}

// ScriptID returns the "Script" edge ID in the mutation.
func (m *ProvisioningScheduledStepMutation) ScriptID() (id uuid.UUID, exists bool) {
	if m._Script != nil {
		return *m._Script, true
	}
	return
}

// ScriptIDs returns the "Script" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScriptID instead. It exists only for internal usage by the builders.
func (m *ProvisioningScheduledStepMutation) ScriptIDs() (ids []uuid.UUID) {
	if id := m._Script; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetScript resets all changes to the "Script" edge.
func (m *ProvisioningScheduledStepMutation) ResetScript() {
	m._Script = nil
	m.cleared_Script = false
}

// SetCommandID sets the "Command" edge to the Command entity by id.
func (m *ProvisioningScheduledStepMutation) SetCommandID(id uuid.UUID) {
	m._Command = &id
}

// ClearCommand clears the "Command" edge to the Command entity.
func (m *ProvisioningScheduledStepMutation) ClearCommand() {
	m.cleared_Command = true
}

// CommandCleared reports if the "Command" edge to the Command entity was cleared.
func (m *ProvisioningScheduledStepMutation) CommandCleared() bool {
	return m.cleared_Command
}

// CommandID returns the "Command" edge ID in the mutation.
func (m *ProvisioningScheduledStepMutation) CommandID() (id uuid.UUID, exists bool) {
	if m._Command != nil {
		return *m._Command, true
	}
	return
}

// CommandIDs returns the "Command" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommandID instead. It exists only for internal usage by the builders.
func (m *ProvisioningScheduledStepMutation) CommandIDs() (ids []uuid.UUID) {
	if id := m._Command; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCommand resets all changes to the "Command" edge.
func (m *ProvisioningScheduledStepMutation) ResetCommand() {
	m._Command = nil
	m.cleared_Command = false
}

// SetDNSRecordID sets the "DNSRecord" edge to the DNSRecord entity by id.
func (m *ProvisioningScheduledStepMutation) SetDNSRecordID(id uuid.UUID) {
	m._DNSRecord = &id
}

// ClearDNSRecord clears the "DNSRecord" edge to the DNSRecord entity.
func (m *ProvisioningScheduledStepMutation) ClearDNSRecord() {
	m.cleared_DNSRecord = true
}

// DNSRecordCleared reports if the "DNSRecord" edge to the DNSRecord entity was cleared.
func (m *ProvisioningScheduledStepMutation) DNSRecordCleared() bool {
	return m.cleared_DNSRecord
}

// DNSRecordID returns the "DNSRecord" edge ID in the mutation.
func (m *ProvisioningScheduledStepMutation) DNSRecordID() (id uuid.UUID, exists bool) {
	if m._DNSRecord != nil {
		return *m._DNSRecord, true
	}
	return
}

// DNSRecordIDs returns the "DNSRecord" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DNSRecordID instead. It exists only for internal usage by the builders.
func (m *ProvisioningScheduledStepMutation) DNSRecordIDs() (ids []uuid.UUID) {
	if id := m._DNSRecord; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDNSRecord resets all changes to the "DNSRecord" edge.
func (m *ProvisioningScheduledStepMutation) ResetDNSRecord() {
	m._DNSRecord = nil
	m.cleared_DNSRecord = false
}

// SetFileDeleteID sets the "FileDelete" edge to the FileDelete entity by id.
func (m *ProvisioningScheduledStepMutation) SetFileDeleteID(id uuid.UUID) {
	m._FileDelete = &id
}

// ClearFileDelete clears the "FileDelete" edge to the FileDelete entity.
func (m *ProvisioningScheduledStepMutation) ClearFileDelete() {
	m.cleared_FileDelete = true
}

// FileDeleteCleared reports if the "FileDelete" edge to the FileDelete entity was cleared.
func (m *ProvisioningScheduledStepMutation) FileDeleteCleared() bool {
	return m.cleared_FileDelete
}

// FileDeleteID returns the "FileDelete" edge ID in the mutation.
func (m *ProvisioningScheduledStepMutation) FileDeleteID() (id uuid.UUID, exists bool) {
	if m._FileDelete != nil {
		return *m._FileDelete, true
	}
	return
}

// FileDeleteIDs returns the "FileDelete" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileDeleteID instead. It exists only for internal usage by the builders.
func (m *ProvisioningScheduledStepMutation) FileDeleteIDs() (ids []uuid.UUID) {
	if id := m._FileDelete; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFileDelete resets all changes to the "FileDelete" edge.
func (m *ProvisioningScheduledStepMutation) ResetFileDelete() {
	m._FileDelete = nil
	m.cleared_FileDelete = false
}

// SetFileDownloadID sets the "FileDownload" edge to the FileDownload entity by id.
func (m *ProvisioningScheduledStepMutation) SetFileDownloadID(id uuid.UUID) {
	m._FileDownload = &id
}

// ClearFileDownload clears the "FileDownload" edge to the FileDownload entity.
func (m *ProvisioningScheduledStepMutation) ClearFileDownload() {
	m.cleared_FileDownload = true
}

// FileDownloadCleared reports if the "FileDownload" edge to the FileDownload entity was cleared.
func (m *ProvisioningScheduledStepMutation) FileDownloadCleared() bool {
	return m.cleared_FileDownload
}

// FileDownloadID returns the "FileDownload" edge ID in the mutation.
func (m *ProvisioningScheduledStepMutation) FileDownloadID() (id uuid.UUID, exists bool) {
	if m._FileDownload != nil {
		return *m._FileDownload, true
	}
	return
}

// FileDownloadIDs returns the "FileDownload" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileDownloadID instead. It exists only for internal usage by the builders.
func (m *ProvisioningScheduledStepMutation) FileDownloadIDs() (ids []uuid.UUID) {
	if id := m._FileDownload; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFileDownload resets all changes to the "FileDownload" edge.
func (m *ProvisioningScheduledStepMutation) ResetFileDownload() {
	m._FileDownload = nil
	m.cleared_FileDownload = false
}

// SetFileExtractID sets the "FileExtract" edge to the FileExtract entity by id.
func (m *ProvisioningScheduledStepMutation) SetFileExtractID(id uuid.UUID) {
	m._FileExtract = &id
}

// ClearFileExtract clears the "FileExtract" edge to the FileExtract entity.
func (m *ProvisioningScheduledStepMutation) ClearFileExtract() {
	m.cleared_FileExtract = true
}

// FileExtractCleared reports if the "FileExtract" edge to the FileExtract entity was cleared.
func (m *ProvisioningScheduledStepMutation) FileExtractCleared() bool {
	return m.cleared_FileExtract
}

// FileExtractID returns the "FileExtract" edge ID in the mutation.
func (m *ProvisioningScheduledStepMutation) FileExtractID() (id uuid.UUID, exists bool) {
	if m._FileExtract != nil {
		return *m._FileExtract, true
	}
	return
}

// FileExtractIDs returns the "FileExtract" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileExtractID instead. It exists only for internal usage by the builders.
func (m *ProvisioningScheduledStepMutation) FileExtractIDs() (ids []uuid.UUID) {
	if id := m._FileExtract; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFileExtract resets all changes to the "FileExtract" edge.
func (m *ProvisioningScheduledStepMutation) ResetFileExtract() {
	m._FileExtract = nil
	m.cleared_FileExtract = false
}

// SetAnsibleID sets the "Ansible" edge to the Ansible entity by id.
func (m *ProvisioningScheduledStepMutation) SetAnsibleID(id uuid.UUID) {
	m._Ansible = &id
}

// ClearAnsible clears the "Ansible" edge to the Ansible entity.
func (m *ProvisioningScheduledStepMutation) ClearAnsible() {
	m.cleared_Ansible = true
}

// AnsibleCleared reports if the "Ansible" edge to the Ansible entity was cleared.
func (m *ProvisioningScheduledStepMutation) AnsibleCleared() bool {
	return m.cleared_Ansible
}

// AnsibleID returns the "Ansible" edge ID in the mutation.
func (m *ProvisioningScheduledStepMutation) AnsibleID() (id uuid.UUID, exists bool) {
	if m._Ansible != nil {
		return *m._Ansible, true
	}
	return
}

// AnsibleIDs returns the "Ansible" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AnsibleID instead. It exists only for internal usage by the builders.
func (m *ProvisioningScheduledStepMutation) AnsibleIDs() (ids []uuid.UUID) {
	if id := m._Ansible; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAnsible resets all changes to the "Ansible" edge.
func (m *ProvisioningScheduledStepMutation) ResetAnsible() {
	m._Ansible = nil
	m.cleared_Ansible = false
}

// AddAgentTaskIDs adds the "AgentTasks" edge to the AgentTask entity by ids.
func (m *ProvisioningScheduledStepMutation) AddAgentTaskIDs(ids ...uuid.UUID) {
	if m._AgentTasks == nil {
		m._AgentTasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._AgentTasks[ids[i]] = struct{}{}
	}
}

// ClearAgentTasks clears the "AgentTasks" edge to the AgentTask entity.
func (m *ProvisioningScheduledStepMutation) ClearAgentTasks() {
	m.cleared_AgentTasks = true
}

// AgentTasksCleared reports if the "AgentTasks" edge to the AgentTask entity was cleared.
func (m *ProvisioningScheduledStepMutation) AgentTasksCleared() bool {
	return m.cleared_AgentTasks
}

// RemoveAgentTaskIDs removes the "AgentTasks" edge to the AgentTask entity by IDs.
func (m *ProvisioningScheduledStepMutation) RemoveAgentTaskIDs(ids ...uuid.UUID) {
	if m.removed_AgentTasks == nil {
		m.removed_AgentTasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._AgentTasks, ids[i])
		m.removed_AgentTasks[ids[i]] = struct{}{}
	}
}

// RemovedAgentTasks returns the removed IDs of the "AgentTasks" edge to the AgentTask entity.
func (m *ProvisioningScheduledStepMutation) RemovedAgentTasksIDs() (ids []uuid.UUID) {
	for id := range m.removed_AgentTasks {
		ids = append(ids, id)
	}
	return
}

// AgentTasksIDs returns the "AgentTasks" edge IDs in the mutation.
func (m *ProvisioningScheduledStepMutation) AgentTasksIDs() (ids []uuid.UUID) {
	for id := range m._AgentTasks {
		ids = append(ids, id)
	}
	return
}

// ResetAgentTasks resets all changes to the "AgentTasks" edge.
func (m *ProvisioningScheduledStepMutation) ResetAgentTasks() {
	m._AgentTasks = nil
	m.cleared_AgentTasks = false
	m.removed_AgentTasks = nil
}

// SetPlanID sets the "Plan" edge to the Plan entity by id.
func (m *ProvisioningScheduledStepMutation) SetPlanID(id uuid.UUID) {
	m._Plan = &id
}

// ClearPlan clears the "Plan" edge to the Plan entity.
func (m *ProvisioningScheduledStepMutation) ClearPlan() {
	m.cleared_Plan = true
}

// PlanCleared reports if the "Plan" edge to the Plan entity was cleared.
func (m *ProvisioningScheduledStepMutation) PlanCleared() bool {
	return m.cleared_Plan
}

// PlanID returns the "Plan" edge ID in the mutation.
func (m *ProvisioningScheduledStepMutation) PlanID() (id uuid.UUID, exists bool) {
	if m._Plan != nil {
		return *m._Plan, true
	}
	return
}

// PlanIDs returns the "Plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *ProvisioningScheduledStepMutation) PlanIDs() (ids []uuid.UUID) {
	if id := m._Plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "Plan" edge.
func (m *ProvisioningScheduledStepMutation) ResetPlan() {
	m._Plan = nil
	m.cleared_Plan = false
}

// SetGinFileMiddlewareID sets the "GinFileMiddleware" edge to the GinFileMiddleware entity by id.
func (m *ProvisioningScheduledStepMutation) SetGinFileMiddlewareID(id uuid.UUID) {
	m._GinFileMiddleware = &id
}

// ClearGinFileMiddleware clears the "GinFileMiddleware" edge to the GinFileMiddleware entity.
func (m *ProvisioningScheduledStepMutation) ClearGinFileMiddleware() {
	m.cleared_GinFileMiddleware = true
}

// GinFileMiddlewareCleared reports if the "GinFileMiddleware" edge to the GinFileMiddleware entity was cleared.
func (m *ProvisioningScheduledStepMutation) GinFileMiddlewareCleared() bool {
	return m.cleared_GinFileMiddleware
}

// GinFileMiddlewareID returns the "GinFileMiddleware" edge ID in the mutation.
func (m *ProvisioningScheduledStepMutation) GinFileMiddlewareID() (id uuid.UUID, exists bool) {
	if m._GinFileMiddleware != nil {
		return *m._GinFileMiddleware, true
	}
	return
}

// GinFileMiddlewareIDs returns the "GinFileMiddleware" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GinFileMiddlewareID instead. It exists only for internal usage by the builders.
func (m *ProvisioningScheduledStepMutation) GinFileMiddlewareIDs() (ids []uuid.UUID) {
	if id := m._GinFileMiddleware; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGinFileMiddleware resets all changes to the "GinFileMiddleware" edge.
func (m *ProvisioningScheduledStepMutation) ResetGinFileMiddleware() {
	m._GinFileMiddleware = nil
	m.cleared_GinFileMiddleware = false
}

// Where appends a list predicates to the ProvisioningScheduledStepMutation builder.
func (m *ProvisioningScheduledStepMutation) Where(ps ...predicate.ProvisioningScheduledStep) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProvisioningScheduledStepMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProvisioningScheduledStep).
func (m *ProvisioningScheduledStepMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProvisioningScheduledStepMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._type != nil {
		fields = append(fields, provisioningscheduledstep.FieldType)
	}
	if m.run_time != nil {
		fields = append(fields, provisioningscheduledstep.FieldRunTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProvisioningScheduledStepMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case provisioningscheduledstep.FieldType:
		return m.GetType()
	case provisioningscheduledstep.FieldRunTime:
		return m.RunTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProvisioningScheduledStepMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case provisioningscheduledstep.FieldType:
		return m.OldType(ctx)
	case provisioningscheduledstep.FieldRunTime:
		return m.OldRunTime(ctx)
	}
	return nil, fmt.Errorf("unknown ProvisioningScheduledStep field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvisioningScheduledStepMutation) SetField(name string, value ent.Value) error {
	switch name {
	case provisioningscheduledstep.FieldType:
		v, ok := value.(provisioningscheduledstep.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case provisioningscheduledstep.FieldRunTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunTime(v)
		return nil
	}
	return fmt.Errorf("unknown ProvisioningScheduledStep field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProvisioningScheduledStepMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProvisioningScheduledStepMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvisioningScheduledStepMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProvisioningScheduledStep numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProvisioningScheduledStepMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProvisioningScheduledStepMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProvisioningScheduledStepMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProvisioningScheduledStep nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProvisioningScheduledStepMutation) ResetField(name string) error {
	switch name {
	case provisioningscheduledstep.FieldType:
		m.ResetType()
		return nil
	case provisioningscheduledstep.FieldRunTime:
		m.ResetRunTime()
		return nil
	}
	return fmt.Errorf("unknown ProvisioningScheduledStep field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProvisioningScheduledStepMutation) AddedEdges() []string {
	edges := make([]string, 0, 13)
	if m._Status != nil {
		edges = append(edges, provisioningscheduledstep.EdgeStatus)
	}
	if m._ScheduledStep != nil {
		edges = append(edges, provisioningscheduledstep.EdgeScheduledStep)
	}
	if m._ProvisionedHost != nil {
		edges = append(edges, provisioningscheduledstep.EdgeProvisionedHost)
	}
	if m._Script != nil {
		edges = append(edges, provisioningscheduledstep.EdgeScript)
	}
	if m._Command != nil {
		edges = append(edges, provisioningscheduledstep.EdgeCommand)
	}
	if m._DNSRecord != nil {
		edges = append(edges, provisioningscheduledstep.EdgeDNSRecord)
	}
	if m._FileDelete != nil {
		edges = append(edges, provisioningscheduledstep.EdgeFileDelete)
	}
	if m._FileDownload != nil {
		edges = append(edges, provisioningscheduledstep.EdgeFileDownload)
	}
	if m._FileExtract != nil {
		edges = append(edges, provisioningscheduledstep.EdgeFileExtract)
	}
	if m._Ansible != nil {
		edges = append(edges, provisioningscheduledstep.EdgeAnsible)
	}
	if m._AgentTasks != nil {
		edges = append(edges, provisioningscheduledstep.EdgeAgentTasks)
	}
	if m._Plan != nil {
		edges = append(edges, provisioningscheduledstep.EdgePlan)
	}
	if m._GinFileMiddleware != nil {
		edges = append(edges, provisioningscheduledstep.EdgeGinFileMiddleware)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProvisioningScheduledStepMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case provisioningscheduledstep.EdgeStatus:
		if id := m._Status; id != nil {
			return []ent.Value{*id}
		}
	case provisioningscheduledstep.EdgeScheduledStep:
		if id := m._ScheduledStep; id != nil {
			return []ent.Value{*id}
		}
	case provisioningscheduledstep.EdgeProvisionedHost:
		if id := m._ProvisionedHost; id != nil {
			return []ent.Value{*id}
		}
	case provisioningscheduledstep.EdgeScript:
		if id := m._Script; id != nil {
			return []ent.Value{*id}
		}
	case provisioningscheduledstep.EdgeCommand:
		if id := m._Command; id != nil {
			return []ent.Value{*id}
		}
	case provisioningscheduledstep.EdgeDNSRecord:
		if id := m._DNSRecord; id != nil {
			return []ent.Value{*id}
		}
	case provisioningscheduledstep.EdgeFileDelete:
		if id := m._FileDelete; id != nil {
			return []ent.Value{*id}
		}
	case provisioningscheduledstep.EdgeFileDownload:
		if id := m._FileDownload; id != nil {
			return []ent.Value{*id}
		}
	case provisioningscheduledstep.EdgeFileExtract:
		if id := m._FileExtract; id != nil {
			return []ent.Value{*id}
		}
	case provisioningscheduledstep.EdgeAnsible:
		if id := m._Ansible; id != nil {
			return []ent.Value{*id}
		}
	case provisioningscheduledstep.EdgeAgentTasks:
		ids := make([]ent.Value, 0, len(m._AgentTasks))
		for id := range m._AgentTasks {
			ids = append(ids, id)
		}
		return ids
	case provisioningscheduledstep.EdgePlan:
		if id := m._Plan; id != nil {
			return []ent.Value{*id}
		}
	case provisioningscheduledstep.EdgeGinFileMiddleware:
		if id := m._GinFileMiddleware; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProvisioningScheduledStepMutation) RemovedEdges() []string {
	edges := make([]string, 0, 13)
	if m.removed_AgentTasks != nil {
		edges = append(edges, provisioningscheduledstep.EdgeAgentTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProvisioningScheduledStepMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case provisioningscheduledstep.EdgeAgentTasks:
		ids := make([]ent.Value, 0, len(m.removed_AgentTasks))
		for id := range m.removed_AgentTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProvisioningScheduledStepMutation) ClearedEdges() []string {
	edges := make([]string, 0, 13)
	if m.cleared_Status {
		edges = append(edges, provisioningscheduledstep.EdgeStatus)
	}
	if m.cleared_ScheduledStep {
		edges = append(edges, provisioningscheduledstep.EdgeScheduledStep)
	}
	if m.cleared_ProvisionedHost {
		edges = append(edges, provisioningscheduledstep.EdgeProvisionedHost)
	}
	if m.cleared_Script {
		edges = append(edges, provisioningscheduledstep.EdgeScript)
	}
	if m.cleared_Command {
		edges = append(edges, provisioningscheduledstep.EdgeCommand)
	}
	if m.cleared_DNSRecord {
		edges = append(edges, provisioningscheduledstep.EdgeDNSRecord)
	}
	if m.cleared_FileDelete {
		edges = append(edges, provisioningscheduledstep.EdgeFileDelete)
	}
	if m.cleared_FileDownload {
		edges = append(edges, provisioningscheduledstep.EdgeFileDownload)
	}
	if m.cleared_FileExtract {
		edges = append(edges, provisioningscheduledstep.EdgeFileExtract)
	}
	if m.cleared_Ansible {
		edges = append(edges, provisioningscheduledstep.EdgeAnsible)
	}
	if m.cleared_AgentTasks {
		edges = append(edges, provisioningscheduledstep.EdgeAgentTasks)
	}
	if m.cleared_Plan {
		edges = append(edges, provisioningscheduledstep.EdgePlan)
	}
	if m.cleared_GinFileMiddleware {
		edges = append(edges, provisioningscheduledstep.EdgeGinFileMiddleware)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProvisioningScheduledStepMutation) EdgeCleared(name string) bool {
	switch name {
	case provisioningscheduledstep.EdgeStatus:
		return m.cleared_Status
	case provisioningscheduledstep.EdgeScheduledStep:
		return m.cleared_ScheduledStep
	case provisioningscheduledstep.EdgeProvisionedHost:
		return m.cleared_ProvisionedHost
	case provisioningscheduledstep.EdgeScript:
		return m.cleared_Script
	case provisioningscheduledstep.EdgeCommand:
		return m.cleared_Command
	case provisioningscheduledstep.EdgeDNSRecord:
		return m.cleared_DNSRecord
	case provisioningscheduledstep.EdgeFileDelete:
		return m.cleared_FileDelete
	case provisioningscheduledstep.EdgeFileDownload:
		return m.cleared_FileDownload
	case provisioningscheduledstep.EdgeFileExtract:
		return m.cleared_FileExtract
	case provisioningscheduledstep.EdgeAnsible:
		return m.cleared_Ansible
	case provisioningscheduledstep.EdgeAgentTasks:
		return m.cleared_AgentTasks
	case provisioningscheduledstep.EdgePlan:
		return m.cleared_Plan
	case provisioningscheduledstep.EdgeGinFileMiddleware:
		return m.cleared_GinFileMiddleware
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProvisioningScheduledStepMutation) ClearEdge(name string) error {
	switch name {
	case provisioningscheduledstep.EdgeStatus:
		m.ClearStatus()
		return nil
	case provisioningscheduledstep.EdgeScheduledStep:
		m.ClearScheduledStep()
		return nil
	case provisioningscheduledstep.EdgeProvisionedHost:
		m.ClearProvisionedHost()
		return nil
	case provisioningscheduledstep.EdgeScript:
		m.ClearScript()
		return nil
	case provisioningscheduledstep.EdgeCommand:
		m.ClearCommand()
		return nil
	case provisioningscheduledstep.EdgeDNSRecord:
		m.ClearDNSRecord()
		return nil
	case provisioningscheduledstep.EdgeFileDelete:
		m.ClearFileDelete()
		return nil
	case provisioningscheduledstep.EdgeFileDownload:
		m.ClearFileDownload()
		return nil
	case provisioningscheduledstep.EdgeFileExtract:
		m.ClearFileExtract()
		return nil
	case provisioningscheduledstep.EdgeAnsible:
		m.ClearAnsible()
		return nil
	case provisioningscheduledstep.EdgePlan:
		m.ClearPlan()
		return nil
	case provisioningscheduledstep.EdgeGinFileMiddleware:
		m.ClearGinFileMiddleware()
		return nil
	}
	return fmt.Errorf("unknown ProvisioningScheduledStep unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProvisioningScheduledStepMutation) ResetEdge(name string) error {
	switch name {
	case provisioningscheduledstep.EdgeStatus:
		m.ResetStatus()
		return nil
	case provisioningscheduledstep.EdgeScheduledStep:
		m.ResetScheduledStep()
		return nil
	case provisioningscheduledstep.EdgeProvisionedHost:
		m.ResetProvisionedHost()
		return nil
	case provisioningscheduledstep.EdgeScript:
		m.ResetScript()
		return nil
	case provisioningscheduledstep.EdgeCommand:
		m.ResetCommand()
		return nil
	case provisioningscheduledstep.EdgeDNSRecord:
		m.ResetDNSRecord()
		return nil
	case provisioningscheduledstep.EdgeFileDelete:
		m.ResetFileDelete()
		return nil
	case provisioningscheduledstep.EdgeFileDownload:
		m.ResetFileDownload()
		return nil
	case provisioningscheduledstep.EdgeFileExtract:
		m.ResetFileExtract()
		return nil
	case provisioningscheduledstep.EdgeAnsible:
		m.ResetAnsible()
		return nil
	case provisioningscheduledstep.EdgeAgentTasks:
		m.ResetAgentTasks()
		return nil
	case provisioningscheduledstep.EdgePlan:
		m.ResetPlan()
		return nil
	case provisioningscheduledstep.EdgeGinFileMiddleware:
		m.ResetGinFileMiddleware()
		return nil
	}
	return fmt.Errorf("unknown ProvisioningScheduledStep edge %s", name)
}

// ProvisioningStepMutation represents an operation that mutates the ProvisioningStep nodes in the graph.
type ProvisioningStepMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	_type                     *provisioningstep.Type
	step_number               *int
	addstep_number            *int
	clearedFields             map[string]struct{}
	_Status                   *uuid.UUID
	cleared_Status            bool
	_ProvisionedHost          *uuid.UUID
	cleared_ProvisionedHost   bool
	_Script                   *uuid.UUID
	cleared_Script            bool
	_Command                  *uuid.UUID
	cleared_Command           bool
	_DNSRecord                *uuid.UUID
	cleared_DNSRecord         bool
	_FileDelete               *uuid.UUID
	cleared_FileDelete        bool
	_FileDownload             *uuid.UUID
	cleared_FileDownload      bool
	_FileExtract              *uuid.UUID
	cleared_FileExtract       bool
	_Ansible                  *uuid.UUID
	cleared_Ansible           bool
	_Plan                     *uuid.UUID
	cleared_Plan              bool
	_AgentTasks               map[uuid.UUID]struct{}
	removed_AgentTasks        map[uuid.UUID]struct{}
	cleared_AgentTasks        bool
	_GinFileMiddleware        *uuid.UUID
	cleared_GinFileMiddleware bool
	done                      bool
	oldValue                  func(context.Context) (*ProvisioningStep, error)
	predicates                []predicate.ProvisioningStep
}

var _ ent.Mutation = (*ProvisioningStepMutation)(nil)

// provisioningstepOption allows management of the mutation configuration using functional options.
type provisioningstepOption func(*ProvisioningStepMutation)

// newProvisioningStepMutation creates new mutation for the ProvisioningStep entity.
func newProvisioningStepMutation(c config, op Op, opts ...provisioningstepOption) *ProvisioningStepMutation {
	m := &ProvisioningStepMutation{
		config:        c,
		op:            op,
		typ:           TypeProvisioningStep,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProvisioningStepID sets the ID field of the mutation.
func withProvisioningStepID(id uuid.UUID) provisioningstepOption {
	return func(m *ProvisioningStepMutation) {
		var (
			err   error
			once  sync.Once
			value *ProvisioningStep
		)
		m.oldValue = func(ctx context.Context) (*ProvisioningStep, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProvisioningStep.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvisioningStep sets the old ProvisioningStep of the mutation.
func withProvisioningStep(node *ProvisioningStep) provisioningstepOption {
	return func(m *ProvisioningStepMutation) {
		m.oldValue = func(context.Context) (*ProvisioningStep, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProvisioningStepMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProvisioningStepMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProvisioningStep entities.
func (m *ProvisioningStepMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProvisioningStepMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProvisioningStepMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProvisioningStep.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *ProvisioningStepMutation) SetType(pr provisioningstep.Type) {
	m._type = &pr
}

// GetType returns the value of the "type" field in the mutation.
func (m *ProvisioningStepMutation) GetType() (r provisioningstep.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ProvisioningStep entity.
// If the ProvisioningStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvisioningStepMutation) OldType(ctx context.Context) (v provisioningstep.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ProvisioningStepMutation) ResetType() {
	m._type = nil
}

// SetStepNumber sets the "step_number" field.
func (m *ProvisioningStepMutation) SetStepNumber(i int) {
	m.step_number = &i
	m.addstep_number = nil
}

// StepNumber returns the value of the "step_number" field in the mutation.
func (m *ProvisioningStepMutation) StepNumber() (r int, exists bool) {
	v := m.step_number
	if v == nil {
		return
	}
	return *v, true
}

// OldStepNumber returns the old "step_number" field's value of the ProvisioningStep entity.
// If the ProvisioningStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvisioningStepMutation) OldStepNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepNumber: %w", err)
	}
	return oldValue.StepNumber, nil
}

// AddStepNumber adds i to the "step_number" field.
func (m *ProvisioningStepMutation) AddStepNumber(i int) {
	if m.addstep_number != nil {
		*m.addstep_number += i
	} else {
		m.addstep_number = &i
	}
}

// AddedStepNumber returns the value that was added to the "step_number" field in this mutation.
func (m *ProvisioningStepMutation) AddedStepNumber() (r int, exists bool) {
	v := m.addstep_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetStepNumber resets all changes to the "step_number" field.
func (m *ProvisioningStepMutation) ResetStepNumber() {
	m.step_number = nil
	m.addstep_number = nil
}

// SetStatusID sets the "Status" edge to the Status entity by id.
func (m *ProvisioningStepMutation) SetStatusID(id uuid.UUID) {
	m._Status = &id
}

// ClearStatus clears the "Status" edge to the Status entity.
func (m *ProvisioningStepMutation) ClearStatus() {
	m.cleared_Status = true
}

// StatusCleared reports if the "Status" edge to the Status entity was cleared.
func (m *ProvisioningStepMutation) StatusCleared() bool {
	return m.cleared_Status
}

// StatusID returns the "Status" edge ID in the mutation.
func (m *ProvisioningStepMutation) StatusID() (id uuid.UUID, exists bool) {
	if m._Status != nil {
		return *m._Status, true
	}
	return
}

// StatusIDs returns the "Status" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusID instead. It exists only for internal usage by the builders.
func (m *ProvisioningStepMutation) StatusIDs() (ids []uuid.UUID) {
	if id := m._Status; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatus resets all changes to the "Status" edge.
func (m *ProvisioningStepMutation) ResetStatus() {
	m._Status = nil
	m.cleared_Status = false
}

// SetProvisionedHostID sets the "ProvisionedHost" edge to the ProvisionedHost entity by id.
func (m *ProvisioningStepMutation) SetProvisionedHostID(id uuid.UUID) {
	m._ProvisionedHost = &id
}

// ClearProvisionedHost clears the "ProvisionedHost" edge to the ProvisionedHost entity.
func (m *ProvisioningStepMutation) ClearProvisionedHost() {
	m.cleared_ProvisionedHost = true
}

// ProvisionedHostCleared reports if the "ProvisionedHost" edge to the ProvisionedHost entity was cleared.
func (m *ProvisioningStepMutation) ProvisionedHostCleared() bool {
	return m.cleared_ProvisionedHost
}

// ProvisionedHostID returns the "ProvisionedHost" edge ID in the mutation.
func (m *ProvisioningStepMutation) ProvisionedHostID() (id uuid.UUID, exists bool) {
	if m._ProvisionedHost != nil {
		return *m._ProvisionedHost, true
	}
	return
}

// ProvisionedHostIDs returns the "ProvisionedHost" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisionedHostID instead. It exists only for internal usage by the builders.
func (m *ProvisioningStepMutation) ProvisionedHostIDs() (ids []uuid.UUID) {
	if id := m._ProvisionedHost; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisionedHost resets all changes to the "ProvisionedHost" edge.
func (m *ProvisioningStepMutation) ResetProvisionedHost() {
	m._ProvisionedHost = nil
	m.cleared_ProvisionedHost = false
}

// SetScriptID sets the "Script" edge to the Script entity by id.
func (m *ProvisioningStepMutation) SetScriptID(id uuid.UUID) {
	m._Script = &id
}

// ClearScript clears the "Script" edge to the Script entity.
func (m *ProvisioningStepMutation) ClearScript() {
	m.cleared_Script = true
}

// ScriptCleared reports if the "Script" edge to the Script entity was cleared.
func (m *ProvisioningStepMutation) ScriptCleared() bool {
	return m.cleared_Script
}

// ScriptID returns the "Script" edge ID in the mutation.
func (m *ProvisioningStepMutation) ScriptID() (id uuid.UUID, exists bool) {
	if m._Script != nil {
		return *m._Script, true
	}
	return
}

// ScriptIDs returns the "Script" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScriptID instead. It exists only for internal usage by the builders.
func (m *ProvisioningStepMutation) ScriptIDs() (ids []uuid.UUID) {
	if id := m._Script; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetScript resets all changes to the "Script" edge.
func (m *ProvisioningStepMutation) ResetScript() {
	m._Script = nil
	m.cleared_Script = false
}

// SetCommandID sets the "Command" edge to the Command entity by id.
func (m *ProvisioningStepMutation) SetCommandID(id uuid.UUID) {
	m._Command = &id
}

// ClearCommand clears the "Command" edge to the Command entity.
func (m *ProvisioningStepMutation) ClearCommand() {
	m.cleared_Command = true
}

// CommandCleared reports if the "Command" edge to the Command entity was cleared.
func (m *ProvisioningStepMutation) CommandCleared() bool {
	return m.cleared_Command
}

// CommandID returns the "Command" edge ID in the mutation.
func (m *ProvisioningStepMutation) CommandID() (id uuid.UUID, exists bool) {
	if m._Command != nil {
		return *m._Command, true
	}
	return
}

// CommandIDs returns the "Command" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommandID instead. It exists only for internal usage by the builders.
func (m *ProvisioningStepMutation) CommandIDs() (ids []uuid.UUID) {
	if id := m._Command; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCommand resets all changes to the "Command" edge.
func (m *ProvisioningStepMutation) ResetCommand() {
	m._Command = nil
	m.cleared_Command = false
}

// SetDNSRecordID sets the "DNSRecord" edge to the DNSRecord entity by id.
func (m *ProvisioningStepMutation) SetDNSRecordID(id uuid.UUID) {
	m._DNSRecord = &id
}

// ClearDNSRecord clears the "DNSRecord" edge to the DNSRecord entity.
func (m *ProvisioningStepMutation) ClearDNSRecord() {
	m.cleared_DNSRecord = true
}

// DNSRecordCleared reports if the "DNSRecord" edge to the DNSRecord entity was cleared.
func (m *ProvisioningStepMutation) DNSRecordCleared() bool {
	return m.cleared_DNSRecord
}

// DNSRecordID returns the "DNSRecord" edge ID in the mutation.
func (m *ProvisioningStepMutation) DNSRecordID() (id uuid.UUID, exists bool) {
	if m._DNSRecord != nil {
		return *m._DNSRecord, true
	}
	return
}

// DNSRecordIDs returns the "DNSRecord" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DNSRecordID instead. It exists only for internal usage by the builders.
func (m *ProvisioningStepMutation) DNSRecordIDs() (ids []uuid.UUID) {
	if id := m._DNSRecord; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDNSRecord resets all changes to the "DNSRecord" edge.
func (m *ProvisioningStepMutation) ResetDNSRecord() {
	m._DNSRecord = nil
	m.cleared_DNSRecord = false
}

// SetFileDeleteID sets the "FileDelete" edge to the FileDelete entity by id.
func (m *ProvisioningStepMutation) SetFileDeleteID(id uuid.UUID) {
	m._FileDelete = &id
}

// ClearFileDelete clears the "FileDelete" edge to the FileDelete entity.
func (m *ProvisioningStepMutation) ClearFileDelete() {
	m.cleared_FileDelete = true
}

// FileDeleteCleared reports if the "FileDelete" edge to the FileDelete entity was cleared.
func (m *ProvisioningStepMutation) FileDeleteCleared() bool {
	return m.cleared_FileDelete
}

// FileDeleteID returns the "FileDelete" edge ID in the mutation.
func (m *ProvisioningStepMutation) FileDeleteID() (id uuid.UUID, exists bool) {
	if m._FileDelete != nil {
		return *m._FileDelete, true
	}
	return
}

// FileDeleteIDs returns the "FileDelete" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileDeleteID instead. It exists only for internal usage by the builders.
func (m *ProvisioningStepMutation) FileDeleteIDs() (ids []uuid.UUID) {
	if id := m._FileDelete; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFileDelete resets all changes to the "FileDelete" edge.
func (m *ProvisioningStepMutation) ResetFileDelete() {
	m._FileDelete = nil
	m.cleared_FileDelete = false
}

// SetFileDownloadID sets the "FileDownload" edge to the FileDownload entity by id.
func (m *ProvisioningStepMutation) SetFileDownloadID(id uuid.UUID) {
	m._FileDownload = &id
}

// ClearFileDownload clears the "FileDownload" edge to the FileDownload entity.
func (m *ProvisioningStepMutation) ClearFileDownload() {
	m.cleared_FileDownload = true
}

// FileDownloadCleared reports if the "FileDownload" edge to the FileDownload entity was cleared.
func (m *ProvisioningStepMutation) FileDownloadCleared() bool {
	return m.cleared_FileDownload
}

// FileDownloadID returns the "FileDownload" edge ID in the mutation.
func (m *ProvisioningStepMutation) FileDownloadID() (id uuid.UUID, exists bool) {
	if m._FileDownload != nil {
		return *m._FileDownload, true
	}
	return
}

// FileDownloadIDs returns the "FileDownload" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileDownloadID instead. It exists only for internal usage by the builders.
func (m *ProvisioningStepMutation) FileDownloadIDs() (ids []uuid.UUID) {
	if id := m._FileDownload; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFileDownload resets all changes to the "FileDownload" edge.
func (m *ProvisioningStepMutation) ResetFileDownload() {
	m._FileDownload = nil
	m.cleared_FileDownload = false
}

// SetFileExtractID sets the "FileExtract" edge to the FileExtract entity by id.
func (m *ProvisioningStepMutation) SetFileExtractID(id uuid.UUID) {
	m._FileExtract = &id
}

// ClearFileExtract clears the "FileExtract" edge to the FileExtract entity.
func (m *ProvisioningStepMutation) ClearFileExtract() {
	m.cleared_FileExtract = true
}

// FileExtractCleared reports if the "FileExtract" edge to the FileExtract entity was cleared.
func (m *ProvisioningStepMutation) FileExtractCleared() bool {
	return m.cleared_FileExtract
}

// FileExtractID returns the "FileExtract" edge ID in the mutation.
func (m *ProvisioningStepMutation) FileExtractID() (id uuid.UUID, exists bool) {
	if m._FileExtract != nil {
		return *m._FileExtract, true
	}
	return
}

// FileExtractIDs returns the "FileExtract" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileExtractID instead. It exists only for internal usage by the builders.
func (m *ProvisioningStepMutation) FileExtractIDs() (ids []uuid.UUID) {
	if id := m._FileExtract; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFileExtract resets all changes to the "FileExtract" edge.
func (m *ProvisioningStepMutation) ResetFileExtract() {
	m._FileExtract = nil
	m.cleared_FileExtract = false
}

// SetAnsibleID sets the "Ansible" edge to the Ansible entity by id.
func (m *ProvisioningStepMutation) SetAnsibleID(id uuid.UUID) {
	m._Ansible = &id
}

// ClearAnsible clears the "Ansible" edge to the Ansible entity.
func (m *ProvisioningStepMutation) ClearAnsible() {
	m.cleared_Ansible = true
}

// AnsibleCleared reports if the "Ansible" edge to the Ansible entity was cleared.
func (m *ProvisioningStepMutation) AnsibleCleared() bool {
	return m.cleared_Ansible
}

// AnsibleID returns the "Ansible" edge ID in the mutation.
func (m *ProvisioningStepMutation) AnsibleID() (id uuid.UUID, exists bool) {
	if m._Ansible != nil {
		return *m._Ansible, true
	}
	return
}

// AnsibleIDs returns the "Ansible" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AnsibleID instead. It exists only for internal usage by the builders.
func (m *ProvisioningStepMutation) AnsibleIDs() (ids []uuid.UUID) {
	if id := m._Ansible; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAnsible resets all changes to the "Ansible" edge.
func (m *ProvisioningStepMutation) ResetAnsible() {
	m._Ansible = nil
	m.cleared_Ansible = false
}

// SetPlanID sets the "Plan" edge to the Plan entity by id.
func (m *ProvisioningStepMutation) SetPlanID(id uuid.UUID) {
	m._Plan = &id
}

// ClearPlan clears the "Plan" edge to the Plan entity.
func (m *ProvisioningStepMutation) ClearPlan() {
	m.cleared_Plan = true
}

// PlanCleared reports if the "Plan" edge to the Plan entity was cleared.
func (m *ProvisioningStepMutation) PlanCleared() bool {
	return m.cleared_Plan
}

// PlanID returns the "Plan" edge ID in the mutation.
func (m *ProvisioningStepMutation) PlanID() (id uuid.UUID, exists bool) {
	if m._Plan != nil {
		return *m._Plan, true
	}
	return
}

// PlanIDs returns the "Plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *ProvisioningStepMutation) PlanIDs() (ids []uuid.UUID) {
	if id := m._Plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "Plan" edge.
func (m *ProvisioningStepMutation) ResetPlan() {
	m._Plan = nil
	m.cleared_Plan = false
}

// AddAgentTaskIDs adds the "AgentTasks" edge to the AgentTask entity by ids.
func (m *ProvisioningStepMutation) AddAgentTaskIDs(ids ...uuid.UUID) {
	if m._AgentTasks == nil {
		m._AgentTasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._AgentTasks[ids[i]] = struct{}{}
	}
}

// ClearAgentTasks clears the "AgentTasks" edge to the AgentTask entity.
func (m *ProvisioningStepMutation) ClearAgentTasks() {
	m.cleared_AgentTasks = true
}

// AgentTasksCleared reports if the "AgentTasks" edge to the AgentTask entity was cleared.
func (m *ProvisioningStepMutation) AgentTasksCleared() bool {
	return m.cleared_AgentTasks
}

// RemoveAgentTaskIDs removes the "AgentTasks" edge to the AgentTask entity by IDs.
func (m *ProvisioningStepMutation) RemoveAgentTaskIDs(ids ...uuid.UUID) {
	if m.removed_AgentTasks == nil {
		m.removed_AgentTasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._AgentTasks, ids[i])
		m.removed_AgentTasks[ids[i]] = struct{}{}
	}
}

// RemovedAgentTasks returns the removed IDs of the "AgentTasks" edge to the AgentTask entity.
func (m *ProvisioningStepMutation) RemovedAgentTasksIDs() (ids []uuid.UUID) {
	for id := range m.removed_AgentTasks {
		ids = append(ids, id)
	}
	return
}

// AgentTasksIDs returns the "AgentTasks" edge IDs in the mutation.
func (m *ProvisioningStepMutation) AgentTasksIDs() (ids []uuid.UUID) {
	for id := range m._AgentTasks {
		ids = append(ids, id)
	}
	return
}

// ResetAgentTasks resets all changes to the "AgentTasks" edge.
func (m *ProvisioningStepMutation) ResetAgentTasks() {
	m._AgentTasks = nil
	m.cleared_AgentTasks = false
	m.removed_AgentTasks = nil
}

// SetGinFileMiddlewareID sets the "GinFileMiddleware" edge to the GinFileMiddleware entity by id.
func (m *ProvisioningStepMutation) SetGinFileMiddlewareID(id uuid.UUID) {
	m._GinFileMiddleware = &id
}

// ClearGinFileMiddleware clears the "GinFileMiddleware" edge to the GinFileMiddleware entity.
func (m *ProvisioningStepMutation) ClearGinFileMiddleware() {
	m.cleared_GinFileMiddleware = true
}

// GinFileMiddlewareCleared reports if the "GinFileMiddleware" edge to the GinFileMiddleware entity was cleared.
func (m *ProvisioningStepMutation) GinFileMiddlewareCleared() bool {
	return m.cleared_GinFileMiddleware
}

// GinFileMiddlewareID returns the "GinFileMiddleware" edge ID in the mutation.
func (m *ProvisioningStepMutation) GinFileMiddlewareID() (id uuid.UUID, exists bool) {
	if m._GinFileMiddleware != nil {
		return *m._GinFileMiddleware, true
	}
	return
}

// GinFileMiddlewareIDs returns the "GinFileMiddleware" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GinFileMiddlewareID instead. It exists only for internal usage by the builders.
func (m *ProvisioningStepMutation) GinFileMiddlewareIDs() (ids []uuid.UUID) {
	if id := m._GinFileMiddleware; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGinFileMiddleware resets all changes to the "GinFileMiddleware" edge.
func (m *ProvisioningStepMutation) ResetGinFileMiddleware() {
	m._GinFileMiddleware = nil
	m.cleared_GinFileMiddleware = false
}

// Where appends a list predicates to the ProvisioningStepMutation builder.
func (m *ProvisioningStepMutation) Where(ps ...predicate.ProvisioningStep) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProvisioningStepMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProvisioningStep).
func (m *ProvisioningStepMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProvisioningStepMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._type != nil {
		fields = append(fields, provisioningstep.FieldType)
	}
	if m.step_number != nil {
		fields = append(fields, provisioningstep.FieldStepNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProvisioningStepMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case provisioningstep.FieldType:
		return m.GetType()
	case provisioningstep.FieldStepNumber:
		return m.StepNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProvisioningStepMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case provisioningstep.FieldType:
		return m.OldType(ctx)
	case provisioningstep.FieldStepNumber:
		return m.OldStepNumber(ctx)
	}
	return nil, fmt.Errorf("unknown ProvisioningStep field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvisioningStepMutation) SetField(name string, value ent.Value) error {
	switch name {
	case provisioningstep.FieldType:
		v, ok := value.(provisioningstep.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case provisioningstep.FieldStepNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepNumber(v)
		return nil
	}
	return fmt.Errorf("unknown ProvisioningStep field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProvisioningStepMutation) AddedFields() []string {
	var fields []string
	if m.addstep_number != nil {
		fields = append(fields, provisioningstep.FieldStepNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProvisioningStepMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case provisioningstep.FieldStepNumber:
		return m.AddedStepNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvisioningStepMutation) AddField(name string, value ent.Value) error {
	switch name {
	case provisioningstep.FieldStepNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStepNumber(v)
		return nil
	}
	return fmt.Errorf("unknown ProvisioningStep numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProvisioningStepMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProvisioningStepMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProvisioningStepMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProvisioningStep nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProvisioningStepMutation) ResetField(name string) error {
	switch name {
	case provisioningstep.FieldType:
		m.ResetType()
		return nil
	case provisioningstep.FieldStepNumber:
		m.ResetStepNumber()
		return nil
	}
	return fmt.Errorf("unknown ProvisioningStep field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProvisioningStepMutation) AddedEdges() []string {
	edges := make([]string, 0, 12)
	if m._Status != nil {
		edges = append(edges, provisioningstep.EdgeStatus)
	}
	if m._ProvisionedHost != nil {
		edges = append(edges, provisioningstep.EdgeProvisionedHost)
	}
	if m._Script != nil {
		edges = append(edges, provisioningstep.EdgeScript)
	}
	if m._Command != nil {
		edges = append(edges, provisioningstep.EdgeCommand)
	}
	if m._DNSRecord != nil {
		edges = append(edges, provisioningstep.EdgeDNSRecord)
	}
	if m._FileDelete != nil {
		edges = append(edges, provisioningstep.EdgeFileDelete)
	}
	if m._FileDownload != nil {
		edges = append(edges, provisioningstep.EdgeFileDownload)
	}
	if m._FileExtract != nil {
		edges = append(edges, provisioningstep.EdgeFileExtract)
	}
	if m._Ansible != nil {
		edges = append(edges, provisioningstep.EdgeAnsible)
	}
	if m._Plan != nil {
		edges = append(edges, provisioningstep.EdgePlan)
	}
	if m._AgentTasks != nil {
		edges = append(edges, provisioningstep.EdgeAgentTasks)
	}
	if m._GinFileMiddleware != nil {
		edges = append(edges, provisioningstep.EdgeGinFileMiddleware)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProvisioningStepMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case provisioningstep.EdgeStatus:
		if id := m._Status; id != nil {
			return []ent.Value{*id}
		}
	case provisioningstep.EdgeProvisionedHost:
		if id := m._ProvisionedHost; id != nil {
			return []ent.Value{*id}
		}
	case provisioningstep.EdgeScript:
		if id := m._Script; id != nil {
			return []ent.Value{*id}
		}
	case provisioningstep.EdgeCommand:
		if id := m._Command; id != nil {
			return []ent.Value{*id}
		}
	case provisioningstep.EdgeDNSRecord:
		if id := m._DNSRecord; id != nil {
			return []ent.Value{*id}
		}
	case provisioningstep.EdgeFileDelete:
		if id := m._FileDelete; id != nil {
			return []ent.Value{*id}
		}
	case provisioningstep.EdgeFileDownload:
		if id := m._FileDownload; id != nil {
			return []ent.Value{*id}
		}
	case provisioningstep.EdgeFileExtract:
		if id := m._FileExtract; id != nil {
			return []ent.Value{*id}
		}
	case provisioningstep.EdgeAnsible:
		if id := m._Ansible; id != nil {
			return []ent.Value{*id}
		}
	case provisioningstep.EdgePlan:
		if id := m._Plan; id != nil {
			return []ent.Value{*id}
		}
	case provisioningstep.EdgeAgentTasks:
		ids := make([]ent.Value, 0, len(m._AgentTasks))
		for id := range m._AgentTasks {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeGinFileMiddleware:
		if id := m._GinFileMiddleware; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProvisioningStepMutation) RemovedEdges() []string {
	edges := make([]string, 0, 12)
	if m.removed_AgentTasks != nil {
		edges = append(edges, provisioningstep.EdgeAgentTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProvisioningStepMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case provisioningstep.EdgeAgentTasks:
		ids := make([]ent.Value, 0, len(m.removed_AgentTasks))
		for id := range m.removed_AgentTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProvisioningStepMutation) ClearedEdges() []string {
	edges := make([]string, 0, 12)
	if m.cleared_Status {
		edges = append(edges, provisioningstep.EdgeStatus)
	}
	if m.cleared_ProvisionedHost {
		edges = append(edges, provisioningstep.EdgeProvisionedHost)
	}
	if m.cleared_Script {
		edges = append(edges, provisioningstep.EdgeScript)
	}
	if m.cleared_Command {
		edges = append(edges, provisioningstep.EdgeCommand)
	}
	if m.cleared_DNSRecord {
		edges = append(edges, provisioningstep.EdgeDNSRecord)
	}
	if m.cleared_FileDelete {
		edges = append(edges, provisioningstep.EdgeFileDelete)
	}
	if m.cleared_FileDownload {
		edges = append(edges, provisioningstep.EdgeFileDownload)
	}
	if m.cleared_FileExtract {
		edges = append(edges, provisioningstep.EdgeFileExtract)
	}
	if m.cleared_Ansible {
		edges = append(edges, provisioningstep.EdgeAnsible)
	}
	if m.cleared_Plan {
		edges = append(edges, provisioningstep.EdgePlan)
	}
	if m.cleared_AgentTasks {
		edges = append(edges, provisioningstep.EdgeAgentTasks)
	}
	if m.cleared_GinFileMiddleware {
		edges = append(edges, provisioningstep.EdgeGinFileMiddleware)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProvisioningStepMutation) EdgeCleared(name string) bool {
	switch name {
	case provisioningstep.EdgeStatus:
		return m.cleared_Status
	case provisioningstep.EdgeProvisionedHost:
		return m.cleared_ProvisionedHost
	case provisioningstep.EdgeScript:
		return m.cleared_Script
	case provisioningstep.EdgeCommand:
		return m.cleared_Command
	case provisioningstep.EdgeDNSRecord:
		return m.cleared_DNSRecord
	case provisioningstep.EdgeFileDelete:
		return m.cleared_FileDelete
	case provisioningstep.EdgeFileDownload:
		return m.cleared_FileDownload
	case provisioningstep.EdgeFileExtract:
		return m.cleared_FileExtract
	case provisioningstep.EdgeAnsible:
		return m.cleared_Ansible
	case provisioningstep.EdgePlan:
		return m.cleared_Plan
	case provisioningstep.EdgeAgentTasks:
		return m.cleared_AgentTasks
	case provisioningstep.EdgeGinFileMiddleware:
		return m.cleared_GinFileMiddleware
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProvisioningStepMutation) ClearEdge(name string) error {
	switch name {
	case provisioningstep.EdgeStatus:
		m.ClearStatus()
		return nil
	case provisioningstep.EdgeProvisionedHost:
		m.ClearProvisionedHost()
		return nil
	case provisioningstep.EdgeScript:
		m.ClearScript()
		return nil
	case provisioningstep.EdgeCommand:
		m.ClearCommand()
		return nil
	case provisioningstep.EdgeDNSRecord:
		m.ClearDNSRecord()
		return nil
	case provisioningstep.EdgeFileDelete:
		m.ClearFileDelete()
		return nil
	case provisioningstep.EdgeFileDownload:
		m.ClearFileDownload()
		return nil
	case provisioningstep.EdgeFileExtract:
		m.ClearFileExtract()
		return nil
	case provisioningstep.EdgeAnsible:
		m.ClearAnsible()
		return nil
	case provisioningstep.EdgePlan:
		m.ClearPlan()
		return nil
	case provisioningstep.EdgeGinFileMiddleware:
		m.ClearGinFileMiddleware()
		return nil
	}
	return fmt.Errorf("unknown ProvisioningStep unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProvisioningStepMutation) ResetEdge(name string) error {
	switch name {
	case provisioningstep.EdgeStatus:
		m.ResetStatus()
		return nil
	case provisioningstep.EdgeProvisionedHost:
		m.ResetProvisionedHost()
		return nil
	case provisioningstep.EdgeScript:
		m.ResetScript()
		return nil
	case provisioningstep.EdgeCommand:
		m.ResetCommand()
		return nil
	case provisioningstep.EdgeDNSRecord:
		m.ResetDNSRecord()
		return nil
	case provisioningstep.EdgeFileDelete:
		m.ResetFileDelete()
		return nil
	case provisioningstep.EdgeFileDownload:
		m.ResetFileDownload()
		return nil
	case provisioningstep.EdgeFileExtract:
		m.ResetFileExtract()
		return nil
	case provisioningstep.EdgeAnsible:
		m.ResetAnsible()
		return nil
	case provisioningstep.EdgePlan:
		m.ResetPlan()
		return nil
	case provisioningstep.EdgeAgentTasks:
		m.ResetAgentTasks()
		return nil
	case provisioningstep.EdgeGinFileMiddleware:
		m.ResetGinFileMiddleware()
		return nil
	}
	return fmt.Errorf("unknown ProvisioningStep edge %s", name)
}

// RepoCommitMutation represents an operation that mutates the RepoCommit nodes in the graph.
type RepoCommitMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	revision           *int
	addrevision        *int
	hash               *string
	author             *object.Signature
	committer          *object.Signature
	pgp_signature      *string
	message            *string
	tree_hash          *string
	parent_hashes      *[]string
	clearedFields      map[string]struct{}
	_Repository        *uuid.UUID
	cleared_Repository bool
	done               bool
	oldValue           func(context.Context) (*RepoCommit, error)
	predicates         []predicate.RepoCommit
}

var _ ent.Mutation = (*RepoCommitMutation)(nil)

// repocommitOption allows management of the mutation configuration using functional options.
type repocommitOption func(*RepoCommitMutation)

// newRepoCommitMutation creates new mutation for the RepoCommit entity.
func newRepoCommitMutation(c config, op Op, opts ...repocommitOption) *RepoCommitMutation {
	m := &RepoCommitMutation{
		config:        c,
		op:            op,
		typ:           TypeRepoCommit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRepoCommitID sets the ID field of the mutation.
func withRepoCommitID(id uuid.UUID) repocommitOption {
	return func(m *RepoCommitMutation) {
		var (
			err   error
			once  sync.Once
			value *RepoCommit
		)
		m.oldValue = func(ctx context.Context) (*RepoCommit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RepoCommit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRepoCommit sets the old RepoCommit of the mutation.
func withRepoCommit(node *RepoCommit) repocommitOption {
	return func(m *RepoCommitMutation) {
		m.oldValue = func(context.Context) (*RepoCommit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RepoCommitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RepoCommitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RepoCommit entities.
func (m *RepoCommitMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RepoCommitMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RepoCommitMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RepoCommit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRevision sets the "revision" field.
func (m *RepoCommitMutation) SetRevision(i int) {
	m.revision = &i
	m.addrevision = nil
}

// Revision returns the value of the "revision" field in the mutation.
func (m *RepoCommitMutation) Revision() (r int, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the RepoCommit entity.
// If the RepoCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoCommitMutation) OldRevision(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// AddRevision adds i to the "revision" field.
func (m *RepoCommitMutation) AddRevision(i int) {
	if m.addrevision != nil {
		*m.addrevision += i
	} else {
		m.addrevision = &i
	}
}

// AddedRevision returns the value that was added to the "revision" field in this mutation.
func (m *RepoCommitMutation) AddedRevision() (r int, exists bool) {
	v := m.addrevision
	if v == nil {
		return
	}
	return *v, true
}

// ResetRevision resets all changes to the "revision" field.
func (m *RepoCommitMutation) ResetRevision() {
	m.revision = nil
	m.addrevision = nil
}

// SetHash sets the "hash" field.
func (m *RepoCommitMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *RepoCommitMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the RepoCommit entity.
// If the RepoCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoCommitMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *RepoCommitMutation) ResetHash() {
	m.hash = nil
}

// SetAuthor sets the "author" field.
func (m *RepoCommitMutation) SetAuthor(o object.Signature) {
	m.author = &o
}

// Author returns the value of the "author" field in the mutation.
func (m *RepoCommitMutation) Author() (r object.Signature, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the RepoCommit entity.
// If the RepoCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoCommitMutation) OldAuthor(ctx context.Context) (v object.Signature, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ResetAuthor resets all changes to the "author" field.
func (m *RepoCommitMutation) ResetAuthor() {
	m.author = nil
}

// SetCommitter sets the "committer" field.
func (m *RepoCommitMutation) SetCommitter(o object.Signature) {
	m.committer = &o
}

// Committer returns the value of the "committer" field in the mutation.
func (m *RepoCommitMutation) Committer() (r object.Signature, exists bool) {
	v := m.committer
	if v == nil {
		return
	}
	return *v, true
}

// OldCommitter returns the old "committer" field's value of the RepoCommit entity.
// If the RepoCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoCommitMutation) OldCommitter(ctx context.Context) (v object.Signature, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommitter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommitter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommitter: %w", err)
	}
	return oldValue.Committer, nil
}

// ResetCommitter resets all changes to the "committer" field.
func (m *RepoCommitMutation) ResetCommitter() {
	m.committer = nil
}

// SetPgpSignature sets the "pgp_signature" field.
func (m *RepoCommitMutation) SetPgpSignature(s string) {
	m.pgp_signature = &s
}

// PgpSignature returns the value of the "pgp_signature" field in the mutation.
func (m *RepoCommitMutation) PgpSignature() (r string, exists bool) {
	v := m.pgp_signature
	if v == nil {
		return
	}
	return *v, true
}

// OldPgpSignature returns the old "pgp_signature" field's value of the RepoCommit entity.
// If the RepoCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoCommitMutation) OldPgpSignature(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPgpSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPgpSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPgpSignature: %w", err)
	}
	return oldValue.PgpSignature, nil
}

// ResetPgpSignature resets all changes to the "pgp_signature" field.
func (m *RepoCommitMutation) ResetPgpSignature() {
	m.pgp_signature = nil
}

// SetMessage sets the "message" field.
func (m *RepoCommitMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *RepoCommitMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the RepoCommit entity.
// If the RepoCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoCommitMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *RepoCommitMutation) ResetMessage() {
	m.message = nil
}

// SetTreeHash sets the "tree_hash" field.
func (m *RepoCommitMutation) SetTreeHash(s string) {
	m.tree_hash = &s
}

// TreeHash returns the value of the "tree_hash" field in the mutation.
func (m *RepoCommitMutation) TreeHash() (r string, exists bool) {
	v := m.tree_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTreeHash returns the old "tree_hash" field's value of the RepoCommit entity.
// If the RepoCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoCommitMutation) OldTreeHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTreeHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTreeHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTreeHash: %w", err)
	}
	return oldValue.TreeHash, nil
}

// ResetTreeHash resets all changes to the "tree_hash" field.
func (m *RepoCommitMutation) ResetTreeHash() {
	m.tree_hash = nil
}

// SetParentHashes sets the "parent_hashes" field.
func (m *RepoCommitMutation) SetParentHashes(s []string) {
	m.parent_hashes = &s
}

// ParentHashes returns the value of the "parent_hashes" field in the mutation.
func (m *RepoCommitMutation) ParentHashes() (r []string, exists bool) {
	v := m.parent_hashes
	if v == nil {
		return
	}
	return *v, true
}

// OldParentHashes returns the old "parent_hashes" field's value of the RepoCommit entity.
// If the RepoCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoCommitMutation) OldParentHashes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentHashes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentHashes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentHashes: %w", err)
	}
	return oldValue.ParentHashes, nil
}

// ResetParentHashes resets all changes to the "parent_hashes" field.
func (m *RepoCommitMutation) ResetParentHashes() {
	m.parent_hashes = nil
}

// SetRepositoryID sets the "Repository" edge to the Repository entity by id.
func (m *RepoCommitMutation) SetRepositoryID(id uuid.UUID) {
	m._Repository = &id
}

// ClearRepository clears the "Repository" edge to the Repository entity.
func (m *RepoCommitMutation) ClearRepository() {
	m.cleared_Repository = true
}

// RepositoryCleared reports if the "Repository" edge to the Repository entity was cleared.
func (m *RepoCommitMutation) RepositoryCleared() bool {
	return m.cleared_Repository
}

// RepositoryID returns the "Repository" edge ID in the mutation.
func (m *RepoCommitMutation) RepositoryID() (id uuid.UUID, exists bool) {
	if m._Repository != nil {
		return *m._Repository, true
	}
	return
}

// RepositoryIDs returns the "Repository" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RepositoryID instead. It exists only for internal usage by the builders.
func (m *RepoCommitMutation) RepositoryIDs() (ids []uuid.UUID) {
	if id := m._Repository; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepository resets all changes to the "Repository" edge.
func (m *RepoCommitMutation) ResetRepository() {
	m._Repository = nil
	m.cleared_Repository = false
}

// Where appends a list predicates to the RepoCommitMutation builder.
func (m *RepoCommitMutation) Where(ps ...predicate.RepoCommit) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RepoCommitMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (RepoCommit).
func (m *RepoCommitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RepoCommitMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.revision != nil {
		fields = append(fields, repocommit.FieldRevision)
	}
	if m.hash != nil {
		fields = append(fields, repocommit.FieldHash)
	}
	if m.author != nil {
		fields = append(fields, repocommit.FieldAuthor)
	}
	if m.committer != nil {
		fields = append(fields, repocommit.FieldCommitter)
	}
	if m.pgp_signature != nil {
		fields = append(fields, repocommit.FieldPgpSignature)
	}
	if m.message != nil {
		fields = append(fields, repocommit.FieldMessage)
	}
	if m.tree_hash != nil {
		fields = append(fields, repocommit.FieldTreeHash)
	}
	if m.parent_hashes != nil {
		fields = append(fields, repocommit.FieldParentHashes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RepoCommitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case repocommit.FieldRevision:
		return m.Revision()
	case repocommit.FieldHash:
		return m.Hash()
	case repocommit.FieldAuthor:
		return m.Author()
	case repocommit.FieldCommitter:
		return m.Committer()
	case repocommit.FieldPgpSignature:
		return m.PgpSignature()
	case repocommit.FieldMessage:
		return m.Message()
	case repocommit.FieldTreeHash:
		return m.TreeHash()
	case repocommit.FieldParentHashes:
		return m.ParentHashes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RepoCommitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case repocommit.FieldRevision:
		return m.OldRevision(ctx)
	case repocommit.FieldHash:
		return m.OldHash(ctx)
	case repocommit.FieldAuthor:
		return m.OldAuthor(ctx)
	case repocommit.FieldCommitter:
		return m.OldCommitter(ctx)
	case repocommit.FieldPgpSignature:
		return m.OldPgpSignature(ctx)
	case repocommit.FieldMessage:
		return m.OldMessage(ctx)
	case repocommit.FieldTreeHash:
		return m.OldTreeHash(ctx)
	case repocommit.FieldParentHashes:
		return m.OldParentHashes(ctx)
	}
	return nil, fmt.Errorf("unknown RepoCommit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepoCommitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case repocommit.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case repocommit.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case repocommit.FieldAuthor:
		v, ok := value.(object.Signature)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case repocommit.FieldCommitter:
		v, ok := value.(object.Signature)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommitter(v)
		return nil
	case repocommit.FieldPgpSignature:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPgpSignature(v)
		return nil
	case repocommit.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case repocommit.FieldTreeHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTreeHash(v)
		return nil
	case repocommit.FieldParentHashes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentHashes(v)
		return nil
	}
	return fmt.Errorf("unknown RepoCommit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RepoCommitMutation) AddedFields() []string {
	var fields []string
	if m.addrevision != nil {
		fields = append(fields, repocommit.FieldRevision)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RepoCommitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case repocommit.FieldRevision:
		return m.AddedRevision()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepoCommitMutation) AddField(name string, value ent.Value) error {
	switch name {
	case repocommit.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevision(v)
		return nil
	}
	return fmt.Errorf("unknown RepoCommit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RepoCommitMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RepoCommitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RepoCommitMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RepoCommit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RepoCommitMutation) ResetField(name string) error {
	switch name {
	case repocommit.FieldRevision:
		m.ResetRevision()
		return nil
	case repocommit.FieldHash:
		m.ResetHash()
		return nil
	case repocommit.FieldAuthor:
		m.ResetAuthor()
		return nil
	case repocommit.FieldCommitter:
		m.ResetCommitter()
		return nil
	case repocommit.FieldPgpSignature:
		m.ResetPgpSignature()
		return nil
	case repocommit.FieldMessage:
		m.ResetMessage()
		return nil
	case repocommit.FieldTreeHash:
		m.ResetTreeHash()
		return nil
	case repocommit.FieldParentHashes:
		m.ResetParentHashes()
		return nil
	}
	return fmt.Errorf("unknown RepoCommit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RepoCommitMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Repository != nil {
		edges = append(edges, repocommit.EdgeRepository)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RepoCommitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case repocommit.EdgeRepository:
		if id := m._Repository; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RepoCommitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RepoCommitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RepoCommitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Repository {
		edges = append(edges, repocommit.EdgeRepository)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RepoCommitMutation) EdgeCleared(name string) bool {
	switch name {
	case repocommit.EdgeRepository:
		return m.cleared_Repository
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RepoCommitMutation) ClearEdge(name string) error {
	switch name {
	case repocommit.EdgeRepository:
		m.ClearRepository()
		return nil
	}
	return fmt.Errorf("unknown RepoCommit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RepoCommitMutation) ResetEdge(name string) error {
	switch name {
	case repocommit.EdgeRepository:
		m.ResetRepository()
		return nil
	}
	return fmt.Errorf("unknown RepoCommit edge %s", name)
}

// RepositoryMutation represents an operation that mutates the Repository nodes in the graph.
type RepositoryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	repo_url             *string
	branch_name          *string
	enviroment_filepath  *string
	folder_path          *string
	clearedFields        map[string]struct{}
	_Environments        map[uuid.UUID]struct{}
	removed_Environments map[uuid.UUID]struct{}
	cleared_Environments bool
	_RepoCommits         map[uuid.UUID]struct{}
	removed_RepoCommits  map[uuid.UUID]struct{}
	cleared_RepoCommits  bool
	done                 bool
	oldValue             func(context.Context) (*Repository, error)
	predicates           []predicate.Repository
}

var _ ent.Mutation = (*RepositoryMutation)(nil)

// repositoryOption allows management of the mutation configuration using functional options.
type repositoryOption func(*RepositoryMutation)

// newRepositoryMutation creates new mutation for the Repository entity.
func newRepositoryMutation(c config, op Op, opts ...repositoryOption) *RepositoryMutation {
	m := &RepositoryMutation{
		config:        c,
		op:            op,
		typ:           TypeRepository,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRepositoryID sets the ID field of the mutation.
func withRepositoryID(id uuid.UUID) repositoryOption {
	return func(m *RepositoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Repository
		)
		m.oldValue = func(ctx context.Context) (*Repository, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Repository.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRepository sets the old Repository of the mutation.
func withRepository(node *Repository) repositoryOption {
	return func(m *RepositoryMutation) {
		m.oldValue = func(context.Context) (*Repository, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RepositoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RepositoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Repository entities.
func (m *RepositoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RepositoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RepositoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Repository.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRepoURL sets the "repo_url" field.
func (m *RepositoryMutation) SetRepoURL(s string) {
	m.repo_url = &s
}

// RepoURL returns the value of the "repo_url" field in the mutation.
func (m *RepositoryMutation) RepoURL() (r string, exists bool) {
	v := m.repo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRepoURL returns the old "repo_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldRepoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepoURL: %w", err)
	}
	return oldValue.RepoURL, nil
}

// ResetRepoURL resets all changes to the "repo_url" field.
func (m *RepositoryMutation) ResetRepoURL() {
	m.repo_url = nil
}

// SetBranchName sets the "branch_name" field.
func (m *RepositoryMutation) SetBranchName(s string) {
	m.branch_name = &s
}

// BranchName returns the value of the "branch_name" field in the mutation.
func (m *RepositoryMutation) BranchName() (r string, exists bool) {
	v := m.branch_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBranchName returns the old "branch_name" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldBranchName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBranchName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBranchName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranchName: %w", err)
	}
	return oldValue.BranchName, nil
}

// ResetBranchName resets all changes to the "branch_name" field.
func (m *RepositoryMutation) ResetBranchName() {
	m.branch_name = nil
}

// SetEnviromentFilepath sets the "enviroment_filepath" field.
func (m *RepositoryMutation) SetEnviromentFilepath(s string) {
	m.enviroment_filepath = &s
}

// EnviromentFilepath returns the value of the "enviroment_filepath" field in the mutation.
func (m *RepositoryMutation) EnviromentFilepath() (r string, exists bool) {
	v := m.enviroment_filepath
	if v == nil {
		return
	}
	return *v, true
}

// OldEnviromentFilepath returns the old "enviroment_filepath" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldEnviromentFilepath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnviromentFilepath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnviromentFilepath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnviromentFilepath: %w", err)
	}
	return oldValue.EnviromentFilepath, nil
}

// ResetEnviromentFilepath resets all changes to the "enviroment_filepath" field.
func (m *RepositoryMutation) ResetEnviromentFilepath() {
	m.enviroment_filepath = nil
}

// SetFolderPath sets the "folder_path" field.
func (m *RepositoryMutation) SetFolderPath(s string) {
	m.folder_path = &s
}

// FolderPath returns the value of the "folder_path" field in the mutation.
func (m *RepositoryMutation) FolderPath() (r string, exists bool) {
	v := m.folder_path
	if v == nil {
		return
	}
	return *v, true
}

// OldFolderPath returns the old "folder_path" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldFolderPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFolderPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFolderPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFolderPath: %w", err)
	}
	return oldValue.FolderPath, nil
}

// ResetFolderPath resets all changes to the "folder_path" field.
func (m *RepositoryMutation) ResetFolderPath() {
	m.folder_path = nil
}

// AddEnvironmentIDs adds the "Environments" edge to the Environment entity by ids.
func (m *RepositoryMutation) AddEnvironmentIDs(ids ...uuid.UUID) {
	if m._Environments == nil {
		m._Environments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Environments[ids[i]] = struct{}{}
	}
}

// ClearEnvironments clears the "Environments" edge to the Environment entity.
func (m *RepositoryMutation) ClearEnvironments() {
	m.cleared_Environments = true
}

// EnvironmentsCleared reports if the "Environments" edge to the Environment entity was cleared.
func (m *RepositoryMutation) EnvironmentsCleared() bool {
	return m.cleared_Environments
}

// RemoveEnvironmentIDs removes the "Environments" edge to the Environment entity by IDs.
func (m *RepositoryMutation) RemoveEnvironmentIDs(ids ...uuid.UUID) {
	if m.removed_Environments == nil {
		m.removed_Environments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Environments, ids[i])
		m.removed_Environments[ids[i]] = struct{}{}
	}
}

// RemovedEnvironments returns the removed IDs of the "Environments" edge to the Environment entity.
func (m *RepositoryMutation) RemovedEnvironmentsIDs() (ids []uuid.UUID) {
	for id := range m.removed_Environments {
		ids = append(ids, id)
	}
	return
}

// EnvironmentsIDs returns the "Environments" edge IDs in the mutation.
func (m *RepositoryMutation) EnvironmentsIDs() (ids []uuid.UUID) {
	for id := range m._Environments {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironments resets all changes to the "Environments" edge.
func (m *RepositoryMutation) ResetEnvironments() {
	m._Environments = nil
	m.cleared_Environments = false
	m.removed_Environments = nil
}

// AddRepoCommitIDs adds the "RepoCommits" edge to the RepoCommit entity by ids.
func (m *RepositoryMutation) AddRepoCommitIDs(ids ...uuid.UUID) {
	if m._RepoCommits == nil {
		m._RepoCommits = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._RepoCommits[ids[i]] = struct{}{}
	}
}

// ClearRepoCommits clears the "RepoCommits" edge to the RepoCommit entity.
func (m *RepositoryMutation) ClearRepoCommits() {
	m.cleared_RepoCommits = true
}

// RepoCommitsCleared reports if the "RepoCommits" edge to the RepoCommit entity was cleared.
func (m *RepositoryMutation) RepoCommitsCleared() bool {
	return m.cleared_RepoCommits
}

// RemoveRepoCommitIDs removes the "RepoCommits" edge to the RepoCommit entity by IDs.
func (m *RepositoryMutation) RemoveRepoCommitIDs(ids ...uuid.UUID) {
	if m.removed_RepoCommits == nil {
		m.removed_RepoCommits = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._RepoCommits, ids[i])
		m.removed_RepoCommits[ids[i]] = struct{}{}
	}
}

// RemovedRepoCommits returns the removed IDs of the "RepoCommits" edge to the RepoCommit entity.
func (m *RepositoryMutation) RemovedRepoCommitsIDs() (ids []uuid.UUID) {
	for id := range m.removed_RepoCommits {
		ids = append(ids, id)
	}
	return
}

// RepoCommitsIDs returns the "RepoCommits" edge IDs in the mutation.
func (m *RepositoryMutation) RepoCommitsIDs() (ids []uuid.UUID) {
	for id := range m._RepoCommits {
		ids = append(ids, id)
	}
	return
}

// ResetRepoCommits resets all changes to the "RepoCommits" edge.
func (m *RepositoryMutation) ResetRepoCommits() {
	m._RepoCommits = nil
	m.cleared_RepoCommits = false
	m.removed_RepoCommits = nil
}

// Where appends a list predicates to the RepositoryMutation builder.
func (m *RepositoryMutation) Where(ps ...predicate.Repository) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RepositoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Repository).
func (m *RepositoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RepositoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.repo_url != nil {
		fields = append(fields, repository.FieldRepoURL)
	}
	if m.branch_name != nil {
		fields = append(fields, repository.FieldBranchName)
	}
	if m.enviroment_filepath != nil {
		fields = append(fields, repository.FieldEnviromentFilepath)
	}
	if m.folder_path != nil {
		fields = append(fields, repository.FieldFolderPath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RepositoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case repository.FieldRepoURL:
		return m.RepoURL()
	case repository.FieldBranchName:
		return m.BranchName()
	case repository.FieldEnviromentFilepath:
		return m.EnviromentFilepath()
	case repository.FieldFolderPath:
		return m.FolderPath()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RepositoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case repository.FieldRepoURL:
		return m.OldRepoURL(ctx)
	case repository.FieldBranchName:
		return m.OldBranchName(ctx)
	case repository.FieldEnviromentFilepath:
		return m.OldEnviromentFilepath(ctx)
	case repository.FieldFolderPath:
		return m.OldFolderPath(ctx)
	}
	return nil, fmt.Errorf("unknown Repository field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepositoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case repository.FieldRepoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepoURL(v)
		return nil
	case repository.FieldBranchName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranchName(v)
		return nil
	case repository.FieldEnviromentFilepath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnviromentFilepath(v)
		return nil
	case repository.FieldFolderPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFolderPath(v)
		return nil
	}
	return fmt.Errorf("unknown Repository field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RepositoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RepositoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepositoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Repository numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RepositoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RepositoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RepositoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Repository nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RepositoryMutation) ResetField(name string) error {
	switch name {
	case repository.FieldRepoURL:
		m.ResetRepoURL()
		return nil
	case repository.FieldBranchName:
		m.ResetBranchName()
		return nil
	case repository.FieldEnviromentFilepath:
		m.ResetEnviromentFilepath()
		return nil
	case repository.FieldFolderPath:
		m.ResetFolderPath()
		return nil
	}
	return fmt.Errorf("unknown Repository field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RepositoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._Environments != nil {
		edges = append(edges, repository.EdgeEnvironments)
	}
	if m._RepoCommits != nil {
		edges = append(edges, repository.EdgeRepoCommits)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RepositoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case repository.EdgeEnvironments:
		ids := make([]ent.Value, 0, len(m._Environments))
		for id := range m._Environments {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeRepoCommits:
		ids := make([]ent.Value, 0, len(m._RepoCommits))
		for id := range m._RepoCommits {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RepositoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_Environments != nil {
		edges = append(edges, repository.EdgeEnvironments)
	}
	if m.removed_RepoCommits != nil {
		edges = append(edges, repository.EdgeRepoCommits)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RepositoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case repository.EdgeEnvironments:
		ids := make([]ent.Value, 0, len(m.removed_Environments))
		for id := range m.removed_Environments {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeRepoCommits:
		ids := make([]ent.Value, 0, len(m.removed_RepoCommits))
		for id := range m.removed_RepoCommits {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RepositoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_Environments {
		edges = append(edges, repository.EdgeEnvironments)
	}
	if m.cleared_RepoCommits {
		edges = append(edges, repository.EdgeRepoCommits)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RepositoryMutation) EdgeCleared(name string) bool {
	switch name {
	case repository.EdgeEnvironments:
		return m.cleared_Environments
	case repository.EdgeRepoCommits:
		return m.cleared_RepoCommits
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RepositoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Repository unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RepositoryMutation) ResetEdge(name string) error {
	switch name {
	case repository.EdgeEnvironments:
		m.ResetEnvironments()
		return nil
	case repository.EdgeRepoCommits:
		m.ResetRepoCommits()
		return nil
	}
	return fmt.Errorf("unknown Repository edge %s", name)
}

// ScheduledStepMutation represents an operation that mutates the ScheduledStep nodes in the graph.
type ScheduledStepMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	hcl_id              *string
	name                *string
	description         *string
	step                *string
	_type               *scheduledstep.Type
	schedule            *string
	run_at              *int64
	addrun_at           *int64
	clearedFields       map[string]struct{}
	_Environment        *uuid.UUID
	cleared_Environment bool
	done                bool
	oldValue            func(context.Context) (*ScheduledStep, error)
	predicates          []predicate.ScheduledStep
}

var _ ent.Mutation = (*ScheduledStepMutation)(nil)

// scheduledstepOption allows management of the mutation configuration using functional options.
type scheduledstepOption func(*ScheduledStepMutation)

// newScheduledStepMutation creates new mutation for the ScheduledStep entity.
func newScheduledStepMutation(c config, op Op, opts ...scheduledstepOption) *ScheduledStepMutation {
	m := &ScheduledStepMutation{
		config:        c,
		op:            op,
		typ:           TypeScheduledStep,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScheduledStepID sets the ID field of the mutation.
func withScheduledStepID(id uuid.UUID) scheduledstepOption {
	return func(m *ScheduledStepMutation) {
		var (
			err   error
			once  sync.Once
			value *ScheduledStep
		)
		m.oldValue = func(ctx context.Context) (*ScheduledStep, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ScheduledStep.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScheduledStep sets the old ScheduledStep of the mutation.
func withScheduledStep(node *ScheduledStep) scheduledstepOption {
	return func(m *ScheduledStepMutation) {
		m.oldValue = func(context.Context) (*ScheduledStep, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScheduledStepMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScheduledStepMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ScheduledStep entities.
func (m *ScheduledStepMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScheduledStepMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScheduledStepMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ScheduledStep.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHclID sets the "hcl_id" field.
func (m *ScheduledStepMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *ScheduledStepMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the ScheduledStep entity.
// If the ScheduledStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledStepMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *ScheduledStepMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetName sets the "name" field.
func (m *ScheduledStepMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ScheduledStepMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ScheduledStep entity.
// If the ScheduledStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledStepMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ScheduledStepMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ScheduledStepMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ScheduledStepMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ScheduledStep entity.
// If the ScheduledStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledStepMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ScheduledStepMutation) ResetDescription() {
	m.description = nil
}

// SetStep sets the "step" field.
func (m *ScheduledStepMutation) SetStep(s string) {
	m.step = &s
}

// Step returns the value of the "step" field in the mutation.
func (m *ScheduledStepMutation) Step() (r string, exists bool) {
	v := m.step
	if v == nil {
		return
	}
	return *v, true
}

// OldStep returns the old "step" field's value of the ScheduledStep entity.
// If the ScheduledStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledStepMutation) OldStep(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStep: %w", err)
	}
	return oldValue.Step, nil
}

// ResetStep resets all changes to the "step" field.
func (m *ScheduledStepMutation) ResetStep() {
	m.step = nil
}

// SetType sets the "type" field.
func (m *ScheduledStepMutation) SetType(s scheduledstep.Type) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ScheduledStepMutation) GetType() (r scheduledstep.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ScheduledStep entity.
// If the ScheduledStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledStepMutation) OldType(ctx context.Context) (v scheduledstep.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ScheduledStepMutation) ResetType() {
	m._type = nil
}

// SetSchedule sets the "schedule" field.
func (m *ScheduledStepMutation) SetSchedule(s string) {
	m.schedule = &s
}

// Schedule returns the value of the "schedule" field in the mutation.
func (m *ScheduledStepMutation) Schedule() (r string, exists bool) {
	v := m.schedule
	if v == nil {
		return
	}
	return *v, true
}

// OldSchedule returns the old "schedule" field's value of the ScheduledStep entity.
// If the ScheduledStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledStepMutation) OldSchedule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchedule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchedule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchedule: %w", err)
	}
	return oldValue.Schedule, nil
}

// ClearSchedule clears the value of the "schedule" field.
func (m *ScheduledStepMutation) ClearSchedule() {
	m.schedule = nil
	m.clearedFields[scheduledstep.FieldSchedule] = struct{}{}
}

// ScheduleCleared returns if the "schedule" field was cleared in this mutation.
func (m *ScheduledStepMutation) ScheduleCleared() bool {
	_, ok := m.clearedFields[scheduledstep.FieldSchedule]
	return ok
}

// ResetSchedule resets all changes to the "schedule" field.
func (m *ScheduledStepMutation) ResetSchedule() {
	m.schedule = nil
	delete(m.clearedFields, scheduledstep.FieldSchedule)
}

// SetRunAt sets the "run_at" field.
func (m *ScheduledStepMutation) SetRunAt(i int64) {
	m.run_at = &i
	m.addrun_at = nil
}

// RunAt returns the value of the "run_at" field in the mutation.
func (m *ScheduledStepMutation) RunAt() (r int64, exists bool) {
	v := m.run_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRunAt returns the old "run_at" field's value of the ScheduledStep entity.
// If the ScheduledStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduledStepMutation) OldRunAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunAt: %w", err)
	}
	return oldValue.RunAt, nil
}

// AddRunAt adds i to the "run_at" field.
func (m *ScheduledStepMutation) AddRunAt(i int64) {
	if m.addrun_at != nil {
		*m.addrun_at += i
	} else {
		m.addrun_at = &i
	}
}

// AddedRunAt returns the value that was added to the "run_at" field in this mutation.
func (m *ScheduledStepMutation) AddedRunAt() (r int64, exists bool) {
	v := m.addrun_at
	if v == nil {
		return
	}
	return *v, true
}

// ClearRunAt clears the value of the "run_at" field.
func (m *ScheduledStepMutation) ClearRunAt() {
	m.run_at = nil
	m.addrun_at = nil
	m.clearedFields[scheduledstep.FieldRunAt] = struct{}{}
}

// RunAtCleared returns if the "run_at" field was cleared in this mutation.
func (m *ScheduledStepMutation) RunAtCleared() bool {
	_, ok := m.clearedFields[scheduledstep.FieldRunAt]
	return ok
}

// ResetRunAt resets all changes to the "run_at" field.
func (m *ScheduledStepMutation) ResetRunAt() {
	m.run_at = nil
	m.addrun_at = nil
	delete(m.clearedFields, scheduledstep.FieldRunAt)
}

// SetEnvironmentID sets the "Environment" edge to the Environment entity by id.
func (m *ScheduledStepMutation) SetEnvironmentID(id uuid.UUID) {
	m._Environment = &id
}

// ClearEnvironment clears the "Environment" edge to the Environment entity.
func (m *ScheduledStepMutation) ClearEnvironment() {
	m.cleared_Environment = true
}

// EnvironmentCleared reports if the "Environment" edge to the Environment entity was cleared.
func (m *ScheduledStepMutation) EnvironmentCleared() bool {
	return m.cleared_Environment
}

// EnvironmentID returns the "Environment" edge ID in the mutation.
func (m *ScheduledStepMutation) EnvironmentID() (id uuid.UUID, exists bool) {
	if m._Environment != nil {
		return *m._Environment, true
	}
	return
}

// EnvironmentIDs returns the "Environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *ScheduledStepMutation) EnvironmentIDs() (ids []uuid.UUID) {
	if id := m._Environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "Environment" edge.
func (m *ScheduledStepMutation) ResetEnvironment() {
	m._Environment = nil
	m.cleared_Environment = false
}

// Where appends a list predicates to the ScheduledStepMutation builder.
func (m *ScheduledStepMutation) Where(ps ...predicate.ScheduledStep) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ScheduledStepMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ScheduledStep).
func (m *ScheduledStepMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScheduledStepMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.hcl_id != nil {
		fields = append(fields, scheduledstep.FieldHclID)
	}
	if m.name != nil {
		fields = append(fields, scheduledstep.FieldName)
	}
	if m.description != nil {
		fields = append(fields, scheduledstep.FieldDescription)
	}
	if m.step != nil {
		fields = append(fields, scheduledstep.FieldStep)
	}
	if m._type != nil {
		fields = append(fields, scheduledstep.FieldType)
	}
	if m.schedule != nil {
		fields = append(fields, scheduledstep.FieldSchedule)
	}
	if m.run_at != nil {
		fields = append(fields, scheduledstep.FieldRunAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScheduledStepMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case scheduledstep.FieldHclID:
		return m.HclID()
	case scheduledstep.FieldName:
		return m.Name()
	case scheduledstep.FieldDescription:
		return m.Description()
	case scheduledstep.FieldStep:
		return m.Step()
	case scheduledstep.FieldType:
		return m.GetType()
	case scheduledstep.FieldSchedule:
		return m.Schedule()
	case scheduledstep.FieldRunAt:
		return m.RunAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScheduledStepMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case scheduledstep.FieldHclID:
		return m.OldHclID(ctx)
	case scheduledstep.FieldName:
		return m.OldName(ctx)
	case scheduledstep.FieldDescription:
		return m.OldDescription(ctx)
	case scheduledstep.FieldStep:
		return m.OldStep(ctx)
	case scheduledstep.FieldType:
		return m.OldType(ctx)
	case scheduledstep.FieldSchedule:
		return m.OldSchedule(ctx)
	case scheduledstep.FieldRunAt:
		return m.OldRunAt(ctx)
	}
	return nil, fmt.Errorf("unknown ScheduledStep field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduledStepMutation) SetField(name string, value ent.Value) error {
	switch name {
	case scheduledstep.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case scheduledstep.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case scheduledstep.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case scheduledstep.FieldStep:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStep(v)
		return nil
	case scheduledstep.FieldType:
		v, ok := value.(scheduledstep.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case scheduledstep.FieldSchedule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchedule(v)
		return nil
	case scheduledstep.FieldRunAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunAt(v)
		return nil
	}
	return fmt.Errorf("unknown ScheduledStep field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScheduledStepMutation) AddedFields() []string {
	var fields []string
	if m.addrun_at != nil {
		fields = append(fields, scheduledstep.FieldRunAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScheduledStepMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case scheduledstep.FieldRunAt:
		return m.AddedRunAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduledStepMutation) AddField(name string, value ent.Value) error {
	switch name {
	case scheduledstep.FieldRunAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRunAt(v)
		return nil
	}
	return fmt.Errorf("unknown ScheduledStep numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScheduledStepMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(scheduledstep.FieldSchedule) {
		fields = append(fields, scheduledstep.FieldSchedule)
	}
	if m.FieldCleared(scheduledstep.FieldRunAt) {
		fields = append(fields, scheduledstep.FieldRunAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScheduledStepMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScheduledStepMutation) ClearField(name string) error {
	switch name {
	case scheduledstep.FieldSchedule:
		m.ClearSchedule()
		return nil
	case scheduledstep.FieldRunAt:
		m.ClearRunAt()
		return nil
	}
	return fmt.Errorf("unknown ScheduledStep nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScheduledStepMutation) ResetField(name string) error {
	switch name {
	case scheduledstep.FieldHclID:
		m.ResetHclID()
		return nil
	case scheduledstep.FieldName:
		m.ResetName()
		return nil
	case scheduledstep.FieldDescription:
		m.ResetDescription()
		return nil
	case scheduledstep.FieldStep:
		m.ResetStep()
		return nil
	case scheduledstep.FieldType:
		m.ResetType()
		return nil
	case scheduledstep.FieldSchedule:
		m.ResetSchedule()
		return nil
	case scheduledstep.FieldRunAt:
		m.ResetRunAt()
		return nil
	}
	return fmt.Errorf("unknown ScheduledStep field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScheduledStepMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Environment != nil {
		edges = append(edges, scheduledstep.EdgeEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScheduledStepMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case scheduledstep.EdgeEnvironment:
		if id := m._Environment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScheduledStepMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScheduledStepMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScheduledStepMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Environment {
		edges = append(edges, scheduledstep.EdgeEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScheduledStepMutation) EdgeCleared(name string) bool {
	switch name {
	case scheduledstep.EdgeEnvironment:
		return m.cleared_Environment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScheduledStepMutation) ClearEdge(name string) error {
	switch name {
	case scheduledstep.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	}
	return fmt.Errorf("unknown ScheduledStep unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScheduledStepMutation) ResetEdge(name string) error {
	switch name {
	case scheduledstep.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	}
	return fmt.Errorf("unknown ScheduledStep edge %s", name)
}

// ScriptMutation represents an operation that mutates the Script nodes in the graph.
type ScriptMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	hcl_id              *string
	name                *string
	language            *string
	description         *string
	source              *string
	source_type         *string
	cooldown            *int
	addcooldown         *int
	timeout             *int
	addtimeout          *int
	ignore_errors       *bool
	args                *[]string
	disabled            *bool
	vars                *map[string]string
	abs_path            *string
	tags                *map[string]string
	clearedFields       map[string]struct{}
	_Users              map[uuid.UUID]struct{}
	removed_Users       map[uuid.UUID]struct{}
	cleared_Users       bool
	_Findings           map[uuid.UUID]struct{}
	removed_Findings    map[uuid.UUID]struct{}
	cleared_Findings    bool
	_Environment        *uuid.UUID
	cleared_Environment bool
	done                bool
	oldValue            func(context.Context) (*Script, error)
	predicates          []predicate.Script
}

var _ ent.Mutation = (*ScriptMutation)(nil)

// scriptOption allows management of the mutation configuration using functional options.
type scriptOption func(*ScriptMutation)

// newScriptMutation creates new mutation for the Script entity.
func newScriptMutation(c config, op Op, opts ...scriptOption) *ScriptMutation {
	m := &ScriptMutation{
		config:        c,
		op:            op,
		typ:           TypeScript,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScriptID sets the ID field of the mutation.
func withScriptID(id uuid.UUID) scriptOption {
	return func(m *ScriptMutation) {
		var (
			err   error
			once  sync.Once
			value *Script
		)
		m.oldValue = func(ctx context.Context) (*Script, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Script.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScript sets the old Script of the mutation.
func withScript(node *Script) scriptOption {
	return func(m *ScriptMutation) {
		m.oldValue = func(context.Context) (*Script, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScriptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScriptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Script entities.
func (m *ScriptMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScriptMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScriptMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Script.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHclID sets the "hcl_id" field.
func (m *ScriptMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *ScriptMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *ScriptMutation) ResetHclID() {
	m.hcl_id = nil
}

// SetName sets the "name" field.
func (m *ScriptMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ScriptMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ScriptMutation) ResetName() {
	m.name = nil
}

// SetLanguage sets the "language" field.
func (m *ScriptMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *ScriptMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *ScriptMutation) ResetLanguage() {
	m.language = nil
}

// SetDescription sets the "description" field.
func (m *ScriptMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ScriptMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ScriptMutation) ResetDescription() {
	m.description = nil
}

// SetSource sets the "source" field.
func (m *ScriptMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *ScriptMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *ScriptMutation) ResetSource() {
	m.source = nil
}

// SetSourceType sets the "source_type" field.
func (m *ScriptMutation) SetSourceType(s string) {
	m.source_type = &s
}

// SourceType returns the value of the "source_type" field in the mutation.
func (m *ScriptMutation) SourceType() (r string, exists bool) {
	v := m.source_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceType returns the old "source_type" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldSourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceType: %w", err)
	}
	return oldValue.SourceType, nil
}

// ResetSourceType resets all changes to the "source_type" field.
func (m *ScriptMutation) ResetSourceType() {
	m.source_type = nil
}

// SetCooldown sets the "cooldown" field.
func (m *ScriptMutation) SetCooldown(i int) {
	m.cooldown = &i
	m.addcooldown = nil
}

// Cooldown returns the value of the "cooldown" field in the mutation.
func (m *ScriptMutation) Cooldown() (r int, exists bool) {
	v := m.cooldown
	if v == nil {
		return
	}
	return *v, true
}

// OldCooldown returns the old "cooldown" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldCooldown(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCooldown is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCooldown requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCooldown: %w", err)
	}
	return oldValue.Cooldown, nil
}

// AddCooldown adds i to the "cooldown" field.
func (m *ScriptMutation) AddCooldown(i int) {
	if m.addcooldown != nil {
		*m.addcooldown += i
	} else {
		m.addcooldown = &i
	}
}

// AddedCooldown returns the value that was added to the "cooldown" field in this mutation.
func (m *ScriptMutation) AddedCooldown() (r int, exists bool) {
	v := m.addcooldown
	if v == nil {
		return
	}
	return *v, true
}

// ResetCooldown resets all changes to the "cooldown" field.
func (m *ScriptMutation) ResetCooldown() {
	m.cooldown = nil
	m.addcooldown = nil
}

// SetTimeout sets the "timeout" field.
func (m *ScriptMutation) SetTimeout(i int) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *ScriptMutation) Timeout() (r int, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to the "timeout" field.
func (m *ScriptMutation) AddTimeout(i int) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the "timeout" field in this mutation.
func (m *ScriptMutation) AddedTimeout() (r int, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *ScriptMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
}

// SetIgnoreErrors sets the "ignore_errors" field.
func (m *ScriptMutation) SetIgnoreErrors(b bool) {
	m.ignore_errors = &b
}

// IgnoreErrors returns the value of the "ignore_errors" field in the mutation.
func (m *ScriptMutation) IgnoreErrors() (r bool, exists bool) {
	v := m.ignore_errors
	if v == nil {
		return
	}
	return *v, true
}

// OldIgnoreErrors returns the old "ignore_errors" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldIgnoreErrors(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIgnoreErrors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIgnoreErrors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIgnoreErrors: %w", err)
	}
	return oldValue.IgnoreErrors, nil
}

// ResetIgnoreErrors resets all changes to the "ignore_errors" field.
func (m *ScriptMutation) ResetIgnoreErrors() {
	m.ignore_errors = nil
}

// SetArgs sets the "args" field.
func (m *ScriptMutation) SetArgs(s []string) {
	m.args = &s
}

// Args returns the value of the "args" field in the mutation.
func (m *ScriptMutation) Args() (r []string, exists bool) {
	v := m.args
	if v == nil {
		return
	}
	return *v, true
}

// OldArgs returns the old "args" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldArgs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArgs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArgs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArgs: %w", err)
	}
	return oldValue.Args, nil
}

// ResetArgs resets all changes to the "args" field.
func (m *ScriptMutation) ResetArgs() {
	m.args = nil
}

// SetDisabled sets the "disabled" field.
func (m *ScriptMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *ScriptMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *ScriptMutation) ResetDisabled() {
	m.disabled = nil
}

// SetVars sets the "vars" field.
func (m *ScriptMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *ScriptMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *ScriptMutation) ResetVars() {
	m.vars = nil
}

// SetAbsPath sets the "abs_path" field.
func (m *ScriptMutation) SetAbsPath(s string) {
	m.abs_path = &s
}

// AbsPath returns the value of the "abs_path" field in the mutation.
func (m *ScriptMutation) AbsPath() (r string, exists bool) {
	v := m.abs_path
	if v == nil {
		return
	}
	return *v, true
}

// OldAbsPath returns the old "abs_path" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldAbsPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbsPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbsPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbsPath: %w", err)
	}
	return oldValue.AbsPath, nil
}

// ResetAbsPath resets all changes to the "abs_path" field.
func (m *ScriptMutation) ResetAbsPath() {
	m.abs_path = nil
}

// SetTags sets the "tags" field.
func (m *ScriptMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ScriptMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *ScriptMutation) ResetTags() {
	m.tags = nil
}

// AddUserIDs adds the "Users" edge to the User entity by ids.
func (m *ScriptMutation) AddUserIDs(ids ...uuid.UUID) {
	if m._Users == nil {
		m._Users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "Users" edge to the User entity.
func (m *ScriptMutation) ClearUsers() {
	m.cleared_Users = true
}

// UsersCleared reports if the "Users" edge to the User entity was cleared.
func (m *ScriptMutation) UsersCleared() bool {
	return m.cleared_Users
}

// RemoveUserIDs removes the "Users" edge to the User entity by IDs.
func (m *ScriptMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removed_Users == nil {
		m.removed_Users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Users, ids[i])
		m.removed_Users[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "Users" edge to the User entity.
func (m *ScriptMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removed_Users {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "Users" edge IDs in the mutation.
func (m *ScriptMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m._Users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "Users" edge.
func (m *ScriptMutation) ResetUsers() {
	m._Users = nil
	m.cleared_Users = false
	m.removed_Users = nil
}

// AddFindingIDs adds the "Findings" edge to the Finding entity by ids.
func (m *ScriptMutation) AddFindingIDs(ids ...uuid.UUID) {
	if m._Findings == nil {
		m._Findings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Findings[ids[i]] = struct{}{}
	}
}

// ClearFindings clears the "Findings" edge to the Finding entity.
func (m *ScriptMutation) ClearFindings() {
	m.cleared_Findings = true
}

// FindingsCleared reports if the "Findings" edge to the Finding entity was cleared.
func (m *ScriptMutation) FindingsCleared() bool {
	return m.cleared_Findings
}

// RemoveFindingIDs removes the "Findings" edge to the Finding entity by IDs.
func (m *ScriptMutation) RemoveFindingIDs(ids ...uuid.UUID) {
	if m.removed_Findings == nil {
		m.removed_Findings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Findings, ids[i])
		m.removed_Findings[ids[i]] = struct{}{}
	}
}

// RemovedFindings returns the removed IDs of the "Findings" edge to the Finding entity.
func (m *ScriptMutation) RemovedFindingsIDs() (ids []uuid.UUID) {
	for id := range m.removed_Findings {
		ids = append(ids, id)
	}
	return
}

// FindingsIDs returns the "Findings" edge IDs in the mutation.
func (m *ScriptMutation) FindingsIDs() (ids []uuid.UUID) {
	for id := range m._Findings {
		ids = append(ids, id)
	}
	return
}

// ResetFindings resets all changes to the "Findings" edge.
func (m *ScriptMutation) ResetFindings() {
	m._Findings = nil
	m.cleared_Findings = false
	m.removed_Findings = nil
}

// SetEnvironmentID sets the "Environment" edge to the Environment entity by id.
func (m *ScriptMutation) SetEnvironmentID(id uuid.UUID) {
	m._Environment = &id
}

// ClearEnvironment clears the "Environment" edge to the Environment entity.
func (m *ScriptMutation) ClearEnvironment() {
	m.cleared_Environment = true
}

// EnvironmentCleared reports if the "Environment" edge to the Environment entity was cleared.
func (m *ScriptMutation) EnvironmentCleared() bool {
	return m.cleared_Environment
}

// EnvironmentID returns the "Environment" edge ID in the mutation.
func (m *ScriptMutation) EnvironmentID() (id uuid.UUID, exists bool) {
	if m._Environment != nil {
		return *m._Environment, true
	}
	return
}

// EnvironmentIDs returns the "Environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *ScriptMutation) EnvironmentIDs() (ids []uuid.UUID) {
	if id := m._Environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "Environment" edge.
func (m *ScriptMutation) ResetEnvironment() {
	m._Environment = nil
	m.cleared_Environment = false
}

// Where appends a list predicates to the ScriptMutation builder.
func (m *ScriptMutation) Where(ps ...predicate.Script) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ScriptMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Script).
func (m *ScriptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScriptMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.hcl_id != nil {
		fields = append(fields, script.FieldHclID)
	}
	if m.name != nil {
		fields = append(fields, script.FieldName)
	}
	if m.language != nil {
		fields = append(fields, script.FieldLanguage)
	}
	if m.description != nil {
		fields = append(fields, script.FieldDescription)
	}
	if m.source != nil {
		fields = append(fields, script.FieldSource)
	}
	if m.source_type != nil {
		fields = append(fields, script.FieldSourceType)
	}
	if m.cooldown != nil {
		fields = append(fields, script.FieldCooldown)
	}
	if m.timeout != nil {
		fields = append(fields, script.FieldTimeout)
	}
	if m.ignore_errors != nil {
		fields = append(fields, script.FieldIgnoreErrors)
	}
	if m.args != nil {
		fields = append(fields, script.FieldArgs)
	}
	if m.disabled != nil {
		fields = append(fields, script.FieldDisabled)
	}
	if m.vars != nil {
		fields = append(fields, script.FieldVars)
	}
	if m.abs_path != nil {
		fields = append(fields, script.FieldAbsPath)
	}
	if m.tags != nil {
		fields = append(fields, script.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScriptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case script.FieldHclID:
		return m.HclID()
	case script.FieldName:
		return m.Name()
	case script.FieldLanguage:
		return m.Language()
	case script.FieldDescription:
		return m.Description()
	case script.FieldSource:
		return m.Source()
	case script.FieldSourceType:
		return m.SourceType()
	case script.FieldCooldown:
		return m.Cooldown()
	case script.FieldTimeout:
		return m.Timeout()
	case script.FieldIgnoreErrors:
		return m.IgnoreErrors()
	case script.FieldArgs:
		return m.Args()
	case script.FieldDisabled:
		return m.Disabled()
	case script.FieldVars:
		return m.Vars()
	case script.FieldAbsPath:
		return m.AbsPath()
	case script.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScriptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case script.FieldHclID:
		return m.OldHclID(ctx)
	case script.FieldName:
		return m.OldName(ctx)
	case script.FieldLanguage:
		return m.OldLanguage(ctx)
	case script.FieldDescription:
		return m.OldDescription(ctx)
	case script.FieldSource:
		return m.OldSource(ctx)
	case script.FieldSourceType:
		return m.OldSourceType(ctx)
	case script.FieldCooldown:
		return m.OldCooldown(ctx)
	case script.FieldTimeout:
		return m.OldTimeout(ctx)
	case script.FieldIgnoreErrors:
		return m.OldIgnoreErrors(ctx)
	case script.FieldArgs:
		return m.OldArgs(ctx)
	case script.FieldDisabled:
		return m.OldDisabled(ctx)
	case script.FieldVars:
		return m.OldVars(ctx)
	case script.FieldAbsPath:
		return m.OldAbsPath(ctx)
	case script.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Script field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScriptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case script.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	case script.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case script.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case script.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case script.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case script.FieldSourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceType(v)
		return nil
	case script.FieldCooldown:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCooldown(v)
		return nil
	case script.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case script.FieldIgnoreErrors:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIgnoreErrors(v)
		return nil
	case script.FieldArgs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArgs(v)
		return nil
	case script.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case script.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	case script.FieldAbsPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbsPath(v)
		return nil
	case script.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Script field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScriptMutation) AddedFields() []string {
	var fields []string
	if m.addcooldown != nil {
		fields = append(fields, script.FieldCooldown)
	}
	if m.addtimeout != nil {
		fields = append(fields, script.FieldTimeout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScriptMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case script.FieldCooldown:
		return m.AddedCooldown()
	case script.FieldTimeout:
		return m.AddedTimeout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScriptMutation) AddField(name string, value ent.Value) error {
	switch name {
	case script.FieldCooldown:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCooldown(v)
		return nil
	case script.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown Script numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScriptMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScriptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScriptMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Script nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScriptMutation) ResetField(name string) error {
	switch name {
	case script.FieldHclID:
		m.ResetHclID()
		return nil
	case script.FieldName:
		m.ResetName()
		return nil
	case script.FieldLanguage:
		m.ResetLanguage()
		return nil
	case script.FieldDescription:
		m.ResetDescription()
		return nil
	case script.FieldSource:
		m.ResetSource()
		return nil
	case script.FieldSourceType:
		m.ResetSourceType()
		return nil
	case script.FieldCooldown:
		m.ResetCooldown()
		return nil
	case script.FieldTimeout:
		m.ResetTimeout()
		return nil
	case script.FieldIgnoreErrors:
		m.ResetIgnoreErrors()
		return nil
	case script.FieldArgs:
		m.ResetArgs()
		return nil
	case script.FieldDisabled:
		m.ResetDisabled()
		return nil
	case script.FieldVars:
		m.ResetVars()
		return nil
	case script.FieldAbsPath:
		m.ResetAbsPath()
		return nil
	case script.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Script field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScriptMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Users != nil {
		edges = append(edges, script.EdgeUsers)
	}
	if m._Findings != nil {
		edges = append(edges, script.EdgeFindings)
	}
	if m._Environment != nil {
		edges = append(edges, script.EdgeEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScriptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case script.EdgeUsers:
		ids := make([]ent.Value, 0, len(m._Users))
		for id := range m._Users {
			ids = append(ids, id)
		}
		return ids
	case script.EdgeFindings:
		ids := make([]ent.Value, 0, len(m._Findings))
		for id := range m._Findings {
			ids = append(ids, id)
		}
		return ids
	case script.EdgeEnvironment:
		if id := m._Environment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScriptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_Users != nil {
		edges = append(edges, script.EdgeUsers)
	}
	if m.removed_Findings != nil {
		edges = append(edges, script.EdgeFindings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScriptMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case script.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removed_Users))
		for id := range m.removed_Users {
			ids = append(ids, id)
		}
		return ids
	case script.EdgeFindings:
		ids := make([]ent.Value, 0, len(m.removed_Findings))
		for id := range m.removed_Findings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScriptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Users {
		edges = append(edges, script.EdgeUsers)
	}
	if m.cleared_Findings {
		edges = append(edges, script.EdgeFindings)
	}
	if m.cleared_Environment {
		edges = append(edges, script.EdgeEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScriptMutation) EdgeCleared(name string) bool {
	switch name {
	case script.EdgeUsers:
		return m.cleared_Users
	case script.EdgeFindings:
		return m.cleared_Findings
	case script.EdgeEnvironment:
		return m.cleared_Environment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScriptMutation) ClearEdge(name string) error {
	switch name {
	case script.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Script unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScriptMutation) ResetEdge(name string) error {
	switch name {
	case script.EdgeUsers:
		m.ResetUsers()
		return nil
	case script.EdgeFindings:
		m.ResetFindings()
		return nil
	case script.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Script edge %s", name)
}

// ServerTaskMutation represents an operation that mutates the ServerTask nodes in the graph.
type ServerTaskMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	_type                     *servertask.Type
	start_time                *time.Time
	end_time                  *time.Time
	errors                    *[]string
	log_file_path             *string
	clearedFields             map[string]struct{}
	_AuthUser                 *uuid.UUID
	cleared_AuthUser          bool
	_Status                   *uuid.UUID
	cleared_Status            bool
	_Environment              *uuid.UUID
	cleared_Environment       bool
	_Build                    *uuid.UUID
	cleared_Build             bool
	_BuildCommit              *uuid.UUID
	cleared_BuildCommit       bool
	_GinFileMiddleware        map[uuid.UUID]struct{}
	removed_GinFileMiddleware map[uuid.UUID]struct{}
	cleared_GinFileMiddleware bool
	done                      bool
	oldValue                  func(context.Context) (*ServerTask, error)
	predicates                []predicate.ServerTask
}

var _ ent.Mutation = (*ServerTaskMutation)(nil)

// servertaskOption allows management of the mutation configuration using functional options.
type servertaskOption func(*ServerTaskMutation)

// newServerTaskMutation creates new mutation for the ServerTask entity.
func newServerTaskMutation(c config, op Op, opts ...servertaskOption) *ServerTaskMutation {
	m := &ServerTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeServerTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerTaskID sets the ID field of the mutation.
func withServerTaskID(id uuid.UUID) servertaskOption {
	return func(m *ServerTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerTask
		)
		m.oldValue = func(ctx context.Context) (*ServerTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerTask sets the old ServerTask of the mutation.
func withServerTask(node *ServerTask) servertaskOption {
	return func(m *ServerTaskMutation) {
		m.oldValue = func(context.Context) (*ServerTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerTask entities.
func (m *ServerTaskMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerTaskMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerTaskMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *ServerTaskMutation) SetType(s servertask.Type) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ServerTaskMutation) GetType() (r servertask.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ServerTask entity.
// If the ServerTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerTaskMutation) OldType(ctx context.Context) (v servertask.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ServerTaskMutation) ResetType() {
	m._type = nil
}

// SetStartTime sets the "start_time" field.
func (m *ServerTaskMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ServerTaskMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the ServerTask entity.
// If the ServerTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerTaskMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *ServerTaskMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[servertask.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *ServerTaskMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[servertask.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ServerTaskMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, servertask.FieldStartTime)
}

// SetEndTime sets the "end_time" field.
func (m *ServerTaskMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *ServerTaskMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the ServerTask entity.
// If the ServerTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerTaskMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *ServerTaskMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[servertask.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *ServerTaskMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[servertask.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *ServerTaskMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, servertask.FieldEndTime)
}

// SetErrors sets the "errors" field.
func (m *ServerTaskMutation) SetErrors(s []string) {
	m.errors = &s
}

// Errors returns the value of the "errors" field in the mutation.
func (m *ServerTaskMutation) Errors() (r []string, exists bool) {
	v := m.errors
	if v == nil {
		return
	}
	return *v, true
}

// OldErrors returns the old "errors" field's value of the ServerTask entity.
// If the ServerTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerTaskMutation) OldErrors(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrors: %w", err)
	}
	return oldValue.Errors, nil
}

// ClearErrors clears the value of the "errors" field.
func (m *ServerTaskMutation) ClearErrors() {
	m.errors = nil
	m.clearedFields[servertask.FieldErrors] = struct{}{}
}

// ErrorsCleared returns if the "errors" field was cleared in this mutation.
func (m *ServerTaskMutation) ErrorsCleared() bool {
	_, ok := m.clearedFields[servertask.FieldErrors]
	return ok
}

// ResetErrors resets all changes to the "errors" field.
func (m *ServerTaskMutation) ResetErrors() {
	m.errors = nil
	delete(m.clearedFields, servertask.FieldErrors)
}

// SetLogFilePath sets the "log_file_path" field.
func (m *ServerTaskMutation) SetLogFilePath(s string) {
	m.log_file_path = &s
}

// LogFilePath returns the value of the "log_file_path" field in the mutation.
func (m *ServerTaskMutation) LogFilePath() (r string, exists bool) {
	v := m.log_file_path
	if v == nil {
		return
	}
	return *v, true
}

// OldLogFilePath returns the old "log_file_path" field's value of the ServerTask entity.
// If the ServerTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerTaskMutation) OldLogFilePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogFilePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogFilePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogFilePath: %w", err)
	}
	return oldValue.LogFilePath, nil
}

// ClearLogFilePath clears the value of the "log_file_path" field.
func (m *ServerTaskMutation) ClearLogFilePath() {
	m.log_file_path = nil
	m.clearedFields[servertask.FieldLogFilePath] = struct{}{}
}

// LogFilePathCleared returns if the "log_file_path" field was cleared in this mutation.
func (m *ServerTaskMutation) LogFilePathCleared() bool {
	_, ok := m.clearedFields[servertask.FieldLogFilePath]
	return ok
}

// ResetLogFilePath resets all changes to the "log_file_path" field.
func (m *ServerTaskMutation) ResetLogFilePath() {
	m.log_file_path = nil
	delete(m.clearedFields, servertask.FieldLogFilePath)
}

// SetAuthUserID sets the "AuthUser" edge to the AuthUser entity by id.
func (m *ServerTaskMutation) SetAuthUserID(id uuid.UUID) {
	m._AuthUser = &id
}

// ClearAuthUser clears the "AuthUser" edge to the AuthUser entity.
func (m *ServerTaskMutation) ClearAuthUser() {
	m.cleared_AuthUser = true
}

// AuthUserCleared reports if the "AuthUser" edge to the AuthUser entity was cleared.
func (m *ServerTaskMutation) AuthUserCleared() bool {
	return m.cleared_AuthUser
}

// AuthUserID returns the "AuthUser" edge ID in the mutation.
func (m *ServerTaskMutation) AuthUserID() (id uuid.UUID, exists bool) {
	if m._AuthUser != nil {
		return *m._AuthUser, true
	}
	return
}

// AuthUserIDs returns the "AuthUser" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthUserID instead. It exists only for internal usage by the builders.
func (m *ServerTaskMutation) AuthUserIDs() (ids []uuid.UUID) {
	if id := m._AuthUser; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthUser resets all changes to the "AuthUser" edge.
func (m *ServerTaskMutation) ResetAuthUser() {
	m._AuthUser = nil
	m.cleared_AuthUser = false
}

// SetStatusID sets the "Status" edge to the Status entity by id.
func (m *ServerTaskMutation) SetStatusID(id uuid.UUID) {
	m._Status = &id
}

// ClearStatus clears the "Status" edge to the Status entity.
func (m *ServerTaskMutation) ClearStatus() {
	m.cleared_Status = true
}

// StatusCleared reports if the "Status" edge to the Status entity was cleared.
func (m *ServerTaskMutation) StatusCleared() bool {
	return m.cleared_Status
}

// StatusID returns the "Status" edge ID in the mutation.
func (m *ServerTaskMutation) StatusID() (id uuid.UUID, exists bool) {
	if m._Status != nil {
		return *m._Status, true
	}
	return
}

// StatusIDs returns the "Status" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusID instead. It exists only for internal usage by the builders.
func (m *ServerTaskMutation) StatusIDs() (ids []uuid.UUID) {
	if id := m._Status; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatus resets all changes to the "Status" edge.
func (m *ServerTaskMutation) ResetStatus() {
	m._Status = nil
	m.cleared_Status = false
}

// SetEnvironmentID sets the "Environment" edge to the Environment entity by id.
func (m *ServerTaskMutation) SetEnvironmentID(id uuid.UUID) {
	m._Environment = &id
}

// ClearEnvironment clears the "Environment" edge to the Environment entity.
func (m *ServerTaskMutation) ClearEnvironment() {
	m.cleared_Environment = true
}

// EnvironmentCleared reports if the "Environment" edge to the Environment entity was cleared.
func (m *ServerTaskMutation) EnvironmentCleared() bool {
	return m.cleared_Environment
}

// EnvironmentID returns the "Environment" edge ID in the mutation.
func (m *ServerTaskMutation) EnvironmentID() (id uuid.UUID, exists bool) {
	if m._Environment != nil {
		return *m._Environment, true
	}
	return
}

// EnvironmentIDs returns the "Environment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnvironmentID instead. It exists only for internal usage by the builders.
func (m *ServerTaskMutation) EnvironmentIDs() (ids []uuid.UUID) {
	if id := m._Environment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnvironment resets all changes to the "Environment" edge.
func (m *ServerTaskMutation) ResetEnvironment() {
	m._Environment = nil
	m.cleared_Environment = false
}

// SetBuildID sets the "Build" edge to the Build entity by id.
func (m *ServerTaskMutation) SetBuildID(id uuid.UUID) {
	m._Build = &id
}

// ClearBuild clears the "Build" edge to the Build entity.
func (m *ServerTaskMutation) ClearBuild() {
	m.cleared_Build = true
}

// BuildCleared reports if the "Build" edge to the Build entity was cleared.
func (m *ServerTaskMutation) BuildCleared() bool {
	return m.cleared_Build
}

// BuildID returns the "Build" edge ID in the mutation.
func (m *ServerTaskMutation) BuildID() (id uuid.UUID, exists bool) {
	if m._Build != nil {
		return *m._Build, true
	}
	return
}

// BuildIDs returns the "Build" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuildID instead. It exists only for internal usage by the builders.
func (m *ServerTaskMutation) BuildIDs() (ids []uuid.UUID) {
	if id := m._Build; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuild resets all changes to the "Build" edge.
func (m *ServerTaskMutation) ResetBuild() {
	m._Build = nil
	m.cleared_Build = false
}

// SetBuildCommitID sets the "BuildCommit" edge to the BuildCommit entity by id.
func (m *ServerTaskMutation) SetBuildCommitID(id uuid.UUID) {
	m._BuildCommit = &id
}

// ClearBuildCommit clears the "BuildCommit" edge to the BuildCommit entity.
func (m *ServerTaskMutation) ClearBuildCommit() {
	m.cleared_BuildCommit = true
}

// BuildCommitCleared reports if the "BuildCommit" edge to the BuildCommit entity was cleared.
func (m *ServerTaskMutation) BuildCommitCleared() bool {
	return m.cleared_BuildCommit
}

// BuildCommitID returns the "BuildCommit" edge ID in the mutation.
func (m *ServerTaskMutation) BuildCommitID() (id uuid.UUID, exists bool) {
	if m._BuildCommit != nil {
		return *m._BuildCommit, true
	}
	return
}

// BuildCommitIDs returns the "BuildCommit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuildCommitID instead. It exists only for internal usage by the builders.
func (m *ServerTaskMutation) BuildCommitIDs() (ids []uuid.UUID) {
	if id := m._BuildCommit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuildCommit resets all changes to the "BuildCommit" edge.
func (m *ServerTaskMutation) ResetBuildCommit() {
	m._BuildCommit = nil
	m.cleared_BuildCommit = false
}

// AddGinFileMiddlewareIDs adds the "GinFileMiddleware" edge to the GinFileMiddleware entity by ids.
func (m *ServerTaskMutation) AddGinFileMiddlewareIDs(ids ...uuid.UUID) {
	if m._GinFileMiddleware == nil {
		m._GinFileMiddleware = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._GinFileMiddleware[ids[i]] = struct{}{}
	}
}

// ClearGinFileMiddleware clears the "GinFileMiddleware" edge to the GinFileMiddleware entity.
func (m *ServerTaskMutation) ClearGinFileMiddleware() {
	m.cleared_GinFileMiddleware = true
}

// GinFileMiddlewareCleared reports if the "GinFileMiddleware" edge to the GinFileMiddleware entity was cleared.
func (m *ServerTaskMutation) GinFileMiddlewareCleared() bool {
	return m.cleared_GinFileMiddleware
}

// RemoveGinFileMiddlewareIDs removes the "GinFileMiddleware" edge to the GinFileMiddleware entity by IDs.
func (m *ServerTaskMutation) RemoveGinFileMiddlewareIDs(ids ...uuid.UUID) {
	if m.removed_GinFileMiddleware == nil {
		m.removed_GinFileMiddleware = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._GinFileMiddleware, ids[i])
		m.removed_GinFileMiddleware[ids[i]] = struct{}{}
	}
}

// RemovedGinFileMiddleware returns the removed IDs of the "GinFileMiddleware" edge to the GinFileMiddleware entity.
func (m *ServerTaskMutation) RemovedGinFileMiddlewareIDs() (ids []uuid.UUID) {
	for id := range m.removed_GinFileMiddleware {
		ids = append(ids, id)
	}
	return
}

// GinFileMiddlewareIDs returns the "GinFileMiddleware" edge IDs in the mutation.
func (m *ServerTaskMutation) GinFileMiddlewareIDs() (ids []uuid.UUID) {
	for id := range m._GinFileMiddleware {
		ids = append(ids, id)
	}
	return
}

// ResetGinFileMiddleware resets all changes to the "GinFileMiddleware" edge.
func (m *ServerTaskMutation) ResetGinFileMiddleware() {
	m._GinFileMiddleware = nil
	m.cleared_GinFileMiddleware = false
	m.removed_GinFileMiddleware = nil
}

// Where appends a list predicates to the ServerTaskMutation builder.
func (m *ServerTaskMutation) Where(ps ...predicate.ServerTask) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ServerTaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ServerTask).
func (m *ServerTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerTaskMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._type != nil {
		fields = append(fields, servertask.FieldType)
	}
	if m.start_time != nil {
		fields = append(fields, servertask.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, servertask.FieldEndTime)
	}
	if m.errors != nil {
		fields = append(fields, servertask.FieldErrors)
	}
	if m.log_file_path != nil {
		fields = append(fields, servertask.FieldLogFilePath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servertask.FieldType:
		return m.GetType()
	case servertask.FieldStartTime:
		return m.StartTime()
	case servertask.FieldEndTime:
		return m.EndTime()
	case servertask.FieldErrors:
		return m.Errors()
	case servertask.FieldLogFilePath:
		return m.LogFilePath()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servertask.FieldType:
		return m.OldType(ctx)
	case servertask.FieldStartTime:
		return m.OldStartTime(ctx)
	case servertask.FieldEndTime:
		return m.OldEndTime(ctx)
	case servertask.FieldErrors:
		return m.OldErrors(ctx)
	case servertask.FieldLogFilePath:
		return m.OldLogFilePath(ctx)
	}
	return nil, fmt.Errorf("unknown ServerTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servertask.FieldType:
		v, ok := value.(servertask.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case servertask.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case servertask.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case servertask.FieldErrors:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrors(v)
		return nil
	case servertask.FieldLogFilePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogFilePath(v)
		return nil
	}
	return fmt.Errorf("unknown ServerTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerTaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerTaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerTaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(servertask.FieldStartTime) {
		fields = append(fields, servertask.FieldStartTime)
	}
	if m.FieldCleared(servertask.FieldEndTime) {
		fields = append(fields, servertask.FieldEndTime)
	}
	if m.FieldCleared(servertask.FieldErrors) {
		fields = append(fields, servertask.FieldErrors)
	}
	if m.FieldCleared(servertask.FieldLogFilePath) {
		fields = append(fields, servertask.FieldLogFilePath)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerTaskMutation) ClearField(name string) error {
	switch name {
	case servertask.FieldStartTime:
		m.ClearStartTime()
		return nil
	case servertask.FieldEndTime:
		m.ClearEndTime()
		return nil
	case servertask.FieldErrors:
		m.ClearErrors()
		return nil
	case servertask.FieldLogFilePath:
		m.ClearLogFilePath()
		return nil
	}
	return fmt.Errorf("unknown ServerTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerTaskMutation) ResetField(name string) error {
	switch name {
	case servertask.FieldType:
		m.ResetType()
		return nil
	case servertask.FieldStartTime:
		m.ResetStartTime()
		return nil
	case servertask.FieldEndTime:
		m.ResetEndTime()
		return nil
	case servertask.FieldErrors:
		m.ResetErrors()
		return nil
	case servertask.FieldLogFilePath:
		m.ResetLogFilePath()
		return nil
	}
	return fmt.Errorf("unknown ServerTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m._AuthUser != nil {
		edges = append(edges, servertask.EdgeAuthUser)
	}
	if m._Status != nil {
		edges = append(edges, servertask.EdgeStatus)
	}
	if m._Environment != nil {
		edges = append(edges, servertask.EdgeEnvironment)
	}
	if m._Build != nil {
		edges = append(edges, servertask.EdgeBuild)
	}
	if m._BuildCommit != nil {
		edges = append(edges, servertask.EdgeBuildCommit)
	}
	if m._GinFileMiddleware != nil {
		edges = append(edges, servertask.EdgeGinFileMiddleware)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerTaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servertask.EdgeAuthUser:
		if id := m._AuthUser; id != nil {
			return []ent.Value{*id}
		}
	case servertask.EdgeStatus:
		if id := m._Status; id != nil {
			return []ent.Value{*id}
		}
	case servertask.EdgeEnvironment:
		if id := m._Environment; id != nil {
			return []ent.Value{*id}
		}
	case servertask.EdgeBuild:
		if id := m._Build; id != nil {
			return []ent.Value{*id}
		}
	case servertask.EdgeBuildCommit:
		if id := m._BuildCommit; id != nil {
			return []ent.Value{*id}
		}
	case servertask.EdgeGinFileMiddleware:
		ids := make([]ent.Value, 0, len(m._GinFileMiddleware))
		for id := range m._GinFileMiddleware {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removed_GinFileMiddleware != nil {
		edges = append(edges, servertask.EdgeGinFileMiddleware)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerTaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case servertask.EdgeGinFileMiddleware:
		ids := make([]ent.Value, 0, len(m.removed_GinFileMiddleware))
		for id := range m.removed_GinFileMiddleware {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleared_AuthUser {
		edges = append(edges, servertask.EdgeAuthUser)
	}
	if m.cleared_Status {
		edges = append(edges, servertask.EdgeStatus)
	}
	if m.cleared_Environment {
		edges = append(edges, servertask.EdgeEnvironment)
	}
	if m.cleared_Build {
		edges = append(edges, servertask.EdgeBuild)
	}
	if m.cleared_BuildCommit {
		edges = append(edges, servertask.EdgeBuildCommit)
	}
	if m.cleared_GinFileMiddleware {
		edges = append(edges, servertask.EdgeGinFileMiddleware)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerTaskMutation) EdgeCleared(name string) bool {
	switch name {
	case servertask.EdgeAuthUser:
		return m.cleared_AuthUser
	case servertask.EdgeStatus:
		return m.cleared_Status
	case servertask.EdgeEnvironment:
		return m.cleared_Environment
	case servertask.EdgeBuild:
		return m.cleared_Build
	case servertask.EdgeBuildCommit:
		return m.cleared_BuildCommit
	case servertask.EdgeGinFileMiddleware:
		return m.cleared_GinFileMiddleware
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerTaskMutation) ClearEdge(name string) error {
	switch name {
	case servertask.EdgeAuthUser:
		m.ClearAuthUser()
		return nil
	case servertask.EdgeStatus:
		m.ClearStatus()
		return nil
	case servertask.EdgeEnvironment:
		m.ClearEnvironment()
		return nil
	case servertask.EdgeBuild:
		m.ClearBuild()
		return nil
	case servertask.EdgeBuildCommit:
		m.ClearBuildCommit()
		return nil
	}
	return fmt.Errorf("unknown ServerTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerTaskMutation) ResetEdge(name string) error {
	switch name {
	case servertask.EdgeAuthUser:
		m.ResetAuthUser()
		return nil
	case servertask.EdgeStatus:
		m.ResetStatus()
		return nil
	case servertask.EdgeEnvironment:
		m.ResetEnvironment()
		return nil
	case servertask.EdgeBuild:
		m.ResetBuild()
		return nil
	case servertask.EdgeBuildCommit:
		m.ResetBuildCommit()
		return nil
	case servertask.EdgeGinFileMiddleware:
		m.ResetGinFileMiddleware()
		return nil
	}
	return fmt.Errorf("unknown ServerTask edge %s", name)
}

// StatusMutation represents an operation that mutates the Status nodes in the graph.
type StatusMutation struct {
	config
	op                                Op
	typ                               string
	id                                *uuid.UUID
	state                             *status.State
	status_for                        *status.StatusFor
	started_at                        *time.Time
	ended_at                          *time.Time
	failed                            *bool
	completed                         *bool
	error                             *string
	clearedFields                     map[string]struct{}
	_Build                            *uuid.UUID
	cleared_Build                     bool
	_ProvisionedNetwork               *uuid.UUID
	cleared_ProvisionedNetwork        bool
	_ProvisionedHost                  *uuid.UUID
	cleared_ProvisionedHost           bool
	_ProvisioningStep                 *uuid.UUID
	cleared_ProvisioningStep          bool
	_Team                             *uuid.UUID
	cleared_Team                      bool
	_Plan                             *uuid.UUID
	cleared_Plan                      bool
	_ServerTask                       *uuid.UUID
	cleared_ServerTask                bool
	_AdhocPlan                        *uuid.UUID
	cleared_AdhocPlan                 bool
	_ProvisioningScheduledStep        *uuid.UUID
	cleared_ProvisioningScheduledStep bool
	done                              bool
	oldValue                          func(context.Context) (*Status, error)
	predicates                        []predicate.Status
}

var _ ent.Mutation = (*StatusMutation)(nil)

// statusOption allows management of the mutation configuration using functional options.
type statusOption func(*StatusMutation)

// newStatusMutation creates new mutation for the Status entity.
func newStatusMutation(c config, op Op, opts ...statusOption) *StatusMutation {
	m := &StatusMutation{
		config:        c,
		op:            op,
		typ:           TypeStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatusID sets the ID field of the mutation.
func withStatusID(id uuid.UUID) statusOption {
	return func(m *StatusMutation) {
		var (
			err   error
			once  sync.Once
			value *Status
		)
		m.oldValue = func(ctx context.Context) (*Status, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Status.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatus sets the old Status of the mutation.
func withStatus(node *Status) statusOption {
	return func(m *StatusMutation) {
		m.oldValue = func(context.Context) (*Status, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Status entities.
func (m *StatusMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StatusMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StatusMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Status.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetState sets the "state" field.
func (m *StatusMutation) SetState(s status.State) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *StatusMutation) State() (r status.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldState(ctx context.Context) (v status.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *StatusMutation) ResetState() {
	m.state = nil
}

// SetStatusFor sets the "status_for" field.
func (m *StatusMutation) SetStatusFor(sf status.StatusFor) {
	m.status_for = &sf
}

// StatusFor returns the value of the "status_for" field in the mutation.
func (m *StatusMutation) StatusFor() (r status.StatusFor, exists bool) {
	v := m.status_for
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusFor returns the old "status_for" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldStatusFor(ctx context.Context) (v status.StatusFor, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusFor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusFor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusFor: %w", err)
	}
	return oldValue.StatusFor, nil
}

// ResetStatusFor resets all changes to the "status_for" field.
func (m *StatusMutation) ResetStatusFor() {
	m.status_for = nil
}

// SetStartedAt sets the "started_at" field.
func (m *StatusMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *StatusMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *StatusMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[status.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *StatusMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[status.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *StatusMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, status.FieldStartedAt)
}

// SetEndedAt sets the "ended_at" field.
func (m *StatusMutation) SetEndedAt(t time.Time) {
	m.ended_at = &t
}

// EndedAt returns the value of the "ended_at" field in the mutation.
func (m *StatusMutation) EndedAt() (r time.Time, exists bool) {
	v := m.ended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old "ended_at" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldEndedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ClearEndedAt clears the value of the "ended_at" field.
func (m *StatusMutation) ClearEndedAt() {
	m.ended_at = nil
	m.clearedFields[status.FieldEndedAt] = struct{}{}
}

// EndedAtCleared returns if the "ended_at" field was cleared in this mutation.
func (m *StatusMutation) EndedAtCleared() bool {
	_, ok := m.clearedFields[status.FieldEndedAt]
	return ok
}

// ResetEndedAt resets all changes to the "ended_at" field.
func (m *StatusMutation) ResetEndedAt() {
	m.ended_at = nil
	delete(m.clearedFields, status.FieldEndedAt)
}

// SetFailed sets the "failed" field.
func (m *StatusMutation) SetFailed(b bool) {
	m.failed = &b
}

// Failed returns the value of the "failed" field in the mutation.
func (m *StatusMutation) Failed() (r bool, exists bool) {
	v := m.failed
	if v == nil {
		return
	}
	return *v, true
}

// OldFailed returns the old "failed" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldFailed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailed: %w", err)
	}
	return oldValue.Failed, nil
}

// ResetFailed resets all changes to the "failed" field.
func (m *StatusMutation) ResetFailed() {
	m.failed = nil
}

// SetCompleted sets the "completed" field.
func (m *StatusMutation) SetCompleted(b bool) {
	m.completed = &b
}

// Completed returns the value of the "completed" field in the mutation.
func (m *StatusMutation) Completed() (r bool, exists bool) {
	v := m.completed
	if v == nil {
		return
	}
	return *v, true
}

// OldCompleted returns the old "completed" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldCompleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompleted: %w", err)
	}
	return oldValue.Completed, nil
}

// ResetCompleted resets all changes to the "completed" field.
func (m *StatusMutation) ResetCompleted() {
	m.completed = nil
}

// SetError sets the "error" field.
func (m *StatusMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *StatusMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *StatusMutation) ClearError() {
	m.error = nil
	m.clearedFields[status.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *StatusMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[status.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *StatusMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, status.FieldError)
}

// SetBuildID sets the "Build" edge to the Build entity by id.
func (m *StatusMutation) SetBuildID(id uuid.UUID) {
	m._Build = &id
}

// ClearBuild clears the "Build" edge to the Build entity.
func (m *StatusMutation) ClearBuild() {
	m.cleared_Build = true
}

// BuildCleared reports if the "Build" edge to the Build entity was cleared.
func (m *StatusMutation) BuildCleared() bool {
	return m.cleared_Build
}

// BuildID returns the "Build" edge ID in the mutation.
func (m *StatusMutation) BuildID() (id uuid.UUID, exists bool) {
	if m._Build != nil {
		return *m._Build, true
	}
	return
}

// BuildIDs returns the "Build" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuildID instead. It exists only for internal usage by the builders.
func (m *StatusMutation) BuildIDs() (ids []uuid.UUID) {
	if id := m._Build; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuild resets all changes to the "Build" edge.
func (m *StatusMutation) ResetBuild() {
	m._Build = nil
	m.cleared_Build = false
}

// SetProvisionedNetworkID sets the "ProvisionedNetwork" edge to the ProvisionedNetwork entity by id.
func (m *StatusMutation) SetProvisionedNetworkID(id uuid.UUID) {
	m._ProvisionedNetwork = &id
}

// ClearProvisionedNetwork clears the "ProvisionedNetwork" edge to the ProvisionedNetwork entity.
func (m *StatusMutation) ClearProvisionedNetwork() {
	m.cleared_ProvisionedNetwork = true
}

// ProvisionedNetworkCleared reports if the "ProvisionedNetwork" edge to the ProvisionedNetwork entity was cleared.
func (m *StatusMutation) ProvisionedNetworkCleared() bool {
	return m.cleared_ProvisionedNetwork
}

// ProvisionedNetworkID returns the "ProvisionedNetwork" edge ID in the mutation.
func (m *StatusMutation) ProvisionedNetworkID() (id uuid.UUID, exists bool) {
	if m._ProvisionedNetwork != nil {
		return *m._ProvisionedNetwork, true
	}
	return
}

// ProvisionedNetworkIDs returns the "ProvisionedNetwork" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisionedNetworkID instead. It exists only for internal usage by the builders.
func (m *StatusMutation) ProvisionedNetworkIDs() (ids []uuid.UUID) {
	if id := m._ProvisionedNetwork; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisionedNetwork resets all changes to the "ProvisionedNetwork" edge.
func (m *StatusMutation) ResetProvisionedNetwork() {
	m._ProvisionedNetwork = nil
	m.cleared_ProvisionedNetwork = false
}

// SetProvisionedHostID sets the "ProvisionedHost" edge to the ProvisionedHost entity by id.
func (m *StatusMutation) SetProvisionedHostID(id uuid.UUID) {
	m._ProvisionedHost = &id
}

// ClearProvisionedHost clears the "ProvisionedHost" edge to the ProvisionedHost entity.
func (m *StatusMutation) ClearProvisionedHost() {
	m.cleared_ProvisionedHost = true
}

// ProvisionedHostCleared reports if the "ProvisionedHost" edge to the ProvisionedHost entity was cleared.
func (m *StatusMutation) ProvisionedHostCleared() bool {
	return m.cleared_ProvisionedHost
}

// ProvisionedHostID returns the "ProvisionedHost" edge ID in the mutation.
func (m *StatusMutation) ProvisionedHostID() (id uuid.UUID, exists bool) {
	if m._ProvisionedHost != nil {
		return *m._ProvisionedHost, true
	}
	return
}

// ProvisionedHostIDs returns the "ProvisionedHost" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisionedHostID instead. It exists only for internal usage by the builders.
func (m *StatusMutation) ProvisionedHostIDs() (ids []uuid.UUID) {
	if id := m._ProvisionedHost; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisionedHost resets all changes to the "ProvisionedHost" edge.
func (m *StatusMutation) ResetProvisionedHost() {
	m._ProvisionedHost = nil
	m.cleared_ProvisionedHost = false
}

// SetProvisioningStepID sets the "ProvisioningStep" edge to the ProvisioningStep entity by id.
func (m *StatusMutation) SetProvisioningStepID(id uuid.UUID) {
	m._ProvisioningStep = &id
}

// ClearProvisioningStep clears the "ProvisioningStep" edge to the ProvisioningStep entity.
func (m *StatusMutation) ClearProvisioningStep() {
	m.cleared_ProvisioningStep = true
}

// ProvisioningStepCleared reports if the "ProvisioningStep" edge to the ProvisioningStep entity was cleared.
func (m *StatusMutation) ProvisioningStepCleared() bool {
	return m.cleared_ProvisioningStep
}

// ProvisioningStepID returns the "ProvisioningStep" edge ID in the mutation.
func (m *StatusMutation) ProvisioningStepID() (id uuid.UUID, exists bool) {
	if m._ProvisioningStep != nil {
		return *m._ProvisioningStep, true
	}
	return
}

// ProvisioningStepIDs returns the "ProvisioningStep" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisioningStepID instead. It exists only for internal usage by the builders.
func (m *StatusMutation) ProvisioningStepIDs() (ids []uuid.UUID) {
	if id := m._ProvisioningStep; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisioningStep resets all changes to the "ProvisioningStep" edge.
func (m *StatusMutation) ResetProvisioningStep() {
	m._ProvisioningStep = nil
	m.cleared_ProvisioningStep = false
}

// SetTeamID sets the "Team" edge to the Team entity by id.
func (m *StatusMutation) SetTeamID(id uuid.UUID) {
	m._Team = &id
}

// ClearTeam clears the "Team" edge to the Team entity.
func (m *StatusMutation) ClearTeam() {
	m.cleared_Team = true
}

// TeamCleared reports if the "Team" edge to the Team entity was cleared.
func (m *StatusMutation) TeamCleared() bool {
	return m.cleared_Team
}

// TeamID returns the "Team" edge ID in the mutation.
func (m *StatusMutation) TeamID() (id uuid.UUID, exists bool) {
	if m._Team != nil {
		return *m._Team, true
	}
	return
}

// TeamIDs returns the "Team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *StatusMutation) TeamIDs() (ids []uuid.UUID) {
	if id := m._Team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "Team" edge.
func (m *StatusMutation) ResetTeam() {
	m._Team = nil
	m.cleared_Team = false
}

// SetPlanID sets the "Plan" edge to the Plan entity by id.
func (m *StatusMutation) SetPlanID(id uuid.UUID) {
	m._Plan = &id
}

// ClearPlan clears the "Plan" edge to the Plan entity.
func (m *StatusMutation) ClearPlan() {
	m.cleared_Plan = true
}

// PlanCleared reports if the "Plan" edge to the Plan entity was cleared.
func (m *StatusMutation) PlanCleared() bool {
	return m.cleared_Plan
}

// PlanID returns the "Plan" edge ID in the mutation.
func (m *StatusMutation) PlanID() (id uuid.UUID, exists bool) {
	if m._Plan != nil {
		return *m._Plan, true
	}
	return
}

// PlanIDs returns the "Plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *StatusMutation) PlanIDs() (ids []uuid.UUID) {
	if id := m._Plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "Plan" edge.
func (m *StatusMutation) ResetPlan() {
	m._Plan = nil
	m.cleared_Plan = false
}

// SetServerTaskID sets the "ServerTask" edge to the ServerTask entity by id.
func (m *StatusMutation) SetServerTaskID(id uuid.UUID) {
	m._ServerTask = &id
}

// ClearServerTask clears the "ServerTask" edge to the ServerTask entity.
func (m *StatusMutation) ClearServerTask() {
	m.cleared_ServerTask = true
}

// ServerTaskCleared reports if the "ServerTask" edge to the ServerTask entity was cleared.
func (m *StatusMutation) ServerTaskCleared() bool {
	return m.cleared_ServerTask
}

// ServerTaskID returns the "ServerTask" edge ID in the mutation.
func (m *StatusMutation) ServerTaskID() (id uuid.UUID, exists bool) {
	if m._ServerTask != nil {
		return *m._ServerTask, true
	}
	return
}

// ServerTaskIDs returns the "ServerTask" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerTaskID instead. It exists only for internal usage by the builders.
func (m *StatusMutation) ServerTaskIDs() (ids []uuid.UUID) {
	if id := m._ServerTask; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServerTask resets all changes to the "ServerTask" edge.
func (m *StatusMutation) ResetServerTask() {
	m._ServerTask = nil
	m.cleared_ServerTask = false
}

// SetAdhocPlanID sets the "AdhocPlan" edge to the AdhocPlan entity by id.
func (m *StatusMutation) SetAdhocPlanID(id uuid.UUID) {
	m._AdhocPlan = &id
}

// ClearAdhocPlan clears the "AdhocPlan" edge to the AdhocPlan entity.
func (m *StatusMutation) ClearAdhocPlan() {
	m.cleared_AdhocPlan = true
}

// AdhocPlanCleared reports if the "AdhocPlan" edge to the AdhocPlan entity was cleared.
func (m *StatusMutation) AdhocPlanCleared() bool {
	return m.cleared_AdhocPlan
}

// AdhocPlanID returns the "AdhocPlan" edge ID in the mutation.
func (m *StatusMutation) AdhocPlanID() (id uuid.UUID, exists bool) {
	if m._AdhocPlan != nil {
		return *m._AdhocPlan, true
	}
	return
}

// AdhocPlanIDs returns the "AdhocPlan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdhocPlanID instead. It exists only for internal usage by the builders.
func (m *StatusMutation) AdhocPlanIDs() (ids []uuid.UUID) {
	if id := m._AdhocPlan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdhocPlan resets all changes to the "AdhocPlan" edge.
func (m *StatusMutation) ResetAdhocPlan() {
	m._AdhocPlan = nil
	m.cleared_AdhocPlan = false
}

// SetProvisioningScheduledStepID sets the "ProvisioningScheduledStep" edge to the ProvisioningScheduledStep entity by id.
func (m *StatusMutation) SetProvisioningScheduledStepID(id uuid.UUID) {
	m._ProvisioningScheduledStep = &id
}

// ClearProvisioningScheduledStep clears the "ProvisioningScheduledStep" edge to the ProvisioningScheduledStep entity.
func (m *StatusMutation) ClearProvisioningScheduledStep() {
	m.cleared_ProvisioningScheduledStep = true
}

// ProvisioningScheduledStepCleared reports if the "ProvisioningScheduledStep" edge to the ProvisioningScheduledStep entity was cleared.
func (m *StatusMutation) ProvisioningScheduledStepCleared() bool {
	return m.cleared_ProvisioningScheduledStep
}

// ProvisioningScheduledStepID returns the "ProvisioningScheduledStep" edge ID in the mutation.
func (m *StatusMutation) ProvisioningScheduledStepID() (id uuid.UUID, exists bool) {
	if m._ProvisioningScheduledStep != nil {
		return *m._ProvisioningScheduledStep, true
	}
	return
}

// ProvisioningScheduledStepIDs returns the "ProvisioningScheduledStep" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisioningScheduledStepID instead. It exists only for internal usage by the builders.
func (m *StatusMutation) ProvisioningScheduledStepIDs() (ids []uuid.UUID) {
	if id := m._ProvisioningScheduledStep; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisioningScheduledStep resets all changes to the "ProvisioningScheduledStep" edge.
func (m *StatusMutation) ResetProvisioningScheduledStep() {
	m._ProvisioningScheduledStep = nil
	m.cleared_ProvisioningScheduledStep = false
}

// Where appends a list predicates to the StatusMutation builder.
func (m *StatusMutation) Where(ps ...predicate.Status) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Status).
func (m *StatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatusMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.state != nil {
		fields = append(fields, status.FieldState)
	}
	if m.status_for != nil {
		fields = append(fields, status.FieldStatusFor)
	}
	if m.started_at != nil {
		fields = append(fields, status.FieldStartedAt)
	}
	if m.ended_at != nil {
		fields = append(fields, status.FieldEndedAt)
	}
	if m.failed != nil {
		fields = append(fields, status.FieldFailed)
	}
	if m.completed != nil {
		fields = append(fields, status.FieldCompleted)
	}
	if m.error != nil {
		fields = append(fields, status.FieldError)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case status.FieldState:
		return m.State()
	case status.FieldStatusFor:
		return m.StatusFor()
	case status.FieldStartedAt:
		return m.StartedAt()
	case status.FieldEndedAt:
		return m.EndedAt()
	case status.FieldFailed:
		return m.Failed()
	case status.FieldCompleted:
		return m.Completed()
	case status.FieldError:
		return m.Error()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case status.FieldState:
		return m.OldState(ctx)
	case status.FieldStatusFor:
		return m.OldStatusFor(ctx)
	case status.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case status.FieldEndedAt:
		return m.OldEndedAt(ctx)
	case status.FieldFailed:
		return m.OldFailed(ctx)
	case status.FieldCompleted:
		return m.OldCompleted(ctx)
	case status.FieldError:
		return m.OldError(ctx)
	}
	return nil, fmt.Errorf("unknown Status field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case status.FieldState:
		v, ok := value.(status.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case status.FieldStatusFor:
		v, ok := value.(status.StatusFor)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusFor(v)
		return nil
	case status.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case status.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	case status.FieldFailed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailed(v)
		return nil
	case status.FieldCompleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompleted(v)
		return nil
	case status.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	}
	return fmt.Errorf("unknown Status field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Status numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatusMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(status.FieldStartedAt) {
		fields = append(fields, status.FieldStartedAt)
	}
	if m.FieldCleared(status.FieldEndedAt) {
		fields = append(fields, status.FieldEndedAt)
	}
	if m.FieldCleared(status.FieldError) {
		fields = append(fields, status.FieldError)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatusMutation) ClearField(name string) error {
	switch name {
	case status.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case status.FieldEndedAt:
		m.ClearEndedAt()
		return nil
	case status.FieldError:
		m.ClearError()
		return nil
	}
	return fmt.Errorf("unknown Status nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatusMutation) ResetField(name string) error {
	switch name {
	case status.FieldState:
		m.ResetState()
		return nil
	case status.FieldStatusFor:
		m.ResetStatusFor()
		return nil
	case status.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case status.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	case status.FieldFailed:
		m.ResetFailed()
		return nil
	case status.FieldCompleted:
		m.ResetCompleted()
		return nil
	case status.FieldError:
		m.ResetError()
		return nil
	}
	return fmt.Errorf("unknown Status field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m._Build != nil {
		edges = append(edges, status.EdgeBuild)
	}
	if m._ProvisionedNetwork != nil {
		edges = append(edges, status.EdgeProvisionedNetwork)
	}
	if m._ProvisionedHost != nil {
		edges = append(edges, status.EdgeProvisionedHost)
	}
	if m._ProvisioningStep != nil {
		edges = append(edges, status.EdgeProvisioningStep)
	}
	if m._Team != nil {
		edges = append(edges, status.EdgeTeam)
	}
	if m._Plan != nil {
		edges = append(edges, status.EdgePlan)
	}
	if m._ServerTask != nil {
		edges = append(edges, status.EdgeServerTask)
	}
	if m._AdhocPlan != nil {
		edges = append(edges, status.EdgeAdhocPlan)
	}
	if m._ProvisioningScheduledStep != nil {
		edges = append(edges, status.EdgeProvisioningScheduledStep)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case status.EdgeBuild:
		if id := m._Build; id != nil {
			return []ent.Value{*id}
		}
	case status.EdgeProvisionedNetwork:
		if id := m._ProvisionedNetwork; id != nil {
			return []ent.Value{*id}
		}
	case status.EdgeProvisionedHost:
		if id := m._ProvisionedHost; id != nil {
			return []ent.Value{*id}
		}
	case status.EdgeProvisioningStep:
		if id := m._ProvisioningStep; id != nil {
			return []ent.Value{*id}
		}
	case status.EdgeTeam:
		if id := m._Team; id != nil {
			return []ent.Value{*id}
		}
	case status.EdgePlan:
		if id := m._Plan; id != nil {
			return []ent.Value{*id}
		}
	case status.EdgeServerTask:
		if id := m._ServerTask; id != nil {
			return []ent.Value{*id}
		}
	case status.EdgeAdhocPlan:
		if id := m._AdhocPlan; id != nil {
			return []ent.Value{*id}
		}
	case status.EdgeProvisioningScheduledStep:
		if id := m._ProvisioningScheduledStep; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.cleared_Build {
		edges = append(edges, status.EdgeBuild)
	}
	if m.cleared_ProvisionedNetwork {
		edges = append(edges, status.EdgeProvisionedNetwork)
	}
	if m.cleared_ProvisionedHost {
		edges = append(edges, status.EdgeProvisionedHost)
	}
	if m.cleared_ProvisioningStep {
		edges = append(edges, status.EdgeProvisioningStep)
	}
	if m.cleared_Team {
		edges = append(edges, status.EdgeTeam)
	}
	if m.cleared_Plan {
		edges = append(edges, status.EdgePlan)
	}
	if m.cleared_ServerTask {
		edges = append(edges, status.EdgeServerTask)
	}
	if m.cleared_AdhocPlan {
		edges = append(edges, status.EdgeAdhocPlan)
	}
	if m.cleared_ProvisioningScheduledStep {
		edges = append(edges, status.EdgeProvisioningScheduledStep)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatusMutation) EdgeCleared(name string) bool {
	switch name {
	case status.EdgeBuild:
		return m.cleared_Build
	case status.EdgeProvisionedNetwork:
		return m.cleared_ProvisionedNetwork
	case status.EdgeProvisionedHost:
		return m.cleared_ProvisionedHost
	case status.EdgeProvisioningStep:
		return m.cleared_ProvisioningStep
	case status.EdgeTeam:
		return m.cleared_Team
	case status.EdgePlan:
		return m.cleared_Plan
	case status.EdgeServerTask:
		return m.cleared_ServerTask
	case status.EdgeAdhocPlan:
		return m.cleared_AdhocPlan
	case status.EdgeProvisioningScheduledStep:
		return m.cleared_ProvisioningScheduledStep
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatusMutation) ClearEdge(name string) error {
	switch name {
	case status.EdgeBuild:
		m.ClearBuild()
		return nil
	case status.EdgeProvisionedNetwork:
		m.ClearProvisionedNetwork()
		return nil
	case status.EdgeProvisionedHost:
		m.ClearProvisionedHost()
		return nil
	case status.EdgeProvisioningStep:
		m.ClearProvisioningStep()
		return nil
	case status.EdgeTeam:
		m.ClearTeam()
		return nil
	case status.EdgePlan:
		m.ClearPlan()
		return nil
	case status.EdgeServerTask:
		m.ClearServerTask()
		return nil
	case status.EdgeAdhocPlan:
		m.ClearAdhocPlan()
		return nil
	case status.EdgeProvisioningScheduledStep:
		m.ClearProvisioningScheduledStep()
		return nil
	}
	return fmt.Errorf("unknown Status unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatusMutation) ResetEdge(name string) error {
	switch name {
	case status.EdgeBuild:
		m.ResetBuild()
		return nil
	case status.EdgeProvisionedNetwork:
		m.ResetProvisionedNetwork()
		return nil
	case status.EdgeProvisionedHost:
		m.ResetProvisionedHost()
		return nil
	case status.EdgeProvisioningStep:
		m.ResetProvisioningStep()
		return nil
	case status.EdgeTeam:
		m.ResetTeam()
		return nil
	case status.EdgePlan:
		m.ResetPlan()
		return nil
	case status.EdgeServerTask:
		m.ResetServerTask()
		return nil
	case status.EdgeAdhocPlan:
		m.ResetAdhocPlan()
		return nil
	case status.EdgeProvisioningScheduledStep:
		m.ResetProvisioningScheduledStep()
		return nil
	}
	return fmt.Errorf("unknown Status edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	uuid          *uuid.UUID
	name          *string
	description   *map[string]string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Tag, error)
	predicates    []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id uuid.UUID) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *TagMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TagMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TagMutation) ResetUUID() {
	m.uuid = nil
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TagMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *TagMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TagMutation) ResetDescription() {
	m.description = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.uuid != nil {
		fields = append(fields, tag.FieldUUID)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.description != nil {
		fields = append(fields, tag.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldUUID:
		return m.UUID()
	case tag.FieldName:
		return m.Name()
	case tag.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldUUID:
		return m.OldUUID(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldUUID:
		m.ResetUUID()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Tag edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uuid.UUID
	team_number                 *int
	addteam_number              *int
	vars                        *map[string]string
	clearedFields               map[string]struct{}
	_Build                      *uuid.UUID
	cleared_Build               bool
	_Status                     *uuid.UUID
	cleared_Status              bool
	_ProvisionedNetworks        map[uuid.UUID]struct{}
	removed_ProvisionedNetworks map[uuid.UUID]struct{}
	cleared_ProvisionedNetworks bool
	_Plan                       *uuid.UUID
	cleared_Plan                bool
	done                        bool
	oldValue                    func(context.Context) (*Team, error)
	predicates                  []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id uuid.UUID) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Team entities.
func (m *TeamMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Team.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTeamNumber sets the "team_number" field.
func (m *TeamMutation) SetTeamNumber(i int) {
	m.team_number = &i
	m.addteam_number = nil
}

// TeamNumber returns the value of the "team_number" field in the mutation.
func (m *TeamMutation) TeamNumber() (r int, exists bool) {
	v := m.team_number
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamNumber returns the old "team_number" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldTeamNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamNumber: %w", err)
	}
	return oldValue.TeamNumber, nil
}

// AddTeamNumber adds i to the "team_number" field.
func (m *TeamMutation) AddTeamNumber(i int) {
	if m.addteam_number != nil {
		*m.addteam_number += i
	} else {
		m.addteam_number = &i
	}
}

// AddedTeamNumber returns the value that was added to the "team_number" field in this mutation.
func (m *TeamMutation) AddedTeamNumber() (r int, exists bool) {
	v := m.addteam_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetTeamNumber resets all changes to the "team_number" field.
func (m *TeamMutation) ResetTeamNumber() {
	m.team_number = nil
	m.addteam_number = nil
}

// SetVars sets the "vars" field.
func (m *TeamMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *TeamMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *TeamMutation) ResetVars() {
	m.vars = nil
}

// SetBuildID sets the "Build" edge to the Build entity by id.
func (m *TeamMutation) SetBuildID(id uuid.UUID) {
	m._Build = &id
}

// ClearBuild clears the "Build" edge to the Build entity.
func (m *TeamMutation) ClearBuild() {
	m.cleared_Build = true
}

// BuildCleared reports if the "Build" edge to the Build entity was cleared.
func (m *TeamMutation) BuildCleared() bool {
	return m.cleared_Build
}

// BuildID returns the "Build" edge ID in the mutation.
func (m *TeamMutation) BuildID() (id uuid.UUID, exists bool) {
	if m._Build != nil {
		return *m._Build, true
	}
	return
}

// BuildIDs returns the "Build" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuildID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) BuildIDs() (ids []uuid.UUID) {
	if id := m._Build; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuild resets all changes to the "Build" edge.
func (m *TeamMutation) ResetBuild() {
	m._Build = nil
	m.cleared_Build = false
}

// SetStatusID sets the "Status" edge to the Status entity by id.
func (m *TeamMutation) SetStatusID(id uuid.UUID) {
	m._Status = &id
}

// ClearStatus clears the "Status" edge to the Status entity.
func (m *TeamMutation) ClearStatus() {
	m.cleared_Status = true
}

// StatusCleared reports if the "Status" edge to the Status entity was cleared.
func (m *TeamMutation) StatusCleared() bool {
	return m.cleared_Status
}

// StatusID returns the "Status" edge ID in the mutation.
func (m *TeamMutation) StatusID() (id uuid.UUID, exists bool) {
	if m._Status != nil {
		return *m._Status, true
	}
	return
}

// StatusIDs returns the "Status" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) StatusIDs() (ids []uuid.UUID) {
	if id := m._Status; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatus resets all changes to the "Status" edge.
func (m *TeamMutation) ResetStatus() {
	m._Status = nil
	m.cleared_Status = false
}

// AddProvisionedNetworkIDs adds the "ProvisionedNetworks" edge to the ProvisionedNetwork entity by ids.
func (m *TeamMutation) AddProvisionedNetworkIDs(ids ...uuid.UUID) {
	if m._ProvisionedNetworks == nil {
		m._ProvisionedNetworks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ProvisionedNetworks[ids[i]] = struct{}{}
	}
}

// ClearProvisionedNetworks clears the "ProvisionedNetworks" edge to the ProvisionedNetwork entity.
func (m *TeamMutation) ClearProvisionedNetworks() {
	m.cleared_ProvisionedNetworks = true
}

// ProvisionedNetworksCleared reports if the "ProvisionedNetworks" edge to the ProvisionedNetwork entity was cleared.
func (m *TeamMutation) ProvisionedNetworksCleared() bool {
	return m.cleared_ProvisionedNetworks
}

// RemoveProvisionedNetworkIDs removes the "ProvisionedNetworks" edge to the ProvisionedNetwork entity by IDs.
func (m *TeamMutation) RemoveProvisionedNetworkIDs(ids ...uuid.UUID) {
	if m.removed_ProvisionedNetworks == nil {
		m.removed_ProvisionedNetworks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._ProvisionedNetworks, ids[i])
		m.removed_ProvisionedNetworks[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedNetworks returns the removed IDs of the "ProvisionedNetworks" edge to the ProvisionedNetwork entity.
func (m *TeamMutation) RemovedProvisionedNetworksIDs() (ids []uuid.UUID) {
	for id := range m.removed_ProvisionedNetworks {
		ids = append(ids, id)
	}
	return
}

// ProvisionedNetworksIDs returns the "ProvisionedNetworks" edge IDs in the mutation.
func (m *TeamMutation) ProvisionedNetworksIDs() (ids []uuid.UUID) {
	for id := range m._ProvisionedNetworks {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedNetworks resets all changes to the "ProvisionedNetworks" edge.
func (m *TeamMutation) ResetProvisionedNetworks() {
	m._ProvisionedNetworks = nil
	m.cleared_ProvisionedNetworks = false
	m.removed_ProvisionedNetworks = nil
}

// SetPlanID sets the "Plan" edge to the Plan entity by id.
func (m *TeamMutation) SetPlanID(id uuid.UUID) {
	m._Plan = &id
}

// ClearPlan clears the "Plan" edge to the Plan entity.
func (m *TeamMutation) ClearPlan() {
	m.cleared_Plan = true
}

// PlanCleared reports if the "Plan" edge to the Plan entity was cleared.
func (m *TeamMutation) PlanCleared() bool {
	return m.cleared_Plan
}

// PlanID returns the "Plan" edge ID in the mutation.
func (m *TeamMutation) PlanID() (id uuid.UUID, exists bool) {
	if m._Plan != nil {
		return *m._Plan, true
	}
	return
}

// PlanIDs returns the "Plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) PlanIDs() (ids []uuid.UUID) {
	if id := m._Plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "Plan" edge.
func (m *TeamMutation) ResetPlan() {
	m._Plan = nil
	m.cleared_Plan = false
}

// Where appends a list predicates to the TeamMutation builder.
func (m *TeamMutation) Where(ps ...predicate.Team) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.team_number != nil {
		fields = append(fields, team.FieldTeamNumber)
	}
	if m.vars != nil {
		fields = append(fields, team.FieldVars)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldTeamNumber:
		return m.TeamNumber()
	case team.FieldVars:
		return m.Vars()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldTeamNumber:
		return m.OldTeamNumber(ctx)
	case team.FieldVars:
		return m.OldVars(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldTeamNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamNumber(v)
		return nil
	case team.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	var fields []string
	if m.addteam_number != nil {
		fields = append(fields, team.FieldTeamNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case team.FieldTeamNumber:
		return m.AddedTeamNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	case team.FieldTeamNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTeamNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldTeamNumber:
		m.ResetTeamNumber()
		return nil
	case team.FieldVars:
		m.ResetVars()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._Build != nil {
		edges = append(edges, team.EdgeBuild)
	}
	if m._Status != nil {
		edges = append(edges, team.EdgeStatus)
	}
	if m._ProvisionedNetworks != nil {
		edges = append(edges, team.EdgeProvisionedNetworks)
	}
	if m._Plan != nil {
		edges = append(edges, team.EdgePlan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeBuild:
		if id := m._Build; id != nil {
			return []ent.Value{*id}
		}
	case team.EdgeStatus:
		if id := m._Status; id != nil {
			return []ent.Value{*id}
		}
	case team.EdgeProvisionedNetworks:
		ids := make([]ent.Value, 0, len(m._ProvisionedNetworks))
		for id := range m._ProvisionedNetworks {
			ids = append(ids, id)
		}
		return ids
	case team.EdgePlan:
		if id := m._Plan; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removed_ProvisionedNetworks != nil {
		edges = append(edges, team.EdgeProvisionedNetworks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeProvisionedNetworks:
		ids := make([]ent.Value, 0, len(m.removed_ProvisionedNetworks))
		for id := range m.removed_ProvisionedNetworks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_Build {
		edges = append(edges, team.EdgeBuild)
	}
	if m.cleared_Status {
		edges = append(edges, team.EdgeStatus)
	}
	if m.cleared_ProvisionedNetworks {
		edges = append(edges, team.EdgeProvisionedNetworks)
	}
	if m.cleared_Plan {
		edges = append(edges, team.EdgePlan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeBuild:
		return m.cleared_Build
	case team.EdgeStatus:
		return m.cleared_Status
	case team.EdgeProvisionedNetworks:
		return m.cleared_ProvisionedNetworks
	case team.EdgePlan:
		return m.cleared_Plan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	case team.EdgeBuild:
		m.ClearBuild()
		return nil
	case team.EdgeStatus:
		m.ClearStatus()
		return nil
	case team.EdgePlan:
		m.ClearPlan()
		return nil
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeBuild:
		m.ResetBuild()
		return nil
	case team.EdgeStatus:
		m.ResetStatus()
		return nil
	case team.EdgeProvisionedNetworks:
		m.ResetProvisionedNetworks()
		return nil
	case team.EdgePlan:
		m.ResetPlan()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	token            *string
	expire_at        *int64
	addexpire_at     *int64
	clearedFields    map[string]struct{}
	_AuthUser        *uuid.UUID
	cleared_AuthUser bool
	done             bool
	oldValue         func(context.Context) (*Token, error)
	predicates       []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id uuid.UUID) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Token entities.
func (m *TokenMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetToken sets the "token" field.
func (m *TokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *TokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *TokenMutation) ResetToken() {
	m.token = nil
}

// SetExpireAt sets the "expire_at" field.
func (m *TokenMutation) SetExpireAt(i int64) {
	m.expire_at = &i
	m.addexpire_at = nil
}

// ExpireAt returns the value of the "expire_at" field in the mutation.
func (m *TokenMutation) ExpireAt() (r int64, exists bool) {
	v := m.expire_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireAt returns the old "expire_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldExpireAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpireAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpireAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireAt: %w", err)
	}
	return oldValue.ExpireAt, nil
}

// AddExpireAt adds i to the "expire_at" field.
func (m *TokenMutation) AddExpireAt(i int64) {
	if m.addexpire_at != nil {
		*m.addexpire_at += i
	} else {
		m.addexpire_at = &i
	}
}

// AddedExpireAt returns the value that was added to the "expire_at" field in this mutation.
func (m *TokenMutation) AddedExpireAt() (r int64, exists bool) {
	v := m.addexpire_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetExpireAt resets all changes to the "expire_at" field.
func (m *TokenMutation) ResetExpireAt() {
	m.expire_at = nil
	m.addexpire_at = nil
}

// SetAuthUserID sets the "AuthUser" edge to the AuthUser entity by id.
func (m *TokenMutation) SetAuthUserID(id uuid.UUID) {
	m._AuthUser = &id
}

// ClearAuthUser clears the "AuthUser" edge to the AuthUser entity.
func (m *TokenMutation) ClearAuthUser() {
	m.cleared_AuthUser = true
}

// AuthUserCleared reports if the "AuthUser" edge to the AuthUser entity was cleared.
func (m *TokenMutation) AuthUserCleared() bool {
	return m.cleared_AuthUser
}

// AuthUserID returns the "AuthUser" edge ID in the mutation.
func (m *TokenMutation) AuthUserID() (id uuid.UUID, exists bool) {
	if m._AuthUser != nil {
		return *m._AuthUser, true
	}
	return
}

// AuthUserIDs returns the "AuthUser" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthUserID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) AuthUserIDs() (ids []uuid.UUID) {
	if id := m._AuthUser; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthUser resets all changes to the "AuthUser" edge.
func (m *TokenMutation) ResetAuthUser() {
	m._AuthUser = nil
	m.cleared_AuthUser = false
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.token != nil {
		fields = append(fields, token.FieldToken)
	}
	if m.expire_at != nil {
		fields = append(fields, token.FieldExpireAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldToken:
		return m.Token()
	case token.FieldExpireAt:
		return m.ExpireAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldToken:
		return m.OldToken(ctx)
	case token.FieldExpireAt:
		return m.OldExpireAt(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case token.FieldExpireAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireAt(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	var fields []string
	if m.addexpire_at != nil {
		fields = append(fields, token.FieldExpireAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case token.FieldExpireAt:
		return m.AddedExpireAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case token.FieldExpireAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpireAt(v)
		return nil
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldToken:
		m.ResetToken()
		return nil
	case token.FieldExpireAt:
		m.ResetExpireAt()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._AuthUser != nil {
		edges = append(edges, token.EdgeAuthUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case token.EdgeAuthUser:
		if id := m._AuthUser; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_AuthUser {
		edges = append(edges, token.EdgeAuthUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	switch name {
	case token.EdgeAuthUser:
		return m.cleared_AuthUser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	switch name {
	case token.EdgeAuthUser:
		m.ClearAuthUser()
		return nil
	}
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	switch name {
	case token.EdgeAuthUser:
		m.ResetAuthUser()
		return nil
	}
	return fmt.Errorf("unknown Token edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	name                 *string
	uuid                 *string
	email                *string
	hcl_id               *string
	clearedFields        map[string]struct{}
	_Tag                 map[uuid.UUID]struct{}
	removed_Tag          map[uuid.UUID]struct{}
	cleared_Tag          bool
	_Environments        map[uuid.UUID]struct{}
	removed_Environments map[uuid.UUID]struct{}
	cleared_Environments bool
	done                 bool
	oldValue             func(context.Context) (*User, error)
	predicates           []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetUUID sets the "uuid" field.
func (m *UserMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *UserMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *UserMutation) ResetUUID() {
	m.uuid = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetHclID sets the "hcl_id" field.
func (m *UserMutation) SetHclID(s string) {
	m.hcl_id = &s
}

// HclID returns the value of the "hcl_id" field in the mutation.
func (m *UserMutation) HclID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHclID returns the old "hcl_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHclID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHclID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHclID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHclID: %w", err)
	}
	return oldValue.HclID, nil
}

// ResetHclID resets all changes to the "hcl_id" field.
func (m *UserMutation) ResetHclID() {
	m.hcl_id = nil
}

// AddTagIDs adds the "Tag" edge to the Tag entity by ids.
func (m *UserMutation) AddTagIDs(ids ...uuid.UUID) {
	if m._Tag == nil {
		m._Tag = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the "Tag" edge to the Tag entity.
func (m *UserMutation) ClearTag() {
	m.cleared_Tag = true
}

// TagCleared reports if the "Tag" edge to the Tag entity was cleared.
func (m *UserMutation) TagCleared() bool {
	return m.cleared_Tag
}

// RemoveTagIDs removes the "Tag" edge to the Tag entity by IDs.
func (m *UserMutation) RemoveTagIDs(ids ...uuid.UUID) {
	if m.removed_Tag == nil {
		m.removed_Tag = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Tag, ids[i])
		m.removed_Tag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed IDs of the "Tag" edge to the Tag entity.
func (m *UserMutation) RemovedTagIDs() (ids []uuid.UUID) {
	for id := range m.removed_Tag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the "Tag" edge IDs in the mutation.
func (m *UserMutation) TagIDs() (ids []uuid.UUID) {
	for id := range m._Tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag resets all changes to the "Tag" edge.
func (m *UserMutation) ResetTag() {
	m._Tag = nil
	m.cleared_Tag = false
	m.removed_Tag = nil
}

// AddEnvironmentIDs adds the "Environments" edge to the Environment entity by ids.
func (m *UserMutation) AddEnvironmentIDs(ids ...uuid.UUID) {
	if m._Environments == nil {
		m._Environments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Environments[ids[i]] = struct{}{}
	}
}

// ClearEnvironments clears the "Environments" edge to the Environment entity.
func (m *UserMutation) ClearEnvironments() {
	m.cleared_Environments = true
}

// EnvironmentsCleared reports if the "Environments" edge to the Environment entity was cleared.
func (m *UserMutation) EnvironmentsCleared() bool {
	return m.cleared_Environments
}

// RemoveEnvironmentIDs removes the "Environments" edge to the Environment entity by IDs.
func (m *UserMutation) RemoveEnvironmentIDs(ids ...uuid.UUID) {
	if m.removed_Environments == nil {
		m.removed_Environments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Environments, ids[i])
		m.removed_Environments[ids[i]] = struct{}{}
	}
}

// RemovedEnvironments returns the removed IDs of the "Environments" edge to the Environment entity.
func (m *UserMutation) RemovedEnvironmentsIDs() (ids []uuid.UUID) {
	for id := range m.removed_Environments {
		ids = append(ids, id)
	}
	return
}

// EnvironmentsIDs returns the "Environments" edge IDs in the mutation.
func (m *UserMutation) EnvironmentsIDs() (ids []uuid.UUID) {
	for id := range m._Environments {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironments resets all changes to the "Environments" edge.
func (m *UserMutation) ResetEnvironments() {
	m._Environments = nil
	m.cleared_Environments = false
	m.removed_Environments = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.uuid != nil {
		fields = append(fields, user.FieldUUID)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.hcl_id != nil {
		fields = append(fields, user.FieldHclID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldUUID:
		return m.UUID()
	case user.FieldEmail:
		return m.Email()
	case user.FieldHclID:
		return m.HclID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldUUID:
		return m.OldUUID(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldHclID:
		return m.OldHclID(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldHclID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHclID(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldUUID:
		m.ResetUUID()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldHclID:
		m.ResetHclID()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._Tag != nil {
		edges = append(edges, user.EdgeTag)
	}
	if m._Environments != nil {
		edges = append(edges, user.EdgeEnvironments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTag:
		ids := make([]ent.Value, 0, len(m._Tag))
		for id := range m._Tag {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEnvironments:
		ids := make([]ent.Value, 0, len(m._Environments))
		for id := range m._Environments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_Tag != nil {
		edges = append(edges, user.EdgeTag)
	}
	if m.removed_Environments != nil {
		edges = append(edges, user.EdgeEnvironments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removed_Tag))
		for id := range m.removed_Tag {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEnvironments:
		ids := make([]ent.Value, 0, len(m.removed_Environments))
		for id := range m.removed_Environments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_Tag {
		edges = append(edges, user.EdgeTag)
	}
	if m.cleared_Environments {
		edges = append(edges, user.EdgeEnvironments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeTag:
		return m.cleared_Tag
	case user.EdgeEnvironments:
		return m.cleared_Environments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeTag:
		m.ResetTag()
		return nil
	case user.EdgeEnvironments:
		m.ResetEnvironments()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
