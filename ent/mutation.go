// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/gen0cide/laforge/ent/adhocplan"
	"github.com/gen0cide/laforge/ent/agentstatus"
	"github.com/gen0cide/laforge/ent/agenttask"
	"github.com/gen0cide/laforge/ent/ansible"
	"github.com/gen0cide/laforge/ent/authuser"
	"github.com/gen0cide/laforge/ent/build"
	"github.com/gen0cide/laforge/ent/buildcommit"
	"github.com/gen0cide/laforge/ent/command"
	"github.com/gen0cide/laforge/ent/competition"
	"github.com/gen0cide/laforge/ent/disk"
	"github.com/gen0cide/laforge/ent/dns"
	"github.com/gen0cide/laforge/ent/dnsrecord"
	"github.com/gen0cide/laforge/ent/environment"
	"github.com/gen0cide/laforge/ent/filedelete"
	"github.com/gen0cide/laforge/ent/filedownload"
	"github.com/gen0cide/laforge/ent/fileextract"
	"github.com/gen0cide/laforge/ent/finding"
	"github.com/gen0cide/laforge/ent/ginfilemiddleware"
	"github.com/gen0cide/laforge/ent/host"
	"github.com/gen0cide/laforge/ent/hostdependency"
	"github.com/gen0cide/laforge/ent/identity"
	"github.com/gen0cide/laforge/ent/includednetwork"
	"github.com/gen0cide/laforge/ent/network"
	"github.com/gen0cide/laforge/ent/plan"
	"github.com/gen0cide/laforge/ent/plandiff"
	"github.com/gen0cide/laforge/ent/predicate"
	"github.com/gen0cide/laforge/ent/provisionedhost"
	"github.com/gen0cide/laforge/ent/provisionednetwork"
	"github.com/gen0cide/laforge/ent/provisioningstep"
	"github.com/gen0cide/laforge/ent/repocommit"
	"github.com/gen0cide/laforge/ent/repository"
	"github.com/gen0cide/laforge/ent/script"
	"github.com/gen0cide/laforge/ent/servertask"
	"github.com/gen0cide/laforge/ent/status"
	"github.com/gen0cide/laforge/ent/tag"
	"github.com/gen0cide/laforge/ent/team"
	"github.com/gen0cide/laforge/ent/token"
	"github.com/gen0cide/laforge/ent/user"
	"github.com/go-git/go-git/v5/plumbing/object"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdhocPlan          = "AdhocPlan"
	TypeAgentStatus        = "AgentStatus"
	TypeAgentTask          = "AgentTask"
	TypeAnsible            = "Ansible"
	TypeAuthUser           = "AuthUser"
	TypeBuild              = "Build"
	TypeBuildCommit        = "BuildCommit"
	TypeCommand            = "Command"
	TypeCompetition        = "Competition"
	TypeDNS                = "DNS"
	TypeDNSRecord          = "DNSRecord"
	TypeDisk               = "Disk"
	TypeEnvironment        = "Environment"
	TypeFileDelete         = "FileDelete"
	TypeFileDownload       = "FileDownload"
	TypeFileExtract        = "FileExtract"
	TypeFinding            = "Finding"
	TypeGinFileMiddleware  = "GinFileMiddleware"
	TypeHost               = "Host"
	TypeHostDependency     = "HostDependency"
	TypeIdentity           = "Identity"
	TypeIncludedNetwork    = "IncludedNetwork"
	TypeNetwork            = "Network"
	TypePlan               = "Plan"
	TypePlanDiff           = "PlanDiff"
	TypeProvisionedHost    = "ProvisionedHost"
	TypeProvisionedNetwork = "ProvisionedNetwork"
	TypeProvisioningStep   = "ProvisioningStep"
	TypeRepoCommit         = "RepoCommit"
	TypeRepository         = "Repository"
	TypeScript             = "Script"
	TypeServerTask         = "ServerTask"
	TypeStatus             = "Status"
	TypeTag                = "Tag"
	TypeTeam               = "Team"
	TypeToken              = "Token"
	TypeUser               = "User"
)

// AdhocPlanMutation represents an operation that mutates the AdhocPlan nodes in the graph.
type AdhocPlanMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	clearedFields                map[string]struct{}
	_PrevAdhocPlan               map[uuid.UUID]struct{}
	removed_PrevAdhocPlan        map[uuid.UUID]struct{}
	cleared_PrevAdhocPlan        bool
	_NextAdhocPlan               map[uuid.UUID]struct{}
	removed_NextAdhocPlan        map[uuid.UUID]struct{}
	cleared_NextAdhocPlan        bool
	_AdhocPlanToBuild            *uuid.UUID
	cleared_AdhocPlanToBuild     bool
	_AdhocPlanToStatus           *uuid.UUID
	cleared_AdhocPlanToStatus    bool
	_AdhocPlanToAgentTask        *uuid.UUID
	cleared_AdhocPlanToAgentTask bool
	done                         bool
	oldValue                     func(context.Context) (*AdhocPlan, error)
	predicates                   []predicate.AdhocPlan
}

var _ ent.Mutation = (*AdhocPlanMutation)(nil)

// adhocplanOption allows management of the mutation configuration using functional options.
type adhocplanOption func(*AdhocPlanMutation)

// newAdhocPlanMutation creates new mutation for the AdhocPlan entity.
func newAdhocPlanMutation(c config, op Op, opts ...adhocplanOption) *AdhocPlanMutation {
	m := &AdhocPlanMutation{
		config:        c,
		op:            op,
		typ:           TypeAdhocPlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdhocPlanID sets the ID field of the mutation.
func withAdhocPlanID(id uuid.UUID) adhocplanOption {
	return func(m *AdhocPlanMutation) {
		var (
			err   error
			once  sync.Once
			value *AdhocPlan
		)
		m.oldValue = func(ctx context.Context) (*AdhocPlan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdhocPlan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdhocPlan sets the old AdhocPlan of the mutation.
func withAdhocPlan(node *AdhocPlan) adhocplanOption {
	return func(m *AdhocPlanMutation) {
		m.oldValue = func(context.Context) (*AdhocPlan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdhocPlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdhocPlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AdhocPlan entities.
func (m *AdhocPlanMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdhocPlanMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdhocPlanMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdhocPlan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// AddPrevAdhocPlanIDs adds the "PrevAdhocPlan" edge to the AdhocPlan entity by ids.
func (m *AdhocPlanMutation) AddPrevAdhocPlanIDs(ids ...uuid.UUID) {
	if m._PrevAdhocPlan == nil {
		m._PrevAdhocPlan = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._PrevAdhocPlan[ids[i]] = struct{}{}
	}
}

// ClearPrevAdhocPlan clears the "PrevAdhocPlan" edge to the AdhocPlan entity.
func (m *AdhocPlanMutation) ClearPrevAdhocPlan() {
	m.cleared_PrevAdhocPlan = true
}

// PrevAdhocPlanCleared reports if the "PrevAdhocPlan" edge to the AdhocPlan entity was cleared.
func (m *AdhocPlanMutation) PrevAdhocPlanCleared() bool {
	return m.cleared_PrevAdhocPlan
}

// RemovePrevAdhocPlanIDs removes the "PrevAdhocPlan" edge to the AdhocPlan entity by IDs.
func (m *AdhocPlanMutation) RemovePrevAdhocPlanIDs(ids ...uuid.UUID) {
	if m.removed_PrevAdhocPlan == nil {
		m.removed_PrevAdhocPlan = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._PrevAdhocPlan, ids[i])
		m.removed_PrevAdhocPlan[ids[i]] = struct{}{}
	}
}

// RemovedPrevAdhocPlan returns the removed IDs of the "PrevAdhocPlan" edge to the AdhocPlan entity.
func (m *AdhocPlanMutation) RemovedPrevAdhocPlanIDs() (ids []uuid.UUID) {
	for id := range m.removed_PrevAdhocPlan {
		ids = append(ids, id)
	}
	return
}

// PrevAdhocPlanIDs returns the "PrevAdhocPlan" edge IDs in the mutation.
func (m *AdhocPlanMutation) PrevAdhocPlanIDs() (ids []uuid.UUID) {
	for id := range m._PrevAdhocPlan {
		ids = append(ids, id)
	}
	return
}

// ResetPrevAdhocPlan resets all changes to the "PrevAdhocPlan" edge.
func (m *AdhocPlanMutation) ResetPrevAdhocPlan() {
	m._PrevAdhocPlan = nil
	m.cleared_PrevAdhocPlan = false
	m.removed_PrevAdhocPlan = nil
}

// AddNextAdhocPlanIDs adds the "NextAdhocPlan" edge to the AdhocPlan entity by ids.
func (m *AdhocPlanMutation) AddNextAdhocPlanIDs(ids ...uuid.UUID) {
	if m._NextAdhocPlan == nil {
		m._NextAdhocPlan = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._NextAdhocPlan[ids[i]] = struct{}{}
	}
}

// ClearNextAdhocPlan clears the "NextAdhocPlan" edge to the AdhocPlan entity.
func (m *AdhocPlanMutation) ClearNextAdhocPlan() {
	m.cleared_NextAdhocPlan = true
}

// NextAdhocPlanCleared reports if the "NextAdhocPlan" edge to the AdhocPlan entity was cleared.
func (m *AdhocPlanMutation) NextAdhocPlanCleared() bool {
	return m.cleared_NextAdhocPlan
}

// RemoveNextAdhocPlanIDs removes the "NextAdhocPlan" edge to the AdhocPlan entity by IDs.
func (m *AdhocPlanMutation) RemoveNextAdhocPlanIDs(ids ...uuid.UUID) {
	if m.removed_NextAdhocPlan == nil {
		m.removed_NextAdhocPlan = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._NextAdhocPlan, ids[i])
		m.removed_NextAdhocPlan[ids[i]] = struct{}{}
	}
}

// RemovedNextAdhocPlan returns the removed IDs of the "NextAdhocPlan" edge to the AdhocPlan entity.
func (m *AdhocPlanMutation) RemovedNextAdhocPlanIDs() (ids []uuid.UUID) {
	for id := range m.removed_NextAdhocPlan {
		ids = append(ids, id)
	}
	return
}

// NextAdhocPlanIDs returns the "NextAdhocPlan" edge IDs in the mutation.
func (m *AdhocPlanMutation) NextAdhocPlanIDs() (ids []uuid.UUID) {
	for id := range m._NextAdhocPlan {
		ids = append(ids, id)
	}
	return
}

// ResetNextAdhocPlan resets all changes to the "NextAdhocPlan" edge.
func (m *AdhocPlanMutation) ResetNextAdhocPlan() {
	m._NextAdhocPlan = nil
	m.cleared_NextAdhocPlan = false
	m.removed_NextAdhocPlan = nil
}

// SetAdhocPlanToBuildID sets the "AdhocPlanToBuild" edge to the Build entity by id.
func (m *AdhocPlanMutation) SetAdhocPlanToBuildID(id uuid.UUID) {
	m._AdhocPlanToBuild = &id
}

// ClearAdhocPlanToBuild clears the "AdhocPlanToBuild" edge to the Build entity.
func (m *AdhocPlanMutation) ClearAdhocPlanToBuild() {
	m.cleared_AdhocPlanToBuild = true
}

// AdhocPlanToBuildCleared reports if the "AdhocPlanToBuild" edge to the Build entity was cleared.
func (m *AdhocPlanMutation) AdhocPlanToBuildCleared() bool {
	return m.cleared_AdhocPlanToBuild
}

// AdhocPlanToBuildID returns the "AdhocPlanToBuild" edge ID in the mutation.
func (m *AdhocPlanMutation) AdhocPlanToBuildID() (id uuid.UUID, exists bool) {
	if m._AdhocPlanToBuild != nil {
		return *m._AdhocPlanToBuild, true
	}
	return
}

// AdhocPlanToBuildIDs returns the "AdhocPlanToBuild" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdhocPlanToBuildID instead. It exists only for internal usage by the builders.
func (m *AdhocPlanMutation) AdhocPlanToBuildIDs() (ids []uuid.UUID) {
	if id := m._AdhocPlanToBuild; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdhocPlanToBuild resets all changes to the "AdhocPlanToBuild" edge.
func (m *AdhocPlanMutation) ResetAdhocPlanToBuild() {
	m._AdhocPlanToBuild = nil
	m.cleared_AdhocPlanToBuild = false
}

// SetAdhocPlanToStatusID sets the "AdhocPlanToStatus" edge to the Status entity by id.
func (m *AdhocPlanMutation) SetAdhocPlanToStatusID(id uuid.UUID) {
	m._AdhocPlanToStatus = &id
}

// ClearAdhocPlanToStatus clears the "AdhocPlanToStatus" edge to the Status entity.
func (m *AdhocPlanMutation) ClearAdhocPlanToStatus() {
	m.cleared_AdhocPlanToStatus = true
}

// AdhocPlanToStatusCleared reports if the "AdhocPlanToStatus" edge to the Status entity was cleared.
func (m *AdhocPlanMutation) AdhocPlanToStatusCleared() bool {
	return m.cleared_AdhocPlanToStatus
}

// AdhocPlanToStatusID returns the "AdhocPlanToStatus" edge ID in the mutation.
func (m *AdhocPlanMutation) AdhocPlanToStatusID() (id uuid.UUID, exists bool) {
	if m._AdhocPlanToStatus != nil {
		return *m._AdhocPlanToStatus, true
	}
	return
}

// AdhocPlanToStatusIDs returns the "AdhocPlanToStatus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdhocPlanToStatusID instead. It exists only for internal usage by the builders.
func (m *AdhocPlanMutation) AdhocPlanToStatusIDs() (ids []uuid.UUID) {
	if id := m._AdhocPlanToStatus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdhocPlanToStatus resets all changes to the "AdhocPlanToStatus" edge.
func (m *AdhocPlanMutation) ResetAdhocPlanToStatus() {
	m._AdhocPlanToStatus = nil
	m.cleared_AdhocPlanToStatus = false
}

// SetAdhocPlanToAgentTaskID sets the "AdhocPlanToAgentTask" edge to the AgentTask entity by id.
func (m *AdhocPlanMutation) SetAdhocPlanToAgentTaskID(id uuid.UUID) {
	m._AdhocPlanToAgentTask = &id
}

// ClearAdhocPlanToAgentTask clears the "AdhocPlanToAgentTask" edge to the AgentTask entity.
func (m *AdhocPlanMutation) ClearAdhocPlanToAgentTask() {
	m.cleared_AdhocPlanToAgentTask = true
}

// AdhocPlanToAgentTaskCleared reports if the "AdhocPlanToAgentTask" edge to the AgentTask entity was cleared.
func (m *AdhocPlanMutation) AdhocPlanToAgentTaskCleared() bool {
	return m.cleared_AdhocPlanToAgentTask
}

// AdhocPlanToAgentTaskID returns the "AdhocPlanToAgentTask" edge ID in the mutation.
func (m *AdhocPlanMutation) AdhocPlanToAgentTaskID() (id uuid.UUID, exists bool) {
	if m._AdhocPlanToAgentTask != nil {
		return *m._AdhocPlanToAgentTask, true
	}
	return
}

// AdhocPlanToAgentTaskIDs returns the "AdhocPlanToAgentTask" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdhocPlanToAgentTaskID instead. It exists only for internal usage by the builders.
func (m *AdhocPlanMutation) AdhocPlanToAgentTaskIDs() (ids []uuid.UUID) {
	if id := m._AdhocPlanToAgentTask; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdhocPlanToAgentTask resets all changes to the "AdhocPlanToAgentTask" edge.
func (m *AdhocPlanMutation) ResetAdhocPlanToAgentTask() {
	m._AdhocPlanToAgentTask = nil
	m.cleared_AdhocPlanToAgentTask = false
}

// Where appends a list predicates to the AdhocPlanMutation builder.
func (m *AdhocPlanMutation) Where(ps ...predicate.AdhocPlan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdhocPlanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdhocPlanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AdhocPlan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdhocPlanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdhocPlanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AdhocPlan).
func (m *AdhocPlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdhocPlanMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdhocPlanMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdhocPlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown AdhocPlan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdhocPlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AdhocPlan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdhocPlanMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdhocPlanMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdhocPlanMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown AdhocPlan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdhocPlanMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdhocPlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdhocPlanMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AdhocPlan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdhocPlanMutation) ResetField(name string) error {
	return fmt.Errorf("unknown AdhocPlan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdhocPlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m._PrevAdhocPlan != nil {
		edges = append(edges, adhocplan.EdgePrevAdhocPlan)
	}
	if m._NextAdhocPlan != nil {
		edges = append(edges, adhocplan.EdgeNextAdhocPlan)
	}
	if m._AdhocPlanToBuild != nil {
		edges = append(edges, adhocplan.EdgeAdhocPlanToBuild)
	}
	if m._AdhocPlanToStatus != nil {
		edges = append(edges, adhocplan.EdgeAdhocPlanToStatus)
	}
	if m._AdhocPlanToAgentTask != nil {
		edges = append(edges, adhocplan.EdgeAdhocPlanToAgentTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdhocPlanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case adhocplan.EdgePrevAdhocPlan:
		ids := make([]ent.Value, 0, len(m._PrevAdhocPlan))
		for id := range m._PrevAdhocPlan {
			ids = append(ids, id)
		}
		return ids
	case adhocplan.EdgeNextAdhocPlan:
		ids := make([]ent.Value, 0, len(m._NextAdhocPlan))
		for id := range m._NextAdhocPlan {
			ids = append(ids, id)
		}
		return ids
	case adhocplan.EdgeAdhocPlanToBuild:
		if id := m._AdhocPlanToBuild; id != nil {
			return []ent.Value{*id}
		}
	case adhocplan.EdgeAdhocPlanToStatus:
		if id := m._AdhocPlanToStatus; id != nil {
			return []ent.Value{*id}
		}
	case adhocplan.EdgeAdhocPlanToAgentTask:
		if id := m._AdhocPlanToAgentTask; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdhocPlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removed_PrevAdhocPlan != nil {
		edges = append(edges, adhocplan.EdgePrevAdhocPlan)
	}
	if m.removed_NextAdhocPlan != nil {
		edges = append(edges, adhocplan.EdgeNextAdhocPlan)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdhocPlanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case adhocplan.EdgePrevAdhocPlan:
		ids := make([]ent.Value, 0, len(m.removed_PrevAdhocPlan))
		for id := range m.removed_PrevAdhocPlan {
			ids = append(ids, id)
		}
		return ids
	case adhocplan.EdgeNextAdhocPlan:
		ids := make([]ent.Value, 0, len(m.removed_NextAdhocPlan))
		for id := range m.removed_NextAdhocPlan {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdhocPlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleared_PrevAdhocPlan {
		edges = append(edges, adhocplan.EdgePrevAdhocPlan)
	}
	if m.cleared_NextAdhocPlan {
		edges = append(edges, adhocplan.EdgeNextAdhocPlan)
	}
	if m.cleared_AdhocPlanToBuild {
		edges = append(edges, adhocplan.EdgeAdhocPlanToBuild)
	}
	if m.cleared_AdhocPlanToStatus {
		edges = append(edges, adhocplan.EdgeAdhocPlanToStatus)
	}
	if m.cleared_AdhocPlanToAgentTask {
		edges = append(edges, adhocplan.EdgeAdhocPlanToAgentTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdhocPlanMutation) EdgeCleared(name string) bool {
	switch name {
	case adhocplan.EdgePrevAdhocPlan:
		return m.cleared_PrevAdhocPlan
	case adhocplan.EdgeNextAdhocPlan:
		return m.cleared_NextAdhocPlan
	case adhocplan.EdgeAdhocPlanToBuild:
		return m.cleared_AdhocPlanToBuild
	case adhocplan.EdgeAdhocPlanToStatus:
		return m.cleared_AdhocPlanToStatus
	case adhocplan.EdgeAdhocPlanToAgentTask:
		return m.cleared_AdhocPlanToAgentTask
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdhocPlanMutation) ClearEdge(name string) error {
	switch name {
	case adhocplan.EdgeAdhocPlanToBuild:
		m.ClearAdhocPlanToBuild()
		return nil
	case adhocplan.EdgeAdhocPlanToStatus:
		m.ClearAdhocPlanToStatus()
		return nil
	case adhocplan.EdgeAdhocPlanToAgentTask:
		m.ClearAdhocPlanToAgentTask()
		return nil
	}
	return fmt.Errorf("unknown AdhocPlan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdhocPlanMutation) ResetEdge(name string) error {
	switch name {
	case adhocplan.EdgePrevAdhocPlan:
		m.ResetPrevAdhocPlan()
		return nil
	case adhocplan.EdgeNextAdhocPlan:
		m.ResetNextAdhocPlan()
		return nil
	case adhocplan.EdgeAdhocPlanToBuild:
		m.ResetAdhocPlanToBuild()
		return nil
	case adhocplan.EdgeAdhocPlanToStatus:
		m.ResetAdhocPlanToStatus()
		return nil
	case adhocplan.EdgeAdhocPlanToAgentTask:
		m.ResetAdhocPlanToAgentTask()
		return nil
	}
	return fmt.Errorf("unknown AdhocPlan edge %s", name)
}

// AgentStatusMutation represents an operation that mutates the AgentStatus nodes in the graph.
type AgentStatusMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *uuid.UUID
	_ClientID                               *string
	_Hostname                               *string
	_UpTime                                 *int64
	add_UpTime                              *int64
	_BootTime                               *int64
	add_BootTime                            *int64
	_NumProcs                               *int64
	add_NumProcs                            *int64
	_Os                                     *string
	_HostID                                 *string
	_Load1                                  *float64
	add_Load1                               *float64
	_Load5                                  *float64
	add_Load5                               *float64
	_Load15                                 *float64
	add_Load15                              *float64
	_TotalMem                               *int64
	add_TotalMem                            *int64
	_FreeMem                                *int64
	add_FreeMem                             *int64
	_UsedMem                                *int64
	add_UsedMem                             *int64
	_Timestamp                              *int64
	add_Timestamp                           *int64
	clearedFields                           map[string]struct{}
	_AgentStatusToProvisionedHost           *uuid.UUID
	cleared_AgentStatusToProvisionedHost    bool
	_AgentStatusToProvisionedNetwork        *uuid.UUID
	cleared_AgentStatusToProvisionedNetwork bool
	_AgentStatusToBuild                     *uuid.UUID
	cleared_AgentStatusToBuild              bool
	done                                    bool
	oldValue                                func(context.Context) (*AgentStatus, error)
	predicates                              []predicate.AgentStatus
}

var _ ent.Mutation = (*AgentStatusMutation)(nil)

// agentstatusOption allows management of the mutation configuration using functional options.
type agentstatusOption func(*AgentStatusMutation)

// newAgentStatusMutation creates new mutation for the AgentStatus entity.
func newAgentStatusMutation(c config, op Op, opts ...agentstatusOption) *AgentStatusMutation {
	m := &AgentStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeAgentStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentStatusID sets the ID field of the mutation.
func withAgentStatusID(id uuid.UUID) agentstatusOption {
	return func(m *AgentStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *AgentStatus
		)
		m.oldValue = func(ctx context.Context) (*AgentStatus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AgentStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgentStatus sets the old AgentStatus of the mutation.
func withAgentStatus(node *AgentStatus) agentstatusOption {
	return func(m *AgentStatusMutation) {
		m.oldValue = func(context.Context) (*AgentStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AgentStatus entities.
func (m *AgentStatusMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgentStatusMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgentStatusMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AgentStatus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClientID sets the "ClientID" field.
func (m *AgentStatusMutation) SetClientID(s string) {
	m._ClientID = &s
}

// ClientID returns the value of the "ClientID" field in the mutation.
func (m *AgentStatusMutation) ClientID() (r string, exists bool) {
	v := m._ClientID
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "ClientID" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "ClientID" field.
func (m *AgentStatusMutation) ResetClientID() {
	m._ClientID = nil
}

// SetHostname sets the "Hostname" field.
func (m *AgentStatusMutation) SetHostname(s string) {
	m._Hostname = &s
}

// Hostname returns the value of the "Hostname" field in the mutation.
func (m *AgentStatusMutation) Hostname() (r string, exists bool) {
	v := m._Hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "Hostname" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname resets all changes to the "Hostname" field.
func (m *AgentStatusMutation) ResetHostname() {
	m._Hostname = nil
}

// SetUpTime sets the "UpTime" field.
func (m *AgentStatusMutation) SetUpTime(i int64) {
	m._UpTime = &i
	m.add_UpTime = nil
}

// UpTime returns the value of the "UpTime" field in the mutation.
func (m *AgentStatusMutation) UpTime() (r int64, exists bool) {
	v := m._UpTime
	if v == nil {
		return
	}
	return *v, true
}

// OldUpTime returns the old "UpTime" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldUpTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpTime: %w", err)
	}
	return oldValue.UpTime, nil
}

// AddUpTime adds i to the "UpTime" field.
func (m *AgentStatusMutation) AddUpTime(i int64) {
	if m.add_UpTime != nil {
		*m.add_UpTime += i
	} else {
		m.add_UpTime = &i
	}
}

// AddedUpTime returns the value that was added to the "UpTime" field in this mutation.
func (m *AgentStatusMutation) AddedUpTime() (r int64, exists bool) {
	v := m.add_UpTime
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpTime resets all changes to the "UpTime" field.
func (m *AgentStatusMutation) ResetUpTime() {
	m._UpTime = nil
	m.add_UpTime = nil
}

// SetBootTime sets the "BootTime" field.
func (m *AgentStatusMutation) SetBootTime(i int64) {
	m._BootTime = &i
	m.add_BootTime = nil
}

// BootTime returns the value of the "BootTime" field in the mutation.
func (m *AgentStatusMutation) BootTime() (r int64, exists bool) {
	v := m._BootTime
	if v == nil {
		return
	}
	return *v, true
}

// OldBootTime returns the old "BootTime" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldBootTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBootTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBootTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBootTime: %w", err)
	}
	return oldValue.BootTime, nil
}

// AddBootTime adds i to the "BootTime" field.
func (m *AgentStatusMutation) AddBootTime(i int64) {
	if m.add_BootTime != nil {
		*m.add_BootTime += i
	} else {
		m.add_BootTime = &i
	}
}

// AddedBootTime returns the value that was added to the "BootTime" field in this mutation.
func (m *AgentStatusMutation) AddedBootTime() (r int64, exists bool) {
	v := m.add_BootTime
	if v == nil {
		return
	}
	return *v, true
}

// ResetBootTime resets all changes to the "BootTime" field.
func (m *AgentStatusMutation) ResetBootTime() {
	m._BootTime = nil
	m.add_BootTime = nil
}

// SetNumProcs sets the "NumProcs" field.
func (m *AgentStatusMutation) SetNumProcs(i int64) {
	m._NumProcs = &i
	m.add_NumProcs = nil
}

// NumProcs returns the value of the "NumProcs" field in the mutation.
func (m *AgentStatusMutation) NumProcs() (r int64, exists bool) {
	v := m._NumProcs
	if v == nil {
		return
	}
	return *v, true
}

// OldNumProcs returns the old "NumProcs" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldNumProcs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumProcs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumProcs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumProcs: %w", err)
	}
	return oldValue.NumProcs, nil
}

// AddNumProcs adds i to the "NumProcs" field.
func (m *AgentStatusMutation) AddNumProcs(i int64) {
	if m.add_NumProcs != nil {
		*m.add_NumProcs += i
	} else {
		m.add_NumProcs = &i
	}
}

// AddedNumProcs returns the value that was added to the "NumProcs" field in this mutation.
func (m *AgentStatusMutation) AddedNumProcs() (r int64, exists bool) {
	v := m.add_NumProcs
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumProcs resets all changes to the "NumProcs" field.
func (m *AgentStatusMutation) ResetNumProcs() {
	m._NumProcs = nil
	m.add_NumProcs = nil
}

// SetOs sets the "Os" field.
func (m *AgentStatusMutation) SetOs(s string) {
	m._Os = &s
}

// Os returns the value of the "Os" field in the mutation.
func (m *AgentStatusMutation) Os() (r string, exists bool) {
	v := m._Os
	if v == nil {
		return
	}
	return *v, true
}

// OldOs returns the old "Os" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldOs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOs: %w", err)
	}
	return oldValue.Os, nil
}

// ResetOs resets all changes to the "Os" field.
func (m *AgentStatusMutation) ResetOs() {
	m._Os = nil
}

// SetHostID sets the "HostID" field.
func (m *AgentStatusMutation) SetHostID(s string) {
	m._HostID = &s
}

// HostID returns the value of the "HostID" field in the mutation.
func (m *AgentStatusMutation) HostID() (r string, exists bool) {
	v := m._HostID
	if v == nil {
		return
	}
	return *v, true
}

// OldHostID returns the old "HostID" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldHostID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostID: %w", err)
	}
	return oldValue.HostID, nil
}

// ResetHostID resets all changes to the "HostID" field.
func (m *AgentStatusMutation) ResetHostID() {
	m._HostID = nil
}

// SetLoad1 sets the "Load1" field.
func (m *AgentStatusMutation) SetLoad1(f float64) {
	m._Load1 = &f
	m.add_Load1 = nil
}

// Load1 returns the value of the "Load1" field in the mutation.
func (m *AgentStatusMutation) Load1() (r float64, exists bool) {
	v := m._Load1
	if v == nil {
		return
	}
	return *v, true
}

// OldLoad1 returns the old "Load1" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldLoad1(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoad1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoad1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoad1: %w", err)
	}
	return oldValue.Load1, nil
}

// AddLoad1 adds f to the "Load1" field.
func (m *AgentStatusMutation) AddLoad1(f float64) {
	if m.add_Load1 != nil {
		*m.add_Load1 += f
	} else {
		m.add_Load1 = &f
	}
}

// AddedLoad1 returns the value that was added to the "Load1" field in this mutation.
func (m *AgentStatusMutation) AddedLoad1() (r float64, exists bool) {
	v := m.add_Load1
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoad1 resets all changes to the "Load1" field.
func (m *AgentStatusMutation) ResetLoad1() {
	m._Load1 = nil
	m.add_Load1 = nil
}

// SetLoad5 sets the "Load5" field.
func (m *AgentStatusMutation) SetLoad5(f float64) {
	m._Load5 = &f
	m.add_Load5 = nil
}

// Load5 returns the value of the "Load5" field in the mutation.
func (m *AgentStatusMutation) Load5() (r float64, exists bool) {
	v := m._Load5
	if v == nil {
		return
	}
	return *v, true
}

// OldLoad5 returns the old "Load5" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldLoad5(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoad5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoad5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoad5: %w", err)
	}
	return oldValue.Load5, nil
}

// AddLoad5 adds f to the "Load5" field.
func (m *AgentStatusMutation) AddLoad5(f float64) {
	if m.add_Load5 != nil {
		*m.add_Load5 += f
	} else {
		m.add_Load5 = &f
	}
}

// AddedLoad5 returns the value that was added to the "Load5" field in this mutation.
func (m *AgentStatusMutation) AddedLoad5() (r float64, exists bool) {
	v := m.add_Load5
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoad5 resets all changes to the "Load5" field.
func (m *AgentStatusMutation) ResetLoad5() {
	m._Load5 = nil
	m.add_Load5 = nil
}

// SetLoad15 sets the "Load15" field.
func (m *AgentStatusMutation) SetLoad15(f float64) {
	m._Load15 = &f
	m.add_Load15 = nil
}

// Load15 returns the value of the "Load15" field in the mutation.
func (m *AgentStatusMutation) Load15() (r float64, exists bool) {
	v := m._Load15
	if v == nil {
		return
	}
	return *v, true
}

// OldLoad15 returns the old "Load15" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldLoad15(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoad15 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoad15 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoad15: %w", err)
	}
	return oldValue.Load15, nil
}

// AddLoad15 adds f to the "Load15" field.
func (m *AgentStatusMutation) AddLoad15(f float64) {
	if m.add_Load15 != nil {
		*m.add_Load15 += f
	} else {
		m.add_Load15 = &f
	}
}

// AddedLoad15 returns the value that was added to the "Load15" field in this mutation.
func (m *AgentStatusMutation) AddedLoad15() (r float64, exists bool) {
	v := m.add_Load15
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoad15 resets all changes to the "Load15" field.
func (m *AgentStatusMutation) ResetLoad15() {
	m._Load15 = nil
	m.add_Load15 = nil
}

// SetTotalMem sets the "TotalMem" field.
func (m *AgentStatusMutation) SetTotalMem(i int64) {
	m._TotalMem = &i
	m.add_TotalMem = nil
}

// TotalMem returns the value of the "TotalMem" field in the mutation.
func (m *AgentStatusMutation) TotalMem() (r int64, exists bool) {
	v := m._TotalMem
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalMem returns the old "TotalMem" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldTotalMem(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalMem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalMem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalMem: %w", err)
	}
	return oldValue.TotalMem, nil
}

// AddTotalMem adds i to the "TotalMem" field.
func (m *AgentStatusMutation) AddTotalMem(i int64) {
	if m.add_TotalMem != nil {
		*m.add_TotalMem += i
	} else {
		m.add_TotalMem = &i
	}
}

// AddedTotalMem returns the value that was added to the "TotalMem" field in this mutation.
func (m *AgentStatusMutation) AddedTotalMem() (r int64, exists bool) {
	v := m.add_TotalMem
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalMem resets all changes to the "TotalMem" field.
func (m *AgentStatusMutation) ResetTotalMem() {
	m._TotalMem = nil
	m.add_TotalMem = nil
}

// SetFreeMem sets the "FreeMem" field.
func (m *AgentStatusMutation) SetFreeMem(i int64) {
	m._FreeMem = &i
	m.add_FreeMem = nil
}

// FreeMem returns the value of the "FreeMem" field in the mutation.
func (m *AgentStatusMutation) FreeMem() (r int64, exists bool) {
	v := m._FreeMem
	if v == nil {
		return
	}
	return *v, true
}

// OldFreeMem returns the old "FreeMem" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldFreeMem(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreeMem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreeMem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreeMem: %w", err)
	}
	return oldValue.FreeMem, nil
}

// AddFreeMem adds i to the "FreeMem" field.
func (m *AgentStatusMutation) AddFreeMem(i int64) {
	if m.add_FreeMem != nil {
		*m.add_FreeMem += i
	} else {
		m.add_FreeMem = &i
	}
}

// AddedFreeMem returns the value that was added to the "FreeMem" field in this mutation.
func (m *AgentStatusMutation) AddedFreeMem() (r int64, exists bool) {
	v := m.add_FreeMem
	if v == nil {
		return
	}
	return *v, true
}

// ResetFreeMem resets all changes to the "FreeMem" field.
func (m *AgentStatusMutation) ResetFreeMem() {
	m._FreeMem = nil
	m.add_FreeMem = nil
}

// SetUsedMem sets the "UsedMem" field.
func (m *AgentStatusMutation) SetUsedMem(i int64) {
	m._UsedMem = &i
	m.add_UsedMem = nil
}

// UsedMem returns the value of the "UsedMem" field in the mutation.
func (m *AgentStatusMutation) UsedMem() (r int64, exists bool) {
	v := m._UsedMem
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedMem returns the old "UsedMem" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldUsedMem(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedMem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedMem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedMem: %w", err)
	}
	return oldValue.UsedMem, nil
}

// AddUsedMem adds i to the "UsedMem" field.
func (m *AgentStatusMutation) AddUsedMem(i int64) {
	if m.add_UsedMem != nil {
		*m.add_UsedMem += i
	} else {
		m.add_UsedMem = &i
	}
}

// AddedUsedMem returns the value that was added to the "UsedMem" field in this mutation.
func (m *AgentStatusMutation) AddedUsedMem() (r int64, exists bool) {
	v := m.add_UsedMem
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsedMem resets all changes to the "UsedMem" field.
func (m *AgentStatusMutation) ResetUsedMem() {
	m._UsedMem = nil
	m.add_UsedMem = nil
}

// SetTimestamp sets the "Timestamp" field.
func (m *AgentStatusMutation) SetTimestamp(i int64) {
	m._Timestamp = &i
	m.add_Timestamp = nil
}

// Timestamp returns the value of the "Timestamp" field in the mutation.
func (m *AgentStatusMutation) Timestamp() (r int64, exists bool) {
	v := m._Timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "Timestamp" field's value of the AgentStatus entity.
// If the AgentStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentStatusMutation) OldTimestamp(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// AddTimestamp adds i to the "Timestamp" field.
func (m *AgentStatusMutation) AddTimestamp(i int64) {
	if m.add_Timestamp != nil {
		*m.add_Timestamp += i
	} else {
		m.add_Timestamp = &i
	}
}

// AddedTimestamp returns the value that was added to the "Timestamp" field in this mutation.
func (m *AgentStatusMutation) AddedTimestamp() (r int64, exists bool) {
	v := m.add_Timestamp
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimestamp resets all changes to the "Timestamp" field.
func (m *AgentStatusMutation) ResetTimestamp() {
	m._Timestamp = nil
	m.add_Timestamp = nil
}

// SetAgentStatusToProvisionedHostID sets the "AgentStatusToProvisionedHost" edge to the ProvisionedHost entity by id.
func (m *AgentStatusMutation) SetAgentStatusToProvisionedHostID(id uuid.UUID) {
	m._AgentStatusToProvisionedHost = &id
}

// ClearAgentStatusToProvisionedHost clears the "AgentStatusToProvisionedHost" edge to the ProvisionedHost entity.
func (m *AgentStatusMutation) ClearAgentStatusToProvisionedHost() {
	m.cleared_AgentStatusToProvisionedHost = true
}

// AgentStatusToProvisionedHostCleared reports if the "AgentStatusToProvisionedHost" edge to the ProvisionedHost entity was cleared.
func (m *AgentStatusMutation) AgentStatusToProvisionedHostCleared() bool {
	return m.cleared_AgentStatusToProvisionedHost
}

// AgentStatusToProvisionedHostID returns the "AgentStatusToProvisionedHost" edge ID in the mutation.
func (m *AgentStatusMutation) AgentStatusToProvisionedHostID() (id uuid.UUID, exists bool) {
	if m._AgentStatusToProvisionedHost != nil {
		return *m._AgentStatusToProvisionedHost, true
	}
	return
}

// AgentStatusToProvisionedHostIDs returns the "AgentStatusToProvisionedHost" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentStatusToProvisionedHostID instead. It exists only for internal usage by the builders.
func (m *AgentStatusMutation) AgentStatusToProvisionedHostIDs() (ids []uuid.UUID) {
	if id := m._AgentStatusToProvisionedHost; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgentStatusToProvisionedHost resets all changes to the "AgentStatusToProvisionedHost" edge.
func (m *AgentStatusMutation) ResetAgentStatusToProvisionedHost() {
	m._AgentStatusToProvisionedHost = nil
	m.cleared_AgentStatusToProvisionedHost = false
}

// SetAgentStatusToProvisionedNetworkID sets the "AgentStatusToProvisionedNetwork" edge to the ProvisionedNetwork entity by id.
func (m *AgentStatusMutation) SetAgentStatusToProvisionedNetworkID(id uuid.UUID) {
	m._AgentStatusToProvisionedNetwork = &id
}

// ClearAgentStatusToProvisionedNetwork clears the "AgentStatusToProvisionedNetwork" edge to the ProvisionedNetwork entity.
func (m *AgentStatusMutation) ClearAgentStatusToProvisionedNetwork() {
	m.cleared_AgentStatusToProvisionedNetwork = true
}

// AgentStatusToProvisionedNetworkCleared reports if the "AgentStatusToProvisionedNetwork" edge to the ProvisionedNetwork entity was cleared.
func (m *AgentStatusMutation) AgentStatusToProvisionedNetworkCleared() bool {
	return m.cleared_AgentStatusToProvisionedNetwork
}

// AgentStatusToProvisionedNetworkID returns the "AgentStatusToProvisionedNetwork" edge ID in the mutation.
func (m *AgentStatusMutation) AgentStatusToProvisionedNetworkID() (id uuid.UUID, exists bool) {
	if m._AgentStatusToProvisionedNetwork != nil {
		return *m._AgentStatusToProvisionedNetwork, true
	}
	return
}

// AgentStatusToProvisionedNetworkIDs returns the "AgentStatusToProvisionedNetwork" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentStatusToProvisionedNetworkID instead. It exists only for internal usage by the builders.
func (m *AgentStatusMutation) AgentStatusToProvisionedNetworkIDs() (ids []uuid.UUID) {
	if id := m._AgentStatusToProvisionedNetwork; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgentStatusToProvisionedNetwork resets all changes to the "AgentStatusToProvisionedNetwork" edge.
func (m *AgentStatusMutation) ResetAgentStatusToProvisionedNetwork() {
	m._AgentStatusToProvisionedNetwork = nil
	m.cleared_AgentStatusToProvisionedNetwork = false
}

// SetAgentStatusToBuildID sets the "AgentStatusToBuild" edge to the Build entity by id.
func (m *AgentStatusMutation) SetAgentStatusToBuildID(id uuid.UUID) {
	m._AgentStatusToBuild = &id
}

// ClearAgentStatusToBuild clears the "AgentStatusToBuild" edge to the Build entity.
func (m *AgentStatusMutation) ClearAgentStatusToBuild() {
	m.cleared_AgentStatusToBuild = true
}

// AgentStatusToBuildCleared reports if the "AgentStatusToBuild" edge to the Build entity was cleared.
func (m *AgentStatusMutation) AgentStatusToBuildCleared() bool {
	return m.cleared_AgentStatusToBuild
}

// AgentStatusToBuildID returns the "AgentStatusToBuild" edge ID in the mutation.
func (m *AgentStatusMutation) AgentStatusToBuildID() (id uuid.UUID, exists bool) {
	if m._AgentStatusToBuild != nil {
		return *m._AgentStatusToBuild, true
	}
	return
}

// AgentStatusToBuildIDs returns the "AgentStatusToBuild" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentStatusToBuildID instead. It exists only for internal usage by the builders.
func (m *AgentStatusMutation) AgentStatusToBuildIDs() (ids []uuid.UUID) {
	if id := m._AgentStatusToBuild; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgentStatusToBuild resets all changes to the "AgentStatusToBuild" edge.
func (m *AgentStatusMutation) ResetAgentStatusToBuild() {
	m._AgentStatusToBuild = nil
	m.cleared_AgentStatusToBuild = false
}

// Where appends a list predicates to the AgentStatusMutation builder.
func (m *AgentStatusMutation) Where(ps ...predicate.AgentStatus) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AgentStatusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AgentStatusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AgentStatus, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AgentStatusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AgentStatusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AgentStatus).
func (m *AgentStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentStatusMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m._ClientID != nil {
		fields = append(fields, agentstatus.FieldClientID)
	}
	if m._Hostname != nil {
		fields = append(fields, agentstatus.FieldHostname)
	}
	if m._UpTime != nil {
		fields = append(fields, agentstatus.FieldUpTime)
	}
	if m._BootTime != nil {
		fields = append(fields, agentstatus.FieldBootTime)
	}
	if m._NumProcs != nil {
		fields = append(fields, agentstatus.FieldNumProcs)
	}
	if m._Os != nil {
		fields = append(fields, agentstatus.FieldOs)
	}
	if m._HostID != nil {
		fields = append(fields, agentstatus.FieldHostID)
	}
	if m._Load1 != nil {
		fields = append(fields, agentstatus.FieldLoad1)
	}
	if m._Load5 != nil {
		fields = append(fields, agentstatus.FieldLoad5)
	}
	if m._Load15 != nil {
		fields = append(fields, agentstatus.FieldLoad15)
	}
	if m._TotalMem != nil {
		fields = append(fields, agentstatus.FieldTotalMem)
	}
	if m._FreeMem != nil {
		fields = append(fields, agentstatus.FieldFreeMem)
	}
	if m._UsedMem != nil {
		fields = append(fields, agentstatus.FieldUsedMem)
	}
	if m._Timestamp != nil {
		fields = append(fields, agentstatus.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agentstatus.FieldClientID:
		return m.ClientID()
	case agentstatus.FieldHostname:
		return m.Hostname()
	case agentstatus.FieldUpTime:
		return m.UpTime()
	case agentstatus.FieldBootTime:
		return m.BootTime()
	case agentstatus.FieldNumProcs:
		return m.NumProcs()
	case agentstatus.FieldOs:
		return m.Os()
	case agentstatus.FieldHostID:
		return m.HostID()
	case agentstatus.FieldLoad1:
		return m.Load1()
	case agentstatus.FieldLoad5:
		return m.Load5()
	case agentstatus.FieldLoad15:
		return m.Load15()
	case agentstatus.FieldTotalMem:
		return m.TotalMem()
	case agentstatus.FieldFreeMem:
		return m.FreeMem()
	case agentstatus.FieldUsedMem:
		return m.UsedMem()
	case agentstatus.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agentstatus.FieldClientID:
		return m.OldClientID(ctx)
	case agentstatus.FieldHostname:
		return m.OldHostname(ctx)
	case agentstatus.FieldUpTime:
		return m.OldUpTime(ctx)
	case agentstatus.FieldBootTime:
		return m.OldBootTime(ctx)
	case agentstatus.FieldNumProcs:
		return m.OldNumProcs(ctx)
	case agentstatus.FieldOs:
		return m.OldOs(ctx)
	case agentstatus.FieldHostID:
		return m.OldHostID(ctx)
	case agentstatus.FieldLoad1:
		return m.OldLoad1(ctx)
	case agentstatus.FieldLoad5:
		return m.OldLoad5(ctx)
	case agentstatus.FieldLoad15:
		return m.OldLoad15(ctx)
	case agentstatus.FieldTotalMem:
		return m.OldTotalMem(ctx)
	case agentstatus.FieldFreeMem:
		return m.OldFreeMem(ctx)
	case agentstatus.FieldUsedMem:
		return m.OldUsedMem(ctx)
	case agentstatus.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown AgentStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agentstatus.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case agentstatus.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case agentstatus.FieldUpTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpTime(v)
		return nil
	case agentstatus.FieldBootTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBootTime(v)
		return nil
	case agentstatus.FieldNumProcs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumProcs(v)
		return nil
	case agentstatus.FieldOs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOs(v)
		return nil
	case agentstatus.FieldHostID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostID(v)
		return nil
	case agentstatus.FieldLoad1:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoad1(v)
		return nil
	case agentstatus.FieldLoad5:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoad5(v)
		return nil
	case agentstatus.FieldLoad15:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoad15(v)
		return nil
	case agentstatus.FieldTotalMem:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalMem(v)
		return nil
	case agentstatus.FieldFreeMem:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreeMem(v)
		return nil
	case agentstatus.FieldUsedMem:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedMem(v)
		return nil
	case agentstatus.FieldTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown AgentStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentStatusMutation) AddedFields() []string {
	var fields []string
	if m.add_UpTime != nil {
		fields = append(fields, agentstatus.FieldUpTime)
	}
	if m.add_BootTime != nil {
		fields = append(fields, agentstatus.FieldBootTime)
	}
	if m.add_NumProcs != nil {
		fields = append(fields, agentstatus.FieldNumProcs)
	}
	if m.add_Load1 != nil {
		fields = append(fields, agentstatus.FieldLoad1)
	}
	if m.add_Load5 != nil {
		fields = append(fields, agentstatus.FieldLoad5)
	}
	if m.add_Load15 != nil {
		fields = append(fields, agentstatus.FieldLoad15)
	}
	if m.add_TotalMem != nil {
		fields = append(fields, agentstatus.FieldTotalMem)
	}
	if m.add_FreeMem != nil {
		fields = append(fields, agentstatus.FieldFreeMem)
	}
	if m.add_UsedMem != nil {
		fields = append(fields, agentstatus.FieldUsedMem)
	}
	if m.add_Timestamp != nil {
		fields = append(fields, agentstatus.FieldTimestamp)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentStatusMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case agentstatus.FieldUpTime:
		return m.AddedUpTime()
	case agentstatus.FieldBootTime:
		return m.AddedBootTime()
	case agentstatus.FieldNumProcs:
		return m.AddedNumProcs()
	case agentstatus.FieldLoad1:
		return m.AddedLoad1()
	case agentstatus.FieldLoad5:
		return m.AddedLoad5()
	case agentstatus.FieldLoad15:
		return m.AddedLoad15()
	case agentstatus.FieldTotalMem:
		return m.AddedTotalMem()
	case agentstatus.FieldFreeMem:
		return m.AddedFreeMem()
	case agentstatus.FieldUsedMem:
		return m.AddedUsedMem()
	case agentstatus.FieldTimestamp:
		return m.AddedTimestamp()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	case agentstatus.FieldUpTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpTime(v)
		return nil
	case agentstatus.FieldBootTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBootTime(v)
		return nil
	case agentstatus.FieldNumProcs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumProcs(v)
		return nil
	case agentstatus.FieldLoad1:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoad1(v)
		return nil
	case agentstatus.FieldLoad5:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoad5(v)
		return nil
	case agentstatus.FieldLoad15:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoad15(v)
		return nil
	case agentstatus.FieldTotalMem:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalMem(v)
		return nil
	case agentstatus.FieldFreeMem:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFreeMem(v)
		return nil
	case agentstatus.FieldUsedMem:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsedMem(v)
		return nil
	case agentstatus.FieldTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown AgentStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentStatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentStatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AgentStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentStatusMutation) ResetField(name string) error {
	switch name {
	case agentstatus.FieldClientID:
		m.ResetClientID()
		return nil
	case agentstatus.FieldHostname:
		m.ResetHostname()
		return nil
	case agentstatus.FieldUpTime:
		m.ResetUpTime()
		return nil
	case agentstatus.FieldBootTime:
		m.ResetBootTime()
		return nil
	case agentstatus.FieldNumProcs:
		m.ResetNumProcs()
		return nil
	case agentstatus.FieldOs:
		m.ResetOs()
		return nil
	case agentstatus.FieldHostID:
		m.ResetHostID()
		return nil
	case agentstatus.FieldLoad1:
		m.ResetLoad1()
		return nil
	case agentstatus.FieldLoad5:
		m.ResetLoad5()
		return nil
	case agentstatus.FieldLoad15:
		m.ResetLoad15()
		return nil
	case agentstatus.FieldTotalMem:
		m.ResetTotalMem()
		return nil
	case agentstatus.FieldFreeMem:
		m.ResetFreeMem()
		return nil
	case agentstatus.FieldUsedMem:
		m.ResetUsedMem()
		return nil
	case agentstatus.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown AgentStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._AgentStatusToProvisionedHost != nil {
		edges = append(edges, agentstatus.EdgeAgentStatusToProvisionedHost)
	}
	if m._AgentStatusToProvisionedNetwork != nil {
		edges = append(edges, agentstatus.EdgeAgentStatusToProvisionedNetwork)
	}
	if m._AgentStatusToBuild != nil {
		edges = append(edges, agentstatus.EdgeAgentStatusToBuild)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agentstatus.EdgeAgentStatusToProvisionedHost:
		if id := m._AgentStatusToProvisionedHost; id != nil {
			return []ent.Value{*id}
		}
	case agentstatus.EdgeAgentStatusToProvisionedNetwork:
		if id := m._AgentStatusToProvisionedNetwork; id != nil {
			return []ent.Value{*id}
		}
	case agentstatus.EdgeAgentStatusToBuild:
		if id := m._AgentStatusToBuild; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentStatusMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_AgentStatusToProvisionedHost {
		edges = append(edges, agentstatus.EdgeAgentStatusToProvisionedHost)
	}
	if m.cleared_AgentStatusToProvisionedNetwork {
		edges = append(edges, agentstatus.EdgeAgentStatusToProvisionedNetwork)
	}
	if m.cleared_AgentStatusToBuild {
		edges = append(edges, agentstatus.EdgeAgentStatusToBuild)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case agentstatus.EdgeAgentStatusToProvisionedHost:
		return m.cleared_AgentStatusToProvisionedHost
	case agentstatus.EdgeAgentStatusToProvisionedNetwork:
		return m.cleared_AgentStatusToProvisionedNetwork
	case agentstatus.EdgeAgentStatusToBuild:
		return m.cleared_AgentStatusToBuild
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentStatusMutation) ClearEdge(name string) error {
	switch name {
	case agentstatus.EdgeAgentStatusToProvisionedHost:
		m.ClearAgentStatusToProvisionedHost()
		return nil
	case agentstatus.EdgeAgentStatusToProvisionedNetwork:
		m.ClearAgentStatusToProvisionedNetwork()
		return nil
	case agentstatus.EdgeAgentStatusToBuild:
		m.ClearAgentStatusToBuild()
		return nil
	}
	return fmt.Errorf("unknown AgentStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentStatusMutation) ResetEdge(name string) error {
	switch name {
	case agentstatus.EdgeAgentStatusToProvisionedHost:
		m.ResetAgentStatusToProvisionedHost()
		return nil
	case agentstatus.EdgeAgentStatusToProvisionedNetwork:
		m.ResetAgentStatusToProvisionedNetwork()
		return nil
	case agentstatus.EdgeAgentStatusToBuild:
		m.ResetAgentStatusToBuild()
		return nil
	}
	return fmt.Errorf("unknown AgentStatus edge %s", name)
}

// AgentTaskMutation represents an operation that mutates the AgentTask nodes in the graph.
type AgentTaskMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *uuid.UUID
	command                             *agenttask.Command
	args                                *string
	number                              *int
	addnumber                           *int
	output                              *string
	state                               *agenttask.State
	error_message                       *string
	clearedFields                       map[string]struct{}
	_AgentTaskToProvisioningStep        *uuid.UUID
	cleared_AgentTaskToProvisioningStep bool
	_AgentTaskToProvisionedHost         *uuid.UUID
	cleared_AgentTaskToProvisionedHost  bool
	_AgentTaskToAdhocPlan               map[uuid.UUID]struct{}
	removed_AgentTaskToAdhocPlan        map[uuid.UUID]struct{}
	cleared_AgentTaskToAdhocPlan        bool
	done                                bool
	oldValue                            func(context.Context) (*AgentTask, error)
	predicates                          []predicate.AgentTask
}

var _ ent.Mutation = (*AgentTaskMutation)(nil)

// agenttaskOption allows management of the mutation configuration using functional options.
type agenttaskOption func(*AgentTaskMutation)

// newAgentTaskMutation creates new mutation for the AgentTask entity.
func newAgentTaskMutation(c config, op Op, opts ...agenttaskOption) *AgentTaskMutation {
	m := &AgentTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeAgentTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentTaskID sets the ID field of the mutation.
func withAgentTaskID(id uuid.UUID) agenttaskOption {
	return func(m *AgentTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *AgentTask
		)
		m.oldValue = func(ctx context.Context) (*AgentTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AgentTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgentTask sets the old AgentTask of the mutation.
func withAgentTask(node *AgentTask) agenttaskOption {
	return func(m *AgentTaskMutation) {
		m.oldValue = func(context.Context) (*AgentTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AgentTask entities.
func (m *AgentTaskMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgentTaskMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgentTaskMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AgentTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCommand sets the "command" field.
func (m *AgentTaskMutation) SetCommand(a agenttask.Command) {
	m.command = &a
}

// Command returns the value of the "command" field in the mutation.
func (m *AgentTaskMutation) Command() (r agenttask.Command, exists bool) {
	v := m.command
	if v == nil {
		return
	}
	return *v, true
}

// OldCommand returns the old "command" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldCommand(ctx context.Context) (v agenttask.Command, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommand: %w", err)
	}
	return oldValue.Command, nil
}

// ResetCommand resets all changes to the "command" field.
func (m *AgentTaskMutation) ResetCommand() {
	m.command = nil
}

// SetArgs sets the "args" field.
func (m *AgentTaskMutation) SetArgs(s string) {
	m.args = &s
}

// Args returns the value of the "args" field in the mutation.
func (m *AgentTaskMutation) Args() (r string, exists bool) {
	v := m.args
	if v == nil {
		return
	}
	return *v, true
}

// OldArgs returns the old "args" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldArgs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArgs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArgs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArgs: %w", err)
	}
	return oldValue.Args, nil
}

// ResetArgs resets all changes to the "args" field.
func (m *AgentTaskMutation) ResetArgs() {
	m.args = nil
}

// SetNumber sets the "number" field.
func (m *AgentTaskMutation) SetNumber(i int) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *AgentTaskMutation) Number() (r int, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *AgentTaskMutation) AddNumber(i int) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *AgentTaskMutation) AddedNumber() (r int, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber resets all changes to the "number" field.
func (m *AgentTaskMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
}

// SetOutput sets the "output" field.
func (m *AgentTaskMutation) SetOutput(s string) {
	m.output = &s
}

// Output returns the value of the "output" field in the mutation.
func (m *AgentTaskMutation) Output() (r string, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ResetOutput resets all changes to the "output" field.
func (m *AgentTaskMutation) ResetOutput() {
	m.output = nil
}

// SetState sets the "state" field.
func (m *AgentTaskMutation) SetState(a agenttask.State) {
	m.state = &a
}

// State returns the value of the "state" field in the mutation.
func (m *AgentTaskMutation) State() (r agenttask.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldState(ctx context.Context) (v agenttask.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *AgentTaskMutation) ResetState() {
	m.state = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *AgentTaskMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *AgentTaskMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the AgentTask entity.
// If the AgentTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentTaskMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *AgentTaskMutation) ResetErrorMessage() {
	m.error_message = nil
}

// SetAgentTaskToProvisioningStepID sets the "AgentTaskToProvisioningStep" edge to the ProvisioningStep entity by id.
func (m *AgentTaskMutation) SetAgentTaskToProvisioningStepID(id uuid.UUID) {
	m._AgentTaskToProvisioningStep = &id
}

// ClearAgentTaskToProvisioningStep clears the "AgentTaskToProvisioningStep" edge to the ProvisioningStep entity.
func (m *AgentTaskMutation) ClearAgentTaskToProvisioningStep() {
	m.cleared_AgentTaskToProvisioningStep = true
}

// AgentTaskToProvisioningStepCleared reports if the "AgentTaskToProvisioningStep" edge to the ProvisioningStep entity was cleared.
func (m *AgentTaskMutation) AgentTaskToProvisioningStepCleared() bool {
	return m.cleared_AgentTaskToProvisioningStep
}

// AgentTaskToProvisioningStepID returns the "AgentTaskToProvisioningStep" edge ID in the mutation.
func (m *AgentTaskMutation) AgentTaskToProvisioningStepID() (id uuid.UUID, exists bool) {
	if m._AgentTaskToProvisioningStep != nil {
		return *m._AgentTaskToProvisioningStep, true
	}
	return
}

// AgentTaskToProvisioningStepIDs returns the "AgentTaskToProvisioningStep" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentTaskToProvisioningStepID instead. It exists only for internal usage by the builders.
func (m *AgentTaskMutation) AgentTaskToProvisioningStepIDs() (ids []uuid.UUID) {
	if id := m._AgentTaskToProvisioningStep; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgentTaskToProvisioningStep resets all changes to the "AgentTaskToProvisioningStep" edge.
func (m *AgentTaskMutation) ResetAgentTaskToProvisioningStep() {
	m._AgentTaskToProvisioningStep = nil
	m.cleared_AgentTaskToProvisioningStep = false
}

// SetAgentTaskToProvisionedHostID sets the "AgentTaskToProvisionedHost" edge to the ProvisionedHost entity by id.
func (m *AgentTaskMutation) SetAgentTaskToProvisionedHostID(id uuid.UUID) {
	m._AgentTaskToProvisionedHost = &id
}

// ClearAgentTaskToProvisionedHost clears the "AgentTaskToProvisionedHost" edge to the ProvisionedHost entity.
func (m *AgentTaskMutation) ClearAgentTaskToProvisionedHost() {
	m.cleared_AgentTaskToProvisionedHost = true
}

// AgentTaskToProvisionedHostCleared reports if the "AgentTaskToProvisionedHost" edge to the ProvisionedHost entity was cleared.
func (m *AgentTaskMutation) AgentTaskToProvisionedHostCleared() bool {
	return m.cleared_AgentTaskToProvisionedHost
}

// AgentTaskToProvisionedHostID returns the "AgentTaskToProvisionedHost" edge ID in the mutation.
func (m *AgentTaskMutation) AgentTaskToProvisionedHostID() (id uuid.UUID, exists bool) {
	if m._AgentTaskToProvisionedHost != nil {
		return *m._AgentTaskToProvisionedHost, true
	}
	return
}

// AgentTaskToProvisionedHostIDs returns the "AgentTaskToProvisionedHost" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentTaskToProvisionedHostID instead. It exists only for internal usage by the builders.
func (m *AgentTaskMutation) AgentTaskToProvisionedHostIDs() (ids []uuid.UUID) {
	if id := m._AgentTaskToProvisionedHost; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgentTaskToProvisionedHost resets all changes to the "AgentTaskToProvisionedHost" edge.
func (m *AgentTaskMutation) ResetAgentTaskToProvisionedHost() {
	m._AgentTaskToProvisionedHost = nil
	m.cleared_AgentTaskToProvisionedHost = false
}

// AddAgentTaskToAdhocPlanIDs adds the "AgentTaskToAdhocPlan" edge to the AdhocPlan entity by ids.
func (m *AgentTaskMutation) AddAgentTaskToAdhocPlanIDs(ids ...uuid.UUID) {
	if m._AgentTaskToAdhocPlan == nil {
		m._AgentTaskToAdhocPlan = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._AgentTaskToAdhocPlan[ids[i]] = struct{}{}
	}
}

// ClearAgentTaskToAdhocPlan clears the "AgentTaskToAdhocPlan" edge to the AdhocPlan entity.
func (m *AgentTaskMutation) ClearAgentTaskToAdhocPlan() {
	m.cleared_AgentTaskToAdhocPlan = true
}

// AgentTaskToAdhocPlanCleared reports if the "AgentTaskToAdhocPlan" edge to the AdhocPlan entity was cleared.
func (m *AgentTaskMutation) AgentTaskToAdhocPlanCleared() bool {
	return m.cleared_AgentTaskToAdhocPlan
}

// RemoveAgentTaskToAdhocPlanIDs removes the "AgentTaskToAdhocPlan" edge to the AdhocPlan entity by IDs.
func (m *AgentTaskMutation) RemoveAgentTaskToAdhocPlanIDs(ids ...uuid.UUID) {
	if m.removed_AgentTaskToAdhocPlan == nil {
		m.removed_AgentTaskToAdhocPlan = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._AgentTaskToAdhocPlan, ids[i])
		m.removed_AgentTaskToAdhocPlan[ids[i]] = struct{}{}
	}
}

// RemovedAgentTaskToAdhocPlan returns the removed IDs of the "AgentTaskToAdhocPlan" edge to the AdhocPlan entity.
func (m *AgentTaskMutation) RemovedAgentTaskToAdhocPlanIDs() (ids []uuid.UUID) {
	for id := range m.removed_AgentTaskToAdhocPlan {
		ids = append(ids, id)
	}
	return
}

// AgentTaskToAdhocPlanIDs returns the "AgentTaskToAdhocPlan" edge IDs in the mutation.
func (m *AgentTaskMutation) AgentTaskToAdhocPlanIDs() (ids []uuid.UUID) {
	for id := range m._AgentTaskToAdhocPlan {
		ids = append(ids, id)
	}
	return
}

// ResetAgentTaskToAdhocPlan resets all changes to the "AgentTaskToAdhocPlan" edge.
func (m *AgentTaskMutation) ResetAgentTaskToAdhocPlan() {
	m._AgentTaskToAdhocPlan = nil
	m.cleared_AgentTaskToAdhocPlan = false
	m.removed_AgentTaskToAdhocPlan = nil
}

// Where appends a list predicates to the AgentTaskMutation builder.
func (m *AgentTaskMutation) Where(ps ...predicate.AgentTask) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AgentTaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AgentTaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AgentTask, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AgentTaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AgentTaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AgentTask).
func (m *AgentTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentTaskMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.command != nil {
		fields = append(fields, agenttask.FieldCommand)
	}
	if m.args != nil {
		fields = append(fields, agenttask.FieldArgs)
	}
	if m.number != nil {
		fields = append(fields, agenttask.FieldNumber)
	}
	if m.output != nil {
		fields = append(fields, agenttask.FieldOutput)
	}
	if m.state != nil {
		fields = append(fields, agenttask.FieldState)
	}
	if m.error_message != nil {
		fields = append(fields, agenttask.FieldErrorMessage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agenttask.FieldCommand:
		return m.Command()
	case agenttask.FieldArgs:
		return m.Args()
	case agenttask.FieldNumber:
		return m.Number()
	case agenttask.FieldOutput:
		return m.Output()
	case agenttask.FieldState:
		return m.State()
	case agenttask.FieldErrorMessage:
		return m.ErrorMessage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agenttask.FieldCommand:
		return m.OldCommand(ctx)
	case agenttask.FieldArgs:
		return m.OldArgs(ctx)
	case agenttask.FieldNumber:
		return m.OldNumber(ctx)
	case agenttask.FieldOutput:
		return m.OldOutput(ctx)
	case agenttask.FieldState:
		return m.OldState(ctx)
	case agenttask.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	}
	return nil, fmt.Errorf("unknown AgentTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agenttask.FieldCommand:
		v, ok := value.(agenttask.Command)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommand(v)
		return nil
	case agenttask.FieldArgs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArgs(v)
		return nil
	case agenttask.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case agenttask.FieldOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case agenttask.FieldState:
		v, ok := value.(agenttask.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case agenttask.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	}
	return fmt.Errorf("unknown AgentTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentTaskMutation) AddedFields() []string {
	var fields []string
	if m.addnumber != nil {
		fields = append(fields, agenttask.FieldNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentTaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case agenttask.FieldNumber:
		return m.AddedNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case agenttask.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	}
	return fmt.Errorf("unknown AgentTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentTaskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentTaskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AgentTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentTaskMutation) ResetField(name string) error {
	switch name {
	case agenttask.FieldCommand:
		m.ResetCommand()
		return nil
	case agenttask.FieldArgs:
		m.ResetArgs()
		return nil
	case agenttask.FieldNumber:
		m.ResetNumber()
		return nil
	case agenttask.FieldOutput:
		m.ResetOutput()
		return nil
	case agenttask.FieldState:
		m.ResetState()
		return nil
	case agenttask.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown AgentTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._AgentTaskToProvisioningStep != nil {
		edges = append(edges, agenttask.EdgeAgentTaskToProvisioningStep)
	}
	if m._AgentTaskToProvisionedHost != nil {
		edges = append(edges, agenttask.EdgeAgentTaskToProvisionedHost)
	}
	if m._AgentTaskToAdhocPlan != nil {
		edges = append(edges, agenttask.EdgeAgentTaskToAdhocPlan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentTaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agenttask.EdgeAgentTaskToProvisioningStep:
		if id := m._AgentTaskToProvisioningStep; id != nil {
			return []ent.Value{*id}
		}
	case agenttask.EdgeAgentTaskToProvisionedHost:
		if id := m._AgentTaskToProvisionedHost; id != nil {
			return []ent.Value{*id}
		}
	case agenttask.EdgeAgentTaskToAdhocPlan:
		ids := make([]ent.Value, 0, len(m._AgentTaskToAdhocPlan))
		for id := range m._AgentTaskToAdhocPlan {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_AgentTaskToAdhocPlan != nil {
		edges = append(edges, agenttask.EdgeAgentTaskToAdhocPlan)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentTaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case agenttask.EdgeAgentTaskToAdhocPlan:
		ids := make([]ent.Value, 0, len(m.removed_AgentTaskToAdhocPlan))
		for id := range m.removed_AgentTaskToAdhocPlan {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_AgentTaskToProvisioningStep {
		edges = append(edges, agenttask.EdgeAgentTaskToProvisioningStep)
	}
	if m.cleared_AgentTaskToProvisionedHost {
		edges = append(edges, agenttask.EdgeAgentTaskToProvisionedHost)
	}
	if m.cleared_AgentTaskToAdhocPlan {
		edges = append(edges, agenttask.EdgeAgentTaskToAdhocPlan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentTaskMutation) EdgeCleared(name string) bool {
	switch name {
	case agenttask.EdgeAgentTaskToProvisioningStep:
		return m.cleared_AgentTaskToProvisioningStep
	case agenttask.EdgeAgentTaskToProvisionedHost:
		return m.cleared_AgentTaskToProvisionedHost
	case agenttask.EdgeAgentTaskToAdhocPlan:
		return m.cleared_AgentTaskToAdhocPlan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentTaskMutation) ClearEdge(name string) error {
	switch name {
	case agenttask.EdgeAgentTaskToProvisioningStep:
		m.ClearAgentTaskToProvisioningStep()
		return nil
	case agenttask.EdgeAgentTaskToProvisionedHost:
		m.ClearAgentTaskToProvisionedHost()
		return nil
	}
	return fmt.Errorf("unknown AgentTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentTaskMutation) ResetEdge(name string) error {
	switch name {
	case agenttask.EdgeAgentTaskToProvisioningStep:
		m.ResetAgentTaskToProvisioningStep()
		return nil
	case agenttask.EdgeAgentTaskToProvisionedHost:
		m.ResetAgentTaskToProvisionedHost()
		return nil
	case agenttask.EdgeAgentTaskToAdhocPlan:
		m.ResetAgentTaskToAdhocPlan()
		return nil
	}
	return fmt.Errorf("unknown AgentTask edge %s", name)
}

// AnsibleMutation represents an operation that mutates the Ansible nodes in the graph.
type AnsibleMutation struct {
	config
	op                             Op
	typ                            string
	id                             *uuid.UUID
	name                           *string
	hcl_id                         *string
	description                    *string
	source                         *string
	playbook_name                  *string
	method                         *ansible.Method
	inventory                      *string
	abs_path                       *string
	tags                           *map[string]string
	clearedFields                  map[string]struct{}
	_AnsibleToUser                 map[uuid.UUID]struct{}
	removed_AnsibleToUser          map[uuid.UUID]struct{}
	cleared_AnsibleToUser          bool
	_AnsibleFromEnvironment        *uuid.UUID
	cleared_AnsibleFromEnvironment bool
	done                           bool
	oldValue                       func(context.Context) (*Ansible, error)
	predicates                     []predicate.Ansible
}

var _ ent.Mutation = (*AnsibleMutation)(nil)

// ansibleOption allows management of the mutation configuration using functional options.
type ansibleOption func(*AnsibleMutation)

// newAnsibleMutation creates new mutation for the Ansible entity.
func newAnsibleMutation(c config, op Op, opts ...ansibleOption) *AnsibleMutation {
	m := &AnsibleMutation{
		config:        c,
		op:            op,
		typ:           TypeAnsible,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAnsibleID sets the ID field of the mutation.
func withAnsibleID(id uuid.UUID) ansibleOption {
	return func(m *AnsibleMutation) {
		var (
			err   error
			once  sync.Once
			value *Ansible
		)
		m.oldValue = func(ctx context.Context) (*Ansible, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ansible.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAnsible sets the old Ansible of the mutation.
func withAnsible(node *Ansible) ansibleOption {
	return func(m *AnsibleMutation) {
		m.oldValue = func(context.Context) (*Ansible, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AnsibleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AnsibleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Ansible entities.
func (m *AnsibleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AnsibleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AnsibleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ansible.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AnsibleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AnsibleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Ansible entity.
// If the Ansible object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsibleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AnsibleMutation) ResetName() {
	m.name = nil
}

// SetHCLID sets the "hcl_id" field.
func (m *AnsibleMutation) SetHCLID(s string) {
	m.hcl_id = &s
}

// HCLID returns the value of the "hcl_id" field in the mutation.
func (m *AnsibleMutation) HCLID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHCLID returns the old "hcl_id" field's value of the Ansible entity.
// If the Ansible object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsibleMutation) OldHCLID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHCLID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHCLID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHCLID: %w", err)
	}
	return oldValue.HCLID, nil
}

// ResetHCLID resets all changes to the "hcl_id" field.
func (m *AnsibleMutation) ResetHCLID() {
	m.hcl_id = nil
}

// SetDescription sets the "description" field.
func (m *AnsibleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AnsibleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Ansible entity.
// If the Ansible object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsibleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AnsibleMutation) ResetDescription() {
	m.description = nil
}

// SetSource sets the "source" field.
func (m *AnsibleMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *AnsibleMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Ansible entity.
// If the Ansible object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsibleMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *AnsibleMutation) ResetSource() {
	m.source = nil
}

// SetPlaybookName sets the "playbook_name" field.
func (m *AnsibleMutation) SetPlaybookName(s string) {
	m.playbook_name = &s
}

// PlaybookName returns the value of the "playbook_name" field in the mutation.
func (m *AnsibleMutation) PlaybookName() (r string, exists bool) {
	v := m.playbook_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPlaybookName returns the old "playbook_name" field's value of the Ansible entity.
// If the Ansible object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsibleMutation) OldPlaybookName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlaybookName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlaybookName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlaybookName: %w", err)
	}
	return oldValue.PlaybookName, nil
}

// ResetPlaybookName resets all changes to the "playbook_name" field.
func (m *AnsibleMutation) ResetPlaybookName() {
	m.playbook_name = nil
}

// SetMethod sets the "method" field.
func (m *AnsibleMutation) SetMethod(a ansible.Method) {
	m.method = &a
}

// Method returns the value of the "method" field in the mutation.
func (m *AnsibleMutation) Method() (r ansible.Method, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the Ansible entity.
// If the Ansible object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsibleMutation) OldMethod(ctx context.Context) (v ansible.Method, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *AnsibleMutation) ResetMethod() {
	m.method = nil
}

// SetInventory sets the "inventory" field.
func (m *AnsibleMutation) SetInventory(s string) {
	m.inventory = &s
}

// Inventory returns the value of the "inventory" field in the mutation.
func (m *AnsibleMutation) Inventory() (r string, exists bool) {
	v := m.inventory
	if v == nil {
		return
	}
	return *v, true
}

// OldInventory returns the old "inventory" field's value of the Ansible entity.
// If the Ansible object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsibleMutation) OldInventory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInventory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInventory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInventory: %w", err)
	}
	return oldValue.Inventory, nil
}

// ResetInventory resets all changes to the "inventory" field.
func (m *AnsibleMutation) ResetInventory() {
	m.inventory = nil
}

// SetAbsPath sets the "abs_path" field.
func (m *AnsibleMutation) SetAbsPath(s string) {
	m.abs_path = &s
}

// AbsPath returns the value of the "abs_path" field in the mutation.
func (m *AnsibleMutation) AbsPath() (r string, exists bool) {
	v := m.abs_path
	if v == nil {
		return
	}
	return *v, true
}

// OldAbsPath returns the old "abs_path" field's value of the Ansible entity.
// If the Ansible object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsibleMutation) OldAbsPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbsPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbsPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbsPath: %w", err)
	}
	return oldValue.AbsPath, nil
}

// ResetAbsPath resets all changes to the "abs_path" field.
func (m *AnsibleMutation) ResetAbsPath() {
	m.abs_path = nil
}

// SetTags sets the "tags" field.
func (m *AnsibleMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *AnsibleMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Ansible entity.
// If the Ansible object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsibleMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *AnsibleMutation) ResetTags() {
	m.tags = nil
}

// AddAnsibleToUserIDs adds the "AnsibleToUser" edge to the User entity by ids.
func (m *AnsibleMutation) AddAnsibleToUserIDs(ids ...uuid.UUID) {
	if m._AnsibleToUser == nil {
		m._AnsibleToUser = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._AnsibleToUser[ids[i]] = struct{}{}
	}
}

// ClearAnsibleToUser clears the "AnsibleToUser" edge to the User entity.
func (m *AnsibleMutation) ClearAnsibleToUser() {
	m.cleared_AnsibleToUser = true
}

// AnsibleToUserCleared reports if the "AnsibleToUser" edge to the User entity was cleared.
func (m *AnsibleMutation) AnsibleToUserCleared() bool {
	return m.cleared_AnsibleToUser
}

// RemoveAnsibleToUserIDs removes the "AnsibleToUser" edge to the User entity by IDs.
func (m *AnsibleMutation) RemoveAnsibleToUserIDs(ids ...uuid.UUID) {
	if m.removed_AnsibleToUser == nil {
		m.removed_AnsibleToUser = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._AnsibleToUser, ids[i])
		m.removed_AnsibleToUser[ids[i]] = struct{}{}
	}
}

// RemovedAnsibleToUser returns the removed IDs of the "AnsibleToUser" edge to the User entity.
func (m *AnsibleMutation) RemovedAnsibleToUserIDs() (ids []uuid.UUID) {
	for id := range m.removed_AnsibleToUser {
		ids = append(ids, id)
	}
	return
}

// AnsibleToUserIDs returns the "AnsibleToUser" edge IDs in the mutation.
func (m *AnsibleMutation) AnsibleToUserIDs() (ids []uuid.UUID) {
	for id := range m._AnsibleToUser {
		ids = append(ids, id)
	}
	return
}

// ResetAnsibleToUser resets all changes to the "AnsibleToUser" edge.
func (m *AnsibleMutation) ResetAnsibleToUser() {
	m._AnsibleToUser = nil
	m.cleared_AnsibleToUser = false
	m.removed_AnsibleToUser = nil
}

// SetAnsibleFromEnvironmentID sets the "AnsibleFromEnvironment" edge to the Environment entity by id.
func (m *AnsibleMutation) SetAnsibleFromEnvironmentID(id uuid.UUID) {
	m._AnsibleFromEnvironment = &id
}

// ClearAnsibleFromEnvironment clears the "AnsibleFromEnvironment" edge to the Environment entity.
func (m *AnsibleMutation) ClearAnsibleFromEnvironment() {
	m.cleared_AnsibleFromEnvironment = true
}

// AnsibleFromEnvironmentCleared reports if the "AnsibleFromEnvironment" edge to the Environment entity was cleared.
func (m *AnsibleMutation) AnsibleFromEnvironmentCleared() bool {
	return m.cleared_AnsibleFromEnvironment
}

// AnsibleFromEnvironmentID returns the "AnsibleFromEnvironment" edge ID in the mutation.
func (m *AnsibleMutation) AnsibleFromEnvironmentID() (id uuid.UUID, exists bool) {
	if m._AnsibleFromEnvironment != nil {
		return *m._AnsibleFromEnvironment, true
	}
	return
}

// AnsibleFromEnvironmentIDs returns the "AnsibleFromEnvironment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AnsibleFromEnvironmentID instead. It exists only for internal usage by the builders.
func (m *AnsibleMutation) AnsibleFromEnvironmentIDs() (ids []uuid.UUID) {
	if id := m._AnsibleFromEnvironment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAnsibleFromEnvironment resets all changes to the "AnsibleFromEnvironment" edge.
func (m *AnsibleMutation) ResetAnsibleFromEnvironment() {
	m._AnsibleFromEnvironment = nil
	m.cleared_AnsibleFromEnvironment = false
}

// Where appends a list predicates to the AnsibleMutation builder.
func (m *AnsibleMutation) Where(ps ...predicate.Ansible) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AnsibleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AnsibleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ansible, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AnsibleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AnsibleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ansible).
func (m *AnsibleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AnsibleMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, ansible.FieldName)
	}
	if m.hcl_id != nil {
		fields = append(fields, ansible.FieldHCLID)
	}
	if m.description != nil {
		fields = append(fields, ansible.FieldDescription)
	}
	if m.source != nil {
		fields = append(fields, ansible.FieldSource)
	}
	if m.playbook_name != nil {
		fields = append(fields, ansible.FieldPlaybookName)
	}
	if m.method != nil {
		fields = append(fields, ansible.FieldMethod)
	}
	if m.inventory != nil {
		fields = append(fields, ansible.FieldInventory)
	}
	if m.abs_path != nil {
		fields = append(fields, ansible.FieldAbsPath)
	}
	if m.tags != nil {
		fields = append(fields, ansible.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AnsibleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ansible.FieldName:
		return m.Name()
	case ansible.FieldHCLID:
		return m.HCLID()
	case ansible.FieldDescription:
		return m.Description()
	case ansible.FieldSource:
		return m.Source()
	case ansible.FieldPlaybookName:
		return m.PlaybookName()
	case ansible.FieldMethod:
		return m.Method()
	case ansible.FieldInventory:
		return m.Inventory()
	case ansible.FieldAbsPath:
		return m.AbsPath()
	case ansible.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AnsibleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ansible.FieldName:
		return m.OldName(ctx)
	case ansible.FieldHCLID:
		return m.OldHCLID(ctx)
	case ansible.FieldDescription:
		return m.OldDescription(ctx)
	case ansible.FieldSource:
		return m.OldSource(ctx)
	case ansible.FieldPlaybookName:
		return m.OldPlaybookName(ctx)
	case ansible.FieldMethod:
		return m.OldMethod(ctx)
	case ansible.FieldInventory:
		return m.OldInventory(ctx)
	case ansible.FieldAbsPath:
		return m.OldAbsPath(ctx)
	case ansible.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Ansible field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnsibleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ansible.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ansible.FieldHCLID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHCLID(v)
		return nil
	case ansible.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case ansible.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case ansible.FieldPlaybookName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlaybookName(v)
		return nil
	case ansible.FieldMethod:
		v, ok := value.(ansible.Method)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case ansible.FieldInventory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInventory(v)
		return nil
	case ansible.FieldAbsPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbsPath(v)
		return nil
	case ansible.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Ansible field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AnsibleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AnsibleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnsibleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Ansible numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AnsibleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AnsibleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AnsibleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Ansible nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AnsibleMutation) ResetField(name string) error {
	switch name {
	case ansible.FieldName:
		m.ResetName()
		return nil
	case ansible.FieldHCLID:
		m.ResetHCLID()
		return nil
	case ansible.FieldDescription:
		m.ResetDescription()
		return nil
	case ansible.FieldSource:
		m.ResetSource()
		return nil
	case ansible.FieldPlaybookName:
		m.ResetPlaybookName()
		return nil
	case ansible.FieldMethod:
		m.ResetMethod()
		return nil
	case ansible.FieldInventory:
		m.ResetInventory()
		return nil
	case ansible.FieldAbsPath:
		m.ResetAbsPath()
		return nil
	case ansible.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Ansible field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AnsibleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._AnsibleToUser != nil {
		edges = append(edges, ansible.EdgeAnsibleToUser)
	}
	if m._AnsibleFromEnvironment != nil {
		edges = append(edges, ansible.EdgeAnsibleFromEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AnsibleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ansible.EdgeAnsibleToUser:
		ids := make([]ent.Value, 0, len(m._AnsibleToUser))
		for id := range m._AnsibleToUser {
			ids = append(ids, id)
		}
		return ids
	case ansible.EdgeAnsibleFromEnvironment:
		if id := m._AnsibleFromEnvironment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AnsibleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_AnsibleToUser != nil {
		edges = append(edges, ansible.EdgeAnsibleToUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AnsibleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ansible.EdgeAnsibleToUser:
		ids := make([]ent.Value, 0, len(m.removed_AnsibleToUser))
		for id := range m.removed_AnsibleToUser {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AnsibleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_AnsibleToUser {
		edges = append(edges, ansible.EdgeAnsibleToUser)
	}
	if m.cleared_AnsibleFromEnvironment {
		edges = append(edges, ansible.EdgeAnsibleFromEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AnsibleMutation) EdgeCleared(name string) bool {
	switch name {
	case ansible.EdgeAnsibleToUser:
		return m.cleared_AnsibleToUser
	case ansible.EdgeAnsibleFromEnvironment:
		return m.cleared_AnsibleFromEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AnsibleMutation) ClearEdge(name string) error {
	switch name {
	case ansible.EdgeAnsibleFromEnvironment:
		m.ClearAnsibleFromEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Ansible unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AnsibleMutation) ResetEdge(name string) error {
	switch name {
	case ansible.EdgeAnsibleToUser:
		m.ResetAnsibleToUser()
		return nil
	case ansible.EdgeAnsibleFromEnvironment:
		m.ResetAnsibleFromEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Ansible edge %s", name)
}

// AuthUserMutation represents an operation that mutates the AuthUser nodes in the graph.
type AuthUserMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	username                      *string
	password                      *string
	first_name                    *string
	last_name                     *string
	email                         *string
	phone                         *string
	company                       *string
	occupation                    *string
	private_key_path              *string
	role                          *authuser.Role
	provider                      *authuser.Provider
	clearedFields                 map[string]struct{}
	_AuthUserToToken              map[uuid.UUID]struct{}
	removed_AuthUserToToken       map[uuid.UUID]struct{}
	cleared_AuthUserToToken       bool
	_AuthUserToServerTasks        map[uuid.UUID]struct{}
	removed_AuthUserToServerTasks map[uuid.UUID]struct{}
	cleared_AuthUserToServerTasks bool
	done                          bool
	oldValue                      func(context.Context) (*AuthUser, error)
	predicates                    []predicate.AuthUser
}

var _ ent.Mutation = (*AuthUserMutation)(nil)

// authuserOption allows management of the mutation configuration using functional options.
type authuserOption func(*AuthUserMutation)

// newAuthUserMutation creates new mutation for the AuthUser entity.
func newAuthUserMutation(c config, op Op, opts ...authuserOption) *AuthUserMutation {
	m := &AuthUserMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthUserID sets the ID field of the mutation.
func withAuthUserID(id uuid.UUID) authuserOption {
	return func(m *AuthUserMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthUser
		)
		m.oldValue = func(ctx context.Context) (*AuthUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthUser sets the old AuthUser of the mutation.
func withAuthUser(node *AuthUser) authuserOption {
	return func(m *AuthUserMutation) {
		m.oldValue = func(context.Context) (*AuthUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthUser entities.
func (m *AuthUserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthUserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthUserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *AuthUserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AuthUserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *AuthUserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *AuthUserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AuthUserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AuthUserMutation) ResetPassword() {
	m.password = nil
}

// SetFirstName sets the "first_name" field.
func (m *AuthUserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *AuthUserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *AuthUserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *AuthUserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *AuthUserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *AuthUserMutation) ResetLastName() {
	m.last_name = nil
}

// SetEmail sets the "email" field.
func (m *AuthUserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AuthUserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AuthUserMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *AuthUserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *AuthUserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *AuthUserMutation) ResetPhone() {
	m.phone = nil
}

// SetCompany sets the "company" field.
func (m *AuthUserMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *AuthUserMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ResetCompany resets all changes to the "company" field.
func (m *AuthUserMutation) ResetCompany() {
	m.company = nil
}

// SetOccupation sets the "occupation" field.
func (m *AuthUserMutation) SetOccupation(s string) {
	m.occupation = &s
}

// Occupation returns the value of the "occupation" field in the mutation.
func (m *AuthUserMutation) Occupation() (r string, exists bool) {
	v := m.occupation
	if v == nil {
		return
	}
	return *v, true
}

// OldOccupation returns the old "occupation" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldOccupation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOccupation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOccupation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOccupation: %w", err)
	}
	return oldValue.Occupation, nil
}

// ResetOccupation resets all changes to the "occupation" field.
func (m *AuthUserMutation) ResetOccupation() {
	m.occupation = nil
}

// SetPrivateKeyPath sets the "private_key_path" field.
func (m *AuthUserMutation) SetPrivateKeyPath(s string) {
	m.private_key_path = &s
}

// PrivateKeyPath returns the value of the "private_key_path" field in the mutation.
func (m *AuthUserMutation) PrivateKeyPath() (r string, exists bool) {
	v := m.private_key_path
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivateKeyPath returns the old "private_key_path" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldPrivateKeyPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivateKeyPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivateKeyPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivateKeyPath: %w", err)
	}
	return oldValue.PrivateKeyPath, nil
}

// ResetPrivateKeyPath resets all changes to the "private_key_path" field.
func (m *AuthUserMutation) ResetPrivateKeyPath() {
	m.private_key_path = nil
}

// SetRole sets the "role" field.
func (m *AuthUserMutation) SetRole(a authuser.Role) {
	m.role = &a
}

// Role returns the value of the "role" field in the mutation.
func (m *AuthUserMutation) Role() (r authuser.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldRole(ctx context.Context) (v authuser.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *AuthUserMutation) ResetRole() {
	m.role = nil
}

// SetProvider sets the "provider" field.
func (m *AuthUserMutation) SetProvider(a authuser.Provider) {
	m.provider = &a
}

// Provider returns the value of the "provider" field in the mutation.
func (m *AuthUserMutation) Provider() (r authuser.Provider, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the AuthUser entity.
// If the AuthUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthUserMutation) OldProvider(ctx context.Context) (v authuser.Provider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *AuthUserMutation) ResetProvider() {
	m.provider = nil
}

// AddAuthUserToTokenIDs adds the "AuthUserToToken" edge to the Token entity by ids.
func (m *AuthUserMutation) AddAuthUserToTokenIDs(ids ...uuid.UUID) {
	if m._AuthUserToToken == nil {
		m._AuthUserToToken = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._AuthUserToToken[ids[i]] = struct{}{}
	}
}

// ClearAuthUserToToken clears the "AuthUserToToken" edge to the Token entity.
func (m *AuthUserMutation) ClearAuthUserToToken() {
	m.cleared_AuthUserToToken = true
}

// AuthUserToTokenCleared reports if the "AuthUserToToken" edge to the Token entity was cleared.
func (m *AuthUserMutation) AuthUserToTokenCleared() bool {
	return m.cleared_AuthUserToToken
}

// RemoveAuthUserToTokenIDs removes the "AuthUserToToken" edge to the Token entity by IDs.
func (m *AuthUserMutation) RemoveAuthUserToTokenIDs(ids ...uuid.UUID) {
	if m.removed_AuthUserToToken == nil {
		m.removed_AuthUserToToken = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._AuthUserToToken, ids[i])
		m.removed_AuthUserToToken[ids[i]] = struct{}{}
	}
}

// RemovedAuthUserToToken returns the removed IDs of the "AuthUserToToken" edge to the Token entity.
func (m *AuthUserMutation) RemovedAuthUserToTokenIDs() (ids []uuid.UUID) {
	for id := range m.removed_AuthUserToToken {
		ids = append(ids, id)
	}
	return
}

// AuthUserToTokenIDs returns the "AuthUserToToken" edge IDs in the mutation.
func (m *AuthUserMutation) AuthUserToTokenIDs() (ids []uuid.UUID) {
	for id := range m._AuthUserToToken {
		ids = append(ids, id)
	}
	return
}

// ResetAuthUserToToken resets all changes to the "AuthUserToToken" edge.
func (m *AuthUserMutation) ResetAuthUserToToken() {
	m._AuthUserToToken = nil
	m.cleared_AuthUserToToken = false
	m.removed_AuthUserToToken = nil
}

// AddAuthUserToServerTaskIDs adds the "AuthUserToServerTasks" edge to the ServerTask entity by ids.
func (m *AuthUserMutation) AddAuthUserToServerTaskIDs(ids ...uuid.UUID) {
	if m._AuthUserToServerTasks == nil {
		m._AuthUserToServerTasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._AuthUserToServerTasks[ids[i]] = struct{}{}
	}
}

// ClearAuthUserToServerTasks clears the "AuthUserToServerTasks" edge to the ServerTask entity.
func (m *AuthUserMutation) ClearAuthUserToServerTasks() {
	m.cleared_AuthUserToServerTasks = true
}

// AuthUserToServerTasksCleared reports if the "AuthUserToServerTasks" edge to the ServerTask entity was cleared.
func (m *AuthUserMutation) AuthUserToServerTasksCleared() bool {
	return m.cleared_AuthUserToServerTasks
}

// RemoveAuthUserToServerTaskIDs removes the "AuthUserToServerTasks" edge to the ServerTask entity by IDs.
func (m *AuthUserMutation) RemoveAuthUserToServerTaskIDs(ids ...uuid.UUID) {
	if m.removed_AuthUserToServerTasks == nil {
		m.removed_AuthUserToServerTasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._AuthUserToServerTasks, ids[i])
		m.removed_AuthUserToServerTasks[ids[i]] = struct{}{}
	}
}

// RemovedAuthUserToServerTasks returns the removed IDs of the "AuthUserToServerTasks" edge to the ServerTask entity.
func (m *AuthUserMutation) RemovedAuthUserToServerTasksIDs() (ids []uuid.UUID) {
	for id := range m.removed_AuthUserToServerTasks {
		ids = append(ids, id)
	}
	return
}

// AuthUserToServerTasksIDs returns the "AuthUserToServerTasks" edge IDs in the mutation.
func (m *AuthUserMutation) AuthUserToServerTasksIDs() (ids []uuid.UUID) {
	for id := range m._AuthUserToServerTasks {
		ids = append(ids, id)
	}
	return
}

// ResetAuthUserToServerTasks resets all changes to the "AuthUserToServerTasks" edge.
func (m *AuthUserMutation) ResetAuthUserToServerTasks() {
	m._AuthUserToServerTasks = nil
	m.cleared_AuthUserToServerTasks = false
	m.removed_AuthUserToServerTasks = nil
}

// Where appends a list predicates to the AuthUserMutation builder.
func (m *AuthUserMutation) Where(ps ...predicate.AuthUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthUser).
func (m *AuthUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthUserMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.username != nil {
		fields = append(fields, authuser.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, authuser.FieldPassword)
	}
	if m.first_name != nil {
		fields = append(fields, authuser.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, authuser.FieldLastName)
	}
	if m.email != nil {
		fields = append(fields, authuser.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, authuser.FieldPhone)
	}
	if m.company != nil {
		fields = append(fields, authuser.FieldCompany)
	}
	if m.occupation != nil {
		fields = append(fields, authuser.FieldOccupation)
	}
	if m.private_key_path != nil {
		fields = append(fields, authuser.FieldPrivateKeyPath)
	}
	if m.role != nil {
		fields = append(fields, authuser.FieldRole)
	}
	if m.provider != nil {
		fields = append(fields, authuser.FieldProvider)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authuser.FieldUsername:
		return m.Username()
	case authuser.FieldPassword:
		return m.Password()
	case authuser.FieldFirstName:
		return m.FirstName()
	case authuser.FieldLastName:
		return m.LastName()
	case authuser.FieldEmail:
		return m.Email()
	case authuser.FieldPhone:
		return m.Phone()
	case authuser.FieldCompany:
		return m.Company()
	case authuser.FieldOccupation:
		return m.Occupation()
	case authuser.FieldPrivateKeyPath:
		return m.PrivateKeyPath()
	case authuser.FieldRole:
		return m.Role()
	case authuser.FieldProvider:
		return m.Provider()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authuser.FieldUsername:
		return m.OldUsername(ctx)
	case authuser.FieldPassword:
		return m.OldPassword(ctx)
	case authuser.FieldFirstName:
		return m.OldFirstName(ctx)
	case authuser.FieldLastName:
		return m.OldLastName(ctx)
	case authuser.FieldEmail:
		return m.OldEmail(ctx)
	case authuser.FieldPhone:
		return m.OldPhone(ctx)
	case authuser.FieldCompany:
		return m.OldCompany(ctx)
	case authuser.FieldOccupation:
		return m.OldOccupation(ctx)
	case authuser.FieldPrivateKeyPath:
		return m.OldPrivateKeyPath(ctx)
	case authuser.FieldRole:
		return m.OldRole(ctx)
	case authuser.FieldProvider:
		return m.OldProvider(ctx)
	}
	return nil, fmt.Errorf("unknown AuthUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authuser.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case authuser.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case authuser.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case authuser.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case authuser.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case authuser.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case authuser.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case authuser.FieldOccupation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOccupation(v)
		return nil
	case authuser.FieldPrivateKeyPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivateKeyPath(v)
		return nil
	case authuser.FieldRole:
		v, ok := value.(authuser.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case authuser.FieldProvider:
		v, ok := value.(authuser.Provider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	}
	return fmt.Errorf("unknown AuthUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthUserMutation) ResetField(name string) error {
	switch name {
	case authuser.FieldUsername:
		m.ResetUsername()
		return nil
	case authuser.FieldPassword:
		m.ResetPassword()
		return nil
	case authuser.FieldFirstName:
		m.ResetFirstName()
		return nil
	case authuser.FieldLastName:
		m.ResetLastName()
		return nil
	case authuser.FieldEmail:
		m.ResetEmail()
		return nil
	case authuser.FieldPhone:
		m.ResetPhone()
		return nil
	case authuser.FieldCompany:
		m.ResetCompany()
		return nil
	case authuser.FieldOccupation:
		m.ResetOccupation()
		return nil
	case authuser.FieldPrivateKeyPath:
		m.ResetPrivateKeyPath()
		return nil
	case authuser.FieldRole:
		m.ResetRole()
		return nil
	case authuser.FieldProvider:
		m.ResetProvider()
		return nil
	}
	return fmt.Errorf("unknown AuthUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._AuthUserToToken != nil {
		edges = append(edges, authuser.EdgeAuthUserToToken)
	}
	if m._AuthUserToServerTasks != nil {
		edges = append(edges, authuser.EdgeAuthUserToServerTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authuser.EdgeAuthUserToToken:
		ids := make([]ent.Value, 0, len(m._AuthUserToToken))
		for id := range m._AuthUserToToken {
			ids = append(ids, id)
		}
		return ids
	case authuser.EdgeAuthUserToServerTasks:
		ids := make([]ent.Value, 0, len(m._AuthUserToServerTasks))
		for id := range m._AuthUserToServerTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_AuthUserToToken != nil {
		edges = append(edges, authuser.EdgeAuthUserToToken)
	}
	if m.removed_AuthUserToServerTasks != nil {
		edges = append(edges, authuser.EdgeAuthUserToServerTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case authuser.EdgeAuthUserToToken:
		ids := make([]ent.Value, 0, len(m.removed_AuthUserToToken))
		for id := range m.removed_AuthUserToToken {
			ids = append(ids, id)
		}
		return ids
	case authuser.EdgeAuthUserToServerTasks:
		ids := make([]ent.Value, 0, len(m.removed_AuthUserToServerTasks))
		for id := range m.removed_AuthUserToServerTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_AuthUserToToken {
		edges = append(edges, authuser.EdgeAuthUserToToken)
	}
	if m.cleared_AuthUserToServerTasks {
		edges = append(edges, authuser.EdgeAuthUserToServerTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthUserMutation) EdgeCleared(name string) bool {
	switch name {
	case authuser.EdgeAuthUserToToken:
		return m.cleared_AuthUserToToken
	case authuser.EdgeAuthUserToServerTasks:
		return m.cleared_AuthUserToServerTasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthUserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthUserMutation) ResetEdge(name string) error {
	switch name {
	case authuser.EdgeAuthUserToToken:
		m.ResetAuthUserToToken()
		return nil
	case authuser.EdgeAuthUserToServerTasks:
		m.ResetAuthUserToServerTasks()
		return nil
	}
	return fmt.Errorf("unknown AuthUser edge %s", name)
}

// BuildMutation represents an operation that mutates the Build nodes in the graph.
type BuildMutation struct {
	config
	op                                Op
	typ                               string
	id                                *uuid.UUID
	revision                          *int
	addrevision                       *int
	environment_revision              *int
	addenvironment_revision           *int
	vars                              *map[string]string
	completed_plan                    *bool
	clearedFields                     map[string]struct{}
	_BuildToStatus                    *uuid.UUID
	cleared_BuildToStatus             bool
	_BuildToEnvironment               *uuid.UUID
	cleared_BuildToEnvironment        bool
	_BuildToCompetition               *uuid.UUID
	cleared_BuildToCompetition        bool
	_BuildToLatestBuildCommit         *uuid.UUID
	cleared_BuildToLatestBuildCommit  bool
	_BuildToRepoCommit                *uuid.UUID
	cleared_BuildToRepoCommit         bool
	_BuildToProvisionedNetwork        map[uuid.UUID]struct{}
	removed_BuildToProvisionedNetwork map[uuid.UUID]struct{}
	cleared_BuildToProvisionedNetwork bool
	_BuildToTeam                      map[uuid.UUID]struct{}
	removed_BuildToTeam               map[uuid.UUID]struct{}
	cleared_BuildToTeam               bool
	_BuildToPlan                      map[uuid.UUID]struct{}
	removed_BuildToPlan               map[uuid.UUID]struct{}
	cleared_BuildToPlan               bool
	_BuildToBuildCommits              map[uuid.UUID]struct{}
	removed_BuildToBuildCommits       map[uuid.UUID]struct{}
	cleared_BuildToBuildCommits       bool
	_BuildToAdhocPlans                map[uuid.UUID]struct{}
	removed_BuildToAdhocPlans         map[uuid.UUID]struct{}
	cleared_BuildToAdhocPlans         bool
	_BuildToAgentStatuses             map[uuid.UUID]struct{}
	removed_BuildToAgentStatuses      map[uuid.UUID]struct{}
	cleared_BuildToAgentStatuses      bool
	_BuildToServerTasks               map[uuid.UUID]struct{}
	removed_BuildToServerTasks        map[uuid.UUID]struct{}
	cleared_BuildToServerTasks        bool
	done                              bool
	oldValue                          func(context.Context) (*Build, error)
	predicates                        []predicate.Build
}

var _ ent.Mutation = (*BuildMutation)(nil)

// buildOption allows management of the mutation configuration using functional options.
type buildOption func(*BuildMutation)

// newBuildMutation creates new mutation for the Build entity.
func newBuildMutation(c config, op Op, opts ...buildOption) *BuildMutation {
	m := &BuildMutation{
		config:        c,
		op:            op,
		typ:           TypeBuild,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBuildID sets the ID field of the mutation.
func withBuildID(id uuid.UUID) buildOption {
	return func(m *BuildMutation) {
		var (
			err   error
			once  sync.Once
			value *Build
		)
		m.oldValue = func(ctx context.Context) (*Build, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Build.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBuild sets the old Build of the mutation.
func withBuild(node *Build) buildOption {
	return func(m *BuildMutation) {
		m.oldValue = func(context.Context) (*Build, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BuildMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BuildMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Build entities.
func (m *BuildMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BuildMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BuildMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Build.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRevision sets the "revision" field.
func (m *BuildMutation) SetRevision(i int) {
	m.revision = &i
	m.addrevision = nil
}

// Revision returns the value of the "revision" field in the mutation.
func (m *BuildMutation) Revision() (r int, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the Build entity.
// If the Build object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildMutation) OldRevision(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// AddRevision adds i to the "revision" field.
func (m *BuildMutation) AddRevision(i int) {
	if m.addrevision != nil {
		*m.addrevision += i
	} else {
		m.addrevision = &i
	}
}

// AddedRevision returns the value that was added to the "revision" field in this mutation.
func (m *BuildMutation) AddedRevision() (r int, exists bool) {
	v := m.addrevision
	if v == nil {
		return
	}
	return *v, true
}

// ResetRevision resets all changes to the "revision" field.
func (m *BuildMutation) ResetRevision() {
	m.revision = nil
	m.addrevision = nil
}

// SetEnvironmentRevision sets the "environment_revision" field.
func (m *BuildMutation) SetEnvironmentRevision(i int) {
	m.environment_revision = &i
	m.addenvironment_revision = nil
}

// EnvironmentRevision returns the value of the "environment_revision" field in the mutation.
func (m *BuildMutation) EnvironmentRevision() (r int, exists bool) {
	v := m.environment_revision
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvironmentRevision returns the old "environment_revision" field's value of the Build entity.
// If the Build object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildMutation) OldEnvironmentRevision(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvironmentRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvironmentRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvironmentRevision: %w", err)
	}
	return oldValue.EnvironmentRevision, nil
}

// AddEnvironmentRevision adds i to the "environment_revision" field.
func (m *BuildMutation) AddEnvironmentRevision(i int) {
	if m.addenvironment_revision != nil {
		*m.addenvironment_revision += i
	} else {
		m.addenvironment_revision = &i
	}
}

// AddedEnvironmentRevision returns the value that was added to the "environment_revision" field in this mutation.
func (m *BuildMutation) AddedEnvironmentRevision() (r int, exists bool) {
	v := m.addenvironment_revision
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnvironmentRevision resets all changes to the "environment_revision" field.
func (m *BuildMutation) ResetEnvironmentRevision() {
	m.environment_revision = nil
	m.addenvironment_revision = nil
}

// SetVars sets the "vars" field.
func (m *BuildMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *BuildMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the Build entity.
// If the Build object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *BuildMutation) ResetVars() {
	m.vars = nil
}

// SetCompletedPlan sets the "completed_plan" field.
func (m *BuildMutation) SetCompletedPlan(b bool) {
	m.completed_plan = &b
}

// CompletedPlan returns the value of the "completed_plan" field in the mutation.
func (m *BuildMutation) CompletedPlan() (r bool, exists bool) {
	v := m.completed_plan
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedPlan returns the old "completed_plan" field's value of the Build entity.
// If the Build object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildMutation) OldCompletedPlan(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedPlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedPlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedPlan: %w", err)
	}
	return oldValue.CompletedPlan, nil
}

// ResetCompletedPlan resets all changes to the "completed_plan" field.
func (m *BuildMutation) ResetCompletedPlan() {
	m.completed_plan = nil
}

// SetBuildToStatusID sets the "BuildToStatus" edge to the Status entity by id.
func (m *BuildMutation) SetBuildToStatusID(id uuid.UUID) {
	m._BuildToStatus = &id
}

// ClearBuildToStatus clears the "BuildToStatus" edge to the Status entity.
func (m *BuildMutation) ClearBuildToStatus() {
	m.cleared_BuildToStatus = true
}

// BuildToStatusCleared reports if the "BuildToStatus" edge to the Status entity was cleared.
func (m *BuildMutation) BuildToStatusCleared() bool {
	return m.cleared_BuildToStatus
}

// BuildToStatusID returns the "BuildToStatus" edge ID in the mutation.
func (m *BuildMutation) BuildToStatusID() (id uuid.UUID, exists bool) {
	if m._BuildToStatus != nil {
		return *m._BuildToStatus, true
	}
	return
}

// BuildToStatusIDs returns the "BuildToStatus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuildToStatusID instead. It exists only for internal usage by the builders.
func (m *BuildMutation) BuildToStatusIDs() (ids []uuid.UUID) {
	if id := m._BuildToStatus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuildToStatus resets all changes to the "BuildToStatus" edge.
func (m *BuildMutation) ResetBuildToStatus() {
	m._BuildToStatus = nil
	m.cleared_BuildToStatus = false
}

// SetBuildToEnvironmentID sets the "BuildToEnvironment" edge to the Environment entity by id.
func (m *BuildMutation) SetBuildToEnvironmentID(id uuid.UUID) {
	m._BuildToEnvironment = &id
}

// ClearBuildToEnvironment clears the "BuildToEnvironment" edge to the Environment entity.
func (m *BuildMutation) ClearBuildToEnvironment() {
	m.cleared_BuildToEnvironment = true
}

// BuildToEnvironmentCleared reports if the "BuildToEnvironment" edge to the Environment entity was cleared.
func (m *BuildMutation) BuildToEnvironmentCleared() bool {
	return m.cleared_BuildToEnvironment
}

// BuildToEnvironmentID returns the "BuildToEnvironment" edge ID in the mutation.
func (m *BuildMutation) BuildToEnvironmentID() (id uuid.UUID, exists bool) {
	if m._BuildToEnvironment != nil {
		return *m._BuildToEnvironment, true
	}
	return
}

// BuildToEnvironmentIDs returns the "BuildToEnvironment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuildToEnvironmentID instead. It exists only for internal usage by the builders.
func (m *BuildMutation) BuildToEnvironmentIDs() (ids []uuid.UUID) {
	if id := m._BuildToEnvironment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuildToEnvironment resets all changes to the "BuildToEnvironment" edge.
func (m *BuildMutation) ResetBuildToEnvironment() {
	m._BuildToEnvironment = nil
	m.cleared_BuildToEnvironment = false
}

// SetBuildToCompetitionID sets the "BuildToCompetition" edge to the Competition entity by id.
func (m *BuildMutation) SetBuildToCompetitionID(id uuid.UUID) {
	m._BuildToCompetition = &id
}

// ClearBuildToCompetition clears the "BuildToCompetition" edge to the Competition entity.
func (m *BuildMutation) ClearBuildToCompetition() {
	m.cleared_BuildToCompetition = true
}

// BuildToCompetitionCleared reports if the "BuildToCompetition" edge to the Competition entity was cleared.
func (m *BuildMutation) BuildToCompetitionCleared() bool {
	return m.cleared_BuildToCompetition
}

// BuildToCompetitionID returns the "BuildToCompetition" edge ID in the mutation.
func (m *BuildMutation) BuildToCompetitionID() (id uuid.UUID, exists bool) {
	if m._BuildToCompetition != nil {
		return *m._BuildToCompetition, true
	}
	return
}

// BuildToCompetitionIDs returns the "BuildToCompetition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuildToCompetitionID instead. It exists only for internal usage by the builders.
func (m *BuildMutation) BuildToCompetitionIDs() (ids []uuid.UUID) {
	if id := m._BuildToCompetition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuildToCompetition resets all changes to the "BuildToCompetition" edge.
func (m *BuildMutation) ResetBuildToCompetition() {
	m._BuildToCompetition = nil
	m.cleared_BuildToCompetition = false
}

// SetBuildToLatestBuildCommitID sets the "BuildToLatestBuildCommit" edge to the BuildCommit entity by id.
func (m *BuildMutation) SetBuildToLatestBuildCommitID(id uuid.UUID) {
	m._BuildToLatestBuildCommit = &id
}

// ClearBuildToLatestBuildCommit clears the "BuildToLatestBuildCommit" edge to the BuildCommit entity.
func (m *BuildMutation) ClearBuildToLatestBuildCommit() {
	m.cleared_BuildToLatestBuildCommit = true
}

// BuildToLatestBuildCommitCleared reports if the "BuildToLatestBuildCommit" edge to the BuildCommit entity was cleared.
func (m *BuildMutation) BuildToLatestBuildCommitCleared() bool {
	return m.cleared_BuildToLatestBuildCommit
}

// BuildToLatestBuildCommitID returns the "BuildToLatestBuildCommit" edge ID in the mutation.
func (m *BuildMutation) BuildToLatestBuildCommitID() (id uuid.UUID, exists bool) {
	if m._BuildToLatestBuildCommit != nil {
		return *m._BuildToLatestBuildCommit, true
	}
	return
}

// BuildToLatestBuildCommitIDs returns the "BuildToLatestBuildCommit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuildToLatestBuildCommitID instead. It exists only for internal usage by the builders.
func (m *BuildMutation) BuildToLatestBuildCommitIDs() (ids []uuid.UUID) {
	if id := m._BuildToLatestBuildCommit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuildToLatestBuildCommit resets all changes to the "BuildToLatestBuildCommit" edge.
func (m *BuildMutation) ResetBuildToLatestBuildCommit() {
	m._BuildToLatestBuildCommit = nil
	m.cleared_BuildToLatestBuildCommit = false
}

// SetBuildToRepoCommitID sets the "BuildToRepoCommit" edge to the RepoCommit entity by id.
func (m *BuildMutation) SetBuildToRepoCommitID(id uuid.UUID) {
	m._BuildToRepoCommit = &id
}

// ClearBuildToRepoCommit clears the "BuildToRepoCommit" edge to the RepoCommit entity.
func (m *BuildMutation) ClearBuildToRepoCommit() {
	m.cleared_BuildToRepoCommit = true
}

// BuildToRepoCommitCleared reports if the "BuildToRepoCommit" edge to the RepoCommit entity was cleared.
func (m *BuildMutation) BuildToRepoCommitCleared() bool {
	return m.cleared_BuildToRepoCommit
}

// BuildToRepoCommitID returns the "BuildToRepoCommit" edge ID in the mutation.
func (m *BuildMutation) BuildToRepoCommitID() (id uuid.UUID, exists bool) {
	if m._BuildToRepoCommit != nil {
		return *m._BuildToRepoCommit, true
	}
	return
}

// BuildToRepoCommitIDs returns the "BuildToRepoCommit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuildToRepoCommitID instead. It exists only for internal usage by the builders.
func (m *BuildMutation) BuildToRepoCommitIDs() (ids []uuid.UUID) {
	if id := m._BuildToRepoCommit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuildToRepoCommit resets all changes to the "BuildToRepoCommit" edge.
func (m *BuildMutation) ResetBuildToRepoCommit() {
	m._BuildToRepoCommit = nil
	m.cleared_BuildToRepoCommit = false
}

// AddBuildToProvisionedNetworkIDs adds the "BuildToProvisionedNetwork" edge to the ProvisionedNetwork entity by ids.
func (m *BuildMutation) AddBuildToProvisionedNetworkIDs(ids ...uuid.UUID) {
	if m._BuildToProvisionedNetwork == nil {
		m._BuildToProvisionedNetwork = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._BuildToProvisionedNetwork[ids[i]] = struct{}{}
	}
}

// ClearBuildToProvisionedNetwork clears the "BuildToProvisionedNetwork" edge to the ProvisionedNetwork entity.
func (m *BuildMutation) ClearBuildToProvisionedNetwork() {
	m.cleared_BuildToProvisionedNetwork = true
}

// BuildToProvisionedNetworkCleared reports if the "BuildToProvisionedNetwork" edge to the ProvisionedNetwork entity was cleared.
func (m *BuildMutation) BuildToProvisionedNetworkCleared() bool {
	return m.cleared_BuildToProvisionedNetwork
}

// RemoveBuildToProvisionedNetworkIDs removes the "BuildToProvisionedNetwork" edge to the ProvisionedNetwork entity by IDs.
func (m *BuildMutation) RemoveBuildToProvisionedNetworkIDs(ids ...uuid.UUID) {
	if m.removed_BuildToProvisionedNetwork == nil {
		m.removed_BuildToProvisionedNetwork = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._BuildToProvisionedNetwork, ids[i])
		m.removed_BuildToProvisionedNetwork[ids[i]] = struct{}{}
	}
}

// RemovedBuildToProvisionedNetwork returns the removed IDs of the "BuildToProvisionedNetwork" edge to the ProvisionedNetwork entity.
func (m *BuildMutation) RemovedBuildToProvisionedNetworkIDs() (ids []uuid.UUID) {
	for id := range m.removed_BuildToProvisionedNetwork {
		ids = append(ids, id)
	}
	return
}

// BuildToProvisionedNetworkIDs returns the "BuildToProvisionedNetwork" edge IDs in the mutation.
func (m *BuildMutation) BuildToProvisionedNetworkIDs() (ids []uuid.UUID) {
	for id := range m._BuildToProvisionedNetwork {
		ids = append(ids, id)
	}
	return
}

// ResetBuildToProvisionedNetwork resets all changes to the "BuildToProvisionedNetwork" edge.
func (m *BuildMutation) ResetBuildToProvisionedNetwork() {
	m._BuildToProvisionedNetwork = nil
	m.cleared_BuildToProvisionedNetwork = false
	m.removed_BuildToProvisionedNetwork = nil
}

// AddBuildToTeamIDs adds the "BuildToTeam" edge to the Team entity by ids.
func (m *BuildMutation) AddBuildToTeamIDs(ids ...uuid.UUID) {
	if m._BuildToTeam == nil {
		m._BuildToTeam = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._BuildToTeam[ids[i]] = struct{}{}
	}
}

// ClearBuildToTeam clears the "BuildToTeam" edge to the Team entity.
func (m *BuildMutation) ClearBuildToTeam() {
	m.cleared_BuildToTeam = true
}

// BuildToTeamCleared reports if the "BuildToTeam" edge to the Team entity was cleared.
func (m *BuildMutation) BuildToTeamCleared() bool {
	return m.cleared_BuildToTeam
}

// RemoveBuildToTeamIDs removes the "BuildToTeam" edge to the Team entity by IDs.
func (m *BuildMutation) RemoveBuildToTeamIDs(ids ...uuid.UUID) {
	if m.removed_BuildToTeam == nil {
		m.removed_BuildToTeam = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._BuildToTeam, ids[i])
		m.removed_BuildToTeam[ids[i]] = struct{}{}
	}
}

// RemovedBuildToTeam returns the removed IDs of the "BuildToTeam" edge to the Team entity.
func (m *BuildMutation) RemovedBuildToTeamIDs() (ids []uuid.UUID) {
	for id := range m.removed_BuildToTeam {
		ids = append(ids, id)
	}
	return
}

// BuildToTeamIDs returns the "BuildToTeam" edge IDs in the mutation.
func (m *BuildMutation) BuildToTeamIDs() (ids []uuid.UUID) {
	for id := range m._BuildToTeam {
		ids = append(ids, id)
	}
	return
}

// ResetBuildToTeam resets all changes to the "BuildToTeam" edge.
func (m *BuildMutation) ResetBuildToTeam() {
	m._BuildToTeam = nil
	m.cleared_BuildToTeam = false
	m.removed_BuildToTeam = nil
}

// AddBuildToPlanIDs adds the "BuildToPlan" edge to the Plan entity by ids.
func (m *BuildMutation) AddBuildToPlanIDs(ids ...uuid.UUID) {
	if m._BuildToPlan == nil {
		m._BuildToPlan = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._BuildToPlan[ids[i]] = struct{}{}
	}
}

// ClearBuildToPlan clears the "BuildToPlan" edge to the Plan entity.
func (m *BuildMutation) ClearBuildToPlan() {
	m.cleared_BuildToPlan = true
}

// BuildToPlanCleared reports if the "BuildToPlan" edge to the Plan entity was cleared.
func (m *BuildMutation) BuildToPlanCleared() bool {
	return m.cleared_BuildToPlan
}

// RemoveBuildToPlanIDs removes the "BuildToPlan" edge to the Plan entity by IDs.
func (m *BuildMutation) RemoveBuildToPlanIDs(ids ...uuid.UUID) {
	if m.removed_BuildToPlan == nil {
		m.removed_BuildToPlan = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._BuildToPlan, ids[i])
		m.removed_BuildToPlan[ids[i]] = struct{}{}
	}
}

// RemovedBuildToPlan returns the removed IDs of the "BuildToPlan" edge to the Plan entity.
func (m *BuildMutation) RemovedBuildToPlanIDs() (ids []uuid.UUID) {
	for id := range m.removed_BuildToPlan {
		ids = append(ids, id)
	}
	return
}

// BuildToPlanIDs returns the "BuildToPlan" edge IDs in the mutation.
func (m *BuildMutation) BuildToPlanIDs() (ids []uuid.UUID) {
	for id := range m._BuildToPlan {
		ids = append(ids, id)
	}
	return
}

// ResetBuildToPlan resets all changes to the "BuildToPlan" edge.
func (m *BuildMutation) ResetBuildToPlan() {
	m._BuildToPlan = nil
	m.cleared_BuildToPlan = false
	m.removed_BuildToPlan = nil
}

// AddBuildToBuildCommitIDs adds the "BuildToBuildCommits" edge to the BuildCommit entity by ids.
func (m *BuildMutation) AddBuildToBuildCommitIDs(ids ...uuid.UUID) {
	if m._BuildToBuildCommits == nil {
		m._BuildToBuildCommits = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._BuildToBuildCommits[ids[i]] = struct{}{}
	}
}

// ClearBuildToBuildCommits clears the "BuildToBuildCommits" edge to the BuildCommit entity.
func (m *BuildMutation) ClearBuildToBuildCommits() {
	m.cleared_BuildToBuildCommits = true
}

// BuildToBuildCommitsCleared reports if the "BuildToBuildCommits" edge to the BuildCommit entity was cleared.
func (m *BuildMutation) BuildToBuildCommitsCleared() bool {
	return m.cleared_BuildToBuildCommits
}

// RemoveBuildToBuildCommitIDs removes the "BuildToBuildCommits" edge to the BuildCommit entity by IDs.
func (m *BuildMutation) RemoveBuildToBuildCommitIDs(ids ...uuid.UUID) {
	if m.removed_BuildToBuildCommits == nil {
		m.removed_BuildToBuildCommits = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._BuildToBuildCommits, ids[i])
		m.removed_BuildToBuildCommits[ids[i]] = struct{}{}
	}
}

// RemovedBuildToBuildCommits returns the removed IDs of the "BuildToBuildCommits" edge to the BuildCommit entity.
func (m *BuildMutation) RemovedBuildToBuildCommitsIDs() (ids []uuid.UUID) {
	for id := range m.removed_BuildToBuildCommits {
		ids = append(ids, id)
	}
	return
}

// BuildToBuildCommitsIDs returns the "BuildToBuildCommits" edge IDs in the mutation.
func (m *BuildMutation) BuildToBuildCommitsIDs() (ids []uuid.UUID) {
	for id := range m._BuildToBuildCommits {
		ids = append(ids, id)
	}
	return
}

// ResetBuildToBuildCommits resets all changes to the "BuildToBuildCommits" edge.
func (m *BuildMutation) ResetBuildToBuildCommits() {
	m._BuildToBuildCommits = nil
	m.cleared_BuildToBuildCommits = false
	m.removed_BuildToBuildCommits = nil
}

// AddBuildToAdhocPlanIDs adds the "BuildToAdhocPlans" edge to the AdhocPlan entity by ids.
func (m *BuildMutation) AddBuildToAdhocPlanIDs(ids ...uuid.UUID) {
	if m._BuildToAdhocPlans == nil {
		m._BuildToAdhocPlans = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._BuildToAdhocPlans[ids[i]] = struct{}{}
	}
}

// ClearBuildToAdhocPlans clears the "BuildToAdhocPlans" edge to the AdhocPlan entity.
func (m *BuildMutation) ClearBuildToAdhocPlans() {
	m.cleared_BuildToAdhocPlans = true
}

// BuildToAdhocPlansCleared reports if the "BuildToAdhocPlans" edge to the AdhocPlan entity was cleared.
func (m *BuildMutation) BuildToAdhocPlansCleared() bool {
	return m.cleared_BuildToAdhocPlans
}

// RemoveBuildToAdhocPlanIDs removes the "BuildToAdhocPlans" edge to the AdhocPlan entity by IDs.
func (m *BuildMutation) RemoveBuildToAdhocPlanIDs(ids ...uuid.UUID) {
	if m.removed_BuildToAdhocPlans == nil {
		m.removed_BuildToAdhocPlans = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._BuildToAdhocPlans, ids[i])
		m.removed_BuildToAdhocPlans[ids[i]] = struct{}{}
	}
}

// RemovedBuildToAdhocPlans returns the removed IDs of the "BuildToAdhocPlans" edge to the AdhocPlan entity.
func (m *BuildMutation) RemovedBuildToAdhocPlansIDs() (ids []uuid.UUID) {
	for id := range m.removed_BuildToAdhocPlans {
		ids = append(ids, id)
	}
	return
}

// BuildToAdhocPlansIDs returns the "BuildToAdhocPlans" edge IDs in the mutation.
func (m *BuildMutation) BuildToAdhocPlansIDs() (ids []uuid.UUID) {
	for id := range m._BuildToAdhocPlans {
		ids = append(ids, id)
	}
	return
}

// ResetBuildToAdhocPlans resets all changes to the "BuildToAdhocPlans" edge.
func (m *BuildMutation) ResetBuildToAdhocPlans() {
	m._BuildToAdhocPlans = nil
	m.cleared_BuildToAdhocPlans = false
	m.removed_BuildToAdhocPlans = nil
}

// AddBuildToAgentStatuseIDs adds the "BuildToAgentStatuses" edge to the AgentStatus entity by ids.
func (m *BuildMutation) AddBuildToAgentStatuseIDs(ids ...uuid.UUID) {
	if m._BuildToAgentStatuses == nil {
		m._BuildToAgentStatuses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._BuildToAgentStatuses[ids[i]] = struct{}{}
	}
}

// ClearBuildToAgentStatuses clears the "BuildToAgentStatuses" edge to the AgentStatus entity.
func (m *BuildMutation) ClearBuildToAgentStatuses() {
	m.cleared_BuildToAgentStatuses = true
}

// BuildToAgentStatusesCleared reports if the "BuildToAgentStatuses" edge to the AgentStatus entity was cleared.
func (m *BuildMutation) BuildToAgentStatusesCleared() bool {
	return m.cleared_BuildToAgentStatuses
}

// RemoveBuildToAgentStatuseIDs removes the "BuildToAgentStatuses" edge to the AgentStatus entity by IDs.
func (m *BuildMutation) RemoveBuildToAgentStatuseIDs(ids ...uuid.UUID) {
	if m.removed_BuildToAgentStatuses == nil {
		m.removed_BuildToAgentStatuses = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._BuildToAgentStatuses, ids[i])
		m.removed_BuildToAgentStatuses[ids[i]] = struct{}{}
	}
}

// RemovedBuildToAgentStatuses returns the removed IDs of the "BuildToAgentStatuses" edge to the AgentStatus entity.
func (m *BuildMutation) RemovedBuildToAgentStatusesIDs() (ids []uuid.UUID) {
	for id := range m.removed_BuildToAgentStatuses {
		ids = append(ids, id)
	}
	return
}

// BuildToAgentStatusesIDs returns the "BuildToAgentStatuses" edge IDs in the mutation.
func (m *BuildMutation) BuildToAgentStatusesIDs() (ids []uuid.UUID) {
	for id := range m._BuildToAgentStatuses {
		ids = append(ids, id)
	}
	return
}

// ResetBuildToAgentStatuses resets all changes to the "BuildToAgentStatuses" edge.
func (m *BuildMutation) ResetBuildToAgentStatuses() {
	m._BuildToAgentStatuses = nil
	m.cleared_BuildToAgentStatuses = false
	m.removed_BuildToAgentStatuses = nil
}

// AddBuildToServerTaskIDs adds the "BuildToServerTasks" edge to the ServerTask entity by ids.
func (m *BuildMutation) AddBuildToServerTaskIDs(ids ...uuid.UUID) {
	if m._BuildToServerTasks == nil {
		m._BuildToServerTasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._BuildToServerTasks[ids[i]] = struct{}{}
	}
}

// ClearBuildToServerTasks clears the "BuildToServerTasks" edge to the ServerTask entity.
func (m *BuildMutation) ClearBuildToServerTasks() {
	m.cleared_BuildToServerTasks = true
}

// BuildToServerTasksCleared reports if the "BuildToServerTasks" edge to the ServerTask entity was cleared.
func (m *BuildMutation) BuildToServerTasksCleared() bool {
	return m.cleared_BuildToServerTasks
}

// RemoveBuildToServerTaskIDs removes the "BuildToServerTasks" edge to the ServerTask entity by IDs.
func (m *BuildMutation) RemoveBuildToServerTaskIDs(ids ...uuid.UUID) {
	if m.removed_BuildToServerTasks == nil {
		m.removed_BuildToServerTasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._BuildToServerTasks, ids[i])
		m.removed_BuildToServerTasks[ids[i]] = struct{}{}
	}
}

// RemovedBuildToServerTasks returns the removed IDs of the "BuildToServerTasks" edge to the ServerTask entity.
func (m *BuildMutation) RemovedBuildToServerTasksIDs() (ids []uuid.UUID) {
	for id := range m.removed_BuildToServerTasks {
		ids = append(ids, id)
	}
	return
}

// BuildToServerTasksIDs returns the "BuildToServerTasks" edge IDs in the mutation.
func (m *BuildMutation) BuildToServerTasksIDs() (ids []uuid.UUID) {
	for id := range m._BuildToServerTasks {
		ids = append(ids, id)
	}
	return
}

// ResetBuildToServerTasks resets all changes to the "BuildToServerTasks" edge.
func (m *BuildMutation) ResetBuildToServerTasks() {
	m._BuildToServerTasks = nil
	m.cleared_BuildToServerTasks = false
	m.removed_BuildToServerTasks = nil
}

// Where appends a list predicates to the BuildMutation builder.
func (m *BuildMutation) Where(ps ...predicate.Build) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BuildMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BuildMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Build, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BuildMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BuildMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Build).
func (m *BuildMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BuildMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.revision != nil {
		fields = append(fields, build.FieldRevision)
	}
	if m.environment_revision != nil {
		fields = append(fields, build.FieldEnvironmentRevision)
	}
	if m.vars != nil {
		fields = append(fields, build.FieldVars)
	}
	if m.completed_plan != nil {
		fields = append(fields, build.FieldCompletedPlan)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BuildMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case build.FieldRevision:
		return m.Revision()
	case build.FieldEnvironmentRevision:
		return m.EnvironmentRevision()
	case build.FieldVars:
		return m.Vars()
	case build.FieldCompletedPlan:
		return m.CompletedPlan()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BuildMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case build.FieldRevision:
		return m.OldRevision(ctx)
	case build.FieldEnvironmentRevision:
		return m.OldEnvironmentRevision(ctx)
	case build.FieldVars:
		return m.OldVars(ctx)
	case build.FieldCompletedPlan:
		return m.OldCompletedPlan(ctx)
	}
	return nil, fmt.Errorf("unknown Build field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuildMutation) SetField(name string, value ent.Value) error {
	switch name {
	case build.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case build.FieldEnvironmentRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvironmentRevision(v)
		return nil
	case build.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	case build.FieldCompletedPlan:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedPlan(v)
		return nil
	}
	return fmt.Errorf("unknown Build field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BuildMutation) AddedFields() []string {
	var fields []string
	if m.addrevision != nil {
		fields = append(fields, build.FieldRevision)
	}
	if m.addenvironment_revision != nil {
		fields = append(fields, build.FieldEnvironmentRevision)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BuildMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case build.FieldRevision:
		return m.AddedRevision()
	case build.FieldEnvironmentRevision:
		return m.AddedEnvironmentRevision()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuildMutation) AddField(name string, value ent.Value) error {
	switch name {
	case build.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevision(v)
		return nil
	case build.FieldEnvironmentRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnvironmentRevision(v)
		return nil
	}
	return fmt.Errorf("unknown Build numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BuildMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BuildMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BuildMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Build nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BuildMutation) ResetField(name string) error {
	switch name {
	case build.FieldRevision:
		m.ResetRevision()
		return nil
	case build.FieldEnvironmentRevision:
		m.ResetEnvironmentRevision()
		return nil
	case build.FieldVars:
		m.ResetVars()
		return nil
	case build.FieldCompletedPlan:
		m.ResetCompletedPlan()
		return nil
	}
	return fmt.Errorf("unknown Build field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BuildMutation) AddedEdges() []string {
	edges := make([]string, 0, 12)
	if m._BuildToStatus != nil {
		edges = append(edges, build.EdgeBuildToStatus)
	}
	if m._BuildToEnvironment != nil {
		edges = append(edges, build.EdgeBuildToEnvironment)
	}
	if m._BuildToCompetition != nil {
		edges = append(edges, build.EdgeBuildToCompetition)
	}
	if m._BuildToLatestBuildCommit != nil {
		edges = append(edges, build.EdgeBuildToLatestBuildCommit)
	}
	if m._BuildToRepoCommit != nil {
		edges = append(edges, build.EdgeBuildToRepoCommit)
	}
	if m._BuildToProvisionedNetwork != nil {
		edges = append(edges, build.EdgeBuildToProvisionedNetwork)
	}
	if m._BuildToTeam != nil {
		edges = append(edges, build.EdgeBuildToTeam)
	}
	if m._BuildToPlan != nil {
		edges = append(edges, build.EdgeBuildToPlan)
	}
	if m._BuildToBuildCommits != nil {
		edges = append(edges, build.EdgeBuildToBuildCommits)
	}
	if m._BuildToAdhocPlans != nil {
		edges = append(edges, build.EdgeBuildToAdhocPlans)
	}
	if m._BuildToAgentStatuses != nil {
		edges = append(edges, build.EdgeBuildToAgentStatuses)
	}
	if m._BuildToServerTasks != nil {
		edges = append(edges, build.EdgeBuildToServerTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BuildMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case build.EdgeBuildToStatus:
		if id := m._BuildToStatus; id != nil {
			return []ent.Value{*id}
		}
	case build.EdgeBuildToEnvironment:
		if id := m._BuildToEnvironment; id != nil {
			return []ent.Value{*id}
		}
	case build.EdgeBuildToCompetition:
		if id := m._BuildToCompetition; id != nil {
			return []ent.Value{*id}
		}
	case build.EdgeBuildToLatestBuildCommit:
		if id := m._BuildToLatestBuildCommit; id != nil {
			return []ent.Value{*id}
		}
	case build.EdgeBuildToRepoCommit:
		if id := m._BuildToRepoCommit; id != nil {
			return []ent.Value{*id}
		}
	case build.EdgeBuildToProvisionedNetwork:
		ids := make([]ent.Value, 0, len(m._BuildToProvisionedNetwork))
		for id := range m._BuildToProvisionedNetwork {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeBuildToTeam:
		ids := make([]ent.Value, 0, len(m._BuildToTeam))
		for id := range m._BuildToTeam {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeBuildToPlan:
		ids := make([]ent.Value, 0, len(m._BuildToPlan))
		for id := range m._BuildToPlan {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeBuildToBuildCommits:
		ids := make([]ent.Value, 0, len(m._BuildToBuildCommits))
		for id := range m._BuildToBuildCommits {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeBuildToAdhocPlans:
		ids := make([]ent.Value, 0, len(m._BuildToAdhocPlans))
		for id := range m._BuildToAdhocPlans {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeBuildToAgentStatuses:
		ids := make([]ent.Value, 0, len(m._BuildToAgentStatuses))
		for id := range m._BuildToAgentStatuses {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeBuildToServerTasks:
		ids := make([]ent.Value, 0, len(m._BuildToServerTasks))
		for id := range m._BuildToServerTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BuildMutation) RemovedEdges() []string {
	edges := make([]string, 0, 12)
	if m.removed_BuildToProvisionedNetwork != nil {
		edges = append(edges, build.EdgeBuildToProvisionedNetwork)
	}
	if m.removed_BuildToTeam != nil {
		edges = append(edges, build.EdgeBuildToTeam)
	}
	if m.removed_BuildToPlan != nil {
		edges = append(edges, build.EdgeBuildToPlan)
	}
	if m.removed_BuildToBuildCommits != nil {
		edges = append(edges, build.EdgeBuildToBuildCommits)
	}
	if m.removed_BuildToAdhocPlans != nil {
		edges = append(edges, build.EdgeBuildToAdhocPlans)
	}
	if m.removed_BuildToAgentStatuses != nil {
		edges = append(edges, build.EdgeBuildToAgentStatuses)
	}
	if m.removed_BuildToServerTasks != nil {
		edges = append(edges, build.EdgeBuildToServerTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BuildMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case build.EdgeBuildToProvisionedNetwork:
		ids := make([]ent.Value, 0, len(m.removed_BuildToProvisionedNetwork))
		for id := range m.removed_BuildToProvisionedNetwork {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeBuildToTeam:
		ids := make([]ent.Value, 0, len(m.removed_BuildToTeam))
		for id := range m.removed_BuildToTeam {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeBuildToPlan:
		ids := make([]ent.Value, 0, len(m.removed_BuildToPlan))
		for id := range m.removed_BuildToPlan {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeBuildToBuildCommits:
		ids := make([]ent.Value, 0, len(m.removed_BuildToBuildCommits))
		for id := range m.removed_BuildToBuildCommits {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeBuildToAdhocPlans:
		ids := make([]ent.Value, 0, len(m.removed_BuildToAdhocPlans))
		for id := range m.removed_BuildToAdhocPlans {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeBuildToAgentStatuses:
		ids := make([]ent.Value, 0, len(m.removed_BuildToAgentStatuses))
		for id := range m.removed_BuildToAgentStatuses {
			ids = append(ids, id)
		}
		return ids
	case build.EdgeBuildToServerTasks:
		ids := make([]ent.Value, 0, len(m.removed_BuildToServerTasks))
		for id := range m.removed_BuildToServerTasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BuildMutation) ClearedEdges() []string {
	edges := make([]string, 0, 12)
	if m.cleared_BuildToStatus {
		edges = append(edges, build.EdgeBuildToStatus)
	}
	if m.cleared_BuildToEnvironment {
		edges = append(edges, build.EdgeBuildToEnvironment)
	}
	if m.cleared_BuildToCompetition {
		edges = append(edges, build.EdgeBuildToCompetition)
	}
	if m.cleared_BuildToLatestBuildCommit {
		edges = append(edges, build.EdgeBuildToLatestBuildCommit)
	}
	if m.cleared_BuildToRepoCommit {
		edges = append(edges, build.EdgeBuildToRepoCommit)
	}
	if m.cleared_BuildToProvisionedNetwork {
		edges = append(edges, build.EdgeBuildToProvisionedNetwork)
	}
	if m.cleared_BuildToTeam {
		edges = append(edges, build.EdgeBuildToTeam)
	}
	if m.cleared_BuildToPlan {
		edges = append(edges, build.EdgeBuildToPlan)
	}
	if m.cleared_BuildToBuildCommits {
		edges = append(edges, build.EdgeBuildToBuildCommits)
	}
	if m.cleared_BuildToAdhocPlans {
		edges = append(edges, build.EdgeBuildToAdhocPlans)
	}
	if m.cleared_BuildToAgentStatuses {
		edges = append(edges, build.EdgeBuildToAgentStatuses)
	}
	if m.cleared_BuildToServerTasks {
		edges = append(edges, build.EdgeBuildToServerTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BuildMutation) EdgeCleared(name string) bool {
	switch name {
	case build.EdgeBuildToStatus:
		return m.cleared_BuildToStatus
	case build.EdgeBuildToEnvironment:
		return m.cleared_BuildToEnvironment
	case build.EdgeBuildToCompetition:
		return m.cleared_BuildToCompetition
	case build.EdgeBuildToLatestBuildCommit:
		return m.cleared_BuildToLatestBuildCommit
	case build.EdgeBuildToRepoCommit:
		return m.cleared_BuildToRepoCommit
	case build.EdgeBuildToProvisionedNetwork:
		return m.cleared_BuildToProvisionedNetwork
	case build.EdgeBuildToTeam:
		return m.cleared_BuildToTeam
	case build.EdgeBuildToPlan:
		return m.cleared_BuildToPlan
	case build.EdgeBuildToBuildCommits:
		return m.cleared_BuildToBuildCommits
	case build.EdgeBuildToAdhocPlans:
		return m.cleared_BuildToAdhocPlans
	case build.EdgeBuildToAgentStatuses:
		return m.cleared_BuildToAgentStatuses
	case build.EdgeBuildToServerTasks:
		return m.cleared_BuildToServerTasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BuildMutation) ClearEdge(name string) error {
	switch name {
	case build.EdgeBuildToStatus:
		m.ClearBuildToStatus()
		return nil
	case build.EdgeBuildToEnvironment:
		m.ClearBuildToEnvironment()
		return nil
	case build.EdgeBuildToCompetition:
		m.ClearBuildToCompetition()
		return nil
	case build.EdgeBuildToLatestBuildCommit:
		m.ClearBuildToLatestBuildCommit()
		return nil
	case build.EdgeBuildToRepoCommit:
		m.ClearBuildToRepoCommit()
		return nil
	}
	return fmt.Errorf("unknown Build unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BuildMutation) ResetEdge(name string) error {
	switch name {
	case build.EdgeBuildToStatus:
		m.ResetBuildToStatus()
		return nil
	case build.EdgeBuildToEnvironment:
		m.ResetBuildToEnvironment()
		return nil
	case build.EdgeBuildToCompetition:
		m.ResetBuildToCompetition()
		return nil
	case build.EdgeBuildToLatestBuildCommit:
		m.ResetBuildToLatestBuildCommit()
		return nil
	case build.EdgeBuildToRepoCommit:
		m.ResetBuildToRepoCommit()
		return nil
	case build.EdgeBuildToProvisionedNetwork:
		m.ResetBuildToProvisionedNetwork()
		return nil
	case build.EdgeBuildToTeam:
		m.ResetBuildToTeam()
		return nil
	case build.EdgeBuildToPlan:
		m.ResetBuildToPlan()
		return nil
	case build.EdgeBuildToBuildCommits:
		m.ResetBuildToBuildCommits()
		return nil
	case build.EdgeBuildToAdhocPlans:
		m.ResetBuildToAdhocPlans()
		return nil
	case build.EdgeBuildToAgentStatuses:
		m.ResetBuildToAgentStatuses()
		return nil
	case build.EdgeBuildToServerTasks:
		m.ResetBuildToServerTasks()
		return nil
	}
	return fmt.Errorf("unknown Build edge %s", name)
}

// BuildCommitMutation represents an operation that mutates the BuildCommit nodes in the graph.
type BuildCommitMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	_type                           *buildcommit.Type
	revision                        *int
	addrevision                     *int
	state                           *buildcommit.State
	created_at                      *time.Time
	clearedFields                   map[string]struct{}
	_BuildCommitToBuild             *uuid.UUID
	cleared_BuildCommitToBuild      bool
	_BuildCommitToServerTask        map[uuid.UUID]struct{}
	removed_BuildCommitToServerTask map[uuid.UUID]struct{}
	cleared_BuildCommitToServerTask bool
	_BuildCommitToPlanDiffs         map[uuid.UUID]struct{}
	removed_BuildCommitToPlanDiffs  map[uuid.UUID]struct{}
	cleared_BuildCommitToPlanDiffs  bool
	done                            bool
	oldValue                        func(context.Context) (*BuildCommit, error)
	predicates                      []predicate.BuildCommit
}

var _ ent.Mutation = (*BuildCommitMutation)(nil)

// buildcommitOption allows management of the mutation configuration using functional options.
type buildcommitOption func(*BuildCommitMutation)

// newBuildCommitMutation creates new mutation for the BuildCommit entity.
func newBuildCommitMutation(c config, op Op, opts ...buildcommitOption) *BuildCommitMutation {
	m := &BuildCommitMutation{
		config:        c,
		op:            op,
		typ:           TypeBuildCommit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBuildCommitID sets the ID field of the mutation.
func withBuildCommitID(id uuid.UUID) buildcommitOption {
	return func(m *BuildCommitMutation) {
		var (
			err   error
			once  sync.Once
			value *BuildCommit
		)
		m.oldValue = func(ctx context.Context) (*BuildCommit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BuildCommit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBuildCommit sets the old BuildCommit of the mutation.
func withBuildCommit(node *BuildCommit) buildcommitOption {
	return func(m *BuildCommitMutation) {
		m.oldValue = func(context.Context) (*BuildCommit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BuildCommitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BuildCommitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BuildCommit entities.
func (m *BuildCommitMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BuildCommitMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BuildCommitMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BuildCommit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *BuildCommitMutation) SetType(b buildcommit.Type) {
	m._type = &b
}

// GetType returns the value of the "type" field in the mutation.
func (m *BuildCommitMutation) GetType() (r buildcommit.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the BuildCommit entity.
// If the BuildCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildCommitMutation) OldType(ctx context.Context) (v buildcommit.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *BuildCommitMutation) ResetType() {
	m._type = nil
}

// SetRevision sets the "revision" field.
func (m *BuildCommitMutation) SetRevision(i int) {
	m.revision = &i
	m.addrevision = nil
}

// Revision returns the value of the "revision" field in the mutation.
func (m *BuildCommitMutation) Revision() (r int, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the BuildCommit entity.
// If the BuildCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildCommitMutation) OldRevision(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// AddRevision adds i to the "revision" field.
func (m *BuildCommitMutation) AddRevision(i int) {
	if m.addrevision != nil {
		*m.addrevision += i
	} else {
		m.addrevision = &i
	}
}

// AddedRevision returns the value that was added to the "revision" field in this mutation.
func (m *BuildCommitMutation) AddedRevision() (r int, exists bool) {
	v := m.addrevision
	if v == nil {
		return
	}
	return *v, true
}

// ResetRevision resets all changes to the "revision" field.
func (m *BuildCommitMutation) ResetRevision() {
	m.revision = nil
	m.addrevision = nil
}

// SetState sets the "state" field.
func (m *BuildCommitMutation) SetState(b buildcommit.State) {
	m.state = &b
}

// State returns the value of the "state" field in the mutation.
func (m *BuildCommitMutation) State() (r buildcommit.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the BuildCommit entity.
// If the BuildCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildCommitMutation) OldState(ctx context.Context) (v buildcommit.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *BuildCommitMutation) ResetState() {
	m.state = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BuildCommitMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BuildCommitMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BuildCommit entity.
// If the BuildCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildCommitMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BuildCommitMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetBuildCommitToBuildID sets the "BuildCommitToBuild" edge to the Build entity by id.
func (m *BuildCommitMutation) SetBuildCommitToBuildID(id uuid.UUID) {
	m._BuildCommitToBuild = &id
}

// ClearBuildCommitToBuild clears the "BuildCommitToBuild" edge to the Build entity.
func (m *BuildCommitMutation) ClearBuildCommitToBuild() {
	m.cleared_BuildCommitToBuild = true
}

// BuildCommitToBuildCleared reports if the "BuildCommitToBuild" edge to the Build entity was cleared.
func (m *BuildCommitMutation) BuildCommitToBuildCleared() bool {
	return m.cleared_BuildCommitToBuild
}

// BuildCommitToBuildID returns the "BuildCommitToBuild" edge ID in the mutation.
func (m *BuildCommitMutation) BuildCommitToBuildID() (id uuid.UUID, exists bool) {
	if m._BuildCommitToBuild != nil {
		return *m._BuildCommitToBuild, true
	}
	return
}

// BuildCommitToBuildIDs returns the "BuildCommitToBuild" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuildCommitToBuildID instead. It exists only for internal usage by the builders.
func (m *BuildCommitMutation) BuildCommitToBuildIDs() (ids []uuid.UUID) {
	if id := m._BuildCommitToBuild; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuildCommitToBuild resets all changes to the "BuildCommitToBuild" edge.
func (m *BuildCommitMutation) ResetBuildCommitToBuild() {
	m._BuildCommitToBuild = nil
	m.cleared_BuildCommitToBuild = false
}

// AddBuildCommitToServerTaskIDs adds the "BuildCommitToServerTask" edge to the ServerTask entity by ids.
func (m *BuildCommitMutation) AddBuildCommitToServerTaskIDs(ids ...uuid.UUID) {
	if m._BuildCommitToServerTask == nil {
		m._BuildCommitToServerTask = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._BuildCommitToServerTask[ids[i]] = struct{}{}
	}
}

// ClearBuildCommitToServerTask clears the "BuildCommitToServerTask" edge to the ServerTask entity.
func (m *BuildCommitMutation) ClearBuildCommitToServerTask() {
	m.cleared_BuildCommitToServerTask = true
}

// BuildCommitToServerTaskCleared reports if the "BuildCommitToServerTask" edge to the ServerTask entity was cleared.
func (m *BuildCommitMutation) BuildCommitToServerTaskCleared() bool {
	return m.cleared_BuildCommitToServerTask
}

// RemoveBuildCommitToServerTaskIDs removes the "BuildCommitToServerTask" edge to the ServerTask entity by IDs.
func (m *BuildCommitMutation) RemoveBuildCommitToServerTaskIDs(ids ...uuid.UUID) {
	if m.removed_BuildCommitToServerTask == nil {
		m.removed_BuildCommitToServerTask = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._BuildCommitToServerTask, ids[i])
		m.removed_BuildCommitToServerTask[ids[i]] = struct{}{}
	}
}

// RemovedBuildCommitToServerTask returns the removed IDs of the "BuildCommitToServerTask" edge to the ServerTask entity.
func (m *BuildCommitMutation) RemovedBuildCommitToServerTaskIDs() (ids []uuid.UUID) {
	for id := range m.removed_BuildCommitToServerTask {
		ids = append(ids, id)
	}
	return
}

// BuildCommitToServerTaskIDs returns the "BuildCommitToServerTask" edge IDs in the mutation.
func (m *BuildCommitMutation) BuildCommitToServerTaskIDs() (ids []uuid.UUID) {
	for id := range m._BuildCommitToServerTask {
		ids = append(ids, id)
	}
	return
}

// ResetBuildCommitToServerTask resets all changes to the "BuildCommitToServerTask" edge.
func (m *BuildCommitMutation) ResetBuildCommitToServerTask() {
	m._BuildCommitToServerTask = nil
	m.cleared_BuildCommitToServerTask = false
	m.removed_BuildCommitToServerTask = nil
}

// AddBuildCommitToPlanDiffIDs adds the "BuildCommitToPlanDiffs" edge to the PlanDiff entity by ids.
func (m *BuildCommitMutation) AddBuildCommitToPlanDiffIDs(ids ...uuid.UUID) {
	if m._BuildCommitToPlanDiffs == nil {
		m._BuildCommitToPlanDiffs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._BuildCommitToPlanDiffs[ids[i]] = struct{}{}
	}
}

// ClearBuildCommitToPlanDiffs clears the "BuildCommitToPlanDiffs" edge to the PlanDiff entity.
func (m *BuildCommitMutation) ClearBuildCommitToPlanDiffs() {
	m.cleared_BuildCommitToPlanDiffs = true
}

// BuildCommitToPlanDiffsCleared reports if the "BuildCommitToPlanDiffs" edge to the PlanDiff entity was cleared.
func (m *BuildCommitMutation) BuildCommitToPlanDiffsCleared() bool {
	return m.cleared_BuildCommitToPlanDiffs
}

// RemoveBuildCommitToPlanDiffIDs removes the "BuildCommitToPlanDiffs" edge to the PlanDiff entity by IDs.
func (m *BuildCommitMutation) RemoveBuildCommitToPlanDiffIDs(ids ...uuid.UUID) {
	if m.removed_BuildCommitToPlanDiffs == nil {
		m.removed_BuildCommitToPlanDiffs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._BuildCommitToPlanDiffs, ids[i])
		m.removed_BuildCommitToPlanDiffs[ids[i]] = struct{}{}
	}
}

// RemovedBuildCommitToPlanDiffs returns the removed IDs of the "BuildCommitToPlanDiffs" edge to the PlanDiff entity.
func (m *BuildCommitMutation) RemovedBuildCommitToPlanDiffsIDs() (ids []uuid.UUID) {
	for id := range m.removed_BuildCommitToPlanDiffs {
		ids = append(ids, id)
	}
	return
}

// BuildCommitToPlanDiffsIDs returns the "BuildCommitToPlanDiffs" edge IDs in the mutation.
func (m *BuildCommitMutation) BuildCommitToPlanDiffsIDs() (ids []uuid.UUID) {
	for id := range m._BuildCommitToPlanDiffs {
		ids = append(ids, id)
	}
	return
}

// ResetBuildCommitToPlanDiffs resets all changes to the "BuildCommitToPlanDiffs" edge.
func (m *BuildCommitMutation) ResetBuildCommitToPlanDiffs() {
	m._BuildCommitToPlanDiffs = nil
	m.cleared_BuildCommitToPlanDiffs = false
	m.removed_BuildCommitToPlanDiffs = nil
}

// Where appends a list predicates to the BuildCommitMutation builder.
func (m *BuildCommitMutation) Where(ps ...predicate.BuildCommit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BuildCommitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BuildCommitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BuildCommit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BuildCommitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BuildCommitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BuildCommit).
func (m *BuildCommitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BuildCommitMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._type != nil {
		fields = append(fields, buildcommit.FieldType)
	}
	if m.revision != nil {
		fields = append(fields, buildcommit.FieldRevision)
	}
	if m.state != nil {
		fields = append(fields, buildcommit.FieldState)
	}
	if m.created_at != nil {
		fields = append(fields, buildcommit.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BuildCommitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case buildcommit.FieldType:
		return m.GetType()
	case buildcommit.FieldRevision:
		return m.Revision()
	case buildcommit.FieldState:
		return m.State()
	case buildcommit.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BuildCommitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case buildcommit.FieldType:
		return m.OldType(ctx)
	case buildcommit.FieldRevision:
		return m.OldRevision(ctx)
	case buildcommit.FieldState:
		return m.OldState(ctx)
	case buildcommit.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BuildCommit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuildCommitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case buildcommit.FieldType:
		v, ok := value.(buildcommit.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case buildcommit.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case buildcommit.FieldState:
		v, ok := value.(buildcommit.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case buildcommit.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BuildCommit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BuildCommitMutation) AddedFields() []string {
	var fields []string
	if m.addrevision != nil {
		fields = append(fields, buildcommit.FieldRevision)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BuildCommitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case buildcommit.FieldRevision:
		return m.AddedRevision()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuildCommitMutation) AddField(name string, value ent.Value) error {
	switch name {
	case buildcommit.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevision(v)
		return nil
	}
	return fmt.Errorf("unknown BuildCommit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BuildCommitMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BuildCommitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BuildCommitMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BuildCommit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BuildCommitMutation) ResetField(name string) error {
	switch name {
	case buildcommit.FieldType:
		m.ResetType()
		return nil
	case buildcommit.FieldRevision:
		m.ResetRevision()
		return nil
	case buildcommit.FieldState:
		m.ResetState()
		return nil
	case buildcommit.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown BuildCommit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BuildCommitMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._BuildCommitToBuild != nil {
		edges = append(edges, buildcommit.EdgeBuildCommitToBuild)
	}
	if m._BuildCommitToServerTask != nil {
		edges = append(edges, buildcommit.EdgeBuildCommitToServerTask)
	}
	if m._BuildCommitToPlanDiffs != nil {
		edges = append(edges, buildcommit.EdgeBuildCommitToPlanDiffs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BuildCommitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case buildcommit.EdgeBuildCommitToBuild:
		if id := m._BuildCommitToBuild; id != nil {
			return []ent.Value{*id}
		}
	case buildcommit.EdgeBuildCommitToServerTask:
		ids := make([]ent.Value, 0, len(m._BuildCommitToServerTask))
		for id := range m._BuildCommitToServerTask {
			ids = append(ids, id)
		}
		return ids
	case buildcommit.EdgeBuildCommitToPlanDiffs:
		ids := make([]ent.Value, 0, len(m._BuildCommitToPlanDiffs))
		for id := range m._BuildCommitToPlanDiffs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BuildCommitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_BuildCommitToServerTask != nil {
		edges = append(edges, buildcommit.EdgeBuildCommitToServerTask)
	}
	if m.removed_BuildCommitToPlanDiffs != nil {
		edges = append(edges, buildcommit.EdgeBuildCommitToPlanDiffs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BuildCommitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case buildcommit.EdgeBuildCommitToServerTask:
		ids := make([]ent.Value, 0, len(m.removed_BuildCommitToServerTask))
		for id := range m.removed_BuildCommitToServerTask {
			ids = append(ids, id)
		}
		return ids
	case buildcommit.EdgeBuildCommitToPlanDiffs:
		ids := make([]ent.Value, 0, len(m.removed_BuildCommitToPlanDiffs))
		for id := range m.removed_BuildCommitToPlanDiffs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BuildCommitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_BuildCommitToBuild {
		edges = append(edges, buildcommit.EdgeBuildCommitToBuild)
	}
	if m.cleared_BuildCommitToServerTask {
		edges = append(edges, buildcommit.EdgeBuildCommitToServerTask)
	}
	if m.cleared_BuildCommitToPlanDiffs {
		edges = append(edges, buildcommit.EdgeBuildCommitToPlanDiffs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BuildCommitMutation) EdgeCleared(name string) bool {
	switch name {
	case buildcommit.EdgeBuildCommitToBuild:
		return m.cleared_BuildCommitToBuild
	case buildcommit.EdgeBuildCommitToServerTask:
		return m.cleared_BuildCommitToServerTask
	case buildcommit.EdgeBuildCommitToPlanDiffs:
		return m.cleared_BuildCommitToPlanDiffs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BuildCommitMutation) ClearEdge(name string) error {
	switch name {
	case buildcommit.EdgeBuildCommitToBuild:
		m.ClearBuildCommitToBuild()
		return nil
	}
	return fmt.Errorf("unknown BuildCommit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BuildCommitMutation) ResetEdge(name string) error {
	switch name {
	case buildcommit.EdgeBuildCommitToBuild:
		m.ResetBuildCommitToBuild()
		return nil
	case buildcommit.EdgeBuildCommitToServerTask:
		m.ResetBuildCommitToServerTask()
		return nil
	case buildcommit.EdgeBuildCommitToPlanDiffs:
		m.ResetBuildCommitToPlanDiffs()
		return nil
	}
	return fmt.Errorf("unknown BuildCommit edge %s", name)
}

// CommandMutation represents an operation that mutates the Command nodes in the graph.
type CommandMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	hcl_id                       *string
	name                         *string
	description                  *string
	program                      *string
	args                         *[]string
	appendargs                   []string
	ignore_errors                *bool
	disabled                     *bool
	cooldown                     *int
	addcooldown                  *int
	timeout                      *int
	addtimeout                   *int
	vars                         *map[string]string
	tags                         *map[string]string
	clearedFields                map[string]struct{}
	_CommandToUser               map[uuid.UUID]struct{}
	removed_CommandToUser        map[uuid.UUID]struct{}
	cleared_CommandToUser        bool
	_CommandToEnvironment        *uuid.UUID
	cleared_CommandToEnvironment bool
	done                         bool
	oldValue                     func(context.Context) (*Command, error)
	predicates                   []predicate.Command
}

var _ ent.Mutation = (*CommandMutation)(nil)

// commandOption allows management of the mutation configuration using functional options.
type commandOption func(*CommandMutation)

// newCommandMutation creates new mutation for the Command entity.
func newCommandMutation(c config, op Op, opts ...commandOption) *CommandMutation {
	m := &CommandMutation{
		config:        c,
		op:            op,
		typ:           TypeCommand,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommandID sets the ID field of the mutation.
func withCommandID(id uuid.UUID) commandOption {
	return func(m *CommandMutation) {
		var (
			err   error
			once  sync.Once
			value *Command
		)
		m.oldValue = func(ctx context.Context) (*Command, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Command.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommand sets the old Command of the mutation.
func withCommand(node *Command) commandOption {
	return func(m *CommandMutation) {
		m.oldValue = func(context.Context) (*Command, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommandMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommandMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Command entities.
func (m *CommandMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommandMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommandMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Command.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHCLID sets the "hcl_id" field.
func (m *CommandMutation) SetHCLID(s string) {
	m.hcl_id = &s
}

// HCLID returns the value of the "hcl_id" field in the mutation.
func (m *CommandMutation) HCLID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHCLID returns the old "hcl_id" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldHCLID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHCLID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHCLID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHCLID: %w", err)
	}
	return oldValue.HCLID, nil
}

// ResetHCLID resets all changes to the "hcl_id" field.
func (m *CommandMutation) ResetHCLID() {
	m.hcl_id = nil
}

// SetName sets the "name" field.
func (m *CommandMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CommandMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CommandMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CommandMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CommandMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CommandMutation) ResetDescription() {
	m.description = nil
}

// SetProgram sets the "program" field.
func (m *CommandMutation) SetProgram(s string) {
	m.program = &s
}

// Program returns the value of the "program" field in the mutation.
func (m *CommandMutation) Program() (r string, exists bool) {
	v := m.program
	if v == nil {
		return
	}
	return *v, true
}

// OldProgram returns the old "program" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldProgram(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgram is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgram requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgram: %w", err)
	}
	return oldValue.Program, nil
}

// ResetProgram resets all changes to the "program" field.
func (m *CommandMutation) ResetProgram() {
	m.program = nil
}

// SetArgs sets the "args" field.
func (m *CommandMutation) SetArgs(s []string) {
	m.args = &s
	m.appendargs = nil
}

// Args returns the value of the "args" field in the mutation.
func (m *CommandMutation) Args() (r []string, exists bool) {
	v := m.args
	if v == nil {
		return
	}
	return *v, true
}

// OldArgs returns the old "args" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldArgs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArgs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArgs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArgs: %w", err)
	}
	return oldValue.Args, nil
}

// AppendArgs adds s to the "args" field.
func (m *CommandMutation) AppendArgs(s []string) {
	m.appendargs = append(m.appendargs, s...)
}

// AppendedArgs returns the list of values that were appended to the "args" field in this mutation.
func (m *CommandMutation) AppendedArgs() ([]string, bool) {
	if len(m.appendargs) == 0 {
		return nil, false
	}
	return m.appendargs, true
}

// ResetArgs resets all changes to the "args" field.
func (m *CommandMutation) ResetArgs() {
	m.args = nil
	m.appendargs = nil
}

// SetIgnoreErrors sets the "ignore_errors" field.
func (m *CommandMutation) SetIgnoreErrors(b bool) {
	m.ignore_errors = &b
}

// IgnoreErrors returns the value of the "ignore_errors" field in the mutation.
func (m *CommandMutation) IgnoreErrors() (r bool, exists bool) {
	v := m.ignore_errors
	if v == nil {
		return
	}
	return *v, true
}

// OldIgnoreErrors returns the old "ignore_errors" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldIgnoreErrors(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIgnoreErrors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIgnoreErrors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIgnoreErrors: %w", err)
	}
	return oldValue.IgnoreErrors, nil
}

// ResetIgnoreErrors resets all changes to the "ignore_errors" field.
func (m *CommandMutation) ResetIgnoreErrors() {
	m.ignore_errors = nil
}

// SetDisabled sets the "disabled" field.
func (m *CommandMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *CommandMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *CommandMutation) ResetDisabled() {
	m.disabled = nil
}

// SetCooldown sets the "cooldown" field.
func (m *CommandMutation) SetCooldown(i int) {
	m.cooldown = &i
	m.addcooldown = nil
}

// Cooldown returns the value of the "cooldown" field in the mutation.
func (m *CommandMutation) Cooldown() (r int, exists bool) {
	v := m.cooldown
	if v == nil {
		return
	}
	return *v, true
}

// OldCooldown returns the old "cooldown" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldCooldown(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCooldown is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCooldown requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCooldown: %w", err)
	}
	return oldValue.Cooldown, nil
}

// AddCooldown adds i to the "cooldown" field.
func (m *CommandMutation) AddCooldown(i int) {
	if m.addcooldown != nil {
		*m.addcooldown += i
	} else {
		m.addcooldown = &i
	}
}

// AddedCooldown returns the value that was added to the "cooldown" field in this mutation.
func (m *CommandMutation) AddedCooldown() (r int, exists bool) {
	v := m.addcooldown
	if v == nil {
		return
	}
	return *v, true
}

// ResetCooldown resets all changes to the "cooldown" field.
func (m *CommandMutation) ResetCooldown() {
	m.cooldown = nil
	m.addcooldown = nil
}

// SetTimeout sets the "timeout" field.
func (m *CommandMutation) SetTimeout(i int) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *CommandMutation) Timeout() (r int, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to the "timeout" field.
func (m *CommandMutation) AddTimeout(i int) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the "timeout" field in this mutation.
func (m *CommandMutation) AddedTimeout() (r int, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *CommandMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
}

// SetVars sets the "vars" field.
func (m *CommandMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *CommandMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *CommandMutation) ResetVars() {
	m.vars = nil
}

// SetTags sets the "tags" field.
func (m *CommandMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *CommandMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Command entity.
// If the Command object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommandMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *CommandMutation) ResetTags() {
	m.tags = nil
}

// AddCommandToUserIDs adds the "CommandToUser" edge to the User entity by ids.
func (m *CommandMutation) AddCommandToUserIDs(ids ...uuid.UUID) {
	if m._CommandToUser == nil {
		m._CommandToUser = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._CommandToUser[ids[i]] = struct{}{}
	}
}

// ClearCommandToUser clears the "CommandToUser" edge to the User entity.
func (m *CommandMutation) ClearCommandToUser() {
	m.cleared_CommandToUser = true
}

// CommandToUserCleared reports if the "CommandToUser" edge to the User entity was cleared.
func (m *CommandMutation) CommandToUserCleared() bool {
	return m.cleared_CommandToUser
}

// RemoveCommandToUserIDs removes the "CommandToUser" edge to the User entity by IDs.
func (m *CommandMutation) RemoveCommandToUserIDs(ids ...uuid.UUID) {
	if m.removed_CommandToUser == nil {
		m.removed_CommandToUser = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._CommandToUser, ids[i])
		m.removed_CommandToUser[ids[i]] = struct{}{}
	}
}

// RemovedCommandToUser returns the removed IDs of the "CommandToUser" edge to the User entity.
func (m *CommandMutation) RemovedCommandToUserIDs() (ids []uuid.UUID) {
	for id := range m.removed_CommandToUser {
		ids = append(ids, id)
	}
	return
}

// CommandToUserIDs returns the "CommandToUser" edge IDs in the mutation.
func (m *CommandMutation) CommandToUserIDs() (ids []uuid.UUID) {
	for id := range m._CommandToUser {
		ids = append(ids, id)
	}
	return
}

// ResetCommandToUser resets all changes to the "CommandToUser" edge.
func (m *CommandMutation) ResetCommandToUser() {
	m._CommandToUser = nil
	m.cleared_CommandToUser = false
	m.removed_CommandToUser = nil
}

// SetCommandToEnvironmentID sets the "CommandToEnvironment" edge to the Environment entity by id.
func (m *CommandMutation) SetCommandToEnvironmentID(id uuid.UUID) {
	m._CommandToEnvironment = &id
}

// ClearCommandToEnvironment clears the "CommandToEnvironment" edge to the Environment entity.
func (m *CommandMutation) ClearCommandToEnvironment() {
	m.cleared_CommandToEnvironment = true
}

// CommandToEnvironmentCleared reports if the "CommandToEnvironment" edge to the Environment entity was cleared.
func (m *CommandMutation) CommandToEnvironmentCleared() bool {
	return m.cleared_CommandToEnvironment
}

// CommandToEnvironmentID returns the "CommandToEnvironment" edge ID in the mutation.
func (m *CommandMutation) CommandToEnvironmentID() (id uuid.UUID, exists bool) {
	if m._CommandToEnvironment != nil {
		return *m._CommandToEnvironment, true
	}
	return
}

// CommandToEnvironmentIDs returns the "CommandToEnvironment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommandToEnvironmentID instead. It exists only for internal usage by the builders.
func (m *CommandMutation) CommandToEnvironmentIDs() (ids []uuid.UUID) {
	if id := m._CommandToEnvironment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCommandToEnvironment resets all changes to the "CommandToEnvironment" edge.
func (m *CommandMutation) ResetCommandToEnvironment() {
	m._CommandToEnvironment = nil
	m.cleared_CommandToEnvironment = false
}

// Where appends a list predicates to the CommandMutation builder.
func (m *CommandMutation) Where(ps ...predicate.Command) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommandMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommandMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Command, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommandMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommandMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Command).
func (m *CommandMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommandMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.hcl_id != nil {
		fields = append(fields, command.FieldHCLID)
	}
	if m.name != nil {
		fields = append(fields, command.FieldName)
	}
	if m.description != nil {
		fields = append(fields, command.FieldDescription)
	}
	if m.program != nil {
		fields = append(fields, command.FieldProgram)
	}
	if m.args != nil {
		fields = append(fields, command.FieldArgs)
	}
	if m.ignore_errors != nil {
		fields = append(fields, command.FieldIgnoreErrors)
	}
	if m.disabled != nil {
		fields = append(fields, command.FieldDisabled)
	}
	if m.cooldown != nil {
		fields = append(fields, command.FieldCooldown)
	}
	if m.timeout != nil {
		fields = append(fields, command.FieldTimeout)
	}
	if m.vars != nil {
		fields = append(fields, command.FieldVars)
	}
	if m.tags != nil {
		fields = append(fields, command.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommandMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case command.FieldHCLID:
		return m.HCLID()
	case command.FieldName:
		return m.Name()
	case command.FieldDescription:
		return m.Description()
	case command.FieldProgram:
		return m.Program()
	case command.FieldArgs:
		return m.Args()
	case command.FieldIgnoreErrors:
		return m.IgnoreErrors()
	case command.FieldDisabled:
		return m.Disabled()
	case command.FieldCooldown:
		return m.Cooldown()
	case command.FieldTimeout:
		return m.Timeout()
	case command.FieldVars:
		return m.Vars()
	case command.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommandMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case command.FieldHCLID:
		return m.OldHCLID(ctx)
	case command.FieldName:
		return m.OldName(ctx)
	case command.FieldDescription:
		return m.OldDescription(ctx)
	case command.FieldProgram:
		return m.OldProgram(ctx)
	case command.FieldArgs:
		return m.OldArgs(ctx)
	case command.FieldIgnoreErrors:
		return m.OldIgnoreErrors(ctx)
	case command.FieldDisabled:
		return m.OldDisabled(ctx)
	case command.FieldCooldown:
		return m.OldCooldown(ctx)
	case command.FieldTimeout:
		return m.OldTimeout(ctx)
	case command.FieldVars:
		return m.OldVars(ctx)
	case command.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Command field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommandMutation) SetField(name string, value ent.Value) error {
	switch name {
	case command.FieldHCLID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHCLID(v)
		return nil
	case command.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case command.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case command.FieldProgram:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgram(v)
		return nil
	case command.FieldArgs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArgs(v)
		return nil
	case command.FieldIgnoreErrors:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIgnoreErrors(v)
		return nil
	case command.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case command.FieldCooldown:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCooldown(v)
		return nil
	case command.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case command.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	case command.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Command field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommandMutation) AddedFields() []string {
	var fields []string
	if m.addcooldown != nil {
		fields = append(fields, command.FieldCooldown)
	}
	if m.addtimeout != nil {
		fields = append(fields, command.FieldTimeout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommandMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case command.FieldCooldown:
		return m.AddedCooldown()
	case command.FieldTimeout:
		return m.AddedTimeout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommandMutation) AddField(name string, value ent.Value) error {
	switch name {
	case command.FieldCooldown:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCooldown(v)
		return nil
	case command.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown Command numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommandMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommandMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommandMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Command nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommandMutation) ResetField(name string) error {
	switch name {
	case command.FieldHCLID:
		m.ResetHCLID()
		return nil
	case command.FieldName:
		m.ResetName()
		return nil
	case command.FieldDescription:
		m.ResetDescription()
		return nil
	case command.FieldProgram:
		m.ResetProgram()
		return nil
	case command.FieldArgs:
		m.ResetArgs()
		return nil
	case command.FieldIgnoreErrors:
		m.ResetIgnoreErrors()
		return nil
	case command.FieldDisabled:
		m.ResetDisabled()
		return nil
	case command.FieldCooldown:
		m.ResetCooldown()
		return nil
	case command.FieldTimeout:
		m.ResetTimeout()
		return nil
	case command.FieldVars:
		m.ResetVars()
		return nil
	case command.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Command field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommandMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._CommandToUser != nil {
		edges = append(edges, command.EdgeCommandToUser)
	}
	if m._CommandToEnvironment != nil {
		edges = append(edges, command.EdgeCommandToEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommandMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case command.EdgeCommandToUser:
		ids := make([]ent.Value, 0, len(m._CommandToUser))
		for id := range m._CommandToUser {
			ids = append(ids, id)
		}
		return ids
	case command.EdgeCommandToEnvironment:
		if id := m._CommandToEnvironment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommandMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_CommandToUser != nil {
		edges = append(edges, command.EdgeCommandToUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommandMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case command.EdgeCommandToUser:
		ids := make([]ent.Value, 0, len(m.removed_CommandToUser))
		for id := range m.removed_CommandToUser {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommandMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_CommandToUser {
		edges = append(edges, command.EdgeCommandToUser)
	}
	if m.cleared_CommandToEnvironment {
		edges = append(edges, command.EdgeCommandToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommandMutation) EdgeCleared(name string) bool {
	switch name {
	case command.EdgeCommandToUser:
		return m.cleared_CommandToUser
	case command.EdgeCommandToEnvironment:
		return m.cleared_CommandToEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommandMutation) ClearEdge(name string) error {
	switch name {
	case command.EdgeCommandToEnvironment:
		m.ClearCommandToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Command unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommandMutation) ResetEdge(name string) error {
	switch name {
	case command.EdgeCommandToUser:
		m.ResetCommandToUser()
		return nil
	case command.EdgeCommandToEnvironment:
		m.ResetCommandToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Command edge %s", name)
}

// CompetitionMutation represents an operation that mutates the Competition nodes in the graph.
type CompetitionMutation struct {
	config
	op                               Op
	typ                              string
	id                               *uuid.UUID
	hcl_id                           *string
	root_password                    *string
	_config                          *map[string]string
	tags                             *map[string]string
	clearedFields                    map[string]struct{}
	_CompetitionToDNS                map[uuid.UUID]struct{}
	removed_CompetitionToDNS         map[uuid.UUID]struct{}
	cleared_CompetitionToDNS         bool
	_CompetitionToEnvironment        *uuid.UUID
	cleared_CompetitionToEnvironment bool
	_CompetitionToBuild              map[uuid.UUID]struct{}
	removed_CompetitionToBuild       map[uuid.UUID]struct{}
	cleared_CompetitionToBuild       bool
	done                             bool
	oldValue                         func(context.Context) (*Competition, error)
	predicates                       []predicate.Competition
}

var _ ent.Mutation = (*CompetitionMutation)(nil)

// competitionOption allows management of the mutation configuration using functional options.
type competitionOption func(*CompetitionMutation)

// newCompetitionMutation creates new mutation for the Competition entity.
func newCompetitionMutation(c config, op Op, opts ...competitionOption) *CompetitionMutation {
	m := &CompetitionMutation{
		config:        c,
		op:            op,
		typ:           TypeCompetition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompetitionID sets the ID field of the mutation.
func withCompetitionID(id uuid.UUID) competitionOption {
	return func(m *CompetitionMutation) {
		var (
			err   error
			once  sync.Once
			value *Competition
		)
		m.oldValue = func(ctx context.Context) (*Competition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Competition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompetition sets the old Competition of the mutation.
func withCompetition(node *Competition) competitionOption {
	return func(m *CompetitionMutation) {
		m.oldValue = func(context.Context) (*Competition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompetitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompetitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Competition entities.
func (m *CompetitionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompetitionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompetitionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Competition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHCLID sets the "hcl_id" field.
func (m *CompetitionMutation) SetHCLID(s string) {
	m.hcl_id = &s
}

// HCLID returns the value of the "hcl_id" field in the mutation.
func (m *CompetitionMutation) HCLID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHCLID returns the old "hcl_id" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldHCLID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHCLID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHCLID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHCLID: %w", err)
	}
	return oldValue.HCLID, nil
}

// ResetHCLID resets all changes to the "hcl_id" field.
func (m *CompetitionMutation) ResetHCLID() {
	m.hcl_id = nil
}

// SetRootPassword sets the "root_password" field.
func (m *CompetitionMutation) SetRootPassword(s string) {
	m.root_password = &s
}

// RootPassword returns the value of the "root_password" field in the mutation.
func (m *CompetitionMutation) RootPassword() (r string, exists bool) {
	v := m.root_password
	if v == nil {
		return
	}
	return *v, true
}

// OldRootPassword returns the old "root_password" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldRootPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRootPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRootPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootPassword: %w", err)
	}
	return oldValue.RootPassword, nil
}

// ResetRootPassword resets all changes to the "root_password" field.
func (m *CompetitionMutation) ResetRootPassword() {
	m.root_password = nil
}

// SetConfig sets the "config" field.
func (m *CompetitionMutation) SetConfig(value map[string]string) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *CompetitionMutation) Config() (r map[string]string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldConfig(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *CompetitionMutation) ResetConfig() {
	m._config = nil
}

// SetTags sets the "tags" field.
func (m *CompetitionMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *CompetitionMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *CompetitionMutation) ResetTags() {
	m.tags = nil
}

// AddCompetitionToDNSIDs adds the "CompetitionToDNS" edge to the DNS entity by ids.
func (m *CompetitionMutation) AddCompetitionToDNSIDs(ids ...uuid.UUID) {
	if m._CompetitionToDNS == nil {
		m._CompetitionToDNS = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._CompetitionToDNS[ids[i]] = struct{}{}
	}
}

// ClearCompetitionToDNS clears the "CompetitionToDNS" edge to the DNS entity.
func (m *CompetitionMutation) ClearCompetitionToDNS() {
	m.cleared_CompetitionToDNS = true
}

// CompetitionToDNSCleared reports if the "CompetitionToDNS" edge to the DNS entity was cleared.
func (m *CompetitionMutation) CompetitionToDNSCleared() bool {
	return m.cleared_CompetitionToDNS
}

// RemoveCompetitionToDNSIDs removes the "CompetitionToDNS" edge to the DNS entity by IDs.
func (m *CompetitionMutation) RemoveCompetitionToDNSIDs(ids ...uuid.UUID) {
	if m.removed_CompetitionToDNS == nil {
		m.removed_CompetitionToDNS = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._CompetitionToDNS, ids[i])
		m.removed_CompetitionToDNS[ids[i]] = struct{}{}
	}
}

// RemovedCompetitionToDNS returns the removed IDs of the "CompetitionToDNS" edge to the DNS entity.
func (m *CompetitionMutation) RemovedCompetitionToDNSIDs() (ids []uuid.UUID) {
	for id := range m.removed_CompetitionToDNS {
		ids = append(ids, id)
	}
	return
}

// CompetitionToDNSIDs returns the "CompetitionToDNS" edge IDs in the mutation.
func (m *CompetitionMutation) CompetitionToDNSIDs() (ids []uuid.UUID) {
	for id := range m._CompetitionToDNS {
		ids = append(ids, id)
	}
	return
}

// ResetCompetitionToDNS resets all changes to the "CompetitionToDNS" edge.
func (m *CompetitionMutation) ResetCompetitionToDNS() {
	m._CompetitionToDNS = nil
	m.cleared_CompetitionToDNS = false
	m.removed_CompetitionToDNS = nil
}

// SetCompetitionToEnvironmentID sets the "CompetitionToEnvironment" edge to the Environment entity by id.
func (m *CompetitionMutation) SetCompetitionToEnvironmentID(id uuid.UUID) {
	m._CompetitionToEnvironment = &id
}

// ClearCompetitionToEnvironment clears the "CompetitionToEnvironment" edge to the Environment entity.
func (m *CompetitionMutation) ClearCompetitionToEnvironment() {
	m.cleared_CompetitionToEnvironment = true
}

// CompetitionToEnvironmentCleared reports if the "CompetitionToEnvironment" edge to the Environment entity was cleared.
func (m *CompetitionMutation) CompetitionToEnvironmentCleared() bool {
	return m.cleared_CompetitionToEnvironment
}

// CompetitionToEnvironmentID returns the "CompetitionToEnvironment" edge ID in the mutation.
func (m *CompetitionMutation) CompetitionToEnvironmentID() (id uuid.UUID, exists bool) {
	if m._CompetitionToEnvironment != nil {
		return *m._CompetitionToEnvironment, true
	}
	return
}

// CompetitionToEnvironmentIDs returns the "CompetitionToEnvironment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompetitionToEnvironmentID instead. It exists only for internal usage by the builders.
func (m *CompetitionMutation) CompetitionToEnvironmentIDs() (ids []uuid.UUID) {
	if id := m._CompetitionToEnvironment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompetitionToEnvironment resets all changes to the "CompetitionToEnvironment" edge.
func (m *CompetitionMutation) ResetCompetitionToEnvironment() {
	m._CompetitionToEnvironment = nil
	m.cleared_CompetitionToEnvironment = false
}

// AddCompetitionToBuildIDs adds the "CompetitionToBuild" edge to the Build entity by ids.
func (m *CompetitionMutation) AddCompetitionToBuildIDs(ids ...uuid.UUID) {
	if m._CompetitionToBuild == nil {
		m._CompetitionToBuild = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._CompetitionToBuild[ids[i]] = struct{}{}
	}
}

// ClearCompetitionToBuild clears the "CompetitionToBuild" edge to the Build entity.
func (m *CompetitionMutation) ClearCompetitionToBuild() {
	m.cleared_CompetitionToBuild = true
}

// CompetitionToBuildCleared reports if the "CompetitionToBuild" edge to the Build entity was cleared.
func (m *CompetitionMutation) CompetitionToBuildCleared() bool {
	return m.cleared_CompetitionToBuild
}

// RemoveCompetitionToBuildIDs removes the "CompetitionToBuild" edge to the Build entity by IDs.
func (m *CompetitionMutation) RemoveCompetitionToBuildIDs(ids ...uuid.UUID) {
	if m.removed_CompetitionToBuild == nil {
		m.removed_CompetitionToBuild = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._CompetitionToBuild, ids[i])
		m.removed_CompetitionToBuild[ids[i]] = struct{}{}
	}
}

// RemovedCompetitionToBuild returns the removed IDs of the "CompetitionToBuild" edge to the Build entity.
func (m *CompetitionMutation) RemovedCompetitionToBuildIDs() (ids []uuid.UUID) {
	for id := range m.removed_CompetitionToBuild {
		ids = append(ids, id)
	}
	return
}

// CompetitionToBuildIDs returns the "CompetitionToBuild" edge IDs in the mutation.
func (m *CompetitionMutation) CompetitionToBuildIDs() (ids []uuid.UUID) {
	for id := range m._CompetitionToBuild {
		ids = append(ids, id)
	}
	return
}

// ResetCompetitionToBuild resets all changes to the "CompetitionToBuild" edge.
func (m *CompetitionMutation) ResetCompetitionToBuild() {
	m._CompetitionToBuild = nil
	m.cleared_CompetitionToBuild = false
	m.removed_CompetitionToBuild = nil
}

// Where appends a list predicates to the CompetitionMutation builder.
func (m *CompetitionMutation) Where(ps ...predicate.Competition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompetitionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompetitionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Competition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompetitionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompetitionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Competition).
func (m *CompetitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompetitionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.hcl_id != nil {
		fields = append(fields, competition.FieldHCLID)
	}
	if m.root_password != nil {
		fields = append(fields, competition.FieldRootPassword)
	}
	if m._config != nil {
		fields = append(fields, competition.FieldConfig)
	}
	if m.tags != nil {
		fields = append(fields, competition.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompetitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case competition.FieldHCLID:
		return m.HCLID()
	case competition.FieldRootPassword:
		return m.RootPassword()
	case competition.FieldConfig:
		return m.Config()
	case competition.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompetitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case competition.FieldHCLID:
		return m.OldHCLID(ctx)
	case competition.FieldRootPassword:
		return m.OldRootPassword(ctx)
	case competition.FieldConfig:
		return m.OldConfig(ctx)
	case competition.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Competition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompetitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case competition.FieldHCLID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHCLID(v)
		return nil
	case competition.FieldRootPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootPassword(v)
		return nil
	case competition.FieldConfig:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case competition.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Competition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompetitionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompetitionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompetitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Competition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompetitionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompetitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompetitionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Competition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompetitionMutation) ResetField(name string) error {
	switch name {
	case competition.FieldHCLID:
		m.ResetHCLID()
		return nil
	case competition.FieldRootPassword:
		m.ResetRootPassword()
		return nil
	case competition.FieldConfig:
		m.ResetConfig()
		return nil
	case competition.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Competition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompetitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._CompetitionToDNS != nil {
		edges = append(edges, competition.EdgeCompetitionToDNS)
	}
	if m._CompetitionToEnvironment != nil {
		edges = append(edges, competition.EdgeCompetitionToEnvironment)
	}
	if m._CompetitionToBuild != nil {
		edges = append(edges, competition.EdgeCompetitionToBuild)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompetitionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case competition.EdgeCompetitionToDNS:
		ids := make([]ent.Value, 0, len(m._CompetitionToDNS))
		for id := range m._CompetitionToDNS {
			ids = append(ids, id)
		}
		return ids
	case competition.EdgeCompetitionToEnvironment:
		if id := m._CompetitionToEnvironment; id != nil {
			return []ent.Value{*id}
		}
	case competition.EdgeCompetitionToBuild:
		ids := make([]ent.Value, 0, len(m._CompetitionToBuild))
		for id := range m._CompetitionToBuild {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompetitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_CompetitionToDNS != nil {
		edges = append(edges, competition.EdgeCompetitionToDNS)
	}
	if m.removed_CompetitionToBuild != nil {
		edges = append(edges, competition.EdgeCompetitionToBuild)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompetitionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case competition.EdgeCompetitionToDNS:
		ids := make([]ent.Value, 0, len(m.removed_CompetitionToDNS))
		for id := range m.removed_CompetitionToDNS {
			ids = append(ids, id)
		}
		return ids
	case competition.EdgeCompetitionToBuild:
		ids := make([]ent.Value, 0, len(m.removed_CompetitionToBuild))
		for id := range m.removed_CompetitionToBuild {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompetitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_CompetitionToDNS {
		edges = append(edges, competition.EdgeCompetitionToDNS)
	}
	if m.cleared_CompetitionToEnvironment {
		edges = append(edges, competition.EdgeCompetitionToEnvironment)
	}
	if m.cleared_CompetitionToBuild {
		edges = append(edges, competition.EdgeCompetitionToBuild)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompetitionMutation) EdgeCleared(name string) bool {
	switch name {
	case competition.EdgeCompetitionToDNS:
		return m.cleared_CompetitionToDNS
	case competition.EdgeCompetitionToEnvironment:
		return m.cleared_CompetitionToEnvironment
	case competition.EdgeCompetitionToBuild:
		return m.cleared_CompetitionToBuild
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompetitionMutation) ClearEdge(name string) error {
	switch name {
	case competition.EdgeCompetitionToEnvironment:
		m.ClearCompetitionToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Competition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompetitionMutation) ResetEdge(name string) error {
	switch name {
	case competition.EdgeCompetitionToDNS:
		m.ResetCompetitionToDNS()
		return nil
	case competition.EdgeCompetitionToEnvironment:
		m.ResetCompetitionToEnvironment()
		return nil
	case competition.EdgeCompetitionToBuild:
		m.ResetCompetitionToBuild()
		return nil
	}
	return fmt.Errorf("unknown Competition edge %s", name)
}

// DNSMutation represents an operation that mutates the DNS nodes in the graph.
type DNSMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	hcl_id                   *string
	_type                    *string
	root_domain              *string
	dns_servers              *[]string
	appenddns_servers        []string
	ntp_servers              *[]string
	appendntp_servers        []string
	_config                  *map[string]string
	clearedFields            map[string]struct{}
	_DNSToEnvironment        map[uuid.UUID]struct{}
	removed_DNSToEnvironment map[uuid.UUID]struct{}
	cleared_DNSToEnvironment bool
	_DNSToCompetition        map[uuid.UUID]struct{}
	removed_DNSToCompetition map[uuid.UUID]struct{}
	cleared_DNSToCompetition bool
	done                     bool
	oldValue                 func(context.Context) (*DNS, error)
	predicates               []predicate.DNS
}

var _ ent.Mutation = (*DNSMutation)(nil)

// dnsOption allows management of the mutation configuration using functional options.
type dnsOption func(*DNSMutation)

// newDNSMutation creates new mutation for the DNS entity.
func newDNSMutation(c config, op Op, opts ...dnsOption) *DNSMutation {
	m := &DNSMutation{
		config:        c,
		op:            op,
		typ:           TypeDNS,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDNSID sets the ID field of the mutation.
func withDNSID(id uuid.UUID) dnsOption {
	return func(m *DNSMutation) {
		var (
			err   error
			once  sync.Once
			value *DNS
		)
		m.oldValue = func(ctx context.Context) (*DNS, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DNS.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDNS sets the old DNS of the mutation.
func withDNS(node *DNS) dnsOption {
	return func(m *DNSMutation) {
		m.oldValue = func(context.Context) (*DNS, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DNSMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DNSMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DNS entities.
func (m *DNSMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DNSMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DNSMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DNS.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHCLID sets the "hcl_id" field.
func (m *DNSMutation) SetHCLID(s string) {
	m.hcl_id = &s
}

// HCLID returns the value of the "hcl_id" field in the mutation.
func (m *DNSMutation) HCLID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHCLID returns the old "hcl_id" field's value of the DNS entity.
// If the DNS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSMutation) OldHCLID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHCLID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHCLID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHCLID: %w", err)
	}
	return oldValue.HCLID, nil
}

// ResetHCLID resets all changes to the "hcl_id" field.
func (m *DNSMutation) ResetHCLID() {
	m.hcl_id = nil
}

// SetType sets the "type" field.
func (m *DNSMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *DNSMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DNS entity.
// If the DNS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DNSMutation) ResetType() {
	m._type = nil
}

// SetRootDomain sets the "root_domain" field.
func (m *DNSMutation) SetRootDomain(s string) {
	m.root_domain = &s
}

// RootDomain returns the value of the "root_domain" field in the mutation.
func (m *DNSMutation) RootDomain() (r string, exists bool) {
	v := m.root_domain
	if v == nil {
		return
	}
	return *v, true
}

// OldRootDomain returns the old "root_domain" field's value of the DNS entity.
// If the DNS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSMutation) OldRootDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRootDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRootDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootDomain: %w", err)
	}
	return oldValue.RootDomain, nil
}

// ResetRootDomain resets all changes to the "root_domain" field.
func (m *DNSMutation) ResetRootDomain() {
	m.root_domain = nil
}

// SetDNSServers sets the "dns_servers" field.
func (m *DNSMutation) SetDNSServers(s []string) {
	m.dns_servers = &s
	m.appenddns_servers = nil
}

// DNSServers returns the value of the "dns_servers" field in the mutation.
func (m *DNSMutation) DNSServers() (r []string, exists bool) {
	v := m.dns_servers
	if v == nil {
		return
	}
	return *v, true
}

// OldDNSServers returns the old "dns_servers" field's value of the DNS entity.
// If the DNS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSMutation) OldDNSServers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDNSServers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDNSServers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDNSServers: %w", err)
	}
	return oldValue.DNSServers, nil
}

// AppendDNSServers adds s to the "dns_servers" field.
func (m *DNSMutation) AppendDNSServers(s []string) {
	m.appenddns_servers = append(m.appenddns_servers, s...)
}

// AppendedDNSServers returns the list of values that were appended to the "dns_servers" field in this mutation.
func (m *DNSMutation) AppendedDNSServers() ([]string, bool) {
	if len(m.appenddns_servers) == 0 {
		return nil, false
	}
	return m.appenddns_servers, true
}

// ResetDNSServers resets all changes to the "dns_servers" field.
func (m *DNSMutation) ResetDNSServers() {
	m.dns_servers = nil
	m.appenddns_servers = nil
}

// SetNtpServers sets the "ntp_servers" field.
func (m *DNSMutation) SetNtpServers(s []string) {
	m.ntp_servers = &s
	m.appendntp_servers = nil
}

// NtpServers returns the value of the "ntp_servers" field in the mutation.
func (m *DNSMutation) NtpServers() (r []string, exists bool) {
	v := m.ntp_servers
	if v == nil {
		return
	}
	return *v, true
}

// OldNtpServers returns the old "ntp_servers" field's value of the DNS entity.
// If the DNS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSMutation) OldNtpServers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNtpServers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNtpServers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNtpServers: %w", err)
	}
	return oldValue.NtpServers, nil
}

// AppendNtpServers adds s to the "ntp_servers" field.
func (m *DNSMutation) AppendNtpServers(s []string) {
	m.appendntp_servers = append(m.appendntp_servers, s...)
}

// AppendedNtpServers returns the list of values that were appended to the "ntp_servers" field in this mutation.
func (m *DNSMutation) AppendedNtpServers() ([]string, bool) {
	if len(m.appendntp_servers) == 0 {
		return nil, false
	}
	return m.appendntp_servers, true
}

// ResetNtpServers resets all changes to the "ntp_servers" field.
func (m *DNSMutation) ResetNtpServers() {
	m.ntp_servers = nil
	m.appendntp_servers = nil
}

// SetConfig sets the "config" field.
func (m *DNSMutation) SetConfig(value map[string]string) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *DNSMutation) Config() (r map[string]string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the DNS entity.
// If the DNS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSMutation) OldConfig(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *DNSMutation) ResetConfig() {
	m._config = nil
}

// AddDNSToEnvironmentIDs adds the "DNSToEnvironment" edge to the Environment entity by ids.
func (m *DNSMutation) AddDNSToEnvironmentIDs(ids ...uuid.UUID) {
	if m._DNSToEnvironment == nil {
		m._DNSToEnvironment = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._DNSToEnvironment[ids[i]] = struct{}{}
	}
}

// ClearDNSToEnvironment clears the "DNSToEnvironment" edge to the Environment entity.
func (m *DNSMutation) ClearDNSToEnvironment() {
	m.cleared_DNSToEnvironment = true
}

// DNSToEnvironmentCleared reports if the "DNSToEnvironment" edge to the Environment entity was cleared.
func (m *DNSMutation) DNSToEnvironmentCleared() bool {
	return m.cleared_DNSToEnvironment
}

// RemoveDNSToEnvironmentIDs removes the "DNSToEnvironment" edge to the Environment entity by IDs.
func (m *DNSMutation) RemoveDNSToEnvironmentIDs(ids ...uuid.UUID) {
	if m.removed_DNSToEnvironment == nil {
		m.removed_DNSToEnvironment = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._DNSToEnvironment, ids[i])
		m.removed_DNSToEnvironment[ids[i]] = struct{}{}
	}
}

// RemovedDNSToEnvironment returns the removed IDs of the "DNSToEnvironment" edge to the Environment entity.
func (m *DNSMutation) RemovedDNSToEnvironmentIDs() (ids []uuid.UUID) {
	for id := range m.removed_DNSToEnvironment {
		ids = append(ids, id)
	}
	return
}

// DNSToEnvironmentIDs returns the "DNSToEnvironment" edge IDs in the mutation.
func (m *DNSMutation) DNSToEnvironmentIDs() (ids []uuid.UUID) {
	for id := range m._DNSToEnvironment {
		ids = append(ids, id)
	}
	return
}

// ResetDNSToEnvironment resets all changes to the "DNSToEnvironment" edge.
func (m *DNSMutation) ResetDNSToEnvironment() {
	m._DNSToEnvironment = nil
	m.cleared_DNSToEnvironment = false
	m.removed_DNSToEnvironment = nil
}

// AddDNSToCompetitionIDs adds the "DNSToCompetition" edge to the Competition entity by ids.
func (m *DNSMutation) AddDNSToCompetitionIDs(ids ...uuid.UUID) {
	if m._DNSToCompetition == nil {
		m._DNSToCompetition = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._DNSToCompetition[ids[i]] = struct{}{}
	}
}

// ClearDNSToCompetition clears the "DNSToCompetition" edge to the Competition entity.
func (m *DNSMutation) ClearDNSToCompetition() {
	m.cleared_DNSToCompetition = true
}

// DNSToCompetitionCleared reports if the "DNSToCompetition" edge to the Competition entity was cleared.
func (m *DNSMutation) DNSToCompetitionCleared() bool {
	return m.cleared_DNSToCompetition
}

// RemoveDNSToCompetitionIDs removes the "DNSToCompetition" edge to the Competition entity by IDs.
func (m *DNSMutation) RemoveDNSToCompetitionIDs(ids ...uuid.UUID) {
	if m.removed_DNSToCompetition == nil {
		m.removed_DNSToCompetition = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._DNSToCompetition, ids[i])
		m.removed_DNSToCompetition[ids[i]] = struct{}{}
	}
}

// RemovedDNSToCompetition returns the removed IDs of the "DNSToCompetition" edge to the Competition entity.
func (m *DNSMutation) RemovedDNSToCompetitionIDs() (ids []uuid.UUID) {
	for id := range m.removed_DNSToCompetition {
		ids = append(ids, id)
	}
	return
}

// DNSToCompetitionIDs returns the "DNSToCompetition" edge IDs in the mutation.
func (m *DNSMutation) DNSToCompetitionIDs() (ids []uuid.UUID) {
	for id := range m._DNSToCompetition {
		ids = append(ids, id)
	}
	return
}

// ResetDNSToCompetition resets all changes to the "DNSToCompetition" edge.
func (m *DNSMutation) ResetDNSToCompetition() {
	m._DNSToCompetition = nil
	m.cleared_DNSToCompetition = false
	m.removed_DNSToCompetition = nil
}

// Where appends a list predicates to the DNSMutation builder.
func (m *DNSMutation) Where(ps ...predicate.DNS) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DNSMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DNSMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DNS, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DNSMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DNSMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DNS).
func (m *DNSMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DNSMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.hcl_id != nil {
		fields = append(fields, dns.FieldHCLID)
	}
	if m._type != nil {
		fields = append(fields, dns.FieldType)
	}
	if m.root_domain != nil {
		fields = append(fields, dns.FieldRootDomain)
	}
	if m.dns_servers != nil {
		fields = append(fields, dns.FieldDNSServers)
	}
	if m.ntp_servers != nil {
		fields = append(fields, dns.FieldNtpServers)
	}
	if m._config != nil {
		fields = append(fields, dns.FieldConfig)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DNSMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dns.FieldHCLID:
		return m.HCLID()
	case dns.FieldType:
		return m.GetType()
	case dns.FieldRootDomain:
		return m.RootDomain()
	case dns.FieldDNSServers:
		return m.DNSServers()
	case dns.FieldNtpServers:
		return m.NtpServers()
	case dns.FieldConfig:
		return m.Config()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DNSMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dns.FieldHCLID:
		return m.OldHCLID(ctx)
	case dns.FieldType:
		return m.OldType(ctx)
	case dns.FieldRootDomain:
		return m.OldRootDomain(ctx)
	case dns.FieldDNSServers:
		return m.OldDNSServers(ctx)
	case dns.FieldNtpServers:
		return m.OldNtpServers(ctx)
	case dns.FieldConfig:
		return m.OldConfig(ctx)
	}
	return nil, fmt.Errorf("unknown DNS field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DNSMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dns.FieldHCLID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHCLID(v)
		return nil
	case dns.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case dns.FieldRootDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootDomain(v)
		return nil
	case dns.FieldDNSServers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDNSServers(v)
		return nil
	case dns.FieldNtpServers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNtpServers(v)
		return nil
	case dns.FieldConfig:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	}
	return fmt.Errorf("unknown DNS field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DNSMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DNSMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DNSMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DNS numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DNSMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DNSMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DNSMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DNS nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DNSMutation) ResetField(name string) error {
	switch name {
	case dns.FieldHCLID:
		m.ResetHCLID()
		return nil
	case dns.FieldType:
		m.ResetType()
		return nil
	case dns.FieldRootDomain:
		m.ResetRootDomain()
		return nil
	case dns.FieldDNSServers:
		m.ResetDNSServers()
		return nil
	case dns.FieldNtpServers:
		m.ResetNtpServers()
		return nil
	case dns.FieldConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown DNS field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DNSMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._DNSToEnvironment != nil {
		edges = append(edges, dns.EdgeDNSToEnvironment)
	}
	if m._DNSToCompetition != nil {
		edges = append(edges, dns.EdgeDNSToCompetition)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DNSMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dns.EdgeDNSToEnvironment:
		ids := make([]ent.Value, 0, len(m._DNSToEnvironment))
		for id := range m._DNSToEnvironment {
			ids = append(ids, id)
		}
		return ids
	case dns.EdgeDNSToCompetition:
		ids := make([]ent.Value, 0, len(m._DNSToCompetition))
		for id := range m._DNSToCompetition {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DNSMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_DNSToEnvironment != nil {
		edges = append(edges, dns.EdgeDNSToEnvironment)
	}
	if m.removed_DNSToCompetition != nil {
		edges = append(edges, dns.EdgeDNSToCompetition)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DNSMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dns.EdgeDNSToEnvironment:
		ids := make([]ent.Value, 0, len(m.removed_DNSToEnvironment))
		for id := range m.removed_DNSToEnvironment {
			ids = append(ids, id)
		}
		return ids
	case dns.EdgeDNSToCompetition:
		ids := make([]ent.Value, 0, len(m.removed_DNSToCompetition))
		for id := range m.removed_DNSToCompetition {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DNSMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_DNSToEnvironment {
		edges = append(edges, dns.EdgeDNSToEnvironment)
	}
	if m.cleared_DNSToCompetition {
		edges = append(edges, dns.EdgeDNSToCompetition)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DNSMutation) EdgeCleared(name string) bool {
	switch name {
	case dns.EdgeDNSToEnvironment:
		return m.cleared_DNSToEnvironment
	case dns.EdgeDNSToCompetition:
		return m.cleared_DNSToCompetition
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DNSMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DNS unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DNSMutation) ResetEdge(name string) error {
	switch name {
	case dns.EdgeDNSToEnvironment:
		m.ResetDNSToEnvironment()
		return nil
	case dns.EdgeDNSToCompetition:
		m.ResetDNSToCompetition()
		return nil
	}
	return fmt.Errorf("unknown DNS edge %s", name)
}

// DNSRecordMutation represents an operation that mutates the DNSRecord nodes in the graph.
type DNSRecordMutation struct {
	config
	op                             Op
	typ                            string
	id                             *uuid.UUID
	hcl_id                         *string
	name                           *string
	values                         *[]string
	appendvalues                   []string
	_type                          *string
	zone                           *string
	vars                           *map[string]string
	disabled                       *bool
	tags                           *map[string]string
	clearedFields                  map[string]struct{}
	_DNSRecordToEnvironment        *uuid.UUID
	cleared_DNSRecordToEnvironment bool
	done                           bool
	oldValue                       func(context.Context) (*DNSRecord, error)
	predicates                     []predicate.DNSRecord
}

var _ ent.Mutation = (*DNSRecordMutation)(nil)

// dnsrecordOption allows management of the mutation configuration using functional options.
type dnsrecordOption func(*DNSRecordMutation)

// newDNSRecordMutation creates new mutation for the DNSRecord entity.
func newDNSRecordMutation(c config, op Op, opts ...dnsrecordOption) *DNSRecordMutation {
	m := &DNSRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeDNSRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDNSRecordID sets the ID field of the mutation.
func withDNSRecordID(id uuid.UUID) dnsrecordOption {
	return func(m *DNSRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *DNSRecord
		)
		m.oldValue = func(ctx context.Context) (*DNSRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DNSRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDNSRecord sets the old DNSRecord of the mutation.
func withDNSRecord(node *DNSRecord) dnsrecordOption {
	return func(m *DNSRecordMutation) {
		m.oldValue = func(context.Context) (*DNSRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DNSRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DNSRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DNSRecord entities.
func (m *DNSRecordMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DNSRecordMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DNSRecordMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DNSRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHCLID sets the "hcl_id" field.
func (m *DNSRecordMutation) SetHCLID(s string) {
	m.hcl_id = &s
}

// HCLID returns the value of the "hcl_id" field in the mutation.
func (m *DNSRecordMutation) HCLID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHCLID returns the old "hcl_id" field's value of the DNSRecord entity.
// If the DNSRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSRecordMutation) OldHCLID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHCLID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHCLID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHCLID: %w", err)
	}
	return oldValue.HCLID, nil
}

// ResetHCLID resets all changes to the "hcl_id" field.
func (m *DNSRecordMutation) ResetHCLID() {
	m.hcl_id = nil
}

// SetName sets the "name" field.
func (m *DNSRecordMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DNSRecordMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DNSRecord entity.
// If the DNSRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSRecordMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DNSRecordMutation) ResetName() {
	m.name = nil
}

// SetValues sets the "values" field.
func (m *DNSRecordMutation) SetValues(s []string) {
	m.values = &s
	m.appendvalues = nil
}

// Values returns the value of the "values" field in the mutation.
func (m *DNSRecordMutation) Values() (r []string, exists bool) {
	v := m.values
	if v == nil {
		return
	}
	return *v, true
}

// OldValues returns the old "values" field's value of the DNSRecord entity.
// If the DNSRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSRecordMutation) OldValues(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValues: %w", err)
	}
	return oldValue.Values, nil
}

// AppendValues adds s to the "values" field.
func (m *DNSRecordMutation) AppendValues(s []string) {
	m.appendvalues = append(m.appendvalues, s...)
}

// AppendedValues returns the list of values that were appended to the "values" field in this mutation.
func (m *DNSRecordMutation) AppendedValues() ([]string, bool) {
	if len(m.appendvalues) == 0 {
		return nil, false
	}
	return m.appendvalues, true
}

// ResetValues resets all changes to the "values" field.
func (m *DNSRecordMutation) ResetValues() {
	m.values = nil
	m.appendvalues = nil
}

// SetType sets the "type" field.
func (m *DNSRecordMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *DNSRecordMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DNSRecord entity.
// If the DNSRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSRecordMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DNSRecordMutation) ResetType() {
	m._type = nil
}

// SetZone sets the "zone" field.
func (m *DNSRecordMutation) SetZone(s string) {
	m.zone = &s
}

// Zone returns the value of the "zone" field in the mutation.
func (m *DNSRecordMutation) Zone() (r string, exists bool) {
	v := m.zone
	if v == nil {
		return
	}
	return *v, true
}

// OldZone returns the old "zone" field's value of the DNSRecord entity.
// If the DNSRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSRecordMutation) OldZone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZone: %w", err)
	}
	return oldValue.Zone, nil
}

// ResetZone resets all changes to the "zone" field.
func (m *DNSRecordMutation) ResetZone() {
	m.zone = nil
}

// SetVars sets the "vars" field.
func (m *DNSRecordMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *DNSRecordMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the DNSRecord entity.
// If the DNSRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSRecordMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *DNSRecordMutation) ResetVars() {
	m.vars = nil
}

// SetDisabled sets the "disabled" field.
func (m *DNSRecordMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *DNSRecordMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the DNSRecord entity.
// If the DNSRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSRecordMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *DNSRecordMutation) ResetDisabled() {
	m.disabled = nil
}

// SetTags sets the "tags" field.
func (m *DNSRecordMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *DNSRecordMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the DNSRecord entity.
// If the DNSRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DNSRecordMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *DNSRecordMutation) ResetTags() {
	m.tags = nil
}

// SetDNSRecordToEnvironmentID sets the "DNSRecordToEnvironment" edge to the Environment entity by id.
func (m *DNSRecordMutation) SetDNSRecordToEnvironmentID(id uuid.UUID) {
	m._DNSRecordToEnvironment = &id
}

// ClearDNSRecordToEnvironment clears the "DNSRecordToEnvironment" edge to the Environment entity.
func (m *DNSRecordMutation) ClearDNSRecordToEnvironment() {
	m.cleared_DNSRecordToEnvironment = true
}

// DNSRecordToEnvironmentCleared reports if the "DNSRecordToEnvironment" edge to the Environment entity was cleared.
func (m *DNSRecordMutation) DNSRecordToEnvironmentCleared() bool {
	return m.cleared_DNSRecordToEnvironment
}

// DNSRecordToEnvironmentID returns the "DNSRecordToEnvironment" edge ID in the mutation.
func (m *DNSRecordMutation) DNSRecordToEnvironmentID() (id uuid.UUID, exists bool) {
	if m._DNSRecordToEnvironment != nil {
		return *m._DNSRecordToEnvironment, true
	}
	return
}

// DNSRecordToEnvironmentIDs returns the "DNSRecordToEnvironment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DNSRecordToEnvironmentID instead. It exists only for internal usage by the builders.
func (m *DNSRecordMutation) DNSRecordToEnvironmentIDs() (ids []uuid.UUID) {
	if id := m._DNSRecordToEnvironment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDNSRecordToEnvironment resets all changes to the "DNSRecordToEnvironment" edge.
func (m *DNSRecordMutation) ResetDNSRecordToEnvironment() {
	m._DNSRecordToEnvironment = nil
	m.cleared_DNSRecordToEnvironment = false
}

// Where appends a list predicates to the DNSRecordMutation builder.
func (m *DNSRecordMutation) Where(ps ...predicate.DNSRecord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DNSRecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DNSRecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DNSRecord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DNSRecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DNSRecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DNSRecord).
func (m *DNSRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DNSRecordMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.hcl_id != nil {
		fields = append(fields, dnsrecord.FieldHCLID)
	}
	if m.name != nil {
		fields = append(fields, dnsrecord.FieldName)
	}
	if m.values != nil {
		fields = append(fields, dnsrecord.FieldValues)
	}
	if m._type != nil {
		fields = append(fields, dnsrecord.FieldType)
	}
	if m.zone != nil {
		fields = append(fields, dnsrecord.FieldZone)
	}
	if m.vars != nil {
		fields = append(fields, dnsrecord.FieldVars)
	}
	if m.disabled != nil {
		fields = append(fields, dnsrecord.FieldDisabled)
	}
	if m.tags != nil {
		fields = append(fields, dnsrecord.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DNSRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dnsrecord.FieldHCLID:
		return m.HCLID()
	case dnsrecord.FieldName:
		return m.Name()
	case dnsrecord.FieldValues:
		return m.Values()
	case dnsrecord.FieldType:
		return m.GetType()
	case dnsrecord.FieldZone:
		return m.Zone()
	case dnsrecord.FieldVars:
		return m.Vars()
	case dnsrecord.FieldDisabled:
		return m.Disabled()
	case dnsrecord.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DNSRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dnsrecord.FieldHCLID:
		return m.OldHCLID(ctx)
	case dnsrecord.FieldName:
		return m.OldName(ctx)
	case dnsrecord.FieldValues:
		return m.OldValues(ctx)
	case dnsrecord.FieldType:
		return m.OldType(ctx)
	case dnsrecord.FieldZone:
		return m.OldZone(ctx)
	case dnsrecord.FieldVars:
		return m.OldVars(ctx)
	case dnsrecord.FieldDisabled:
		return m.OldDisabled(ctx)
	case dnsrecord.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown DNSRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DNSRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dnsrecord.FieldHCLID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHCLID(v)
		return nil
	case dnsrecord.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dnsrecord.FieldValues:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValues(v)
		return nil
	case dnsrecord.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case dnsrecord.FieldZone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZone(v)
		return nil
	case dnsrecord.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	case dnsrecord.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case dnsrecord.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown DNSRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DNSRecordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DNSRecordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DNSRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DNSRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DNSRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DNSRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DNSRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DNSRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DNSRecordMutation) ResetField(name string) error {
	switch name {
	case dnsrecord.FieldHCLID:
		m.ResetHCLID()
		return nil
	case dnsrecord.FieldName:
		m.ResetName()
		return nil
	case dnsrecord.FieldValues:
		m.ResetValues()
		return nil
	case dnsrecord.FieldType:
		m.ResetType()
		return nil
	case dnsrecord.FieldZone:
		m.ResetZone()
		return nil
	case dnsrecord.FieldVars:
		m.ResetVars()
		return nil
	case dnsrecord.FieldDisabled:
		m.ResetDisabled()
		return nil
	case dnsrecord.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown DNSRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DNSRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._DNSRecordToEnvironment != nil {
		edges = append(edges, dnsrecord.EdgeDNSRecordToEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DNSRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dnsrecord.EdgeDNSRecordToEnvironment:
		if id := m._DNSRecordToEnvironment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DNSRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DNSRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DNSRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_DNSRecordToEnvironment {
		edges = append(edges, dnsrecord.EdgeDNSRecordToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DNSRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case dnsrecord.EdgeDNSRecordToEnvironment:
		return m.cleared_DNSRecordToEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DNSRecordMutation) ClearEdge(name string) error {
	switch name {
	case dnsrecord.EdgeDNSRecordToEnvironment:
		m.ClearDNSRecordToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown DNSRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DNSRecordMutation) ResetEdge(name string) error {
	switch name {
	case dnsrecord.EdgeDNSRecordToEnvironment:
		m.ResetDNSRecordToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown DNSRecord edge %s", name)
}

// DiskMutation represents an operation that mutates the Disk nodes in the graph.
type DiskMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	size               *int
	addsize            *int
	clearedFields      map[string]struct{}
	_DiskToHost        *uuid.UUID
	cleared_DiskToHost bool
	done               bool
	oldValue           func(context.Context) (*Disk, error)
	predicates         []predicate.Disk
}

var _ ent.Mutation = (*DiskMutation)(nil)

// diskOption allows management of the mutation configuration using functional options.
type diskOption func(*DiskMutation)

// newDiskMutation creates new mutation for the Disk entity.
func newDiskMutation(c config, op Op, opts ...diskOption) *DiskMutation {
	m := &DiskMutation{
		config:        c,
		op:            op,
		typ:           TypeDisk,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiskID sets the ID field of the mutation.
func withDiskID(id uuid.UUID) diskOption {
	return func(m *DiskMutation) {
		var (
			err   error
			once  sync.Once
			value *Disk
		)
		m.oldValue = func(ctx context.Context) (*Disk, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Disk.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDisk sets the old Disk of the mutation.
func withDisk(node *Disk) diskOption {
	return func(m *DiskMutation) {
		m.oldValue = func(context.Context) (*Disk, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Disk entities.
func (m *DiskMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DiskMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DiskMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Disk.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSize sets the "size" field.
func (m *DiskMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *DiskMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Disk entity.
// If the Disk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiskMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *DiskMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *DiskMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *DiskMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetDiskToHostID sets the "DiskToHost" edge to the Host entity by id.
func (m *DiskMutation) SetDiskToHostID(id uuid.UUID) {
	m._DiskToHost = &id
}

// ClearDiskToHost clears the "DiskToHost" edge to the Host entity.
func (m *DiskMutation) ClearDiskToHost() {
	m.cleared_DiskToHost = true
}

// DiskToHostCleared reports if the "DiskToHost" edge to the Host entity was cleared.
func (m *DiskMutation) DiskToHostCleared() bool {
	return m.cleared_DiskToHost
}

// DiskToHostID returns the "DiskToHost" edge ID in the mutation.
func (m *DiskMutation) DiskToHostID() (id uuid.UUID, exists bool) {
	if m._DiskToHost != nil {
		return *m._DiskToHost, true
	}
	return
}

// DiskToHostIDs returns the "DiskToHost" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DiskToHostID instead. It exists only for internal usage by the builders.
func (m *DiskMutation) DiskToHostIDs() (ids []uuid.UUID) {
	if id := m._DiskToHost; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDiskToHost resets all changes to the "DiskToHost" edge.
func (m *DiskMutation) ResetDiskToHost() {
	m._DiskToHost = nil
	m.cleared_DiskToHost = false
}

// Where appends a list predicates to the DiskMutation builder.
func (m *DiskMutation) Where(ps ...predicate.Disk) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DiskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DiskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Disk, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DiskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DiskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Disk).
func (m *DiskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DiskMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.size != nil {
		fields = append(fields, disk.FieldSize)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DiskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case disk.FieldSize:
		return m.Size()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DiskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case disk.FieldSize:
		return m.OldSize(ctx)
	}
	return nil, fmt.Errorf("unknown Disk field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case disk.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	}
	return fmt.Errorf("unknown Disk field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DiskMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, disk.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DiskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case disk.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case disk.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown Disk numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DiskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DiskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Disk nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DiskMutation) ResetField(name string) error {
	switch name {
	case disk.FieldSize:
		m.ResetSize()
		return nil
	}
	return fmt.Errorf("unknown Disk field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DiskMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._DiskToHost != nil {
		edges = append(edges, disk.EdgeDiskToHost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DiskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case disk.EdgeDiskToHost:
		if id := m._DiskToHost; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DiskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DiskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DiskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_DiskToHost {
		edges = append(edges, disk.EdgeDiskToHost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DiskMutation) EdgeCleared(name string) bool {
	switch name {
	case disk.EdgeDiskToHost:
		return m.cleared_DiskToHost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DiskMutation) ClearEdge(name string) error {
	switch name {
	case disk.EdgeDiskToHost:
		m.ClearDiskToHost()
		return nil
	}
	return fmt.Errorf("unknown Disk unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DiskMutation) ResetEdge(name string) error {
	switch name {
	case disk.EdgeDiskToHost:
		m.ResetDiskToHost()
		return nil
	}
	return fmt.Errorf("unknown Disk edge %s", name)
}

// EnvironmentMutation represents an operation that mutates the Environment nodes in the graph.
type EnvironmentMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *uuid.UUID
	hcl_id                               *string
	competition_id                       *string
	name                                 *string
	description                          *string
	builder                              *string
	team_count                           *int
	addteam_count                        *int
	revision                             *int
	addrevision                          *int
	admin_cidrs                          *[]string
	appendadmin_cidrs                    []string
	exposed_vdi_ports                    *[]string
	appendexposed_vdi_ports              []string
	_config                              *map[string]string
	tags                                 *map[string]string
	clearedFields                        map[string]struct{}
	_EnvironmentToUser                   map[uuid.UUID]struct{}
	removed_EnvironmentToUser            map[uuid.UUID]struct{}
	cleared_EnvironmentToUser            bool
	_EnvironmentToHost                   map[uuid.UUID]struct{}
	removed_EnvironmentToHost            map[uuid.UUID]struct{}
	cleared_EnvironmentToHost            bool
	_EnvironmentToCompetition            map[uuid.UUID]struct{}
	removed_EnvironmentToCompetition     map[uuid.UUID]struct{}
	cleared_EnvironmentToCompetition     bool
	_EnvironmentToIdentity               map[uuid.UUID]struct{}
	removed_EnvironmentToIdentity        map[uuid.UUID]struct{}
	cleared_EnvironmentToIdentity        bool
	_EnvironmentToCommand                map[uuid.UUID]struct{}
	removed_EnvironmentToCommand         map[uuid.UUID]struct{}
	cleared_EnvironmentToCommand         bool
	_EnvironmentToScript                 map[uuid.UUID]struct{}
	removed_EnvironmentToScript          map[uuid.UUID]struct{}
	cleared_EnvironmentToScript          bool
	_EnvironmentToFileDownload           map[uuid.UUID]struct{}
	removed_EnvironmentToFileDownload    map[uuid.UUID]struct{}
	cleared_EnvironmentToFileDownload    bool
	_EnvironmentToFileDelete             map[uuid.UUID]struct{}
	removed_EnvironmentToFileDelete      map[uuid.UUID]struct{}
	cleared_EnvironmentToFileDelete      bool
	_EnvironmentToFileExtract            map[uuid.UUID]struct{}
	removed_EnvironmentToFileExtract     map[uuid.UUID]struct{}
	cleared_EnvironmentToFileExtract     bool
	_EnvironmentToIncludedNetwork        map[uuid.UUID]struct{}
	removed_EnvironmentToIncludedNetwork map[uuid.UUID]struct{}
	cleared_EnvironmentToIncludedNetwork bool
	_EnvironmentToFinding                map[uuid.UUID]struct{}
	removed_EnvironmentToFinding         map[uuid.UUID]struct{}
	cleared_EnvironmentToFinding         bool
	_EnvironmentToDNSRecord              map[uuid.UUID]struct{}
	removed_EnvironmentToDNSRecord       map[uuid.UUID]struct{}
	cleared_EnvironmentToDNSRecord       bool
	_EnvironmentToDNS                    map[uuid.UUID]struct{}
	removed_EnvironmentToDNS             map[uuid.UUID]struct{}
	cleared_EnvironmentToDNS             bool
	_EnvironmentToNetwork                map[uuid.UUID]struct{}
	removed_EnvironmentToNetwork         map[uuid.UUID]struct{}
	cleared_EnvironmentToNetwork         bool
	_EnvironmentToHostDependency         map[uuid.UUID]struct{}
	removed_EnvironmentToHostDependency  map[uuid.UUID]struct{}
	cleared_EnvironmentToHostDependency  bool
	_EnvironmentToAnsible                map[uuid.UUID]struct{}
	removed_EnvironmentToAnsible         map[uuid.UUID]struct{}
	cleared_EnvironmentToAnsible         bool
	_EnvironmentToBuild                  map[uuid.UUID]struct{}
	removed_EnvironmentToBuild           map[uuid.UUID]struct{}
	cleared_EnvironmentToBuild           bool
	_EnvironmentToRepository             map[uuid.UUID]struct{}
	removed_EnvironmentToRepository      map[uuid.UUID]struct{}
	cleared_EnvironmentToRepository      bool
	_EnvironmentToServerTask             map[uuid.UUID]struct{}
	removed_EnvironmentToServerTask      map[uuid.UUID]struct{}
	cleared_EnvironmentToServerTask      bool
	done                                 bool
	oldValue                             func(context.Context) (*Environment, error)
	predicates                           []predicate.Environment
}

var _ ent.Mutation = (*EnvironmentMutation)(nil)

// environmentOption allows management of the mutation configuration using functional options.
type environmentOption func(*EnvironmentMutation)

// newEnvironmentMutation creates new mutation for the Environment entity.
func newEnvironmentMutation(c config, op Op, opts ...environmentOption) *EnvironmentMutation {
	m := &EnvironmentMutation{
		config:        c,
		op:            op,
		typ:           TypeEnvironment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnvironmentID sets the ID field of the mutation.
func withEnvironmentID(id uuid.UUID) environmentOption {
	return func(m *EnvironmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Environment
		)
		m.oldValue = func(ctx context.Context) (*Environment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Environment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnvironment sets the old Environment of the mutation.
func withEnvironment(node *Environment) environmentOption {
	return func(m *EnvironmentMutation) {
		m.oldValue = func(context.Context) (*Environment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnvironmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnvironmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Environment entities.
func (m *EnvironmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnvironmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnvironmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Environment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHCLID sets the "hcl_id" field.
func (m *EnvironmentMutation) SetHCLID(s string) {
	m.hcl_id = &s
}

// HCLID returns the value of the "hcl_id" field in the mutation.
func (m *EnvironmentMutation) HCLID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHCLID returns the old "hcl_id" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldHCLID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHCLID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHCLID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHCLID: %w", err)
	}
	return oldValue.HCLID, nil
}

// ResetHCLID resets all changes to the "hcl_id" field.
func (m *EnvironmentMutation) ResetHCLID() {
	m.hcl_id = nil
}

// SetCompetitionID sets the "competition_id" field.
func (m *EnvironmentMutation) SetCompetitionID(s string) {
	m.competition_id = &s
}

// CompetitionID returns the value of the "competition_id" field in the mutation.
func (m *EnvironmentMutation) CompetitionID() (r string, exists bool) {
	v := m.competition_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompetitionID returns the old "competition_id" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldCompetitionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompetitionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompetitionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompetitionID: %w", err)
	}
	return oldValue.CompetitionID, nil
}

// ResetCompetitionID resets all changes to the "competition_id" field.
func (m *EnvironmentMutation) ResetCompetitionID() {
	m.competition_id = nil
}

// SetName sets the "name" field.
func (m *EnvironmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EnvironmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EnvironmentMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *EnvironmentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EnvironmentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *EnvironmentMutation) ResetDescription() {
	m.description = nil
}

// SetBuilder sets the "builder" field.
func (m *EnvironmentMutation) SetBuilder(s string) {
	m.builder = &s
}

// Builder returns the value of the "builder" field in the mutation.
func (m *EnvironmentMutation) Builder() (r string, exists bool) {
	v := m.builder
	if v == nil {
		return
	}
	return *v, true
}

// OldBuilder returns the old "builder" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldBuilder(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuilder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuilder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuilder: %w", err)
	}
	return oldValue.Builder, nil
}

// ResetBuilder resets all changes to the "builder" field.
func (m *EnvironmentMutation) ResetBuilder() {
	m.builder = nil
}

// SetTeamCount sets the "team_count" field.
func (m *EnvironmentMutation) SetTeamCount(i int) {
	m.team_count = &i
	m.addteam_count = nil
}

// TeamCount returns the value of the "team_count" field in the mutation.
func (m *EnvironmentMutation) TeamCount() (r int, exists bool) {
	v := m.team_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamCount returns the old "team_count" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldTeamCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamCount: %w", err)
	}
	return oldValue.TeamCount, nil
}

// AddTeamCount adds i to the "team_count" field.
func (m *EnvironmentMutation) AddTeamCount(i int) {
	if m.addteam_count != nil {
		*m.addteam_count += i
	} else {
		m.addteam_count = &i
	}
}

// AddedTeamCount returns the value that was added to the "team_count" field in this mutation.
func (m *EnvironmentMutation) AddedTeamCount() (r int, exists bool) {
	v := m.addteam_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetTeamCount resets all changes to the "team_count" field.
func (m *EnvironmentMutation) ResetTeamCount() {
	m.team_count = nil
	m.addteam_count = nil
}

// SetRevision sets the "revision" field.
func (m *EnvironmentMutation) SetRevision(i int) {
	m.revision = &i
	m.addrevision = nil
}

// Revision returns the value of the "revision" field in the mutation.
func (m *EnvironmentMutation) Revision() (r int, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldRevision(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// AddRevision adds i to the "revision" field.
func (m *EnvironmentMutation) AddRevision(i int) {
	if m.addrevision != nil {
		*m.addrevision += i
	} else {
		m.addrevision = &i
	}
}

// AddedRevision returns the value that was added to the "revision" field in this mutation.
func (m *EnvironmentMutation) AddedRevision() (r int, exists bool) {
	v := m.addrevision
	if v == nil {
		return
	}
	return *v, true
}

// ResetRevision resets all changes to the "revision" field.
func (m *EnvironmentMutation) ResetRevision() {
	m.revision = nil
	m.addrevision = nil
}

// SetAdminCidrs sets the "admin_cidrs" field.
func (m *EnvironmentMutation) SetAdminCidrs(s []string) {
	m.admin_cidrs = &s
	m.appendadmin_cidrs = nil
}

// AdminCidrs returns the value of the "admin_cidrs" field in the mutation.
func (m *EnvironmentMutation) AdminCidrs() (r []string, exists bool) {
	v := m.admin_cidrs
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminCidrs returns the old "admin_cidrs" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldAdminCidrs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdminCidrs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdminCidrs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminCidrs: %w", err)
	}
	return oldValue.AdminCidrs, nil
}

// AppendAdminCidrs adds s to the "admin_cidrs" field.
func (m *EnvironmentMutation) AppendAdminCidrs(s []string) {
	m.appendadmin_cidrs = append(m.appendadmin_cidrs, s...)
}

// AppendedAdminCidrs returns the list of values that were appended to the "admin_cidrs" field in this mutation.
func (m *EnvironmentMutation) AppendedAdminCidrs() ([]string, bool) {
	if len(m.appendadmin_cidrs) == 0 {
		return nil, false
	}
	return m.appendadmin_cidrs, true
}

// ResetAdminCidrs resets all changes to the "admin_cidrs" field.
func (m *EnvironmentMutation) ResetAdminCidrs() {
	m.admin_cidrs = nil
	m.appendadmin_cidrs = nil
}

// SetExposedVdiPorts sets the "exposed_vdi_ports" field.
func (m *EnvironmentMutation) SetExposedVdiPorts(s []string) {
	m.exposed_vdi_ports = &s
	m.appendexposed_vdi_ports = nil
}

// ExposedVdiPorts returns the value of the "exposed_vdi_ports" field in the mutation.
func (m *EnvironmentMutation) ExposedVdiPorts() (r []string, exists bool) {
	v := m.exposed_vdi_ports
	if v == nil {
		return
	}
	return *v, true
}

// OldExposedVdiPorts returns the old "exposed_vdi_ports" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldExposedVdiPorts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExposedVdiPorts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExposedVdiPorts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExposedVdiPorts: %w", err)
	}
	return oldValue.ExposedVdiPorts, nil
}

// AppendExposedVdiPorts adds s to the "exposed_vdi_ports" field.
func (m *EnvironmentMutation) AppendExposedVdiPorts(s []string) {
	m.appendexposed_vdi_ports = append(m.appendexposed_vdi_ports, s...)
}

// AppendedExposedVdiPorts returns the list of values that were appended to the "exposed_vdi_ports" field in this mutation.
func (m *EnvironmentMutation) AppendedExposedVdiPorts() ([]string, bool) {
	if len(m.appendexposed_vdi_ports) == 0 {
		return nil, false
	}
	return m.appendexposed_vdi_ports, true
}

// ResetExposedVdiPorts resets all changes to the "exposed_vdi_ports" field.
func (m *EnvironmentMutation) ResetExposedVdiPorts() {
	m.exposed_vdi_ports = nil
	m.appendexposed_vdi_ports = nil
}

// SetConfig sets the "config" field.
func (m *EnvironmentMutation) SetConfig(value map[string]string) {
	m._config = &value
}

// Config returns the value of the "config" field in the mutation.
func (m *EnvironmentMutation) Config() (r map[string]string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldConfig(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *EnvironmentMutation) ResetConfig() {
	m._config = nil
}

// SetTags sets the "tags" field.
func (m *EnvironmentMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *EnvironmentMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Environment entity.
// If the Environment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnvironmentMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *EnvironmentMutation) ResetTags() {
	m.tags = nil
}

// AddEnvironmentToUserIDs adds the "EnvironmentToUser" edge to the User entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToUserIDs(ids ...uuid.UUID) {
	if m._EnvironmentToUser == nil {
		m._EnvironmentToUser = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._EnvironmentToUser[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToUser clears the "EnvironmentToUser" edge to the User entity.
func (m *EnvironmentMutation) ClearEnvironmentToUser() {
	m.cleared_EnvironmentToUser = true
}

// EnvironmentToUserCleared reports if the "EnvironmentToUser" edge to the User entity was cleared.
func (m *EnvironmentMutation) EnvironmentToUserCleared() bool {
	return m.cleared_EnvironmentToUser
}

// RemoveEnvironmentToUserIDs removes the "EnvironmentToUser" edge to the User entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToUserIDs(ids ...uuid.UUID) {
	if m.removed_EnvironmentToUser == nil {
		m.removed_EnvironmentToUser = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._EnvironmentToUser, ids[i])
		m.removed_EnvironmentToUser[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToUser returns the removed IDs of the "EnvironmentToUser" edge to the User entity.
func (m *EnvironmentMutation) RemovedEnvironmentToUserIDs() (ids []uuid.UUID) {
	for id := range m.removed_EnvironmentToUser {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToUserIDs returns the "EnvironmentToUser" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToUserIDs() (ids []uuid.UUID) {
	for id := range m._EnvironmentToUser {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToUser resets all changes to the "EnvironmentToUser" edge.
func (m *EnvironmentMutation) ResetEnvironmentToUser() {
	m._EnvironmentToUser = nil
	m.cleared_EnvironmentToUser = false
	m.removed_EnvironmentToUser = nil
}

// AddEnvironmentToHostIDs adds the "EnvironmentToHost" edge to the Host entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToHostIDs(ids ...uuid.UUID) {
	if m._EnvironmentToHost == nil {
		m._EnvironmentToHost = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._EnvironmentToHost[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToHost clears the "EnvironmentToHost" edge to the Host entity.
func (m *EnvironmentMutation) ClearEnvironmentToHost() {
	m.cleared_EnvironmentToHost = true
}

// EnvironmentToHostCleared reports if the "EnvironmentToHost" edge to the Host entity was cleared.
func (m *EnvironmentMutation) EnvironmentToHostCleared() bool {
	return m.cleared_EnvironmentToHost
}

// RemoveEnvironmentToHostIDs removes the "EnvironmentToHost" edge to the Host entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToHostIDs(ids ...uuid.UUID) {
	if m.removed_EnvironmentToHost == nil {
		m.removed_EnvironmentToHost = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._EnvironmentToHost, ids[i])
		m.removed_EnvironmentToHost[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToHost returns the removed IDs of the "EnvironmentToHost" edge to the Host entity.
func (m *EnvironmentMutation) RemovedEnvironmentToHostIDs() (ids []uuid.UUID) {
	for id := range m.removed_EnvironmentToHost {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToHostIDs returns the "EnvironmentToHost" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToHostIDs() (ids []uuid.UUID) {
	for id := range m._EnvironmentToHost {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToHost resets all changes to the "EnvironmentToHost" edge.
func (m *EnvironmentMutation) ResetEnvironmentToHost() {
	m._EnvironmentToHost = nil
	m.cleared_EnvironmentToHost = false
	m.removed_EnvironmentToHost = nil
}

// AddEnvironmentToCompetitionIDs adds the "EnvironmentToCompetition" edge to the Competition entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToCompetitionIDs(ids ...uuid.UUID) {
	if m._EnvironmentToCompetition == nil {
		m._EnvironmentToCompetition = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._EnvironmentToCompetition[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToCompetition clears the "EnvironmentToCompetition" edge to the Competition entity.
func (m *EnvironmentMutation) ClearEnvironmentToCompetition() {
	m.cleared_EnvironmentToCompetition = true
}

// EnvironmentToCompetitionCleared reports if the "EnvironmentToCompetition" edge to the Competition entity was cleared.
func (m *EnvironmentMutation) EnvironmentToCompetitionCleared() bool {
	return m.cleared_EnvironmentToCompetition
}

// RemoveEnvironmentToCompetitionIDs removes the "EnvironmentToCompetition" edge to the Competition entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToCompetitionIDs(ids ...uuid.UUID) {
	if m.removed_EnvironmentToCompetition == nil {
		m.removed_EnvironmentToCompetition = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._EnvironmentToCompetition, ids[i])
		m.removed_EnvironmentToCompetition[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToCompetition returns the removed IDs of the "EnvironmentToCompetition" edge to the Competition entity.
func (m *EnvironmentMutation) RemovedEnvironmentToCompetitionIDs() (ids []uuid.UUID) {
	for id := range m.removed_EnvironmentToCompetition {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToCompetitionIDs returns the "EnvironmentToCompetition" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToCompetitionIDs() (ids []uuid.UUID) {
	for id := range m._EnvironmentToCompetition {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToCompetition resets all changes to the "EnvironmentToCompetition" edge.
func (m *EnvironmentMutation) ResetEnvironmentToCompetition() {
	m._EnvironmentToCompetition = nil
	m.cleared_EnvironmentToCompetition = false
	m.removed_EnvironmentToCompetition = nil
}

// AddEnvironmentToIdentityIDs adds the "EnvironmentToIdentity" edge to the Identity entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToIdentityIDs(ids ...uuid.UUID) {
	if m._EnvironmentToIdentity == nil {
		m._EnvironmentToIdentity = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._EnvironmentToIdentity[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToIdentity clears the "EnvironmentToIdentity" edge to the Identity entity.
func (m *EnvironmentMutation) ClearEnvironmentToIdentity() {
	m.cleared_EnvironmentToIdentity = true
}

// EnvironmentToIdentityCleared reports if the "EnvironmentToIdentity" edge to the Identity entity was cleared.
func (m *EnvironmentMutation) EnvironmentToIdentityCleared() bool {
	return m.cleared_EnvironmentToIdentity
}

// RemoveEnvironmentToIdentityIDs removes the "EnvironmentToIdentity" edge to the Identity entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToIdentityIDs(ids ...uuid.UUID) {
	if m.removed_EnvironmentToIdentity == nil {
		m.removed_EnvironmentToIdentity = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._EnvironmentToIdentity, ids[i])
		m.removed_EnvironmentToIdentity[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToIdentity returns the removed IDs of the "EnvironmentToIdentity" edge to the Identity entity.
func (m *EnvironmentMutation) RemovedEnvironmentToIdentityIDs() (ids []uuid.UUID) {
	for id := range m.removed_EnvironmentToIdentity {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToIdentityIDs returns the "EnvironmentToIdentity" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToIdentityIDs() (ids []uuid.UUID) {
	for id := range m._EnvironmentToIdentity {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToIdentity resets all changes to the "EnvironmentToIdentity" edge.
func (m *EnvironmentMutation) ResetEnvironmentToIdentity() {
	m._EnvironmentToIdentity = nil
	m.cleared_EnvironmentToIdentity = false
	m.removed_EnvironmentToIdentity = nil
}

// AddEnvironmentToCommandIDs adds the "EnvironmentToCommand" edge to the Command entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToCommandIDs(ids ...uuid.UUID) {
	if m._EnvironmentToCommand == nil {
		m._EnvironmentToCommand = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._EnvironmentToCommand[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToCommand clears the "EnvironmentToCommand" edge to the Command entity.
func (m *EnvironmentMutation) ClearEnvironmentToCommand() {
	m.cleared_EnvironmentToCommand = true
}

// EnvironmentToCommandCleared reports if the "EnvironmentToCommand" edge to the Command entity was cleared.
func (m *EnvironmentMutation) EnvironmentToCommandCleared() bool {
	return m.cleared_EnvironmentToCommand
}

// RemoveEnvironmentToCommandIDs removes the "EnvironmentToCommand" edge to the Command entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToCommandIDs(ids ...uuid.UUID) {
	if m.removed_EnvironmentToCommand == nil {
		m.removed_EnvironmentToCommand = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._EnvironmentToCommand, ids[i])
		m.removed_EnvironmentToCommand[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToCommand returns the removed IDs of the "EnvironmentToCommand" edge to the Command entity.
func (m *EnvironmentMutation) RemovedEnvironmentToCommandIDs() (ids []uuid.UUID) {
	for id := range m.removed_EnvironmentToCommand {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToCommandIDs returns the "EnvironmentToCommand" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToCommandIDs() (ids []uuid.UUID) {
	for id := range m._EnvironmentToCommand {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToCommand resets all changes to the "EnvironmentToCommand" edge.
func (m *EnvironmentMutation) ResetEnvironmentToCommand() {
	m._EnvironmentToCommand = nil
	m.cleared_EnvironmentToCommand = false
	m.removed_EnvironmentToCommand = nil
}

// AddEnvironmentToScriptIDs adds the "EnvironmentToScript" edge to the Script entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToScriptIDs(ids ...uuid.UUID) {
	if m._EnvironmentToScript == nil {
		m._EnvironmentToScript = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._EnvironmentToScript[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToScript clears the "EnvironmentToScript" edge to the Script entity.
func (m *EnvironmentMutation) ClearEnvironmentToScript() {
	m.cleared_EnvironmentToScript = true
}

// EnvironmentToScriptCleared reports if the "EnvironmentToScript" edge to the Script entity was cleared.
func (m *EnvironmentMutation) EnvironmentToScriptCleared() bool {
	return m.cleared_EnvironmentToScript
}

// RemoveEnvironmentToScriptIDs removes the "EnvironmentToScript" edge to the Script entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToScriptIDs(ids ...uuid.UUID) {
	if m.removed_EnvironmentToScript == nil {
		m.removed_EnvironmentToScript = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._EnvironmentToScript, ids[i])
		m.removed_EnvironmentToScript[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToScript returns the removed IDs of the "EnvironmentToScript" edge to the Script entity.
func (m *EnvironmentMutation) RemovedEnvironmentToScriptIDs() (ids []uuid.UUID) {
	for id := range m.removed_EnvironmentToScript {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToScriptIDs returns the "EnvironmentToScript" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToScriptIDs() (ids []uuid.UUID) {
	for id := range m._EnvironmentToScript {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToScript resets all changes to the "EnvironmentToScript" edge.
func (m *EnvironmentMutation) ResetEnvironmentToScript() {
	m._EnvironmentToScript = nil
	m.cleared_EnvironmentToScript = false
	m.removed_EnvironmentToScript = nil
}

// AddEnvironmentToFileDownloadIDs adds the "EnvironmentToFileDownload" edge to the FileDownload entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToFileDownloadIDs(ids ...uuid.UUID) {
	if m._EnvironmentToFileDownload == nil {
		m._EnvironmentToFileDownload = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._EnvironmentToFileDownload[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToFileDownload clears the "EnvironmentToFileDownload" edge to the FileDownload entity.
func (m *EnvironmentMutation) ClearEnvironmentToFileDownload() {
	m.cleared_EnvironmentToFileDownload = true
}

// EnvironmentToFileDownloadCleared reports if the "EnvironmentToFileDownload" edge to the FileDownload entity was cleared.
func (m *EnvironmentMutation) EnvironmentToFileDownloadCleared() bool {
	return m.cleared_EnvironmentToFileDownload
}

// RemoveEnvironmentToFileDownloadIDs removes the "EnvironmentToFileDownload" edge to the FileDownload entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToFileDownloadIDs(ids ...uuid.UUID) {
	if m.removed_EnvironmentToFileDownload == nil {
		m.removed_EnvironmentToFileDownload = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._EnvironmentToFileDownload, ids[i])
		m.removed_EnvironmentToFileDownload[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToFileDownload returns the removed IDs of the "EnvironmentToFileDownload" edge to the FileDownload entity.
func (m *EnvironmentMutation) RemovedEnvironmentToFileDownloadIDs() (ids []uuid.UUID) {
	for id := range m.removed_EnvironmentToFileDownload {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToFileDownloadIDs returns the "EnvironmentToFileDownload" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToFileDownloadIDs() (ids []uuid.UUID) {
	for id := range m._EnvironmentToFileDownload {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToFileDownload resets all changes to the "EnvironmentToFileDownload" edge.
func (m *EnvironmentMutation) ResetEnvironmentToFileDownload() {
	m._EnvironmentToFileDownload = nil
	m.cleared_EnvironmentToFileDownload = false
	m.removed_EnvironmentToFileDownload = nil
}

// AddEnvironmentToFileDeleteIDs adds the "EnvironmentToFileDelete" edge to the FileDelete entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToFileDeleteIDs(ids ...uuid.UUID) {
	if m._EnvironmentToFileDelete == nil {
		m._EnvironmentToFileDelete = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._EnvironmentToFileDelete[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToFileDelete clears the "EnvironmentToFileDelete" edge to the FileDelete entity.
func (m *EnvironmentMutation) ClearEnvironmentToFileDelete() {
	m.cleared_EnvironmentToFileDelete = true
}

// EnvironmentToFileDeleteCleared reports if the "EnvironmentToFileDelete" edge to the FileDelete entity was cleared.
func (m *EnvironmentMutation) EnvironmentToFileDeleteCleared() bool {
	return m.cleared_EnvironmentToFileDelete
}

// RemoveEnvironmentToFileDeleteIDs removes the "EnvironmentToFileDelete" edge to the FileDelete entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToFileDeleteIDs(ids ...uuid.UUID) {
	if m.removed_EnvironmentToFileDelete == nil {
		m.removed_EnvironmentToFileDelete = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._EnvironmentToFileDelete, ids[i])
		m.removed_EnvironmentToFileDelete[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToFileDelete returns the removed IDs of the "EnvironmentToFileDelete" edge to the FileDelete entity.
func (m *EnvironmentMutation) RemovedEnvironmentToFileDeleteIDs() (ids []uuid.UUID) {
	for id := range m.removed_EnvironmentToFileDelete {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToFileDeleteIDs returns the "EnvironmentToFileDelete" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToFileDeleteIDs() (ids []uuid.UUID) {
	for id := range m._EnvironmentToFileDelete {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToFileDelete resets all changes to the "EnvironmentToFileDelete" edge.
func (m *EnvironmentMutation) ResetEnvironmentToFileDelete() {
	m._EnvironmentToFileDelete = nil
	m.cleared_EnvironmentToFileDelete = false
	m.removed_EnvironmentToFileDelete = nil
}

// AddEnvironmentToFileExtractIDs adds the "EnvironmentToFileExtract" edge to the FileExtract entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToFileExtractIDs(ids ...uuid.UUID) {
	if m._EnvironmentToFileExtract == nil {
		m._EnvironmentToFileExtract = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._EnvironmentToFileExtract[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToFileExtract clears the "EnvironmentToFileExtract" edge to the FileExtract entity.
func (m *EnvironmentMutation) ClearEnvironmentToFileExtract() {
	m.cleared_EnvironmentToFileExtract = true
}

// EnvironmentToFileExtractCleared reports if the "EnvironmentToFileExtract" edge to the FileExtract entity was cleared.
func (m *EnvironmentMutation) EnvironmentToFileExtractCleared() bool {
	return m.cleared_EnvironmentToFileExtract
}

// RemoveEnvironmentToFileExtractIDs removes the "EnvironmentToFileExtract" edge to the FileExtract entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToFileExtractIDs(ids ...uuid.UUID) {
	if m.removed_EnvironmentToFileExtract == nil {
		m.removed_EnvironmentToFileExtract = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._EnvironmentToFileExtract, ids[i])
		m.removed_EnvironmentToFileExtract[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToFileExtract returns the removed IDs of the "EnvironmentToFileExtract" edge to the FileExtract entity.
func (m *EnvironmentMutation) RemovedEnvironmentToFileExtractIDs() (ids []uuid.UUID) {
	for id := range m.removed_EnvironmentToFileExtract {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToFileExtractIDs returns the "EnvironmentToFileExtract" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToFileExtractIDs() (ids []uuid.UUID) {
	for id := range m._EnvironmentToFileExtract {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToFileExtract resets all changes to the "EnvironmentToFileExtract" edge.
func (m *EnvironmentMutation) ResetEnvironmentToFileExtract() {
	m._EnvironmentToFileExtract = nil
	m.cleared_EnvironmentToFileExtract = false
	m.removed_EnvironmentToFileExtract = nil
}

// AddEnvironmentToIncludedNetworkIDs adds the "EnvironmentToIncludedNetwork" edge to the IncludedNetwork entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToIncludedNetworkIDs(ids ...uuid.UUID) {
	if m._EnvironmentToIncludedNetwork == nil {
		m._EnvironmentToIncludedNetwork = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._EnvironmentToIncludedNetwork[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToIncludedNetwork clears the "EnvironmentToIncludedNetwork" edge to the IncludedNetwork entity.
func (m *EnvironmentMutation) ClearEnvironmentToIncludedNetwork() {
	m.cleared_EnvironmentToIncludedNetwork = true
}

// EnvironmentToIncludedNetworkCleared reports if the "EnvironmentToIncludedNetwork" edge to the IncludedNetwork entity was cleared.
func (m *EnvironmentMutation) EnvironmentToIncludedNetworkCleared() bool {
	return m.cleared_EnvironmentToIncludedNetwork
}

// RemoveEnvironmentToIncludedNetworkIDs removes the "EnvironmentToIncludedNetwork" edge to the IncludedNetwork entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToIncludedNetworkIDs(ids ...uuid.UUID) {
	if m.removed_EnvironmentToIncludedNetwork == nil {
		m.removed_EnvironmentToIncludedNetwork = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._EnvironmentToIncludedNetwork, ids[i])
		m.removed_EnvironmentToIncludedNetwork[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToIncludedNetwork returns the removed IDs of the "EnvironmentToIncludedNetwork" edge to the IncludedNetwork entity.
func (m *EnvironmentMutation) RemovedEnvironmentToIncludedNetworkIDs() (ids []uuid.UUID) {
	for id := range m.removed_EnvironmentToIncludedNetwork {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToIncludedNetworkIDs returns the "EnvironmentToIncludedNetwork" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToIncludedNetworkIDs() (ids []uuid.UUID) {
	for id := range m._EnvironmentToIncludedNetwork {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToIncludedNetwork resets all changes to the "EnvironmentToIncludedNetwork" edge.
func (m *EnvironmentMutation) ResetEnvironmentToIncludedNetwork() {
	m._EnvironmentToIncludedNetwork = nil
	m.cleared_EnvironmentToIncludedNetwork = false
	m.removed_EnvironmentToIncludedNetwork = nil
}

// AddEnvironmentToFindingIDs adds the "EnvironmentToFinding" edge to the Finding entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToFindingIDs(ids ...uuid.UUID) {
	if m._EnvironmentToFinding == nil {
		m._EnvironmentToFinding = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._EnvironmentToFinding[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToFinding clears the "EnvironmentToFinding" edge to the Finding entity.
func (m *EnvironmentMutation) ClearEnvironmentToFinding() {
	m.cleared_EnvironmentToFinding = true
}

// EnvironmentToFindingCleared reports if the "EnvironmentToFinding" edge to the Finding entity was cleared.
func (m *EnvironmentMutation) EnvironmentToFindingCleared() bool {
	return m.cleared_EnvironmentToFinding
}

// RemoveEnvironmentToFindingIDs removes the "EnvironmentToFinding" edge to the Finding entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToFindingIDs(ids ...uuid.UUID) {
	if m.removed_EnvironmentToFinding == nil {
		m.removed_EnvironmentToFinding = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._EnvironmentToFinding, ids[i])
		m.removed_EnvironmentToFinding[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToFinding returns the removed IDs of the "EnvironmentToFinding" edge to the Finding entity.
func (m *EnvironmentMutation) RemovedEnvironmentToFindingIDs() (ids []uuid.UUID) {
	for id := range m.removed_EnvironmentToFinding {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToFindingIDs returns the "EnvironmentToFinding" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToFindingIDs() (ids []uuid.UUID) {
	for id := range m._EnvironmentToFinding {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToFinding resets all changes to the "EnvironmentToFinding" edge.
func (m *EnvironmentMutation) ResetEnvironmentToFinding() {
	m._EnvironmentToFinding = nil
	m.cleared_EnvironmentToFinding = false
	m.removed_EnvironmentToFinding = nil
}

// AddEnvironmentToDNSRecordIDs adds the "EnvironmentToDNSRecord" edge to the DNSRecord entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToDNSRecordIDs(ids ...uuid.UUID) {
	if m._EnvironmentToDNSRecord == nil {
		m._EnvironmentToDNSRecord = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._EnvironmentToDNSRecord[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToDNSRecord clears the "EnvironmentToDNSRecord" edge to the DNSRecord entity.
func (m *EnvironmentMutation) ClearEnvironmentToDNSRecord() {
	m.cleared_EnvironmentToDNSRecord = true
}

// EnvironmentToDNSRecordCleared reports if the "EnvironmentToDNSRecord" edge to the DNSRecord entity was cleared.
func (m *EnvironmentMutation) EnvironmentToDNSRecordCleared() bool {
	return m.cleared_EnvironmentToDNSRecord
}

// RemoveEnvironmentToDNSRecordIDs removes the "EnvironmentToDNSRecord" edge to the DNSRecord entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToDNSRecordIDs(ids ...uuid.UUID) {
	if m.removed_EnvironmentToDNSRecord == nil {
		m.removed_EnvironmentToDNSRecord = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._EnvironmentToDNSRecord, ids[i])
		m.removed_EnvironmentToDNSRecord[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToDNSRecord returns the removed IDs of the "EnvironmentToDNSRecord" edge to the DNSRecord entity.
func (m *EnvironmentMutation) RemovedEnvironmentToDNSRecordIDs() (ids []uuid.UUID) {
	for id := range m.removed_EnvironmentToDNSRecord {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToDNSRecordIDs returns the "EnvironmentToDNSRecord" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToDNSRecordIDs() (ids []uuid.UUID) {
	for id := range m._EnvironmentToDNSRecord {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToDNSRecord resets all changes to the "EnvironmentToDNSRecord" edge.
func (m *EnvironmentMutation) ResetEnvironmentToDNSRecord() {
	m._EnvironmentToDNSRecord = nil
	m.cleared_EnvironmentToDNSRecord = false
	m.removed_EnvironmentToDNSRecord = nil
}

// AddEnvironmentToDNSIDs adds the "EnvironmentToDNS" edge to the DNS entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToDNSIDs(ids ...uuid.UUID) {
	if m._EnvironmentToDNS == nil {
		m._EnvironmentToDNS = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._EnvironmentToDNS[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToDNS clears the "EnvironmentToDNS" edge to the DNS entity.
func (m *EnvironmentMutation) ClearEnvironmentToDNS() {
	m.cleared_EnvironmentToDNS = true
}

// EnvironmentToDNSCleared reports if the "EnvironmentToDNS" edge to the DNS entity was cleared.
func (m *EnvironmentMutation) EnvironmentToDNSCleared() bool {
	return m.cleared_EnvironmentToDNS
}

// RemoveEnvironmentToDNSIDs removes the "EnvironmentToDNS" edge to the DNS entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToDNSIDs(ids ...uuid.UUID) {
	if m.removed_EnvironmentToDNS == nil {
		m.removed_EnvironmentToDNS = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._EnvironmentToDNS, ids[i])
		m.removed_EnvironmentToDNS[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToDNS returns the removed IDs of the "EnvironmentToDNS" edge to the DNS entity.
func (m *EnvironmentMutation) RemovedEnvironmentToDNSIDs() (ids []uuid.UUID) {
	for id := range m.removed_EnvironmentToDNS {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToDNSIDs returns the "EnvironmentToDNS" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToDNSIDs() (ids []uuid.UUID) {
	for id := range m._EnvironmentToDNS {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToDNS resets all changes to the "EnvironmentToDNS" edge.
func (m *EnvironmentMutation) ResetEnvironmentToDNS() {
	m._EnvironmentToDNS = nil
	m.cleared_EnvironmentToDNS = false
	m.removed_EnvironmentToDNS = nil
}

// AddEnvironmentToNetworkIDs adds the "EnvironmentToNetwork" edge to the Network entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToNetworkIDs(ids ...uuid.UUID) {
	if m._EnvironmentToNetwork == nil {
		m._EnvironmentToNetwork = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._EnvironmentToNetwork[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToNetwork clears the "EnvironmentToNetwork" edge to the Network entity.
func (m *EnvironmentMutation) ClearEnvironmentToNetwork() {
	m.cleared_EnvironmentToNetwork = true
}

// EnvironmentToNetworkCleared reports if the "EnvironmentToNetwork" edge to the Network entity was cleared.
func (m *EnvironmentMutation) EnvironmentToNetworkCleared() bool {
	return m.cleared_EnvironmentToNetwork
}

// RemoveEnvironmentToNetworkIDs removes the "EnvironmentToNetwork" edge to the Network entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToNetworkIDs(ids ...uuid.UUID) {
	if m.removed_EnvironmentToNetwork == nil {
		m.removed_EnvironmentToNetwork = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._EnvironmentToNetwork, ids[i])
		m.removed_EnvironmentToNetwork[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToNetwork returns the removed IDs of the "EnvironmentToNetwork" edge to the Network entity.
func (m *EnvironmentMutation) RemovedEnvironmentToNetworkIDs() (ids []uuid.UUID) {
	for id := range m.removed_EnvironmentToNetwork {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToNetworkIDs returns the "EnvironmentToNetwork" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToNetworkIDs() (ids []uuid.UUID) {
	for id := range m._EnvironmentToNetwork {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToNetwork resets all changes to the "EnvironmentToNetwork" edge.
func (m *EnvironmentMutation) ResetEnvironmentToNetwork() {
	m._EnvironmentToNetwork = nil
	m.cleared_EnvironmentToNetwork = false
	m.removed_EnvironmentToNetwork = nil
}

// AddEnvironmentToHostDependencyIDs adds the "EnvironmentToHostDependency" edge to the HostDependency entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToHostDependencyIDs(ids ...uuid.UUID) {
	if m._EnvironmentToHostDependency == nil {
		m._EnvironmentToHostDependency = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._EnvironmentToHostDependency[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToHostDependency clears the "EnvironmentToHostDependency" edge to the HostDependency entity.
func (m *EnvironmentMutation) ClearEnvironmentToHostDependency() {
	m.cleared_EnvironmentToHostDependency = true
}

// EnvironmentToHostDependencyCleared reports if the "EnvironmentToHostDependency" edge to the HostDependency entity was cleared.
func (m *EnvironmentMutation) EnvironmentToHostDependencyCleared() bool {
	return m.cleared_EnvironmentToHostDependency
}

// RemoveEnvironmentToHostDependencyIDs removes the "EnvironmentToHostDependency" edge to the HostDependency entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToHostDependencyIDs(ids ...uuid.UUID) {
	if m.removed_EnvironmentToHostDependency == nil {
		m.removed_EnvironmentToHostDependency = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._EnvironmentToHostDependency, ids[i])
		m.removed_EnvironmentToHostDependency[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToHostDependency returns the removed IDs of the "EnvironmentToHostDependency" edge to the HostDependency entity.
func (m *EnvironmentMutation) RemovedEnvironmentToHostDependencyIDs() (ids []uuid.UUID) {
	for id := range m.removed_EnvironmentToHostDependency {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToHostDependencyIDs returns the "EnvironmentToHostDependency" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToHostDependencyIDs() (ids []uuid.UUID) {
	for id := range m._EnvironmentToHostDependency {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToHostDependency resets all changes to the "EnvironmentToHostDependency" edge.
func (m *EnvironmentMutation) ResetEnvironmentToHostDependency() {
	m._EnvironmentToHostDependency = nil
	m.cleared_EnvironmentToHostDependency = false
	m.removed_EnvironmentToHostDependency = nil
}

// AddEnvironmentToAnsibleIDs adds the "EnvironmentToAnsible" edge to the Ansible entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToAnsibleIDs(ids ...uuid.UUID) {
	if m._EnvironmentToAnsible == nil {
		m._EnvironmentToAnsible = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._EnvironmentToAnsible[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToAnsible clears the "EnvironmentToAnsible" edge to the Ansible entity.
func (m *EnvironmentMutation) ClearEnvironmentToAnsible() {
	m.cleared_EnvironmentToAnsible = true
}

// EnvironmentToAnsibleCleared reports if the "EnvironmentToAnsible" edge to the Ansible entity was cleared.
func (m *EnvironmentMutation) EnvironmentToAnsibleCleared() bool {
	return m.cleared_EnvironmentToAnsible
}

// RemoveEnvironmentToAnsibleIDs removes the "EnvironmentToAnsible" edge to the Ansible entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToAnsibleIDs(ids ...uuid.UUID) {
	if m.removed_EnvironmentToAnsible == nil {
		m.removed_EnvironmentToAnsible = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._EnvironmentToAnsible, ids[i])
		m.removed_EnvironmentToAnsible[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToAnsible returns the removed IDs of the "EnvironmentToAnsible" edge to the Ansible entity.
func (m *EnvironmentMutation) RemovedEnvironmentToAnsibleIDs() (ids []uuid.UUID) {
	for id := range m.removed_EnvironmentToAnsible {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToAnsibleIDs returns the "EnvironmentToAnsible" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToAnsibleIDs() (ids []uuid.UUID) {
	for id := range m._EnvironmentToAnsible {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToAnsible resets all changes to the "EnvironmentToAnsible" edge.
func (m *EnvironmentMutation) ResetEnvironmentToAnsible() {
	m._EnvironmentToAnsible = nil
	m.cleared_EnvironmentToAnsible = false
	m.removed_EnvironmentToAnsible = nil
}

// AddEnvironmentToBuildIDs adds the "EnvironmentToBuild" edge to the Build entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToBuildIDs(ids ...uuid.UUID) {
	if m._EnvironmentToBuild == nil {
		m._EnvironmentToBuild = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._EnvironmentToBuild[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToBuild clears the "EnvironmentToBuild" edge to the Build entity.
func (m *EnvironmentMutation) ClearEnvironmentToBuild() {
	m.cleared_EnvironmentToBuild = true
}

// EnvironmentToBuildCleared reports if the "EnvironmentToBuild" edge to the Build entity was cleared.
func (m *EnvironmentMutation) EnvironmentToBuildCleared() bool {
	return m.cleared_EnvironmentToBuild
}

// RemoveEnvironmentToBuildIDs removes the "EnvironmentToBuild" edge to the Build entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToBuildIDs(ids ...uuid.UUID) {
	if m.removed_EnvironmentToBuild == nil {
		m.removed_EnvironmentToBuild = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._EnvironmentToBuild, ids[i])
		m.removed_EnvironmentToBuild[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToBuild returns the removed IDs of the "EnvironmentToBuild" edge to the Build entity.
func (m *EnvironmentMutation) RemovedEnvironmentToBuildIDs() (ids []uuid.UUID) {
	for id := range m.removed_EnvironmentToBuild {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToBuildIDs returns the "EnvironmentToBuild" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToBuildIDs() (ids []uuid.UUID) {
	for id := range m._EnvironmentToBuild {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToBuild resets all changes to the "EnvironmentToBuild" edge.
func (m *EnvironmentMutation) ResetEnvironmentToBuild() {
	m._EnvironmentToBuild = nil
	m.cleared_EnvironmentToBuild = false
	m.removed_EnvironmentToBuild = nil
}

// AddEnvironmentToRepositoryIDs adds the "EnvironmentToRepository" edge to the Repository entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToRepositoryIDs(ids ...uuid.UUID) {
	if m._EnvironmentToRepository == nil {
		m._EnvironmentToRepository = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._EnvironmentToRepository[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToRepository clears the "EnvironmentToRepository" edge to the Repository entity.
func (m *EnvironmentMutation) ClearEnvironmentToRepository() {
	m.cleared_EnvironmentToRepository = true
}

// EnvironmentToRepositoryCleared reports if the "EnvironmentToRepository" edge to the Repository entity was cleared.
func (m *EnvironmentMutation) EnvironmentToRepositoryCleared() bool {
	return m.cleared_EnvironmentToRepository
}

// RemoveEnvironmentToRepositoryIDs removes the "EnvironmentToRepository" edge to the Repository entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToRepositoryIDs(ids ...uuid.UUID) {
	if m.removed_EnvironmentToRepository == nil {
		m.removed_EnvironmentToRepository = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._EnvironmentToRepository, ids[i])
		m.removed_EnvironmentToRepository[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToRepository returns the removed IDs of the "EnvironmentToRepository" edge to the Repository entity.
func (m *EnvironmentMutation) RemovedEnvironmentToRepositoryIDs() (ids []uuid.UUID) {
	for id := range m.removed_EnvironmentToRepository {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToRepositoryIDs returns the "EnvironmentToRepository" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToRepositoryIDs() (ids []uuid.UUID) {
	for id := range m._EnvironmentToRepository {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToRepository resets all changes to the "EnvironmentToRepository" edge.
func (m *EnvironmentMutation) ResetEnvironmentToRepository() {
	m._EnvironmentToRepository = nil
	m.cleared_EnvironmentToRepository = false
	m.removed_EnvironmentToRepository = nil
}

// AddEnvironmentToServerTaskIDs adds the "EnvironmentToServerTask" edge to the ServerTask entity by ids.
func (m *EnvironmentMutation) AddEnvironmentToServerTaskIDs(ids ...uuid.UUID) {
	if m._EnvironmentToServerTask == nil {
		m._EnvironmentToServerTask = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._EnvironmentToServerTask[ids[i]] = struct{}{}
	}
}

// ClearEnvironmentToServerTask clears the "EnvironmentToServerTask" edge to the ServerTask entity.
func (m *EnvironmentMutation) ClearEnvironmentToServerTask() {
	m.cleared_EnvironmentToServerTask = true
}

// EnvironmentToServerTaskCleared reports if the "EnvironmentToServerTask" edge to the ServerTask entity was cleared.
func (m *EnvironmentMutation) EnvironmentToServerTaskCleared() bool {
	return m.cleared_EnvironmentToServerTask
}

// RemoveEnvironmentToServerTaskIDs removes the "EnvironmentToServerTask" edge to the ServerTask entity by IDs.
func (m *EnvironmentMutation) RemoveEnvironmentToServerTaskIDs(ids ...uuid.UUID) {
	if m.removed_EnvironmentToServerTask == nil {
		m.removed_EnvironmentToServerTask = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._EnvironmentToServerTask, ids[i])
		m.removed_EnvironmentToServerTask[ids[i]] = struct{}{}
	}
}

// RemovedEnvironmentToServerTask returns the removed IDs of the "EnvironmentToServerTask" edge to the ServerTask entity.
func (m *EnvironmentMutation) RemovedEnvironmentToServerTaskIDs() (ids []uuid.UUID) {
	for id := range m.removed_EnvironmentToServerTask {
		ids = append(ids, id)
	}
	return
}

// EnvironmentToServerTaskIDs returns the "EnvironmentToServerTask" edge IDs in the mutation.
func (m *EnvironmentMutation) EnvironmentToServerTaskIDs() (ids []uuid.UUID) {
	for id := range m._EnvironmentToServerTask {
		ids = append(ids, id)
	}
	return
}

// ResetEnvironmentToServerTask resets all changes to the "EnvironmentToServerTask" edge.
func (m *EnvironmentMutation) ResetEnvironmentToServerTask() {
	m._EnvironmentToServerTask = nil
	m.cleared_EnvironmentToServerTask = false
	m.removed_EnvironmentToServerTask = nil
}

// Where appends a list predicates to the EnvironmentMutation builder.
func (m *EnvironmentMutation) Where(ps ...predicate.Environment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnvironmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnvironmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Environment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnvironmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnvironmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Environment).
func (m *EnvironmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnvironmentMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.hcl_id != nil {
		fields = append(fields, environment.FieldHCLID)
	}
	if m.competition_id != nil {
		fields = append(fields, environment.FieldCompetitionID)
	}
	if m.name != nil {
		fields = append(fields, environment.FieldName)
	}
	if m.description != nil {
		fields = append(fields, environment.FieldDescription)
	}
	if m.builder != nil {
		fields = append(fields, environment.FieldBuilder)
	}
	if m.team_count != nil {
		fields = append(fields, environment.FieldTeamCount)
	}
	if m.revision != nil {
		fields = append(fields, environment.FieldRevision)
	}
	if m.admin_cidrs != nil {
		fields = append(fields, environment.FieldAdminCidrs)
	}
	if m.exposed_vdi_ports != nil {
		fields = append(fields, environment.FieldExposedVdiPorts)
	}
	if m._config != nil {
		fields = append(fields, environment.FieldConfig)
	}
	if m.tags != nil {
		fields = append(fields, environment.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnvironmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case environment.FieldHCLID:
		return m.HCLID()
	case environment.FieldCompetitionID:
		return m.CompetitionID()
	case environment.FieldName:
		return m.Name()
	case environment.FieldDescription:
		return m.Description()
	case environment.FieldBuilder:
		return m.Builder()
	case environment.FieldTeamCount:
		return m.TeamCount()
	case environment.FieldRevision:
		return m.Revision()
	case environment.FieldAdminCidrs:
		return m.AdminCidrs()
	case environment.FieldExposedVdiPorts:
		return m.ExposedVdiPorts()
	case environment.FieldConfig:
		return m.Config()
	case environment.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnvironmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case environment.FieldHCLID:
		return m.OldHCLID(ctx)
	case environment.FieldCompetitionID:
		return m.OldCompetitionID(ctx)
	case environment.FieldName:
		return m.OldName(ctx)
	case environment.FieldDescription:
		return m.OldDescription(ctx)
	case environment.FieldBuilder:
		return m.OldBuilder(ctx)
	case environment.FieldTeamCount:
		return m.OldTeamCount(ctx)
	case environment.FieldRevision:
		return m.OldRevision(ctx)
	case environment.FieldAdminCidrs:
		return m.OldAdminCidrs(ctx)
	case environment.FieldExposedVdiPorts:
		return m.OldExposedVdiPorts(ctx)
	case environment.FieldConfig:
		return m.OldConfig(ctx)
	case environment.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Environment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvironmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case environment.FieldHCLID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHCLID(v)
		return nil
	case environment.FieldCompetitionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompetitionID(v)
		return nil
	case environment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case environment.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case environment.FieldBuilder:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuilder(v)
		return nil
	case environment.FieldTeamCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamCount(v)
		return nil
	case environment.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case environment.FieldAdminCidrs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminCidrs(v)
		return nil
	case environment.FieldExposedVdiPorts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExposedVdiPorts(v)
		return nil
	case environment.FieldConfig:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case environment.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Environment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnvironmentMutation) AddedFields() []string {
	var fields []string
	if m.addteam_count != nil {
		fields = append(fields, environment.FieldTeamCount)
	}
	if m.addrevision != nil {
		fields = append(fields, environment.FieldRevision)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnvironmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case environment.FieldTeamCount:
		return m.AddedTeamCount()
	case environment.FieldRevision:
		return m.AddedRevision()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnvironmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case environment.FieldTeamCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTeamCount(v)
		return nil
	case environment.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevision(v)
		return nil
	}
	return fmt.Errorf("unknown Environment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnvironmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnvironmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnvironmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Environment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnvironmentMutation) ResetField(name string) error {
	switch name {
	case environment.FieldHCLID:
		m.ResetHCLID()
		return nil
	case environment.FieldCompetitionID:
		m.ResetCompetitionID()
		return nil
	case environment.FieldName:
		m.ResetName()
		return nil
	case environment.FieldDescription:
		m.ResetDescription()
		return nil
	case environment.FieldBuilder:
		m.ResetBuilder()
		return nil
	case environment.FieldTeamCount:
		m.ResetTeamCount()
		return nil
	case environment.FieldRevision:
		m.ResetRevision()
		return nil
	case environment.FieldAdminCidrs:
		m.ResetAdminCidrs()
		return nil
	case environment.FieldExposedVdiPorts:
		m.ResetExposedVdiPorts()
		return nil
	case environment.FieldConfig:
		m.ResetConfig()
		return nil
	case environment.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Environment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnvironmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 19)
	if m._EnvironmentToUser != nil {
		edges = append(edges, environment.EdgeEnvironmentToUser)
	}
	if m._EnvironmentToHost != nil {
		edges = append(edges, environment.EdgeEnvironmentToHost)
	}
	if m._EnvironmentToCompetition != nil {
		edges = append(edges, environment.EdgeEnvironmentToCompetition)
	}
	if m._EnvironmentToIdentity != nil {
		edges = append(edges, environment.EdgeEnvironmentToIdentity)
	}
	if m._EnvironmentToCommand != nil {
		edges = append(edges, environment.EdgeEnvironmentToCommand)
	}
	if m._EnvironmentToScript != nil {
		edges = append(edges, environment.EdgeEnvironmentToScript)
	}
	if m._EnvironmentToFileDownload != nil {
		edges = append(edges, environment.EdgeEnvironmentToFileDownload)
	}
	if m._EnvironmentToFileDelete != nil {
		edges = append(edges, environment.EdgeEnvironmentToFileDelete)
	}
	if m._EnvironmentToFileExtract != nil {
		edges = append(edges, environment.EdgeEnvironmentToFileExtract)
	}
	if m._EnvironmentToIncludedNetwork != nil {
		edges = append(edges, environment.EdgeEnvironmentToIncludedNetwork)
	}
	if m._EnvironmentToFinding != nil {
		edges = append(edges, environment.EdgeEnvironmentToFinding)
	}
	if m._EnvironmentToDNSRecord != nil {
		edges = append(edges, environment.EdgeEnvironmentToDNSRecord)
	}
	if m._EnvironmentToDNS != nil {
		edges = append(edges, environment.EdgeEnvironmentToDNS)
	}
	if m._EnvironmentToNetwork != nil {
		edges = append(edges, environment.EdgeEnvironmentToNetwork)
	}
	if m._EnvironmentToHostDependency != nil {
		edges = append(edges, environment.EdgeEnvironmentToHostDependency)
	}
	if m._EnvironmentToAnsible != nil {
		edges = append(edges, environment.EdgeEnvironmentToAnsible)
	}
	if m._EnvironmentToBuild != nil {
		edges = append(edges, environment.EdgeEnvironmentToBuild)
	}
	if m._EnvironmentToRepository != nil {
		edges = append(edges, environment.EdgeEnvironmentToRepository)
	}
	if m._EnvironmentToServerTask != nil {
		edges = append(edges, environment.EdgeEnvironmentToServerTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnvironmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case environment.EdgeEnvironmentToUser:
		ids := make([]ent.Value, 0, len(m._EnvironmentToUser))
		for id := range m._EnvironmentToUser {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToHost:
		ids := make([]ent.Value, 0, len(m._EnvironmentToHost))
		for id := range m._EnvironmentToHost {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToCompetition:
		ids := make([]ent.Value, 0, len(m._EnvironmentToCompetition))
		for id := range m._EnvironmentToCompetition {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToIdentity:
		ids := make([]ent.Value, 0, len(m._EnvironmentToIdentity))
		for id := range m._EnvironmentToIdentity {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToCommand:
		ids := make([]ent.Value, 0, len(m._EnvironmentToCommand))
		for id := range m._EnvironmentToCommand {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToScript:
		ids := make([]ent.Value, 0, len(m._EnvironmentToScript))
		for id := range m._EnvironmentToScript {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToFileDownload:
		ids := make([]ent.Value, 0, len(m._EnvironmentToFileDownload))
		for id := range m._EnvironmentToFileDownload {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToFileDelete:
		ids := make([]ent.Value, 0, len(m._EnvironmentToFileDelete))
		for id := range m._EnvironmentToFileDelete {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToFileExtract:
		ids := make([]ent.Value, 0, len(m._EnvironmentToFileExtract))
		for id := range m._EnvironmentToFileExtract {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToIncludedNetwork:
		ids := make([]ent.Value, 0, len(m._EnvironmentToIncludedNetwork))
		for id := range m._EnvironmentToIncludedNetwork {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToFinding:
		ids := make([]ent.Value, 0, len(m._EnvironmentToFinding))
		for id := range m._EnvironmentToFinding {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToDNSRecord:
		ids := make([]ent.Value, 0, len(m._EnvironmentToDNSRecord))
		for id := range m._EnvironmentToDNSRecord {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToDNS:
		ids := make([]ent.Value, 0, len(m._EnvironmentToDNS))
		for id := range m._EnvironmentToDNS {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToNetwork:
		ids := make([]ent.Value, 0, len(m._EnvironmentToNetwork))
		for id := range m._EnvironmentToNetwork {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToHostDependency:
		ids := make([]ent.Value, 0, len(m._EnvironmentToHostDependency))
		for id := range m._EnvironmentToHostDependency {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToAnsible:
		ids := make([]ent.Value, 0, len(m._EnvironmentToAnsible))
		for id := range m._EnvironmentToAnsible {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToBuild:
		ids := make([]ent.Value, 0, len(m._EnvironmentToBuild))
		for id := range m._EnvironmentToBuild {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToRepository:
		ids := make([]ent.Value, 0, len(m._EnvironmentToRepository))
		for id := range m._EnvironmentToRepository {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToServerTask:
		ids := make([]ent.Value, 0, len(m._EnvironmentToServerTask))
		for id := range m._EnvironmentToServerTask {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnvironmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 19)
	if m.removed_EnvironmentToUser != nil {
		edges = append(edges, environment.EdgeEnvironmentToUser)
	}
	if m.removed_EnvironmentToHost != nil {
		edges = append(edges, environment.EdgeEnvironmentToHost)
	}
	if m.removed_EnvironmentToCompetition != nil {
		edges = append(edges, environment.EdgeEnvironmentToCompetition)
	}
	if m.removed_EnvironmentToIdentity != nil {
		edges = append(edges, environment.EdgeEnvironmentToIdentity)
	}
	if m.removed_EnvironmentToCommand != nil {
		edges = append(edges, environment.EdgeEnvironmentToCommand)
	}
	if m.removed_EnvironmentToScript != nil {
		edges = append(edges, environment.EdgeEnvironmentToScript)
	}
	if m.removed_EnvironmentToFileDownload != nil {
		edges = append(edges, environment.EdgeEnvironmentToFileDownload)
	}
	if m.removed_EnvironmentToFileDelete != nil {
		edges = append(edges, environment.EdgeEnvironmentToFileDelete)
	}
	if m.removed_EnvironmentToFileExtract != nil {
		edges = append(edges, environment.EdgeEnvironmentToFileExtract)
	}
	if m.removed_EnvironmentToIncludedNetwork != nil {
		edges = append(edges, environment.EdgeEnvironmentToIncludedNetwork)
	}
	if m.removed_EnvironmentToFinding != nil {
		edges = append(edges, environment.EdgeEnvironmentToFinding)
	}
	if m.removed_EnvironmentToDNSRecord != nil {
		edges = append(edges, environment.EdgeEnvironmentToDNSRecord)
	}
	if m.removed_EnvironmentToDNS != nil {
		edges = append(edges, environment.EdgeEnvironmentToDNS)
	}
	if m.removed_EnvironmentToNetwork != nil {
		edges = append(edges, environment.EdgeEnvironmentToNetwork)
	}
	if m.removed_EnvironmentToHostDependency != nil {
		edges = append(edges, environment.EdgeEnvironmentToHostDependency)
	}
	if m.removed_EnvironmentToAnsible != nil {
		edges = append(edges, environment.EdgeEnvironmentToAnsible)
	}
	if m.removed_EnvironmentToBuild != nil {
		edges = append(edges, environment.EdgeEnvironmentToBuild)
	}
	if m.removed_EnvironmentToRepository != nil {
		edges = append(edges, environment.EdgeEnvironmentToRepository)
	}
	if m.removed_EnvironmentToServerTask != nil {
		edges = append(edges, environment.EdgeEnvironmentToServerTask)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnvironmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case environment.EdgeEnvironmentToUser:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToUser))
		for id := range m.removed_EnvironmentToUser {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToHost:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToHost))
		for id := range m.removed_EnvironmentToHost {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToCompetition:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToCompetition))
		for id := range m.removed_EnvironmentToCompetition {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToIdentity:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToIdentity))
		for id := range m.removed_EnvironmentToIdentity {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToCommand:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToCommand))
		for id := range m.removed_EnvironmentToCommand {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToScript:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToScript))
		for id := range m.removed_EnvironmentToScript {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToFileDownload:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToFileDownload))
		for id := range m.removed_EnvironmentToFileDownload {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToFileDelete:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToFileDelete))
		for id := range m.removed_EnvironmentToFileDelete {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToFileExtract:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToFileExtract))
		for id := range m.removed_EnvironmentToFileExtract {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToIncludedNetwork:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToIncludedNetwork))
		for id := range m.removed_EnvironmentToIncludedNetwork {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToFinding:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToFinding))
		for id := range m.removed_EnvironmentToFinding {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToDNSRecord:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToDNSRecord))
		for id := range m.removed_EnvironmentToDNSRecord {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToDNS:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToDNS))
		for id := range m.removed_EnvironmentToDNS {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToNetwork:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToNetwork))
		for id := range m.removed_EnvironmentToNetwork {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToHostDependency:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToHostDependency))
		for id := range m.removed_EnvironmentToHostDependency {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToAnsible:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToAnsible))
		for id := range m.removed_EnvironmentToAnsible {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToBuild:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToBuild))
		for id := range m.removed_EnvironmentToBuild {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToRepository:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToRepository))
		for id := range m.removed_EnvironmentToRepository {
			ids = append(ids, id)
		}
		return ids
	case environment.EdgeEnvironmentToServerTask:
		ids := make([]ent.Value, 0, len(m.removed_EnvironmentToServerTask))
		for id := range m.removed_EnvironmentToServerTask {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnvironmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 19)
	if m.cleared_EnvironmentToUser {
		edges = append(edges, environment.EdgeEnvironmentToUser)
	}
	if m.cleared_EnvironmentToHost {
		edges = append(edges, environment.EdgeEnvironmentToHost)
	}
	if m.cleared_EnvironmentToCompetition {
		edges = append(edges, environment.EdgeEnvironmentToCompetition)
	}
	if m.cleared_EnvironmentToIdentity {
		edges = append(edges, environment.EdgeEnvironmentToIdentity)
	}
	if m.cleared_EnvironmentToCommand {
		edges = append(edges, environment.EdgeEnvironmentToCommand)
	}
	if m.cleared_EnvironmentToScript {
		edges = append(edges, environment.EdgeEnvironmentToScript)
	}
	if m.cleared_EnvironmentToFileDownload {
		edges = append(edges, environment.EdgeEnvironmentToFileDownload)
	}
	if m.cleared_EnvironmentToFileDelete {
		edges = append(edges, environment.EdgeEnvironmentToFileDelete)
	}
	if m.cleared_EnvironmentToFileExtract {
		edges = append(edges, environment.EdgeEnvironmentToFileExtract)
	}
	if m.cleared_EnvironmentToIncludedNetwork {
		edges = append(edges, environment.EdgeEnvironmentToIncludedNetwork)
	}
	if m.cleared_EnvironmentToFinding {
		edges = append(edges, environment.EdgeEnvironmentToFinding)
	}
	if m.cleared_EnvironmentToDNSRecord {
		edges = append(edges, environment.EdgeEnvironmentToDNSRecord)
	}
	if m.cleared_EnvironmentToDNS {
		edges = append(edges, environment.EdgeEnvironmentToDNS)
	}
	if m.cleared_EnvironmentToNetwork {
		edges = append(edges, environment.EdgeEnvironmentToNetwork)
	}
	if m.cleared_EnvironmentToHostDependency {
		edges = append(edges, environment.EdgeEnvironmentToHostDependency)
	}
	if m.cleared_EnvironmentToAnsible {
		edges = append(edges, environment.EdgeEnvironmentToAnsible)
	}
	if m.cleared_EnvironmentToBuild {
		edges = append(edges, environment.EdgeEnvironmentToBuild)
	}
	if m.cleared_EnvironmentToRepository {
		edges = append(edges, environment.EdgeEnvironmentToRepository)
	}
	if m.cleared_EnvironmentToServerTask {
		edges = append(edges, environment.EdgeEnvironmentToServerTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnvironmentMutation) EdgeCleared(name string) bool {
	switch name {
	case environment.EdgeEnvironmentToUser:
		return m.cleared_EnvironmentToUser
	case environment.EdgeEnvironmentToHost:
		return m.cleared_EnvironmentToHost
	case environment.EdgeEnvironmentToCompetition:
		return m.cleared_EnvironmentToCompetition
	case environment.EdgeEnvironmentToIdentity:
		return m.cleared_EnvironmentToIdentity
	case environment.EdgeEnvironmentToCommand:
		return m.cleared_EnvironmentToCommand
	case environment.EdgeEnvironmentToScript:
		return m.cleared_EnvironmentToScript
	case environment.EdgeEnvironmentToFileDownload:
		return m.cleared_EnvironmentToFileDownload
	case environment.EdgeEnvironmentToFileDelete:
		return m.cleared_EnvironmentToFileDelete
	case environment.EdgeEnvironmentToFileExtract:
		return m.cleared_EnvironmentToFileExtract
	case environment.EdgeEnvironmentToIncludedNetwork:
		return m.cleared_EnvironmentToIncludedNetwork
	case environment.EdgeEnvironmentToFinding:
		return m.cleared_EnvironmentToFinding
	case environment.EdgeEnvironmentToDNSRecord:
		return m.cleared_EnvironmentToDNSRecord
	case environment.EdgeEnvironmentToDNS:
		return m.cleared_EnvironmentToDNS
	case environment.EdgeEnvironmentToNetwork:
		return m.cleared_EnvironmentToNetwork
	case environment.EdgeEnvironmentToHostDependency:
		return m.cleared_EnvironmentToHostDependency
	case environment.EdgeEnvironmentToAnsible:
		return m.cleared_EnvironmentToAnsible
	case environment.EdgeEnvironmentToBuild:
		return m.cleared_EnvironmentToBuild
	case environment.EdgeEnvironmentToRepository:
		return m.cleared_EnvironmentToRepository
	case environment.EdgeEnvironmentToServerTask:
		return m.cleared_EnvironmentToServerTask
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnvironmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Environment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnvironmentMutation) ResetEdge(name string) error {
	switch name {
	case environment.EdgeEnvironmentToUser:
		m.ResetEnvironmentToUser()
		return nil
	case environment.EdgeEnvironmentToHost:
		m.ResetEnvironmentToHost()
		return nil
	case environment.EdgeEnvironmentToCompetition:
		m.ResetEnvironmentToCompetition()
		return nil
	case environment.EdgeEnvironmentToIdentity:
		m.ResetEnvironmentToIdentity()
		return nil
	case environment.EdgeEnvironmentToCommand:
		m.ResetEnvironmentToCommand()
		return nil
	case environment.EdgeEnvironmentToScript:
		m.ResetEnvironmentToScript()
		return nil
	case environment.EdgeEnvironmentToFileDownload:
		m.ResetEnvironmentToFileDownload()
		return nil
	case environment.EdgeEnvironmentToFileDelete:
		m.ResetEnvironmentToFileDelete()
		return nil
	case environment.EdgeEnvironmentToFileExtract:
		m.ResetEnvironmentToFileExtract()
		return nil
	case environment.EdgeEnvironmentToIncludedNetwork:
		m.ResetEnvironmentToIncludedNetwork()
		return nil
	case environment.EdgeEnvironmentToFinding:
		m.ResetEnvironmentToFinding()
		return nil
	case environment.EdgeEnvironmentToDNSRecord:
		m.ResetEnvironmentToDNSRecord()
		return nil
	case environment.EdgeEnvironmentToDNS:
		m.ResetEnvironmentToDNS()
		return nil
	case environment.EdgeEnvironmentToNetwork:
		m.ResetEnvironmentToNetwork()
		return nil
	case environment.EdgeEnvironmentToHostDependency:
		m.ResetEnvironmentToHostDependency()
		return nil
	case environment.EdgeEnvironmentToAnsible:
		m.ResetEnvironmentToAnsible()
		return nil
	case environment.EdgeEnvironmentToBuild:
		m.ResetEnvironmentToBuild()
		return nil
	case environment.EdgeEnvironmentToRepository:
		m.ResetEnvironmentToRepository()
		return nil
	case environment.EdgeEnvironmentToServerTask:
		m.ResetEnvironmentToServerTask()
		return nil
	}
	return fmt.Errorf("unknown Environment edge %s", name)
}

// FileDeleteMutation represents an operation that mutates the FileDelete nodes in the graph.
type FileDeleteMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	hcl_id                          *string
	_path                           *string
	tags                            *map[string]string
	clearedFields                   map[string]struct{}
	_FileDeleteToEnvironment        *uuid.UUID
	cleared_FileDeleteToEnvironment bool
	done                            bool
	oldValue                        func(context.Context) (*FileDelete, error)
	predicates                      []predicate.FileDelete
}

var _ ent.Mutation = (*FileDeleteMutation)(nil)

// filedeleteOption allows management of the mutation configuration using functional options.
type filedeleteOption func(*FileDeleteMutation)

// newFileDeleteMutation creates new mutation for the FileDelete entity.
func newFileDeleteMutation(c config, op Op, opts ...filedeleteOption) *FileDeleteMutation {
	m := &FileDeleteMutation{
		config:        c,
		op:            op,
		typ:           TypeFileDelete,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileDeleteID sets the ID field of the mutation.
func withFileDeleteID(id uuid.UUID) filedeleteOption {
	return func(m *FileDeleteMutation) {
		var (
			err   error
			once  sync.Once
			value *FileDelete
		)
		m.oldValue = func(ctx context.Context) (*FileDelete, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileDelete.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileDelete sets the old FileDelete of the mutation.
func withFileDelete(node *FileDelete) filedeleteOption {
	return func(m *FileDeleteMutation) {
		m.oldValue = func(context.Context) (*FileDelete, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileDeleteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileDeleteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FileDelete entities.
func (m *FileDeleteMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileDeleteMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileDeleteMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FileDelete.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHCLID sets the "hcl_id" field.
func (m *FileDeleteMutation) SetHCLID(s string) {
	m.hcl_id = &s
}

// HCLID returns the value of the "hcl_id" field in the mutation.
func (m *FileDeleteMutation) HCLID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHCLID returns the old "hcl_id" field's value of the FileDelete entity.
// If the FileDelete object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDeleteMutation) OldHCLID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHCLID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHCLID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHCLID: %w", err)
	}
	return oldValue.HCLID, nil
}

// ResetHCLID resets all changes to the "hcl_id" field.
func (m *FileDeleteMutation) ResetHCLID() {
	m.hcl_id = nil
}

// SetPath sets the "path" field.
func (m *FileDeleteMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *FileDeleteMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the FileDelete entity.
// If the FileDelete object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDeleteMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *FileDeleteMutation) ResetPath() {
	m._path = nil
}

// SetTags sets the "tags" field.
func (m *FileDeleteMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *FileDeleteMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the FileDelete entity.
// If the FileDelete object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDeleteMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *FileDeleteMutation) ResetTags() {
	m.tags = nil
}

// SetFileDeleteToEnvironmentID sets the "FileDeleteToEnvironment" edge to the Environment entity by id.
func (m *FileDeleteMutation) SetFileDeleteToEnvironmentID(id uuid.UUID) {
	m._FileDeleteToEnvironment = &id
}

// ClearFileDeleteToEnvironment clears the "FileDeleteToEnvironment" edge to the Environment entity.
func (m *FileDeleteMutation) ClearFileDeleteToEnvironment() {
	m.cleared_FileDeleteToEnvironment = true
}

// FileDeleteToEnvironmentCleared reports if the "FileDeleteToEnvironment" edge to the Environment entity was cleared.
func (m *FileDeleteMutation) FileDeleteToEnvironmentCleared() bool {
	return m.cleared_FileDeleteToEnvironment
}

// FileDeleteToEnvironmentID returns the "FileDeleteToEnvironment" edge ID in the mutation.
func (m *FileDeleteMutation) FileDeleteToEnvironmentID() (id uuid.UUID, exists bool) {
	if m._FileDeleteToEnvironment != nil {
		return *m._FileDeleteToEnvironment, true
	}
	return
}

// FileDeleteToEnvironmentIDs returns the "FileDeleteToEnvironment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileDeleteToEnvironmentID instead. It exists only for internal usage by the builders.
func (m *FileDeleteMutation) FileDeleteToEnvironmentIDs() (ids []uuid.UUID) {
	if id := m._FileDeleteToEnvironment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFileDeleteToEnvironment resets all changes to the "FileDeleteToEnvironment" edge.
func (m *FileDeleteMutation) ResetFileDeleteToEnvironment() {
	m._FileDeleteToEnvironment = nil
	m.cleared_FileDeleteToEnvironment = false
}

// Where appends a list predicates to the FileDeleteMutation builder.
func (m *FileDeleteMutation) Where(ps ...predicate.FileDelete) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileDeleteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileDeleteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FileDelete, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileDeleteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileDeleteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FileDelete).
func (m *FileDeleteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileDeleteMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.hcl_id != nil {
		fields = append(fields, filedelete.FieldHCLID)
	}
	if m._path != nil {
		fields = append(fields, filedelete.FieldPath)
	}
	if m.tags != nil {
		fields = append(fields, filedelete.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileDeleteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filedelete.FieldHCLID:
		return m.HCLID()
	case filedelete.FieldPath:
		return m.Path()
	case filedelete.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileDeleteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filedelete.FieldHCLID:
		return m.OldHCLID(ctx)
	case filedelete.FieldPath:
		return m.OldPath(ctx)
	case filedelete.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown FileDelete field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileDeleteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filedelete.FieldHCLID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHCLID(v)
		return nil
	case filedelete.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case filedelete.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown FileDelete field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileDeleteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileDeleteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileDeleteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FileDelete numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileDeleteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileDeleteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileDeleteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FileDelete nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileDeleteMutation) ResetField(name string) error {
	switch name {
	case filedelete.FieldHCLID:
		m.ResetHCLID()
		return nil
	case filedelete.FieldPath:
		m.ResetPath()
		return nil
	case filedelete.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown FileDelete field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileDeleteMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._FileDeleteToEnvironment != nil {
		edges = append(edges, filedelete.EdgeFileDeleteToEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileDeleteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case filedelete.EdgeFileDeleteToEnvironment:
		if id := m._FileDeleteToEnvironment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileDeleteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileDeleteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileDeleteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_FileDeleteToEnvironment {
		edges = append(edges, filedelete.EdgeFileDeleteToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileDeleteMutation) EdgeCleared(name string) bool {
	switch name {
	case filedelete.EdgeFileDeleteToEnvironment:
		return m.cleared_FileDeleteToEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileDeleteMutation) ClearEdge(name string) error {
	switch name {
	case filedelete.EdgeFileDeleteToEnvironment:
		m.ClearFileDeleteToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown FileDelete unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileDeleteMutation) ResetEdge(name string) error {
	switch name {
	case filedelete.EdgeFileDeleteToEnvironment:
		m.ResetFileDeleteToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown FileDelete edge %s", name)
}

// FileDownloadMutation represents an operation that mutates the FileDownload nodes in the graph.
type FileDownloadMutation struct {
	config
	op                                Op
	typ                               string
	id                                *uuid.UUID
	hcl_id                            *string
	source_type                       *string
	source                            *string
	destination                       *string
	template                          *bool
	perms                             *string
	disabled                          *bool
	md5                               *string
	abs_path                          *string
	is_txt                            *bool
	tags                              *map[string]string
	clearedFields                     map[string]struct{}
	_FileDownloadToEnvironment        *uuid.UUID
	cleared_FileDownloadToEnvironment bool
	done                              bool
	oldValue                          func(context.Context) (*FileDownload, error)
	predicates                        []predicate.FileDownload
}

var _ ent.Mutation = (*FileDownloadMutation)(nil)

// filedownloadOption allows management of the mutation configuration using functional options.
type filedownloadOption func(*FileDownloadMutation)

// newFileDownloadMutation creates new mutation for the FileDownload entity.
func newFileDownloadMutation(c config, op Op, opts ...filedownloadOption) *FileDownloadMutation {
	m := &FileDownloadMutation{
		config:        c,
		op:            op,
		typ:           TypeFileDownload,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileDownloadID sets the ID field of the mutation.
func withFileDownloadID(id uuid.UUID) filedownloadOption {
	return func(m *FileDownloadMutation) {
		var (
			err   error
			once  sync.Once
			value *FileDownload
		)
		m.oldValue = func(ctx context.Context) (*FileDownload, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileDownload.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileDownload sets the old FileDownload of the mutation.
func withFileDownload(node *FileDownload) filedownloadOption {
	return func(m *FileDownloadMutation) {
		m.oldValue = func(context.Context) (*FileDownload, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileDownloadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileDownloadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FileDownload entities.
func (m *FileDownloadMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileDownloadMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileDownloadMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FileDownload.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHCLID sets the "hcl_id" field.
func (m *FileDownloadMutation) SetHCLID(s string) {
	m.hcl_id = &s
}

// HCLID returns the value of the "hcl_id" field in the mutation.
func (m *FileDownloadMutation) HCLID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHCLID returns the old "hcl_id" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldHCLID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHCLID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHCLID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHCLID: %w", err)
	}
	return oldValue.HCLID, nil
}

// ResetHCLID resets all changes to the "hcl_id" field.
func (m *FileDownloadMutation) ResetHCLID() {
	m.hcl_id = nil
}

// SetSourceType sets the "source_type" field.
func (m *FileDownloadMutation) SetSourceType(s string) {
	m.source_type = &s
}

// SourceType returns the value of the "source_type" field in the mutation.
func (m *FileDownloadMutation) SourceType() (r string, exists bool) {
	v := m.source_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceType returns the old "source_type" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldSourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceType: %w", err)
	}
	return oldValue.SourceType, nil
}

// ResetSourceType resets all changes to the "source_type" field.
func (m *FileDownloadMutation) ResetSourceType() {
	m.source_type = nil
}

// SetSource sets the "source" field.
func (m *FileDownloadMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *FileDownloadMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *FileDownloadMutation) ResetSource() {
	m.source = nil
}

// SetDestination sets the "destination" field.
func (m *FileDownloadMutation) SetDestination(s string) {
	m.destination = &s
}

// Destination returns the value of the "destination" field in the mutation.
func (m *FileDownloadMutation) Destination() (r string, exists bool) {
	v := m.destination
	if v == nil {
		return
	}
	return *v, true
}

// OldDestination returns the old "destination" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldDestination(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestination is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestination requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestination: %w", err)
	}
	return oldValue.Destination, nil
}

// ResetDestination resets all changes to the "destination" field.
func (m *FileDownloadMutation) ResetDestination() {
	m.destination = nil
}

// SetTemplate sets the "template" field.
func (m *FileDownloadMutation) SetTemplate(b bool) {
	m.template = &b
}

// Template returns the value of the "template" field in the mutation.
func (m *FileDownloadMutation) Template() (r bool, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplate returns the old "template" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldTemplate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplate: %w", err)
	}
	return oldValue.Template, nil
}

// ResetTemplate resets all changes to the "template" field.
func (m *FileDownloadMutation) ResetTemplate() {
	m.template = nil
}

// SetPerms sets the "perms" field.
func (m *FileDownloadMutation) SetPerms(s string) {
	m.perms = &s
}

// Perms returns the value of the "perms" field in the mutation.
func (m *FileDownloadMutation) Perms() (r string, exists bool) {
	v := m.perms
	if v == nil {
		return
	}
	return *v, true
}

// OldPerms returns the old "perms" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldPerms(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPerms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPerms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPerms: %w", err)
	}
	return oldValue.Perms, nil
}

// ResetPerms resets all changes to the "perms" field.
func (m *FileDownloadMutation) ResetPerms() {
	m.perms = nil
}

// SetDisabled sets the "disabled" field.
func (m *FileDownloadMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *FileDownloadMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *FileDownloadMutation) ResetDisabled() {
	m.disabled = nil
}

// SetMd5 sets the "md5" field.
func (m *FileDownloadMutation) SetMd5(s string) {
	m.md5 = &s
}

// Md5 returns the value of the "md5" field in the mutation.
func (m *FileDownloadMutation) Md5() (r string, exists bool) {
	v := m.md5
	if v == nil {
		return
	}
	return *v, true
}

// OldMd5 returns the old "md5" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldMd5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMd5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMd5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMd5: %w", err)
	}
	return oldValue.Md5, nil
}

// ResetMd5 resets all changes to the "md5" field.
func (m *FileDownloadMutation) ResetMd5() {
	m.md5 = nil
}

// SetAbsPath sets the "abs_path" field.
func (m *FileDownloadMutation) SetAbsPath(s string) {
	m.abs_path = &s
}

// AbsPath returns the value of the "abs_path" field in the mutation.
func (m *FileDownloadMutation) AbsPath() (r string, exists bool) {
	v := m.abs_path
	if v == nil {
		return
	}
	return *v, true
}

// OldAbsPath returns the old "abs_path" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldAbsPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbsPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbsPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbsPath: %w", err)
	}
	return oldValue.AbsPath, nil
}

// ResetAbsPath resets all changes to the "abs_path" field.
func (m *FileDownloadMutation) ResetAbsPath() {
	m.abs_path = nil
}

// SetIsTxt sets the "is_txt" field.
func (m *FileDownloadMutation) SetIsTxt(b bool) {
	m.is_txt = &b
}

// IsTxt returns the value of the "is_txt" field in the mutation.
func (m *FileDownloadMutation) IsTxt() (r bool, exists bool) {
	v := m.is_txt
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTxt returns the old "is_txt" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldIsTxt(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTxt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTxt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTxt: %w", err)
	}
	return oldValue.IsTxt, nil
}

// ResetIsTxt resets all changes to the "is_txt" field.
func (m *FileDownloadMutation) ResetIsTxt() {
	m.is_txt = nil
}

// SetTags sets the "tags" field.
func (m *FileDownloadMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *FileDownloadMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the FileDownload entity.
// If the FileDownload object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileDownloadMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *FileDownloadMutation) ResetTags() {
	m.tags = nil
}

// SetFileDownloadToEnvironmentID sets the "FileDownloadToEnvironment" edge to the Environment entity by id.
func (m *FileDownloadMutation) SetFileDownloadToEnvironmentID(id uuid.UUID) {
	m._FileDownloadToEnvironment = &id
}

// ClearFileDownloadToEnvironment clears the "FileDownloadToEnvironment" edge to the Environment entity.
func (m *FileDownloadMutation) ClearFileDownloadToEnvironment() {
	m.cleared_FileDownloadToEnvironment = true
}

// FileDownloadToEnvironmentCleared reports if the "FileDownloadToEnvironment" edge to the Environment entity was cleared.
func (m *FileDownloadMutation) FileDownloadToEnvironmentCleared() bool {
	return m.cleared_FileDownloadToEnvironment
}

// FileDownloadToEnvironmentID returns the "FileDownloadToEnvironment" edge ID in the mutation.
func (m *FileDownloadMutation) FileDownloadToEnvironmentID() (id uuid.UUID, exists bool) {
	if m._FileDownloadToEnvironment != nil {
		return *m._FileDownloadToEnvironment, true
	}
	return
}

// FileDownloadToEnvironmentIDs returns the "FileDownloadToEnvironment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileDownloadToEnvironmentID instead. It exists only for internal usage by the builders.
func (m *FileDownloadMutation) FileDownloadToEnvironmentIDs() (ids []uuid.UUID) {
	if id := m._FileDownloadToEnvironment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFileDownloadToEnvironment resets all changes to the "FileDownloadToEnvironment" edge.
func (m *FileDownloadMutation) ResetFileDownloadToEnvironment() {
	m._FileDownloadToEnvironment = nil
	m.cleared_FileDownloadToEnvironment = false
}

// Where appends a list predicates to the FileDownloadMutation builder.
func (m *FileDownloadMutation) Where(ps ...predicate.FileDownload) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileDownloadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileDownloadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FileDownload, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileDownloadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileDownloadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FileDownload).
func (m *FileDownloadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileDownloadMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.hcl_id != nil {
		fields = append(fields, filedownload.FieldHCLID)
	}
	if m.source_type != nil {
		fields = append(fields, filedownload.FieldSourceType)
	}
	if m.source != nil {
		fields = append(fields, filedownload.FieldSource)
	}
	if m.destination != nil {
		fields = append(fields, filedownload.FieldDestination)
	}
	if m.template != nil {
		fields = append(fields, filedownload.FieldTemplate)
	}
	if m.perms != nil {
		fields = append(fields, filedownload.FieldPerms)
	}
	if m.disabled != nil {
		fields = append(fields, filedownload.FieldDisabled)
	}
	if m.md5 != nil {
		fields = append(fields, filedownload.FieldMd5)
	}
	if m.abs_path != nil {
		fields = append(fields, filedownload.FieldAbsPath)
	}
	if m.is_txt != nil {
		fields = append(fields, filedownload.FieldIsTxt)
	}
	if m.tags != nil {
		fields = append(fields, filedownload.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileDownloadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filedownload.FieldHCLID:
		return m.HCLID()
	case filedownload.FieldSourceType:
		return m.SourceType()
	case filedownload.FieldSource:
		return m.Source()
	case filedownload.FieldDestination:
		return m.Destination()
	case filedownload.FieldTemplate:
		return m.Template()
	case filedownload.FieldPerms:
		return m.Perms()
	case filedownload.FieldDisabled:
		return m.Disabled()
	case filedownload.FieldMd5:
		return m.Md5()
	case filedownload.FieldAbsPath:
		return m.AbsPath()
	case filedownload.FieldIsTxt:
		return m.IsTxt()
	case filedownload.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileDownloadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filedownload.FieldHCLID:
		return m.OldHCLID(ctx)
	case filedownload.FieldSourceType:
		return m.OldSourceType(ctx)
	case filedownload.FieldSource:
		return m.OldSource(ctx)
	case filedownload.FieldDestination:
		return m.OldDestination(ctx)
	case filedownload.FieldTemplate:
		return m.OldTemplate(ctx)
	case filedownload.FieldPerms:
		return m.OldPerms(ctx)
	case filedownload.FieldDisabled:
		return m.OldDisabled(ctx)
	case filedownload.FieldMd5:
		return m.OldMd5(ctx)
	case filedownload.FieldAbsPath:
		return m.OldAbsPath(ctx)
	case filedownload.FieldIsTxt:
		return m.OldIsTxt(ctx)
	case filedownload.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown FileDownload field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileDownloadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filedownload.FieldHCLID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHCLID(v)
		return nil
	case filedownload.FieldSourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceType(v)
		return nil
	case filedownload.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case filedownload.FieldDestination:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestination(v)
		return nil
	case filedownload.FieldTemplate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplate(v)
		return nil
	case filedownload.FieldPerms:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPerms(v)
		return nil
	case filedownload.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case filedownload.FieldMd5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMd5(v)
		return nil
	case filedownload.FieldAbsPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbsPath(v)
		return nil
	case filedownload.FieldIsTxt:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTxt(v)
		return nil
	case filedownload.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown FileDownload field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileDownloadMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileDownloadMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileDownloadMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FileDownload numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileDownloadMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileDownloadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileDownloadMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FileDownload nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileDownloadMutation) ResetField(name string) error {
	switch name {
	case filedownload.FieldHCLID:
		m.ResetHCLID()
		return nil
	case filedownload.FieldSourceType:
		m.ResetSourceType()
		return nil
	case filedownload.FieldSource:
		m.ResetSource()
		return nil
	case filedownload.FieldDestination:
		m.ResetDestination()
		return nil
	case filedownload.FieldTemplate:
		m.ResetTemplate()
		return nil
	case filedownload.FieldPerms:
		m.ResetPerms()
		return nil
	case filedownload.FieldDisabled:
		m.ResetDisabled()
		return nil
	case filedownload.FieldMd5:
		m.ResetMd5()
		return nil
	case filedownload.FieldAbsPath:
		m.ResetAbsPath()
		return nil
	case filedownload.FieldIsTxt:
		m.ResetIsTxt()
		return nil
	case filedownload.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown FileDownload field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileDownloadMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._FileDownloadToEnvironment != nil {
		edges = append(edges, filedownload.EdgeFileDownloadToEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileDownloadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case filedownload.EdgeFileDownloadToEnvironment:
		if id := m._FileDownloadToEnvironment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileDownloadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileDownloadMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileDownloadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_FileDownloadToEnvironment {
		edges = append(edges, filedownload.EdgeFileDownloadToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileDownloadMutation) EdgeCleared(name string) bool {
	switch name {
	case filedownload.EdgeFileDownloadToEnvironment:
		return m.cleared_FileDownloadToEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileDownloadMutation) ClearEdge(name string) error {
	switch name {
	case filedownload.EdgeFileDownloadToEnvironment:
		m.ClearFileDownloadToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown FileDownload unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileDownloadMutation) ResetEdge(name string) error {
	switch name {
	case filedownload.EdgeFileDownloadToEnvironment:
		m.ResetFileDownloadToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown FileDownload edge %s", name)
}

// FileExtractMutation represents an operation that mutates the FileExtract nodes in the graph.
type FileExtractMutation struct {
	config
	op                               Op
	typ                              string
	id                               *uuid.UUID
	hcl_id                           *string
	source                           *string
	destination                      *string
	_type                            *string
	tags                             *map[string]string
	clearedFields                    map[string]struct{}
	_FileExtractToEnvironment        *uuid.UUID
	cleared_FileExtractToEnvironment bool
	done                             bool
	oldValue                         func(context.Context) (*FileExtract, error)
	predicates                       []predicate.FileExtract
}

var _ ent.Mutation = (*FileExtractMutation)(nil)

// fileextractOption allows management of the mutation configuration using functional options.
type fileextractOption func(*FileExtractMutation)

// newFileExtractMutation creates new mutation for the FileExtract entity.
func newFileExtractMutation(c config, op Op, opts ...fileextractOption) *FileExtractMutation {
	m := &FileExtractMutation{
		config:        c,
		op:            op,
		typ:           TypeFileExtract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileExtractID sets the ID field of the mutation.
func withFileExtractID(id uuid.UUID) fileextractOption {
	return func(m *FileExtractMutation) {
		var (
			err   error
			once  sync.Once
			value *FileExtract
		)
		m.oldValue = func(ctx context.Context) (*FileExtract, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileExtract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileExtract sets the old FileExtract of the mutation.
func withFileExtract(node *FileExtract) fileextractOption {
	return func(m *FileExtractMutation) {
		m.oldValue = func(context.Context) (*FileExtract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileExtractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileExtractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FileExtract entities.
func (m *FileExtractMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileExtractMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileExtractMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FileExtract.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHCLID sets the "hcl_id" field.
func (m *FileExtractMutation) SetHCLID(s string) {
	m.hcl_id = &s
}

// HCLID returns the value of the "hcl_id" field in the mutation.
func (m *FileExtractMutation) HCLID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHCLID returns the old "hcl_id" field's value of the FileExtract entity.
// If the FileExtract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileExtractMutation) OldHCLID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHCLID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHCLID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHCLID: %w", err)
	}
	return oldValue.HCLID, nil
}

// ResetHCLID resets all changes to the "hcl_id" field.
func (m *FileExtractMutation) ResetHCLID() {
	m.hcl_id = nil
}

// SetSource sets the "source" field.
func (m *FileExtractMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *FileExtractMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the FileExtract entity.
// If the FileExtract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileExtractMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *FileExtractMutation) ResetSource() {
	m.source = nil
}

// SetDestination sets the "destination" field.
func (m *FileExtractMutation) SetDestination(s string) {
	m.destination = &s
}

// Destination returns the value of the "destination" field in the mutation.
func (m *FileExtractMutation) Destination() (r string, exists bool) {
	v := m.destination
	if v == nil {
		return
	}
	return *v, true
}

// OldDestination returns the old "destination" field's value of the FileExtract entity.
// If the FileExtract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileExtractMutation) OldDestination(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestination is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestination requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestination: %w", err)
	}
	return oldValue.Destination, nil
}

// ResetDestination resets all changes to the "destination" field.
func (m *FileExtractMutation) ResetDestination() {
	m.destination = nil
}

// SetType sets the "type" field.
func (m *FileExtractMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *FileExtractMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the FileExtract entity.
// If the FileExtract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileExtractMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FileExtractMutation) ResetType() {
	m._type = nil
}

// SetTags sets the "tags" field.
func (m *FileExtractMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *FileExtractMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the FileExtract entity.
// If the FileExtract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileExtractMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *FileExtractMutation) ResetTags() {
	m.tags = nil
}

// SetFileExtractToEnvironmentID sets the "FileExtractToEnvironment" edge to the Environment entity by id.
func (m *FileExtractMutation) SetFileExtractToEnvironmentID(id uuid.UUID) {
	m._FileExtractToEnvironment = &id
}

// ClearFileExtractToEnvironment clears the "FileExtractToEnvironment" edge to the Environment entity.
func (m *FileExtractMutation) ClearFileExtractToEnvironment() {
	m.cleared_FileExtractToEnvironment = true
}

// FileExtractToEnvironmentCleared reports if the "FileExtractToEnvironment" edge to the Environment entity was cleared.
func (m *FileExtractMutation) FileExtractToEnvironmentCleared() bool {
	return m.cleared_FileExtractToEnvironment
}

// FileExtractToEnvironmentID returns the "FileExtractToEnvironment" edge ID in the mutation.
func (m *FileExtractMutation) FileExtractToEnvironmentID() (id uuid.UUID, exists bool) {
	if m._FileExtractToEnvironment != nil {
		return *m._FileExtractToEnvironment, true
	}
	return
}

// FileExtractToEnvironmentIDs returns the "FileExtractToEnvironment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileExtractToEnvironmentID instead. It exists only for internal usage by the builders.
func (m *FileExtractMutation) FileExtractToEnvironmentIDs() (ids []uuid.UUID) {
	if id := m._FileExtractToEnvironment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFileExtractToEnvironment resets all changes to the "FileExtractToEnvironment" edge.
func (m *FileExtractMutation) ResetFileExtractToEnvironment() {
	m._FileExtractToEnvironment = nil
	m.cleared_FileExtractToEnvironment = false
}

// Where appends a list predicates to the FileExtractMutation builder.
func (m *FileExtractMutation) Where(ps ...predicate.FileExtract) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileExtractMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileExtractMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FileExtract, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileExtractMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileExtractMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FileExtract).
func (m *FileExtractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileExtractMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.hcl_id != nil {
		fields = append(fields, fileextract.FieldHCLID)
	}
	if m.source != nil {
		fields = append(fields, fileextract.FieldSource)
	}
	if m.destination != nil {
		fields = append(fields, fileextract.FieldDestination)
	}
	if m._type != nil {
		fields = append(fields, fileextract.FieldType)
	}
	if m.tags != nil {
		fields = append(fields, fileextract.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileExtractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fileextract.FieldHCLID:
		return m.HCLID()
	case fileextract.FieldSource:
		return m.Source()
	case fileextract.FieldDestination:
		return m.Destination()
	case fileextract.FieldType:
		return m.GetType()
	case fileextract.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileExtractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fileextract.FieldHCLID:
		return m.OldHCLID(ctx)
	case fileextract.FieldSource:
		return m.OldSource(ctx)
	case fileextract.FieldDestination:
		return m.OldDestination(ctx)
	case fileextract.FieldType:
		return m.OldType(ctx)
	case fileextract.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown FileExtract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileExtractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fileextract.FieldHCLID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHCLID(v)
		return nil
	case fileextract.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case fileextract.FieldDestination:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestination(v)
		return nil
	case fileextract.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case fileextract.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown FileExtract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileExtractMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileExtractMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileExtractMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FileExtract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileExtractMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileExtractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileExtractMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FileExtract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileExtractMutation) ResetField(name string) error {
	switch name {
	case fileextract.FieldHCLID:
		m.ResetHCLID()
		return nil
	case fileextract.FieldSource:
		m.ResetSource()
		return nil
	case fileextract.FieldDestination:
		m.ResetDestination()
		return nil
	case fileextract.FieldType:
		m.ResetType()
		return nil
	case fileextract.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown FileExtract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileExtractMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._FileExtractToEnvironment != nil {
		edges = append(edges, fileextract.EdgeFileExtractToEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileExtractMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fileextract.EdgeFileExtractToEnvironment:
		if id := m._FileExtractToEnvironment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileExtractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileExtractMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileExtractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_FileExtractToEnvironment {
		edges = append(edges, fileextract.EdgeFileExtractToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileExtractMutation) EdgeCleared(name string) bool {
	switch name {
	case fileextract.EdgeFileExtractToEnvironment:
		return m.cleared_FileExtractToEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileExtractMutation) ClearEdge(name string) error {
	switch name {
	case fileextract.EdgeFileExtractToEnvironment:
		m.ClearFileExtractToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown FileExtract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileExtractMutation) ResetEdge(name string) error {
	switch name {
	case fileextract.EdgeFileExtractToEnvironment:
		m.ResetFileExtractToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown FileExtract edge %s", name)
}

// FindingMutation represents an operation that mutates the Finding nodes in the graph.
type FindingMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	name                         *string
	description                  *string
	severity                     *finding.Severity
	difficulty                   *finding.Difficulty
	tags                         *map[string]string
	clearedFields                map[string]struct{}
	_FindingToUser               map[uuid.UUID]struct{}
	removed_FindingToUser        map[uuid.UUID]struct{}
	cleared_FindingToUser        bool
	_FindingToHost               *uuid.UUID
	cleared_FindingToHost        bool
	_FindingToScript             *uuid.UUID
	cleared_FindingToScript      bool
	_FindingToEnvironment        *uuid.UUID
	cleared_FindingToEnvironment bool
	done                         bool
	oldValue                     func(context.Context) (*Finding, error)
	predicates                   []predicate.Finding
}

var _ ent.Mutation = (*FindingMutation)(nil)

// findingOption allows management of the mutation configuration using functional options.
type findingOption func(*FindingMutation)

// newFindingMutation creates new mutation for the Finding entity.
func newFindingMutation(c config, op Op, opts ...findingOption) *FindingMutation {
	m := &FindingMutation{
		config:        c,
		op:            op,
		typ:           TypeFinding,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFindingID sets the ID field of the mutation.
func withFindingID(id uuid.UUID) findingOption {
	return func(m *FindingMutation) {
		var (
			err   error
			once  sync.Once
			value *Finding
		)
		m.oldValue = func(ctx context.Context) (*Finding, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Finding.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFinding sets the old Finding of the mutation.
func withFinding(node *Finding) findingOption {
	return func(m *FindingMutation) {
		m.oldValue = func(context.Context) (*Finding, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FindingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FindingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Finding entities.
func (m *FindingMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FindingMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FindingMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Finding.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *FindingMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FindingMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Finding entity.
// If the Finding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FindingMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *FindingMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FindingMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Finding entity.
// If the Finding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *FindingMutation) ResetDescription() {
	m.description = nil
}

// SetSeverity sets the "severity" field.
func (m *FindingMutation) SetSeverity(f finding.Severity) {
	m.severity = &f
}

// Severity returns the value of the "severity" field in the mutation.
func (m *FindingMutation) Severity() (r finding.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the Finding entity.
// If the Finding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingMutation) OldSeverity(ctx context.Context) (v finding.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *FindingMutation) ResetSeverity() {
	m.severity = nil
}

// SetDifficulty sets the "difficulty" field.
func (m *FindingMutation) SetDifficulty(f finding.Difficulty) {
	m.difficulty = &f
}

// Difficulty returns the value of the "difficulty" field in the mutation.
func (m *FindingMutation) Difficulty() (r finding.Difficulty, exists bool) {
	v := m.difficulty
	if v == nil {
		return
	}
	return *v, true
}

// OldDifficulty returns the old "difficulty" field's value of the Finding entity.
// If the Finding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingMutation) OldDifficulty(ctx context.Context) (v finding.Difficulty, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDifficulty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDifficulty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDifficulty: %w", err)
	}
	return oldValue.Difficulty, nil
}

// ResetDifficulty resets all changes to the "difficulty" field.
func (m *FindingMutation) ResetDifficulty() {
	m.difficulty = nil
}

// SetTags sets the "tags" field.
func (m *FindingMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *FindingMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Finding entity.
// If the Finding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FindingMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *FindingMutation) ResetTags() {
	m.tags = nil
}

// AddFindingToUserIDs adds the "FindingToUser" edge to the User entity by ids.
func (m *FindingMutation) AddFindingToUserIDs(ids ...uuid.UUID) {
	if m._FindingToUser == nil {
		m._FindingToUser = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._FindingToUser[ids[i]] = struct{}{}
	}
}

// ClearFindingToUser clears the "FindingToUser" edge to the User entity.
func (m *FindingMutation) ClearFindingToUser() {
	m.cleared_FindingToUser = true
}

// FindingToUserCleared reports if the "FindingToUser" edge to the User entity was cleared.
func (m *FindingMutation) FindingToUserCleared() bool {
	return m.cleared_FindingToUser
}

// RemoveFindingToUserIDs removes the "FindingToUser" edge to the User entity by IDs.
func (m *FindingMutation) RemoveFindingToUserIDs(ids ...uuid.UUID) {
	if m.removed_FindingToUser == nil {
		m.removed_FindingToUser = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._FindingToUser, ids[i])
		m.removed_FindingToUser[ids[i]] = struct{}{}
	}
}

// RemovedFindingToUser returns the removed IDs of the "FindingToUser" edge to the User entity.
func (m *FindingMutation) RemovedFindingToUserIDs() (ids []uuid.UUID) {
	for id := range m.removed_FindingToUser {
		ids = append(ids, id)
	}
	return
}

// FindingToUserIDs returns the "FindingToUser" edge IDs in the mutation.
func (m *FindingMutation) FindingToUserIDs() (ids []uuid.UUID) {
	for id := range m._FindingToUser {
		ids = append(ids, id)
	}
	return
}

// ResetFindingToUser resets all changes to the "FindingToUser" edge.
func (m *FindingMutation) ResetFindingToUser() {
	m._FindingToUser = nil
	m.cleared_FindingToUser = false
	m.removed_FindingToUser = nil
}

// SetFindingToHostID sets the "FindingToHost" edge to the Host entity by id.
func (m *FindingMutation) SetFindingToHostID(id uuid.UUID) {
	m._FindingToHost = &id
}

// ClearFindingToHost clears the "FindingToHost" edge to the Host entity.
func (m *FindingMutation) ClearFindingToHost() {
	m.cleared_FindingToHost = true
}

// FindingToHostCleared reports if the "FindingToHost" edge to the Host entity was cleared.
func (m *FindingMutation) FindingToHostCleared() bool {
	return m.cleared_FindingToHost
}

// FindingToHostID returns the "FindingToHost" edge ID in the mutation.
func (m *FindingMutation) FindingToHostID() (id uuid.UUID, exists bool) {
	if m._FindingToHost != nil {
		return *m._FindingToHost, true
	}
	return
}

// FindingToHostIDs returns the "FindingToHost" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FindingToHostID instead. It exists only for internal usage by the builders.
func (m *FindingMutation) FindingToHostIDs() (ids []uuid.UUID) {
	if id := m._FindingToHost; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFindingToHost resets all changes to the "FindingToHost" edge.
func (m *FindingMutation) ResetFindingToHost() {
	m._FindingToHost = nil
	m.cleared_FindingToHost = false
}

// SetFindingToScriptID sets the "FindingToScript" edge to the Script entity by id.
func (m *FindingMutation) SetFindingToScriptID(id uuid.UUID) {
	m._FindingToScript = &id
}

// ClearFindingToScript clears the "FindingToScript" edge to the Script entity.
func (m *FindingMutation) ClearFindingToScript() {
	m.cleared_FindingToScript = true
}

// FindingToScriptCleared reports if the "FindingToScript" edge to the Script entity was cleared.
func (m *FindingMutation) FindingToScriptCleared() bool {
	return m.cleared_FindingToScript
}

// FindingToScriptID returns the "FindingToScript" edge ID in the mutation.
func (m *FindingMutation) FindingToScriptID() (id uuid.UUID, exists bool) {
	if m._FindingToScript != nil {
		return *m._FindingToScript, true
	}
	return
}

// FindingToScriptIDs returns the "FindingToScript" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FindingToScriptID instead. It exists only for internal usage by the builders.
func (m *FindingMutation) FindingToScriptIDs() (ids []uuid.UUID) {
	if id := m._FindingToScript; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFindingToScript resets all changes to the "FindingToScript" edge.
func (m *FindingMutation) ResetFindingToScript() {
	m._FindingToScript = nil
	m.cleared_FindingToScript = false
}

// SetFindingToEnvironmentID sets the "FindingToEnvironment" edge to the Environment entity by id.
func (m *FindingMutation) SetFindingToEnvironmentID(id uuid.UUID) {
	m._FindingToEnvironment = &id
}

// ClearFindingToEnvironment clears the "FindingToEnvironment" edge to the Environment entity.
func (m *FindingMutation) ClearFindingToEnvironment() {
	m.cleared_FindingToEnvironment = true
}

// FindingToEnvironmentCleared reports if the "FindingToEnvironment" edge to the Environment entity was cleared.
func (m *FindingMutation) FindingToEnvironmentCleared() bool {
	return m.cleared_FindingToEnvironment
}

// FindingToEnvironmentID returns the "FindingToEnvironment" edge ID in the mutation.
func (m *FindingMutation) FindingToEnvironmentID() (id uuid.UUID, exists bool) {
	if m._FindingToEnvironment != nil {
		return *m._FindingToEnvironment, true
	}
	return
}

// FindingToEnvironmentIDs returns the "FindingToEnvironment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FindingToEnvironmentID instead. It exists only for internal usage by the builders.
func (m *FindingMutation) FindingToEnvironmentIDs() (ids []uuid.UUID) {
	if id := m._FindingToEnvironment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFindingToEnvironment resets all changes to the "FindingToEnvironment" edge.
func (m *FindingMutation) ResetFindingToEnvironment() {
	m._FindingToEnvironment = nil
	m.cleared_FindingToEnvironment = false
}

// Where appends a list predicates to the FindingMutation builder.
func (m *FindingMutation) Where(ps ...predicate.Finding) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FindingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FindingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Finding, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FindingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FindingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Finding).
func (m *FindingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FindingMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, finding.FieldName)
	}
	if m.description != nil {
		fields = append(fields, finding.FieldDescription)
	}
	if m.severity != nil {
		fields = append(fields, finding.FieldSeverity)
	}
	if m.difficulty != nil {
		fields = append(fields, finding.FieldDifficulty)
	}
	if m.tags != nil {
		fields = append(fields, finding.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FindingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case finding.FieldName:
		return m.Name()
	case finding.FieldDescription:
		return m.Description()
	case finding.FieldSeverity:
		return m.Severity()
	case finding.FieldDifficulty:
		return m.Difficulty()
	case finding.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FindingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case finding.FieldName:
		return m.OldName(ctx)
	case finding.FieldDescription:
		return m.OldDescription(ctx)
	case finding.FieldSeverity:
		return m.OldSeverity(ctx)
	case finding.FieldDifficulty:
		return m.OldDifficulty(ctx)
	case finding.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Finding field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FindingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case finding.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case finding.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case finding.FieldSeverity:
		v, ok := value.(finding.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case finding.FieldDifficulty:
		v, ok := value.(finding.Difficulty)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDifficulty(v)
		return nil
	case finding.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Finding field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FindingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FindingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FindingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Finding numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FindingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FindingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FindingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Finding nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FindingMutation) ResetField(name string) error {
	switch name {
	case finding.FieldName:
		m.ResetName()
		return nil
	case finding.FieldDescription:
		m.ResetDescription()
		return nil
	case finding.FieldSeverity:
		m.ResetSeverity()
		return nil
	case finding.FieldDifficulty:
		m.ResetDifficulty()
		return nil
	case finding.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Finding field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FindingMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._FindingToUser != nil {
		edges = append(edges, finding.EdgeFindingToUser)
	}
	if m._FindingToHost != nil {
		edges = append(edges, finding.EdgeFindingToHost)
	}
	if m._FindingToScript != nil {
		edges = append(edges, finding.EdgeFindingToScript)
	}
	if m._FindingToEnvironment != nil {
		edges = append(edges, finding.EdgeFindingToEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FindingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case finding.EdgeFindingToUser:
		ids := make([]ent.Value, 0, len(m._FindingToUser))
		for id := range m._FindingToUser {
			ids = append(ids, id)
		}
		return ids
	case finding.EdgeFindingToHost:
		if id := m._FindingToHost; id != nil {
			return []ent.Value{*id}
		}
	case finding.EdgeFindingToScript:
		if id := m._FindingToScript; id != nil {
			return []ent.Value{*id}
		}
	case finding.EdgeFindingToEnvironment:
		if id := m._FindingToEnvironment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FindingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removed_FindingToUser != nil {
		edges = append(edges, finding.EdgeFindingToUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FindingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case finding.EdgeFindingToUser:
		ids := make([]ent.Value, 0, len(m.removed_FindingToUser))
		for id := range m.removed_FindingToUser {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FindingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_FindingToUser {
		edges = append(edges, finding.EdgeFindingToUser)
	}
	if m.cleared_FindingToHost {
		edges = append(edges, finding.EdgeFindingToHost)
	}
	if m.cleared_FindingToScript {
		edges = append(edges, finding.EdgeFindingToScript)
	}
	if m.cleared_FindingToEnvironment {
		edges = append(edges, finding.EdgeFindingToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FindingMutation) EdgeCleared(name string) bool {
	switch name {
	case finding.EdgeFindingToUser:
		return m.cleared_FindingToUser
	case finding.EdgeFindingToHost:
		return m.cleared_FindingToHost
	case finding.EdgeFindingToScript:
		return m.cleared_FindingToScript
	case finding.EdgeFindingToEnvironment:
		return m.cleared_FindingToEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FindingMutation) ClearEdge(name string) error {
	switch name {
	case finding.EdgeFindingToHost:
		m.ClearFindingToHost()
		return nil
	case finding.EdgeFindingToScript:
		m.ClearFindingToScript()
		return nil
	case finding.EdgeFindingToEnvironment:
		m.ClearFindingToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Finding unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FindingMutation) ResetEdge(name string) error {
	switch name {
	case finding.EdgeFindingToUser:
		m.ResetFindingToUser()
		return nil
	case finding.EdgeFindingToHost:
		m.ResetFindingToHost()
		return nil
	case finding.EdgeFindingToScript:
		m.ResetFindingToScript()
		return nil
	case finding.EdgeFindingToEnvironment:
		m.ResetFindingToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Finding edge %s", name)
}

// GinFileMiddlewareMutation represents an operation that mutates the GinFileMiddleware nodes in the graph.
type GinFileMiddlewareMutation struct {
	config
	op                                          Op
	typ                                         string
	id                                          *uuid.UUID
	url_id                                      *string
	file_path                                   *string
	accessed                                    *bool
	clearedFields                               map[string]struct{}
	_GinFileMiddlewareToProvisionedHost         *uuid.UUID
	cleared_GinFileMiddlewareToProvisionedHost  bool
	_GinFileMiddlewareToProvisioningStep        *uuid.UUID
	cleared_GinFileMiddlewareToProvisioningStep bool
	done                                        bool
	oldValue                                    func(context.Context) (*GinFileMiddleware, error)
	predicates                                  []predicate.GinFileMiddleware
}

var _ ent.Mutation = (*GinFileMiddlewareMutation)(nil)

// ginfilemiddlewareOption allows management of the mutation configuration using functional options.
type ginfilemiddlewareOption func(*GinFileMiddlewareMutation)

// newGinFileMiddlewareMutation creates new mutation for the GinFileMiddleware entity.
func newGinFileMiddlewareMutation(c config, op Op, opts ...ginfilemiddlewareOption) *GinFileMiddlewareMutation {
	m := &GinFileMiddlewareMutation{
		config:        c,
		op:            op,
		typ:           TypeGinFileMiddleware,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGinFileMiddlewareID sets the ID field of the mutation.
func withGinFileMiddlewareID(id uuid.UUID) ginfilemiddlewareOption {
	return func(m *GinFileMiddlewareMutation) {
		var (
			err   error
			once  sync.Once
			value *GinFileMiddleware
		)
		m.oldValue = func(ctx context.Context) (*GinFileMiddleware, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GinFileMiddleware.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGinFileMiddleware sets the old GinFileMiddleware of the mutation.
func withGinFileMiddleware(node *GinFileMiddleware) ginfilemiddlewareOption {
	return func(m *GinFileMiddlewareMutation) {
		m.oldValue = func(context.Context) (*GinFileMiddleware, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GinFileMiddlewareMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GinFileMiddlewareMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GinFileMiddleware entities.
func (m *GinFileMiddlewareMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GinFileMiddlewareMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GinFileMiddlewareMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GinFileMiddleware.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetURLID sets the "url_id" field.
func (m *GinFileMiddlewareMutation) SetURLID(s string) {
	m.url_id = &s
}

// URLID returns the value of the "url_id" field in the mutation.
func (m *GinFileMiddlewareMutation) URLID() (r string, exists bool) {
	v := m.url_id
	if v == nil {
		return
	}
	return *v, true
}

// OldURLID returns the old "url_id" field's value of the GinFileMiddleware entity.
// If the GinFileMiddleware object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinFileMiddlewareMutation) OldURLID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURLID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURLID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURLID: %w", err)
	}
	return oldValue.URLID, nil
}

// ResetURLID resets all changes to the "url_id" field.
func (m *GinFileMiddlewareMutation) ResetURLID() {
	m.url_id = nil
}

// SetFilePath sets the "file_path" field.
func (m *GinFileMiddlewareMutation) SetFilePath(s string) {
	m.file_path = &s
}

// FilePath returns the value of the "file_path" field in the mutation.
func (m *GinFileMiddlewareMutation) FilePath() (r string, exists bool) {
	v := m.file_path
	if v == nil {
		return
	}
	return *v, true
}

// OldFilePath returns the old "file_path" field's value of the GinFileMiddleware entity.
// If the GinFileMiddleware object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinFileMiddlewareMutation) OldFilePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilePath: %w", err)
	}
	return oldValue.FilePath, nil
}

// ResetFilePath resets all changes to the "file_path" field.
func (m *GinFileMiddlewareMutation) ResetFilePath() {
	m.file_path = nil
}

// SetAccessed sets the "accessed" field.
func (m *GinFileMiddlewareMutation) SetAccessed(b bool) {
	m.accessed = &b
}

// Accessed returns the value of the "accessed" field in the mutation.
func (m *GinFileMiddlewareMutation) Accessed() (r bool, exists bool) {
	v := m.accessed
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessed returns the old "accessed" field's value of the GinFileMiddleware entity.
// If the GinFileMiddleware object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GinFileMiddlewareMutation) OldAccessed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessed: %w", err)
	}
	return oldValue.Accessed, nil
}

// ResetAccessed resets all changes to the "accessed" field.
func (m *GinFileMiddlewareMutation) ResetAccessed() {
	m.accessed = nil
}

// SetGinFileMiddlewareToProvisionedHostID sets the "GinFileMiddlewareToProvisionedHost" edge to the ProvisionedHost entity by id.
func (m *GinFileMiddlewareMutation) SetGinFileMiddlewareToProvisionedHostID(id uuid.UUID) {
	m._GinFileMiddlewareToProvisionedHost = &id
}

// ClearGinFileMiddlewareToProvisionedHost clears the "GinFileMiddlewareToProvisionedHost" edge to the ProvisionedHost entity.
func (m *GinFileMiddlewareMutation) ClearGinFileMiddlewareToProvisionedHost() {
	m.cleared_GinFileMiddlewareToProvisionedHost = true
}

// GinFileMiddlewareToProvisionedHostCleared reports if the "GinFileMiddlewareToProvisionedHost" edge to the ProvisionedHost entity was cleared.
func (m *GinFileMiddlewareMutation) GinFileMiddlewareToProvisionedHostCleared() bool {
	return m.cleared_GinFileMiddlewareToProvisionedHost
}

// GinFileMiddlewareToProvisionedHostID returns the "GinFileMiddlewareToProvisionedHost" edge ID in the mutation.
func (m *GinFileMiddlewareMutation) GinFileMiddlewareToProvisionedHostID() (id uuid.UUID, exists bool) {
	if m._GinFileMiddlewareToProvisionedHost != nil {
		return *m._GinFileMiddlewareToProvisionedHost, true
	}
	return
}

// GinFileMiddlewareToProvisionedHostIDs returns the "GinFileMiddlewareToProvisionedHost" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GinFileMiddlewareToProvisionedHostID instead. It exists only for internal usage by the builders.
func (m *GinFileMiddlewareMutation) GinFileMiddlewareToProvisionedHostIDs() (ids []uuid.UUID) {
	if id := m._GinFileMiddlewareToProvisionedHost; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGinFileMiddlewareToProvisionedHost resets all changes to the "GinFileMiddlewareToProvisionedHost" edge.
func (m *GinFileMiddlewareMutation) ResetGinFileMiddlewareToProvisionedHost() {
	m._GinFileMiddlewareToProvisionedHost = nil
	m.cleared_GinFileMiddlewareToProvisionedHost = false
}

// SetGinFileMiddlewareToProvisioningStepID sets the "GinFileMiddlewareToProvisioningStep" edge to the ProvisioningStep entity by id.
func (m *GinFileMiddlewareMutation) SetGinFileMiddlewareToProvisioningStepID(id uuid.UUID) {
	m._GinFileMiddlewareToProvisioningStep = &id
}

// ClearGinFileMiddlewareToProvisioningStep clears the "GinFileMiddlewareToProvisioningStep" edge to the ProvisioningStep entity.
func (m *GinFileMiddlewareMutation) ClearGinFileMiddlewareToProvisioningStep() {
	m.cleared_GinFileMiddlewareToProvisioningStep = true
}

// GinFileMiddlewareToProvisioningStepCleared reports if the "GinFileMiddlewareToProvisioningStep" edge to the ProvisioningStep entity was cleared.
func (m *GinFileMiddlewareMutation) GinFileMiddlewareToProvisioningStepCleared() bool {
	return m.cleared_GinFileMiddlewareToProvisioningStep
}

// GinFileMiddlewareToProvisioningStepID returns the "GinFileMiddlewareToProvisioningStep" edge ID in the mutation.
func (m *GinFileMiddlewareMutation) GinFileMiddlewareToProvisioningStepID() (id uuid.UUID, exists bool) {
	if m._GinFileMiddlewareToProvisioningStep != nil {
		return *m._GinFileMiddlewareToProvisioningStep, true
	}
	return
}

// GinFileMiddlewareToProvisioningStepIDs returns the "GinFileMiddlewareToProvisioningStep" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GinFileMiddlewareToProvisioningStepID instead. It exists only for internal usage by the builders.
func (m *GinFileMiddlewareMutation) GinFileMiddlewareToProvisioningStepIDs() (ids []uuid.UUID) {
	if id := m._GinFileMiddlewareToProvisioningStep; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGinFileMiddlewareToProvisioningStep resets all changes to the "GinFileMiddlewareToProvisioningStep" edge.
func (m *GinFileMiddlewareMutation) ResetGinFileMiddlewareToProvisioningStep() {
	m._GinFileMiddlewareToProvisioningStep = nil
	m.cleared_GinFileMiddlewareToProvisioningStep = false
}

// Where appends a list predicates to the GinFileMiddlewareMutation builder.
func (m *GinFileMiddlewareMutation) Where(ps ...predicate.GinFileMiddleware) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GinFileMiddlewareMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GinFileMiddlewareMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GinFileMiddleware, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GinFileMiddlewareMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GinFileMiddlewareMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GinFileMiddleware).
func (m *GinFileMiddlewareMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GinFileMiddlewareMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.url_id != nil {
		fields = append(fields, ginfilemiddleware.FieldURLID)
	}
	if m.file_path != nil {
		fields = append(fields, ginfilemiddleware.FieldFilePath)
	}
	if m.accessed != nil {
		fields = append(fields, ginfilemiddleware.FieldAccessed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GinFileMiddlewareMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ginfilemiddleware.FieldURLID:
		return m.URLID()
	case ginfilemiddleware.FieldFilePath:
		return m.FilePath()
	case ginfilemiddleware.FieldAccessed:
		return m.Accessed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GinFileMiddlewareMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ginfilemiddleware.FieldURLID:
		return m.OldURLID(ctx)
	case ginfilemiddleware.FieldFilePath:
		return m.OldFilePath(ctx)
	case ginfilemiddleware.FieldAccessed:
		return m.OldAccessed(ctx)
	}
	return nil, fmt.Errorf("unknown GinFileMiddleware field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GinFileMiddlewareMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ginfilemiddleware.FieldURLID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURLID(v)
		return nil
	case ginfilemiddleware.FieldFilePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilePath(v)
		return nil
	case ginfilemiddleware.FieldAccessed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessed(v)
		return nil
	}
	return fmt.Errorf("unknown GinFileMiddleware field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GinFileMiddlewareMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GinFileMiddlewareMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GinFileMiddlewareMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GinFileMiddleware numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GinFileMiddlewareMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GinFileMiddlewareMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GinFileMiddlewareMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GinFileMiddleware nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GinFileMiddlewareMutation) ResetField(name string) error {
	switch name {
	case ginfilemiddleware.FieldURLID:
		m.ResetURLID()
		return nil
	case ginfilemiddleware.FieldFilePath:
		m.ResetFilePath()
		return nil
	case ginfilemiddleware.FieldAccessed:
		m.ResetAccessed()
		return nil
	}
	return fmt.Errorf("unknown GinFileMiddleware field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GinFileMiddlewareMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._GinFileMiddlewareToProvisionedHost != nil {
		edges = append(edges, ginfilemiddleware.EdgeGinFileMiddlewareToProvisionedHost)
	}
	if m._GinFileMiddlewareToProvisioningStep != nil {
		edges = append(edges, ginfilemiddleware.EdgeGinFileMiddlewareToProvisioningStep)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GinFileMiddlewareMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ginfilemiddleware.EdgeGinFileMiddlewareToProvisionedHost:
		if id := m._GinFileMiddlewareToProvisionedHost; id != nil {
			return []ent.Value{*id}
		}
	case ginfilemiddleware.EdgeGinFileMiddlewareToProvisioningStep:
		if id := m._GinFileMiddlewareToProvisioningStep; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GinFileMiddlewareMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GinFileMiddlewareMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GinFileMiddlewareMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_GinFileMiddlewareToProvisionedHost {
		edges = append(edges, ginfilemiddleware.EdgeGinFileMiddlewareToProvisionedHost)
	}
	if m.cleared_GinFileMiddlewareToProvisioningStep {
		edges = append(edges, ginfilemiddleware.EdgeGinFileMiddlewareToProvisioningStep)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GinFileMiddlewareMutation) EdgeCleared(name string) bool {
	switch name {
	case ginfilemiddleware.EdgeGinFileMiddlewareToProvisionedHost:
		return m.cleared_GinFileMiddlewareToProvisionedHost
	case ginfilemiddleware.EdgeGinFileMiddlewareToProvisioningStep:
		return m.cleared_GinFileMiddlewareToProvisioningStep
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GinFileMiddlewareMutation) ClearEdge(name string) error {
	switch name {
	case ginfilemiddleware.EdgeGinFileMiddlewareToProvisionedHost:
		m.ClearGinFileMiddlewareToProvisionedHost()
		return nil
	case ginfilemiddleware.EdgeGinFileMiddlewareToProvisioningStep:
		m.ClearGinFileMiddlewareToProvisioningStep()
		return nil
	}
	return fmt.Errorf("unknown GinFileMiddleware unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GinFileMiddlewareMutation) ResetEdge(name string) error {
	switch name {
	case ginfilemiddleware.EdgeGinFileMiddlewareToProvisionedHost:
		m.ResetGinFileMiddlewareToProvisionedHost()
		return nil
	case ginfilemiddleware.EdgeGinFileMiddlewareToProvisioningStep:
		m.ResetGinFileMiddlewareToProvisioningStep()
		return nil
	}
	return fmt.Errorf("unknown GinFileMiddleware edge %s", name)
}

// HostMutation represents an operation that mutates the Host nodes in the graph.
type HostMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *uuid.UUID
	hcl_id                               *string
	hostname                             *string
	description                          *string
	_OS                                  *string
	last_octet                           *int
	addlast_octet                        *int
	instance_size                        *string
	allow_mac_changes                    *bool
	exposed_tcp_ports                    *[]string
	appendexposed_tcp_ports              []string
	exposed_udp_ports                    *[]string
	appendexposed_udp_ports              []string
	override_password                    *string
	vars                                 *map[string]string
	user_groups                          *[]string
	appenduser_groups                    []string
	provision_steps                      *[]string
	appendprovision_steps                []string
	tags                                 *map[string]string
	clearedFields                        map[string]struct{}
	_HostToDisk                          *uuid.UUID
	cleared_HostToDisk                   bool
	_HostToUser                          map[uuid.UUID]struct{}
	removed_HostToUser                   map[uuid.UUID]struct{}
	cleared_HostToUser                   bool
	_HostToEnvironment                   *uuid.UUID
	cleared_HostToEnvironment            bool
	_HostToIncludedNetwork               map[uuid.UUID]struct{}
	removed_HostToIncludedNetwork        map[uuid.UUID]struct{}
	cleared_HostToIncludedNetwork        bool
	_DependOnHostToHostDependency        map[uuid.UUID]struct{}
	removed_DependOnHostToHostDependency map[uuid.UUID]struct{}
	cleared_DependOnHostToHostDependency bool
	_DependByHostToHostDependency        map[uuid.UUID]struct{}
	removed_DependByHostToHostDependency map[uuid.UUID]struct{}
	cleared_DependByHostToHostDependency bool
	done                                 bool
	oldValue                             func(context.Context) (*Host, error)
	predicates                           []predicate.Host
}

var _ ent.Mutation = (*HostMutation)(nil)

// hostOption allows management of the mutation configuration using functional options.
type hostOption func(*HostMutation)

// newHostMutation creates new mutation for the Host entity.
func newHostMutation(c config, op Op, opts ...hostOption) *HostMutation {
	m := &HostMutation{
		config:        c,
		op:            op,
		typ:           TypeHost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHostID sets the ID field of the mutation.
func withHostID(id uuid.UUID) hostOption {
	return func(m *HostMutation) {
		var (
			err   error
			once  sync.Once
			value *Host
		)
		m.oldValue = func(ctx context.Context) (*Host, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Host.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHost sets the old Host of the mutation.
func withHost(node *Host) hostOption {
	return func(m *HostMutation) {
		m.oldValue = func(context.Context) (*Host, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Host entities.
func (m *HostMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HostMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HostMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Host.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHCLID sets the "hcl_id" field.
func (m *HostMutation) SetHCLID(s string) {
	m.hcl_id = &s
}

// HCLID returns the value of the "hcl_id" field in the mutation.
func (m *HostMutation) HCLID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHCLID returns the old "hcl_id" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldHCLID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHCLID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHCLID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHCLID: %w", err)
	}
	return oldValue.HCLID, nil
}

// ResetHCLID resets all changes to the "hcl_id" field.
func (m *HostMutation) ResetHCLID() {
	m.hcl_id = nil
}

// SetHostname sets the "hostname" field.
func (m *HostMutation) SetHostname(s string) {
	m.hostname = &s
}

// Hostname returns the value of the "hostname" field in the mutation.
func (m *HostMutation) Hostname() (r string, exists bool) {
	v := m.hostname
	if v == nil {
		return
	}
	return *v, true
}

// OldHostname returns the old "hostname" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldHostname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostname: %w", err)
	}
	return oldValue.Hostname, nil
}

// ResetHostname resets all changes to the "hostname" field.
func (m *HostMutation) ResetHostname() {
	m.hostname = nil
}

// SetDescription sets the "description" field.
func (m *HostMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *HostMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *HostMutation) ResetDescription() {
	m.description = nil
}

// SetOS sets the "OS" field.
func (m *HostMutation) SetOS(s string) {
	m._OS = &s
}

// OS returns the value of the "OS" field in the mutation.
func (m *HostMutation) OS() (r string, exists bool) {
	v := m._OS
	if v == nil {
		return
	}
	return *v, true
}

// OldOS returns the old "OS" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldOS(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOS: %w", err)
	}
	return oldValue.OS, nil
}

// ResetOS resets all changes to the "OS" field.
func (m *HostMutation) ResetOS() {
	m._OS = nil
}

// SetLastOctet sets the "last_octet" field.
func (m *HostMutation) SetLastOctet(i int) {
	m.last_octet = &i
	m.addlast_octet = nil
}

// LastOctet returns the value of the "last_octet" field in the mutation.
func (m *HostMutation) LastOctet() (r int, exists bool) {
	v := m.last_octet
	if v == nil {
		return
	}
	return *v, true
}

// OldLastOctet returns the old "last_octet" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldLastOctet(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastOctet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastOctet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastOctet: %w", err)
	}
	return oldValue.LastOctet, nil
}

// AddLastOctet adds i to the "last_octet" field.
func (m *HostMutation) AddLastOctet(i int) {
	if m.addlast_octet != nil {
		*m.addlast_octet += i
	} else {
		m.addlast_octet = &i
	}
}

// AddedLastOctet returns the value that was added to the "last_octet" field in this mutation.
func (m *HostMutation) AddedLastOctet() (r int, exists bool) {
	v := m.addlast_octet
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastOctet resets all changes to the "last_octet" field.
func (m *HostMutation) ResetLastOctet() {
	m.last_octet = nil
	m.addlast_octet = nil
}

// SetInstanceSize sets the "instance_size" field.
func (m *HostMutation) SetInstanceSize(s string) {
	m.instance_size = &s
}

// InstanceSize returns the value of the "instance_size" field in the mutation.
func (m *HostMutation) InstanceSize() (r string, exists bool) {
	v := m.instance_size
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceSize returns the old "instance_size" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldInstanceSize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstanceSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstanceSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceSize: %w", err)
	}
	return oldValue.InstanceSize, nil
}

// ResetInstanceSize resets all changes to the "instance_size" field.
func (m *HostMutation) ResetInstanceSize() {
	m.instance_size = nil
}

// SetAllowMACChanges sets the "allow_mac_changes" field.
func (m *HostMutation) SetAllowMACChanges(b bool) {
	m.allow_mac_changes = &b
}

// AllowMACChanges returns the value of the "allow_mac_changes" field in the mutation.
func (m *HostMutation) AllowMACChanges() (r bool, exists bool) {
	v := m.allow_mac_changes
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowMACChanges returns the old "allow_mac_changes" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldAllowMACChanges(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowMACChanges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowMACChanges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowMACChanges: %w", err)
	}
	return oldValue.AllowMACChanges, nil
}

// ResetAllowMACChanges resets all changes to the "allow_mac_changes" field.
func (m *HostMutation) ResetAllowMACChanges() {
	m.allow_mac_changes = nil
}

// SetExposedTCPPorts sets the "exposed_tcp_ports" field.
func (m *HostMutation) SetExposedTCPPorts(s []string) {
	m.exposed_tcp_ports = &s
	m.appendexposed_tcp_ports = nil
}

// ExposedTCPPorts returns the value of the "exposed_tcp_ports" field in the mutation.
func (m *HostMutation) ExposedTCPPorts() (r []string, exists bool) {
	v := m.exposed_tcp_ports
	if v == nil {
		return
	}
	return *v, true
}

// OldExposedTCPPorts returns the old "exposed_tcp_ports" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldExposedTCPPorts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExposedTCPPorts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExposedTCPPorts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExposedTCPPorts: %w", err)
	}
	return oldValue.ExposedTCPPorts, nil
}

// AppendExposedTCPPorts adds s to the "exposed_tcp_ports" field.
func (m *HostMutation) AppendExposedTCPPorts(s []string) {
	m.appendexposed_tcp_ports = append(m.appendexposed_tcp_ports, s...)
}

// AppendedExposedTCPPorts returns the list of values that were appended to the "exposed_tcp_ports" field in this mutation.
func (m *HostMutation) AppendedExposedTCPPorts() ([]string, bool) {
	if len(m.appendexposed_tcp_ports) == 0 {
		return nil, false
	}
	return m.appendexposed_tcp_ports, true
}

// ResetExposedTCPPorts resets all changes to the "exposed_tcp_ports" field.
func (m *HostMutation) ResetExposedTCPPorts() {
	m.exposed_tcp_ports = nil
	m.appendexposed_tcp_ports = nil
}

// SetExposedUDPPorts sets the "exposed_udp_ports" field.
func (m *HostMutation) SetExposedUDPPorts(s []string) {
	m.exposed_udp_ports = &s
	m.appendexposed_udp_ports = nil
}

// ExposedUDPPorts returns the value of the "exposed_udp_ports" field in the mutation.
func (m *HostMutation) ExposedUDPPorts() (r []string, exists bool) {
	v := m.exposed_udp_ports
	if v == nil {
		return
	}
	return *v, true
}

// OldExposedUDPPorts returns the old "exposed_udp_ports" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldExposedUDPPorts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExposedUDPPorts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExposedUDPPorts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExposedUDPPorts: %w", err)
	}
	return oldValue.ExposedUDPPorts, nil
}

// AppendExposedUDPPorts adds s to the "exposed_udp_ports" field.
func (m *HostMutation) AppendExposedUDPPorts(s []string) {
	m.appendexposed_udp_ports = append(m.appendexposed_udp_ports, s...)
}

// AppendedExposedUDPPorts returns the list of values that were appended to the "exposed_udp_ports" field in this mutation.
func (m *HostMutation) AppendedExposedUDPPorts() ([]string, bool) {
	if len(m.appendexposed_udp_ports) == 0 {
		return nil, false
	}
	return m.appendexposed_udp_ports, true
}

// ResetExposedUDPPorts resets all changes to the "exposed_udp_ports" field.
func (m *HostMutation) ResetExposedUDPPorts() {
	m.exposed_udp_ports = nil
	m.appendexposed_udp_ports = nil
}

// SetOverridePassword sets the "override_password" field.
func (m *HostMutation) SetOverridePassword(s string) {
	m.override_password = &s
}

// OverridePassword returns the value of the "override_password" field in the mutation.
func (m *HostMutation) OverridePassword() (r string, exists bool) {
	v := m.override_password
	if v == nil {
		return
	}
	return *v, true
}

// OldOverridePassword returns the old "override_password" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldOverridePassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverridePassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverridePassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverridePassword: %w", err)
	}
	return oldValue.OverridePassword, nil
}

// ResetOverridePassword resets all changes to the "override_password" field.
func (m *HostMutation) ResetOverridePassword() {
	m.override_password = nil
}

// SetVars sets the "vars" field.
func (m *HostMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *HostMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *HostMutation) ResetVars() {
	m.vars = nil
}

// SetUserGroups sets the "user_groups" field.
func (m *HostMutation) SetUserGroups(s []string) {
	m.user_groups = &s
	m.appenduser_groups = nil
}

// UserGroups returns the value of the "user_groups" field in the mutation.
func (m *HostMutation) UserGroups() (r []string, exists bool) {
	v := m.user_groups
	if v == nil {
		return
	}
	return *v, true
}

// OldUserGroups returns the old "user_groups" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldUserGroups(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserGroups is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserGroups requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserGroups: %w", err)
	}
	return oldValue.UserGroups, nil
}

// AppendUserGroups adds s to the "user_groups" field.
func (m *HostMutation) AppendUserGroups(s []string) {
	m.appenduser_groups = append(m.appenduser_groups, s...)
}

// AppendedUserGroups returns the list of values that were appended to the "user_groups" field in this mutation.
func (m *HostMutation) AppendedUserGroups() ([]string, bool) {
	if len(m.appenduser_groups) == 0 {
		return nil, false
	}
	return m.appenduser_groups, true
}

// ResetUserGroups resets all changes to the "user_groups" field.
func (m *HostMutation) ResetUserGroups() {
	m.user_groups = nil
	m.appenduser_groups = nil
}

// SetProvisionSteps sets the "provision_steps" field.
func (m *HostMutation) SetProvisionSteps(s []string) {
	m.provision_steps = &s
	m.appendprovision_steps = nil
}

// ProvisionSteps returns the value of the "provision_steps" field in the mutation.
func (m *HostMutation) ProvisionSteps() (r []string, exists bool) {
	v := m.provision_steps
	if v == nil {
		return
	}
	return *v, true
}

// OldProvisionSteps returns the old "provision_steps" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldProvisionSteps(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvisionSteps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvisionSteps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvisionSteps: %w", err)
	}
	return oldValue.ProvisionSteps, nil
}

// AppendProvisionSteps adds s to the "provision_steps" field.
func (m *HostMutation) AppendProvisionSteps(s []string) {
	m.appendprovision_steps = append(m.appendprovision_steps, s...)
}

// AppendedProvisionSteps returns the list of values that were appended to the "provision_steps" field in this mutation.
func (m *HostMutation) AppendedProvisionSteps() ([]string, bool) {
	if len(m.appendprovision_steps) == 0 {
		return nil, false
	}
	return m.appendprovision_steps, true
}

// ClearProvisionSteps clears the value of the "provision_steps" field.
func (m *HostMutation) ClearProvisionSteps() {
	m.provision_steps = nil
	m.appendprovision_steps = nil
	m.clearedFields[host.FieldProvisionSteps] = struct{}{}
}

// ProvisionStepsCleared returns if the "provision_steps" field was cleared in this mutation.
func (m *HostMutation) ProvisionStepsCleared() bool {
	_, ok := m.clearedFields[host.FieldProvisionSteps]
	return ok
}

// ResetProvisionSteps resets all changes to the "provision_steps" field.
func (m *HostMutation) ResetProvisionSteps() {
	m.provision_steps = nil
	m.appendprovision_steps = nil
	delete(m.clearedFields, host.FieldProvisionSteps)
}

// SetTags sets the "tags" field.
func (m *HostMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *HostMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *HostMutation) ResetTags() {
	m.tags = nil
}

// SetHostToDiskID sets the "HostToDisk" edge to the Disk entity by id.
func (m *HostMutation) SetHostToDiskID(id uuid.UUID) {
	m._HostToDisk = &id
}

// ClearHostToDisk clears the "HostToDisk" edge to the Disk entity.
func (m *HostMutation) ClearHostToDisk() {
	m.cleared_HostToDisk = true
}

// HostToDiskCleared reports if the "HostToDisk" edge to the Disk entity was cleared.
func (m *HostMutation) HostToDiskCleared() bool {
	return m.cleared_HostToDisk
}

// HostToDiskID returns the "HostToDisk" edge ID in the mutation.
func (m *HostMutation) HostToDiskID() (id uuid.UUID, exists bool) {
	if m._HostToDisk != nil {
		return *m._HostToDisk, true
	}
	return
}

// HostToDiskIDs returns the "HostToDisk" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostToDiskID instead. It exists only for internal usage by the builders.
func (m *HostMutation) HostToDiskIDs() (ids []uuid.UUID) {
	if id := m._HostToDisk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHostToDisk resets all changes to the "HostToDisk" edge.
func (m *HostMutation) ResetHostToDisk() {
	m._HostToDisk = nil
	m.cleared_HostToDisk = false
}

// AddHostToUserIDs adds the "HostToUser" edge to the User entity by ids.
func (m *HostMutation) AddHostToUserIDs(ids ...uuid.UUID) {
	if m._HostToUser == nil {
		m._HostToUser = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._HostToUser[ids[i]] = struct{}{}
	}
}

// ClearHostToUser clears the "HostToUser" edge to the User entity.
func (m *HostMutation) ClearHostToUser() {
	m.cleared_HostToUser = true
}

// HostToUserCleared reports if the "HostToUser" edge to the User entity was cleared.
func (m *HostMutation) HostToUserCleared() bool {
	return m.cleared_HostToUser
}

// RemoveHostToUserIDs removes the "HostToUser" edge to the User entity by IDs.
func (m *HostMutation) RemoveHostToUserIDs(ids ...uuid.UUID) {
	if m.removed_HostToUser == nil {
		m.removed_HostToUser = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._HostToUser, ids[i])
		m.removed_HostToUser[ids[i]] = struct{}{}
	}
}

// RemovedHostToUser returns the removed IDs of the "HostToUser" edge to the User entity.
func (m *HostMutation) RemovedHostToUserIDs() (ids []uuid.UUID) {
	for id := range m.removed_HostToUser {
		ids = append(ids, id)
	}
	return
}

// HostToUserIDs returns the "HostToUser" edge IDs in the mutation.
func (m *HostMutation) HostToUserIDs() (ids []uuid.UUID) {
	for id := range m._HostToUser {
		ids = append(ids, id)
	}
	return
}

// ResetHostToUser resets all changes to the "HostToUser" edge.
func (m *HostMutation) ResetHostToUser() {
	m._HostToUser = nil
	m.cleared_HostToUser = false
	m.removed_HostToUser = nil
}

// SetHostToEnvironmentID sets the "HostToEnvironment" edge to the Environment entity by id.
func (m *HostMutation) SetHostToEnvironmentID(id uuid.UUID) {
	m._HostToEnvironment = &id
}

// ClearHostToEnvironment clears the "HostToEnvironment" edge to the Environment entity.
func (m *HostMutation) ClearHostToEnvironment() {
	m.cleared_HostToEnvironment = true
}

// HostToEnvironmentCleared reports if the "HostToEnvironment" edge to the Environment entity was cleared.
func (m *HostMutation) HostToEnvironmentCleared() bool {
	return m.cleared_HostToEnvironment
}

// HostToEnvironmentID returns the "HostToEnvironment" edge ID in the mutation.
func (m *HostMutation) HostToEnvironmentID() (id uuid.UUID, exists bool) {
	if m._HostToEnvironment != nil {
		return *m._HostToEnvironment, true
	}
	return
}

// HostToEnvironmentIDs returns the "HostToEnvironment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostToEnvironmentID instead. It exists only for internal usage by the builders.
func (m *HostMutation) HostToEnvironmentIDs() (ids []uuid.UUID) {
	if id := m._HostToEnvironment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHostToEnvironment resets all changes to the "HostToEnvironment" edge.
func (m *HostMutation) ResetHostToEnvironment() {
	m._HostToEnvironment = nil
	m.cleared_HostToEnvironment = false
}

// AddHostToIncludedNetworkIDs adds the "HostToIncludedNetwork" edge to the IncludedNetwork entity by ids.
func (m *HostMutation) AddHostToIncludedNetworkIDs(ids ...uuid.UUID) {
	if m._HostToIncludedNetwork == nil {
		m._HostToIncludedNetwork = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._HostToIncludedNetwork[ids[i]] = struct{}{}
	}
}

// ClearHostToIncludedNetwork clears the "HostToIncludedNetwork" edge to the IncludedNetwork entity.
func (m *HostMutation) ClearHostToIncludedNetwork() {
	m.cleared_HostToIncludedNetwork = true
}

// HostToIncludedNetworkCleared reports if the "HostToIncludedNetwork" edge to the IncludedNetwork entity was cleared.
func (m *HostMutation) HostToIncludedNetworkCleared() bool {
	return m.cleared_HostToIncludedNetwork
}

// RemoveHostToIncludedNetworkIDs removes the "HostToIncludedNetwork" edge to the IncludedNetwork entity by IDs.
func (m *HostMutation) RemoveHostToIncludedNetworkIDs(ids ...uuid.UUID) {
	if m.removed_HostToIncludedNetwork == nil {
		m.removed_HostToIncludedNetwork = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._HostToIncludedNetwork, ids[i])
		m.removed_HostToIncludedNetwork[ids[i]] = struct{}{}
	}
}

// RemovedHostToIncludedNetwork returns the removed IDs of the "HostToIncludedNetwork" edge to the IncludedNetwork entity.
func (m *HostMutation) RemovedHostToIncludedNetworkIDs() (ids []uuid.UUID) {
	for id := range m.removed_HostToIncludedNetwork {
		ids = append(ids, id)
	}
	return
}

// HostToIncludedNetworkIDs returns the "HostToIncludedNetwork" edge IDs in the mutation.
func (m *HostMutation) HostToIncludedNetworkIDs() (ids []uuid.UUID) {
	for id := range m._HostToIncludedNetwork {
		ids = append(ids, id)
	}
	return
}

// ResetHostToIncludedNetwork resets all changes to the "HostToIncludedNetwork" edge.
func (m *HostMutation) ResetHostToIncludedNetwork() {
	m._HostToIncludedNetwork = nil
	m.cleared_HostToIncludedNetwork = false
	m.removed_HostToIncludedNetwork = nil
}

// AddDependOnHostToHostDependencyIDs adds the "DependOnHostToHostDependency" edge to the HostDependency entity by ids.
func (m *HostMutation) AddDependOnHostToHostDependencyIDs(ids ...uuid.UUID) {
	if m._DependOnHostToHostDependency == nil {
		m._DependOnHostToHostDependency = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._DependOnHostToHostDependency[ids[i]] = struct{}{}
	}
}

// ClearDependOnHostToHostDependency clears the "DependOnHostToHostDependency" edge to the HostDependency entity.
func (m *HostMutation) ClearDependOnHostToHostDependency() {
	m.cleared_DependOnHostToHostDependency = true
}

// DependOnHostToHostDependencyCleared reports if the "DependOnHostToHostDependency" edge to the HostDependency entity was cleared.
func (m *HostMutation) DependOnHostToHostDependencyCleared() bool {
	return m.cleared_DependOnHostToHostDependency
}

// RemoveDependOnHostToHostDependencyIDs removes the "DependOnHostToHostDependency" edge to the HostDependency entity by IDs.
func (m *HostMutation) RemoveDependOnHostToHostDependencyIDs(ids ...uuid.UUID) {
	if m.removed_DependOnHostToHostDependency == nil {
		m.removed_DependOnHostToHostDependency = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._DependOnHostToHostDependency, ids[i])
		m.removed_DependOnHostToHostDependency[ids[i]] = struct{}{}
	}
}

// RemovedDependOnHostToHostDependency returns the removed IDs of the "DependOnHostToHostDependency" edge to the HostDependency entity.
func (m *HostMutation) RemovedDependOnHostToHostDependencyIDs() (ids []uuid.UUID) {
	for id := range m.removed_DependOnHostToHostDependency {
		ids = append(ids, id)
	}
	return
}

// DependOnHostToHostDependencyIDs returns the "DependOnHostToHostDependency" edge IDs in the mutation.
func (m *HostMutation) DependOnHostToHostDependencyIDs() (ids []uuid.UUID) {
	for id := range m._DependOnHostToHostDependency {
		ids = append(ids, id)
	}
	return
}

// ResetDependOnHostToHostDependency resets all changes to the "DependOnHostToHostDependency" edge.
func (m *HostMutation) ResetDependOnHostToHostDependency() {
	m._DependOnHostToHostDependency = nil
	m.cleared_DependOnHostToHostDependency = false
	m.removed_DependOnHostToHostDependency = nil
}

// AddDependByHostToHostDependencyIDs adds the "DependByHostToHostDependency" edge to the HostDependency entity by ids.
func (m *HostMutation) AddDependByHostToHostDependencyIDs(ids ...uuid.UUID) {
	if m._DependByHostToHostDependency == nil {
		m._DependByHostToHostDependency = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._DependByHostToHostDependency[ids[i]] = struct{}{}
	}
}

// ClearDependByHostToHostDependency clears the "DependByHostToHostDependency" edge to the HostDependency entity.
func (m *HostMutation) ClearDependByHostToHostDependency() {
	m.cleared_DependByHostToHostDependency = true
}

// DependByHostToHostDependencyCleared reports if the "DependByHostToHostDependency" edge to the HostDependency entity was cleared.
func (m *HostMutation) DependByHostToHostDependencyCleared() bool {
	return m.cleared_DependByHostToHostDependency
}

// RemoveDependByHostToHostDependencyIDs removes the "DependByHostToHostDependency" edge to the HostDependency entity by IDs.
func (m *HostMutation) RemoveDependByHostToHostDependencyIDs(ids ...uuid.UUID) {
	if m.removed_DependByHostToHostDependency == nil {
		m.removed_DependByHostToHostDependency = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._DependByHostToHostDependency, ids[i])
		m.removed_DependByHostToHostDependency[ids[i]] = struct{}{}
	}
}

// RemovedDependByHostToHostDependency returns the removed IDs of the "DependByHostToHostDependency" edge to the HostDependency entity.
func (m *HostMutation) RemovedDependByHostToHostDependencyIDs() (ids []uuid.UUID) {
	for id := range m.removed_DependByHostToHostDependency {
		ids = append(ids, id)
	}
	return
}

// DependByHostToHostDependencyIDs returns the "DependByHostToHostDependency" edge IDs in the mutation.
func (m *HostMutation) DependByHostToHostDependencyIDs() (ids []uuid.UUID) {
	for id := range m._DependByHostToHostDependency {
		ids = append(ids, id)
	}
	return
}

// ResetDependByHostToHostDependency resets all changes to the "DependByHostToHostDependency" edge.
func (m *HostMutation) ResetDependByHostToHostDependency() {
	m._DependByHostToHostDependency = nil
	m.cleared_DependByHostToHostDependency = false
	m.removed_DependByHostToHostDependency = nil
}

// Where appends a list predicates to the HostMutation builder.
func (m *HostMutation) Where(ps ...predicate.Host) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Host, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Host).
func (m *HostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HostMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.hcl_id != nil {
		fields = append(fields, host.FieldHCLID)
	}
	if m.hostname != nil {
		fields = append(fields, host.FieldHostname)
	}
	if m.description != nil {
		fields = append(fields, host.FieldDescription)
	}
	if m._OS != nil {
		fields = append(fields, host.FieldOS)
	}
	if m.last_octet != nil {
		fields = append(fields, host.FieldLastOctet)
	}
	if m.instance_size != nil {
		fields = append(fields, host.FieldInstanceSize)
	}
	if m.allow_mac_changes != nil {
		fields = append(fields, host.FieldAllowMACChanges)
	}
	if m.exposed_tcp_ports != nil {
		fields = append(fields, host.FieldExposedTCPPorts)
	}
	if m.exposed_udp_ports != nil {
		fields = append(fields, host.FieldExposedUDPPorts)
	}
	if m.override_password != nil {
		fields = append(fields, host.FieldOverridePassword)
	}
	if m.vars != nil {
		fields = append(fields, host.FieldVars)
	}
	if m.user_groups != nil {
		fields = append(fields, host.FieldUserGroups)
	}
	if m.provision_steps != nil {
		fields = append(fields, host.FieldProvisionSteps)
	}
	if m.tags != nil {
		fields = append(fields, host.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case host.FieldHCLID:
		return m.HCLID()
	case host.FieldHostname:
		return m.Hostname()
	case host.FieldDescription:
		return m.Description()
	case host.FieldOS:
		return m.OS()
	case host.FieldLastOctet:
		return m.LastOctet()
	case host.FieldInstanceSize:
		return m.InstanceSize()
	case host.FieldAllowMACChanges:
		return m.AllowMACChanges()
	case host.FieldExposedTCPPorts:
		return m.ExposedTCPPorts()
	case host.FieldExposedUDPPorts:
		return m.ExposedUDPPorts()
	case host.FieldOverridePassword:
		return m.OverridePassword()
	case host.FieldVars:
		return m.Vars()
	case host.FieldUserGroups:
		return m.UserGroups()
	case host.FieldProvisionSteps:
		return m.ProvisionSteps()
	case host.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case host.FieldHCLID:
		return m.OldHCLID(ctx)
	case host.FieldHostname:
		return m.OldHostname(ctx)
	case host.FieldDescription:
		return m.OldDescription(ctx)
	case host.FieldOS:
		return m.OldOS(ctx)
	case host.FieldLastOctet:
		return m.OldLastOctet(ctx)
	case host.FieldInstanceSize:
		return m.OldInstanceSize(ctx)
	case host.FieldAllowMACChanges:
		return m.OldAllowMACChanges(ctx)
	case host.FieldExposedTCPPorts:
		return m.OldExposedTCPPorts(ctx)
	case host.FieldExposedUDPPorts:
		return m.OldExposedUDPPorts(ctx)
	case host.FieldOverridePassword:
		return m.OldOverridePassword(ctx)
	case host.FieldVars:
		return m.OldVars(ctx)
	case host.FieldUserGroups:
		return m.OldUserGroups(ctx)
	case host.FieldProvisionSteps:
		return m.OldProvisionSteps(ctx)
	case host.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Host field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case host.FieldHCLID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHCLID(v)
		return nil
	case host.FieldHostname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostname(v)
		return nil
	case host.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case host.FieldOS:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOS(v)
		return nil
	case host.FieldLastOctet:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastOctet(v)
		return nil
	case host.FieldInstanceSize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceSize(v)
		return nil
	case host.FieldAllowMACChanges:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowMACChanges(v)
		return nil
	case host.FieldExposedTCPPorts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExposedTCPPorts(v)
		return nil
	case host.FieldExposedUDPPorts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExposedUDPPorts(v)
		return nil
	case host.FieldOverridePassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverridePassword(v)
		return nil
	case host.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	case host.FieldUserGroups:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserGroups(v)
		return nil
	case host.FieldProvisionSteps:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvisionSteps(v)
		return nil
	case host.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Host field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HostMutation) AddedFields() []string {
	var fields []string
	if m.addlast_octet != nil {
		fields = append(fields, host.FieldLastOctet)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case host.FieldLastOctet:
		return m.AddedLastOctet()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case host.FieldLastOctet:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastOctet(v)
		return nil
	}
	return fmt.Errorf("unknown Host numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(host.FieldProvisionSteps) {
		fields = append(fields, host.FieldProvisionSteps)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HostMutation) ClearField(name string) error {
	switch name {
	case host.FieldProvisionSteps:
		m.ClearProvisionSteps()
		return nil
	}
	return fmt.Errorf("unknown Host nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HostMutation) ResetField(name string) error {
	switch name {
	case host.FieldHCLID:
		m.ResetHCLID()
		return nil
	case host.FieldHostname:
		m.ResetHostname()
		return nil
	case host.FieldDescription:
		m.ResetDescription()
		return nil
	case host.FieldOS:
		m.ResetOS()
		return nil
	case host.FieldLastOctet:
		m.ResetLastOctet()
		return nil
	case host.FieldInstanceSize:
		m.ResetInstanceSize()
		return nil
	case host.FieldAllowMACChanges:
		m.ResetAllowMACChanges()
		return nil
	case host.FieldExposedTCPPorts:
		m.ResetExposedTCPPorts()
		return nil
	case host.FieldExposedUDPPorts:
		m.ResetExposedUDPPorts()
		return nil
	case host.FieldOverridePassword:
		m.ResetOverridePassword()
		return nil
	case host.FieldVars:
		m.ResetVars()
		return nil
	case host.FieldUserGroups:
		m.ResetUserGroups()
		return nil
	case host.FieldProvisionSteps:
		m.ResetProvisionSteps()
		return nil
	case host.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Host field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HostMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m._HostToDisk != nil {
		edges = append(edges, host.EdgeHostToDisk)
	}
	if m._HostToUser != nil {
		edges = append(edges, host.EdgeHostToUser)
	}
	if m._HostToEnvironment != nil {
		edges = append(edges, host.EdgeHostToEnvironment)
	}
	if m._HostToIncludedNetwork != nil {
		edges = append(edges, host.EdgeHostToIncludedNetwork)
	}
	if m._DependOnHostToHostDependency != nil {
		edges = append(edges, host.EdgeDependOnHostToHostDependency)
	}
	if m._DependByHostToHostDependency != nil {
		edges = append(edges, host.EdgeDependByHostToHostDependency)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case host.EdgeHostToDisk:
		if id := m._HostToDisk; id != nil {
			return []ent.Value{*id}
		}
	case host.EdgeHostToUser:
		ids := make([]ent.Value, 0, len(m._HostToUser))
		for id := range m._HostToUser {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeHostToEnvironment:
		if id := m._HostToEnvironment; id != nil {
			return []ent.Value{*id}
		}
	case host.EdgeHostToIncludedNetwork:
		ids := make([]ent.Value, 0, len(m._HostToIncludedNetwork))
		for id := range m._HostToIncludedNetwork {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeDependOnHostToHostDependency:
		ids := make([]ent.Value, 0, len(m._DependOnHostToHostDependency))
		for id := range m._DependOnHostToHostDependency {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeDependByHostToHostDependency:
		ids := make([]ent.Value, 0, len(m._DependByHostToHostDependency))
		for id := range m._DependByHostToHostDependency {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removed_HostToUser != nil {
		edges = append(edges, host.EdgeHostToUser)
	}
	if m.removed_HostToIncludedNetwork != nil {
		edges = append(edges, host.EdgeHostToIncludedNetwork)
	}
	if m.removed_DependOnHostToHostDependency != nil {
		edges = append(edges, host.EdgeDependOnHostToHostDependency)
	}
	if m.removed_DependByHostToHostDependency != nil {
		edges = append(edges, host.EdgeDependByHostToHostDependency)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case host.EdgeHostToUser:
		ids := make([]ent.Value, 0, len(m.removed_HostToUser))
		for id := range m.removed_HostToUser {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeHostToIncludedNetwork:
		ids := make([]ent.Value, 0, len(m.removed_HostToIncludedNetwork))
		for id := range m.removed_HostToIncludedNetwork {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeDependOnHostToHostDependency:
		ids := make([]ent.Value, 0, len(m.removed_DependOnHostToHostDependency))
		for id := range m.removed_DependOnHostToHostDependency {
			ids = append(ids, id)
		}
		return ids
	case host.EdgeDependByHostToHostDependency:
		ids := make([]ent.Value, 0, len(m.removed_DependByHostToHostDependency))
		for id := range m.removed_DependByHostToHostDependency {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleared_HostToDisk {
		edges = append(edges, host.EdgeHostToDisk)
	}
	if m.cleared_HostToUser {
		edges = append(edges, host.EdgeHostToUser)
	}
	if m.cleared_HostToEnvironment {
		edges = append(edges, host.EdgeHostToEnvironment)
	}
	if m.cleared_HostToIncludedNetwork {
		edges = append(edges, host.EdgeHostToIncludedNetwork)
	}
	if m.cleared_DependOnHostToHostDependency {
		edges = append(edges, host.EdgeDependOnHostToHostDependency)
	}
	if m.cleared_DependByHostToHostDependency {
		edges = append(edges, host.EdgeDependByHostToHostDependency)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HostMutation) EdgeCleared(name string) bool {
	switch name {
	case host.EdgeHostToDisk:
		return m.cleared_HostToDisk
	case host.EdgeHostToUser:
		return m.cleared_HostToUser
	case host.EdgeHostToEnvironment:
		return m.cleared_HostToEnvironment
	case host.EdgeHostToIncludedNetwork:
		return m.cleared_HostToIncludedNetwork
	case host.EdgeDependOnHostToHostDependency:
		return m.cleared_DependOnHostToHostDependency
	case host.EdgeDependByHostToHostDependency:
		return m.cleared_DependByHostToHostDependency
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HostMutation) ClearEdge(name string) error {
	switch name {
	case host.EdgeHostToDisk:
		m.ClearHostToDisk()
		return nil
	case host.EdgeHostToEnvironment:
		m.ClearHostToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Host unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HostMutation) ResetEdge(name string) error {
	switch name {
	case host.EdgeHostToDisk:
		m.ResetHostToDisk()
		return nil
	case host.EdgeHostToUser:
		m.ResetHostToUser()
		return nil
	case host.EdgeHostToEnvironment:
		m.ResetHostToEnvironment()
		return nil
	case host.EdgeHostToIncludedNetwork:
		m.ResetHostToIncludedNetwork()
		return nil
	case host.EdgeDependOnHostToHostDependency:
		m.ResetDependOnHostToHostDependency()
		return nil
	case host.EdgeDependByHostToHostDependency:
		m.ResetDependByHostToHostDependency()
		return nil
	}
	return fmt.Errorf("unknown Host edge %s", name)
}

// HostDependencyMutation represents an operation that mutates the HostDependency nodes in the graph.
type HostDependencyMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *uuid.UUID
	host_id                              *string
	network_id                           *string
	clearedFields                        map[string]struct{}
	_HostDependencyToDependOnHost        *uuid.UUID
	cleared_HostDependencyToDependOnHost bool
	_HostDependencyToDependByHost        *uuid.UUID
	cleared_HostDependencyToDependByHost bool
	_HostDependencyToNetwork             *uuid.UUID
	cleared_HostDependencyToNetwork      bool
	_HostDependencyToEnvironment         *uuid.UUID
	cleared_HostDependencyToEnvironment  bool
	done                                 bool
	oldValue                             func(context.Context) (*HostDependency, error)
	predicates                           []predicate.HostDependency
}

var _ ent.Mutation = (*HostDependencyMutation)(nil)

// hostdependencyOption allows management of the mutation configuration using functional options.
type hostdependencyOption func(*HostDependencyMutation)

// newHostDependencyMutation creates new mutation for the HostDependency entity.
func newHostDependencyMutation(c config, op Op, opts ...hostdependencyOption) *HostDependencyMutation {
	m := &HostDependencyMutation{
		config:        c,
		op:            op,
		typ:           TypeHostDependency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHostDependencyID sets the ID field of the mutation.
func withHostDependencyID(id uuid.UUID) hostdependencyOption {
	return func(m *HostDependencyMutation) {
		var (
			err   error
			once  sync.Once
			value *HostDependency
		)
		m.oldValue = func(ctx context.Context) (*HostDependency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HostDependency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHostDependency sets the old HostDependency of the mutation.
func withHostDependency(node *HostDependency) hostdependencyOption {
	return func(m *HostDependencyMutation) {
		m.oldValue = func(context.Context) (*HostDependency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HostDependencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HostDependencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HostDependency entities.
func (m *HostDependencyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HostDependencyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HostDependencyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HostDependency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHostID sets the "host_id" field.
func (m *HostDependencyMutation) SetHostID(s string) {
	m.host_id = &s
}

// HostID returns the value of the "host_id" field in the mutation.
func (m *HostDependencyMutation) HostID() (r string, exists bool) {
	v := m.host_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHostID returns the old "host_id" field's value of the HostDependency entity.
// If the HostDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostDependencyMutation) OldHostID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostID: %w", err)
	}
	return oldValue.HostID, nil
}

// ResetHostID resets all changes to the "host_id" field.
func (m *HostDependencyMutation) ResetHostID() {
	m.host_id = nil
}

// SetNetworkID sets the "network_id" field.
func (m *HostDependencyMutation) SetNetworkID(s string) {
	m.network_id = &s
}

// NetworkID returns the value of the "network_id" field in the mutation.
func (m *HostDependencyMutation) NetworkID() (r string, exists bool) {
	v := m.network_id
	if v == nil {
		return
	}
	return *v, true
}

// OldNetworkID returns the old "network_id" field's value of the HostDependency entity.
// If the HostDependency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostDependencyMutation) OldNetworkID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetworkID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetworkID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetworkID: %w", err)
	}
	return oldValue.NetworkID, nil
}

// ResetNetworkID resets all changes to the "network_id" field.
func (m *HostDependencyMutation) ResetNetworkID() {
	m.network_id = nil
}

// SetHostDependencyToDependOnHostID sets the "HostDependencyToDependOnHost" edge to the Host entity by id.
func (m *HostDependencyMutation) SetHostDependencyToDependOnHostID(id uuid.UUID) {
	m._HostDependencyToDependOnHost = &id
}

// ClearHostDependencyToDependOnHost clears the "HostDependencyToDependOnHost" edge to the Host entity.
func (m *HostDependencyMutation) ClearHostDependencyToDependOnHost() {
	m.cleared_HostDependencyToDependOnHost = true
}

// HostDependencyToDependOnHostCleared reports if the "HostDependencyToDependOnHost" edge to the Host entity was cleared.
func (m *HostDependencyMutation) HostDependencyToDependOnHostCleared() bool {
	return m.cleared_HostDependencyToDependOnHost
}

// HostDependencyToDependOnHostID returns the "HostDependencyToDependOnHost" edge ID in the mutation.
func (m *HostDependencyMutation) HostDependencyToDependOnHostID() (id uuid.UUID, exists bool) {
	if m._HostDependencyToDependOnHost != nil {
		return *m._HostDependencyToDependOnHost, true
	}
	return
}

// HostDependencyToDependOnHostIDs returns the "HostDependencyToDependOnHost" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostDependencyToDependOnHostID instead. It exists only for internal usage by the builders.
func (m *HostDependencyMutation) HostDependencyToDependOnHostIDs() (ids []uuid.UUID) {
	if id := m._HostDependencyToDependOnHost; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHostDependencyToDependOnHost resets all changes to the "HostDependencyToDependOnHost" edge.
func (m *HostDependencyMutation) ResetHostDependencyToDependOnHost() {
	m._HostDependencyToDependOnHost = nil
	m.cleared_HostDependencyToDependOnHost = false
}

// SetHostDependencyToDependByHostID sets the "HostDependencyToDependByHost" edge to the Host entity by id.
func (m *HostDependencyMutation) SetHostDependencyToDependByHostID(id uuid.UUID) {
	m._HostDependencyToDependByHost = &id
}

// ClearHostDependencyToDependByHost clears the "HostDependencyToDependByHost" edge to the Host entity.
func (m *HostDependencyMutation) ClearHostDependencyToDependByHost() {
	m.cleared_HostDependencyToDependByHost = true
}

// HostDependencyToDependByHostCleared reports if the "HostDependencyToDependByHost" edge to the Host entity was cleared.
func (m *HostDependencyMutation) HostDependencyToDependByHostCleared() bool {
	return m.cleared_HostDependencyToDependByHost
}

// HostDependencyToDependByHostID returns the "HostDependencyToDependByHost" edge ID in the mutation.
func (m *HostDependencyMutation) HostDependencyToDependByHostID() (id uuid.UUID, exists bool) {
	if m._HostDependencyToDependByHost != nil {
		return *m._HostDependencyToDependByHost, true
	}
	return
}

// HostDependencyToDependByHostIDs returns the "HostDependencyToDependByHost" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostDependencyToDependByHostID instead. It exists only for internal usage by the builders.
func (m *HostDependencyMutation) HostDependencyToDependByHostIDs() (ids []uuid.UUID) {
	if id := m._HostDependencyToDependByHost; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHostDependencyToDependByHost resets all changes to the "HostDependencyToDependByHost" edge.
func (m *HostDependencyMutation) ResetHostDependencyToDependByHost() {
	m._HostDependencyToDependByHost = nil
	m.cleared_HostDependencyToDependByHost = false
}

// SetHostDependencyToNetworkID sets the "HostDependencyToNetwork" edge to the Network entity by id.
func (m *HostDependencyMutation) SetHostDependencyToNetworkID(id uuid.UUID) {
	m._HostDependencyToNetwork = &id
}

// ClearHostDependencyToNetwork clears the "HostDependencyToNetwork" edge to the Network entity.
func (m *HostDependencyMutation) ClearHostDependencyToNetwork() {
	m.cleared_HostDependencyToNetwork = true
}

// HostDependencyToNetworkCleared reports if the "HostDependencyToNetwork" edge to the Network entity was cleared.
func (m *HostDependencyMutation) HostDependencyToNetworkCleared() bool {
	return m.cleared_HostDependencyToNetwork
}

// HostDependencyToNetworkID returns the "HostDependencyToNetwork" edge ID in the mutation.
func (m *HostDependencyMutation) HostDependencyToNetworkID() (id uuid.UUID, exists bool) {
	if m._HostDependencyToNetwork != nil {
		return *m._HostDependencyToNetwork, true
	}
	return
}

// HostDependencyToNetworkIDs returns the "HostDependencyToNetwork" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostDependencyToNetworkID instead. It exists only for internal usage by the builders.
func (m *HostDependencyMutation) HostDependencyToNetworkIDs() (ids []uuid.UUID) {
	if id := m._HostDependencyToNetwork; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHostDependencyToNetwork resets all changes to the "HostDependencyToNetwork" edge.
func (m *HostDependencyMutation) ResetHostDependencyToNetwork() {
	m._HostDependencyToNetwork = nil
	m.cleared_HostDependencyToNetwork = false
}

// SetHostDependencyToEnvironmentID sets the "HostDependencyToEnvironment" edge to the Environment entity by id.
func (m *HostDependencyMutation) SetHostDependencyToEnvironmentID(id uuid.UUID) {
	m._HostDependencyToEnvironment = &id
}

// ClearHostDependencyToEnvironment clears the "HostDependencyToEnvironment" edge to the Environment entity.
func (m *HostDependencyMutation) ClearHostDependencyToEnvironment() {
	m.cleared_HostDependencyToEnvironment = true
}

// HostDependencyToEnvironmentCleared reports if the "HostDependencyToEnvironment" edge to the Environment entity was cleared.
func (m *HostDependencyMutation) HostDependencyToEnvironmentCleared() bool {
	return m.cleared_HostDependencyToEnvironment
}

// HostDependencyToEnvironmentID returns the "HostDependencyToEnvironment" edge ID in the mutation.
func (m *HostDependencyMutation) HostDependencyToEnvironmentID() (id uuid.UUID, exists bool) {
	if m._HostDependencyToEnvironment != nil {
		return *m._HostDependencyToEnvironment, true
	}
	return
}

// HostDependencyToEnvironmentIDs returns the "HostDependencyToEnvironment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostDependencyToEnvironmentID instead. It exists only for internal usage by the builders.
func (m *HostDependencyMutation) HostDependencyToEnvironmentIDs() (ids []uuid.UUID) {
	if id := m._HostDependencyToEnvironment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHostDependencyToEnvironment resets all changes to the "HostDependencyToEnvironment" edge.
func (m *HostDependencyMutation) ResetHostDependencyToEnvironment() {
	m._HostDependencyToEnvironment = nil
	m.cleared_HostDependencyToEnvironment = false
}

// Where appends a list predicates to the HostDependencyMutation builder.
func (m *HostDependencyMutation) Where(ps ...predicate.HostDependency) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HostDependencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HostDependencyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HostDependency, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HostDependencyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HostDependencyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HostDependency).
func (m *HostDependencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HostDependencyMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.host_id != nil {
		fields = append(fields, hostdependency.FieldHostID)
	}
	if m.network_id != nil {
		fields = append(fields, hostdependency.FieldNetworkID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HostDependencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hostdependency.FieldHostID:
		return m.HostID()
	case hostdependency.FieldNetworkID:
		return m.NetworkID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HostDependencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hostdependency.FieldHostID:
		return m.OldHostID(ctx)
	case hostdependency.FieldNetworkID:
		return m.OldNetworkID(ctx)
	}
	return nil, fmt.Errorf("unknown HostDependency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostDependencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hostdependency.FieldHostID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostID(v)
		return nil
	case hostdependency.FieldNetworkID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetworkID(v)
		return nil
	}
	return fmt.Errorf("unknown HostDependency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HostDependencyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HostDependencyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostDependencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HostDependency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HostDependencyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HostDependencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HostDependencyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HostDependency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HostDependencyMutation) ResetField(name string) error {
	switch name {
	case hostdependency.FieldHostID:
		m.ResetHostID()
		return nil
	case hostdependency.FieldNetworkID:
		m.ResetNetworkID()
		return nil
	}
	return fmt.Errorf("unknown HostDependency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HostDependencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._HostDependencyToDependOnHost != nil {
		edges = append(edges, hostdependency.EdgeHostDependencyToDependOnHost)
	}
	if m._HostDependencyToDependByHost != nil {
		edges = append(edges, hostdependency.EdgeHostDependencyToDependByHost)
	}
	if m._HostDependencyToNetwork != nil {
		edges = append(edges, hostdependency.EdgeHostDependencyToNetwork)
	}
	if m._HostDependencyToEnvironment != nil {
		edges = append(edges, hostdependency.EdgeHostDependencyToEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HostDependencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hostdependency.EdgeHostDependencyToDependOnHost:
		if id := m._HostDependencyToDependOnHost; id != nil {
			return []ent.Value{*id}
		}
	case hostdependency.EdgeHostDependencyToDependByHost:
		if id := m._HostDependencyToDependByHost; id != nil {
			return []ent.Value{*id}
		}
	case hostdependency.EdgeHostDependencyToNetwork:
		if id := m._HostDependencyToNetwork; id != nil {
			return []ent.Value{*id}
		}
	case hostdependency.EdgeHostDependencyToEnvironment:
		if id := m._HostDependencyToEnvironment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HostDependencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HostDependencyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HostDependencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_HostDependencyToDependOnHost {
		edges = append(edges, hostdependency.EdgeHostDependencyToDependOnHost)
	}
	if m.cleared_HostDependencyToDependByHost {
		edges = append(edges, hostdependency.EdgeHostDependencyToDependByHost)
	}
	if m.cleared_HostDependencyToNetwork {
		edges = append(edges, hostdependency.EdgeHostDependencyToNetwork)
	}
	if m.cleared_HostDependencyToEnvironment {
		edges = append(edges, hostdependency.EdgeHostDependencyToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HostDependencyMutation) EdgeCleared(name string) bool {
	switch name {
	case hostdependency.EdgeHostDependencyToDependOnHost:
		return m.cleared_HostDependencyToDependOnHost
	case hostdependency.EdgeHostDependencyToDependByHost:
		return m.cleared_HostDependencyToDependByHost
	case hostdependency.EdgeHostDependencyToNetwork:
		return m.cleared_HostDependencyToNetwork
	case hostdependency.EdgeHostDependencyToEnvironment:
		return m.cleared_HostDependencyToEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HostDependencyMutation) ClearEdge(name string) error {
	switch name {
	case hostdependency.EdgeHostDependencyToDependOnHost:
		m.ClearHostDependencyToDependOnHost()
		return nil
	case hostdependency.EdgeHostDependencyToDependByHost:
		m.ClearHostDependencyToDependByHost()
		return nil
	case hostdependency.EdgeHostDependencyToNetwork:
		m.ClearHostDependencyToNetwork()
		return nil
	case hostdependency.EdgeHostDependencyToEnvironment:
		m.ClearHostDependencyToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown HostDependency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HostDependencyMutation) ResetEdge(name string) error {
	switch name {
	case hostdependency.EdgeHostDependencyToDependOnHost:
		m.ResetHostDependencyToDependOnHost()
		return nil
	case hostdependency.EdgeHostDependencyToDependByHost:
		m.ResetHostDependencyToDependByHost()
		return nil
	case hostdependency.EdgeHostDependencyToNetwork:
		m.ResetHostDependencyToNetwork()
		return nil
	case hostdependency.EdgeHostDependencyToEnvironment:
		m.ResetHostDependencyToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown HostDependency edge %s", name)
}

// IdentityMutation represents an operation that mutates the Identity nodes in the graph.
type IdentityMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	hcl_id                        *string
	first_name                    *string
	last_name                     *string
	email                         *string
	password                      *string
	description                   *string
	avatar_file                   *string
	vars                          *map[string]string
	tags                          *map[string]string
	clearedFields                 map[string]struct{}
	_IdentityToEnvironment        *uuid.UUID
	cleared_IdentityToEnvironment bool
	done                          bool
	oldValue                      func(context.Context) (*Identity, error)
	predicates                    []predicate.Identity
}

var _ ent.Mutation = (*IdentityMutation)(nil)

// identityOption allows management of the mutation configuration using functional options.
type identityOption func(*IdentityMutation)

// newIdentityMutation creates new mutation for the Identity entity.
func newIdentityMutation(c config, op Op, opts ...identityOption) *IdentityMutation {
	m := &IdentityMutation{
		config:        c,
		op:            op,
		typ:           TypeIdentity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIdentityID sets the ID field of the mutation.
func withIdentityID(id uuid.UUID) identityOption {
	return func(m *IdentityMutation) {
		var (
			err   error
			once  sync.Once
			value *Identity
		)
		m.oldValue = func(ctx context.Context) (*Identity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Identity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIdentity sets the old Identity of the mutation.
func withIdentity(node *Identity) identityOption {
	return func(m *IdentityMutation) {
		m.oldValue = func(context.Context) (*Identity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IdentityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IdentityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Identity entities.
func (m *IdentityMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IdentityMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IdentityMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Identity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHCLID sets the "hcl_id" field.
func (m *IdentityMutation) SetHCLID(s string) {
	m.hcl_id = &s
}

// HCLID returns the value of the "hcl_id" field in the mutation.
func (m *IdentityMutation) HCLID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHCLID returns the old "hcl_id" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldHCLID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHCLID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHCLID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHCLID: %w", err)
	}
	return oldValue.HCLID, nil
}

// ResetHCLID resets all changes to the "hcl_id" field.
func (m *IdentityMutation) ResetHCLID() {
	m.hcl_id = nil
}

// SetFirstName sets the "first_name" field.
func (m *IdentityMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *IdentityMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *IdentityMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *IdentityMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *IdentityMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *IdentityMutation) ResetLastName() {
	m.last_name = nil
}

// SetEmail sets the "email" field.
func (m *IdentityMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *IdentityMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *IdentityMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *IdentityMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *IdentityMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *IdentityMutation) ResetPassword() {
	m.password = nil
}

// SetDescription sets the "description" field.
func (m *IdentityMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IdentityMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *IdentityMutation) ResetDescription() {
	m.description = nil
}

// SetAvatarFile sets the "avatar_file" field.
func (m *IdentityMutation) SetAvatarFile(s string) {
	m.avatar_file = &s
}

// AvatarFile returns the value of the "avatar_file" field in the mutation.
func (m *IdentityMutation) AvatarFile() (r string, exists bool) {
	v := m.avatar_file
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarFile returns the old "avatar_file" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldAvatarFile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarFile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarFile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarFile: %w", err)
	}
	return oldValue.AvatarFile, nil
}

// ResetAvatarFile resets all changes to the "avatar_file" field.
func (m *IdentityMutation) ResetAvatarFile() {
	m.avatar_file = nil
}

// SetVars sets the "vars" field.
func (m *IdentityMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *IdentityMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *IdentityMutation) ResetVars() {
	m.vars = nil
}

// SetTags sets the "tags" field.
func (m *IdentityMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *IdentityMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *IdentityMutation) ResetTags() {
	m.tags = nil
}

// SetIdentityToEnvironmentID sets the "IdentityToEnvironment" edge to the Environment entity by id.
func (m *IdentityMutation) SetIdentityToEnvironmentID(id uuid.UUID) {
	m._IdentityToEnvironment = &id
}

// ClearIdentityToEnvironment clears the "IdentityToEnvironment" edge to the Environment entity.
func (m *IdentityMutation) ClearIdentityToEnvironment() {
	m.cleared_IdentityToEnvironment = true
}

// IdentityToEnvironmentCleared reports if the "IdentityToEnvironment" edge to the Environment entity was cleared.
func (m *IdentityMutation) IdentityToEnvironmentCleared() bool {
	return m.cleared_IdentityToEnvironment
}

// IdentityToEnvironmentID returns the "IdentityToEnvironment" edge ID in the mutation.
func (m *IdentityMutation) IdentityToEnvironmentID() (id uuid.UUID, exists bool) {
	if m._IdentityToEnvironment != nil {
		return *m._IdentityToEnvironment, true
	}
	return
}

// IdentityToEnvironmentIDs returns the "IdentityToEnvironment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IdentityToEnvironmentID instead. It exists only for internal usage by the builders.
func (m *IdentityMutation) IdentityToEnvironmentIDs() (ids []uuid.UUID) {
	if id := m._IdentityToEnvironment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIdentityToEnvironment resets all changes to the "IdentityToEnvironment" edge.
func (m *IdentityMutation) ResetIdentityToEnvironment() {
	m._IdentityToEnvironment = nil
	m.cleared_IdentityToEnvironment = false
}

// Where appends a list predicates to the IdentityMutation builder.
func (m *IdentityMutation) Where(ps ...predicate.Identity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IdentityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IdentityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Identity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IdentityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IdentityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Identity).
func (m *IdentityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IdentityMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.hcl_id != nil {
		fields = append(fields, identity.FieldHCLID)
	}
	if m.first_name != nil {
		fields = append(fields, identity.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, identity.FieldLastName)
	}
	if m.email != nil {
		fields = append(fields, identity.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, identity.FieldPassword)
	}
	if m.description != nil {
		fields = append(fields, identity.FieldDescription)
	}
	if m.avatar_file != nil {
		fields = append(fields, identity.FieldAvatarFile)
	}
	if m.vars != nil {
		fields = append(fields, identity.FieldVars)
	}
	if m.tags != nil {
		fields = append(fields, identity.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IdentityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case identity.FieldHCLID:
		return m.HCLID()
	case identity.FieldFirstName:
		return m.FirstName()
	case identity.FieldLastName:
		return m.LastName()
	case identity.FieldEmail:
		return m.Email()
	case identity.FieldPassword:
		return m.Password()
	case identity.FieldDescription:
		return m.Description()
	case identity.FieldAvatarFile:
		return m.AvatarFile()
	case identity.FieldVars:
		return m.Vars()
	case identity.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IdentityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case identity.FieldHCLID:
		return m.OldHCLID(ctx)
	case identity.FieldFirstName:
		return m.OldFirstName(ctx)
	case identity.FieldLastName:
		return m.OldLastName(ctx)
	case identity.FieldEmail:
		return m.OldEmail(ctx)
	case identity.FieldPassword:
		return m.OldPassword(ctx)
	case identity.FieldDescription:
		return m.OldDescription(ctx)
	case identity.FieldAvatarFile:
		return m.OldAvatarFile(ctx)
	case identity.FieldVars:
		return m.OldVars(ctx)
	case identity.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Identity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdentityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case identity.FieldHCLID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHCLID(v)
		return nil
	case identity.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case identity.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case identity.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case identity.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case identity.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case identity.FieldAvatarFile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarFile(v)
		return nil
	case identity.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	case identity.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Identity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IdentityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IdentityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdentityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Identity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IdentityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IdentityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IdentityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Identity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IdentityMutation) ResetField(name string) error {
	switch name {
	case identity.FieldHCLID:
		m.ResetHCLID()
		return nil
	case identity.FieldFirstName:
		m.ResetFirstName()
		return nil
	case identity.FieldLastName:
		m.ResetLastName()
		return nil
	case identity.FieldEmail:
		m.ResetEmail()
		return nil
	case identity.FieldPassword:
		m.ResetPassword()
		return nil
	case identity.FieldDescription:
		m.ResetDescription()
		return nil
	case identity.FieldAvatarFile:
		m.ResetAvatarFile()
		return nil
	case identity.FieldVars:
		m.ResetVars()
		return nil
	case identity.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Identity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IdentityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._IdentityToEnvironment != nil {
		edges = append(edges, identity.EdgeIdentityToEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IdentityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case identity.EdgeIdentityToEnvironment:
		if id := m._IdentityToEnvironment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IdentityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IdentityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IdentityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_IdentityToEnvironment {
		edges = append(edges, identity.EdgeIdentityToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IdentityMutation) EdgeCleared(name string) bool {
	switch name {
	case identity.EdgeIdentityToEnvironment:
		return m.cleared_IdentityToEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IdentityMutation) ClearEdge(name string) error {
	switch name {
	case identity.EdgeIdentityToEnvironment:
		m.ClearIdentityToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Identity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IdentityMutation) ResetEdge(name string) error {
	switch name {
	case identity.EdgeIdentityToEnvironment:
		m.ResetIdentityToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Identity edge %s", name)
}

// IncludedNetworkMutation represents an operation that mutates the IncludedNetwork nodes in the graph.
type IncludedNetworkMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *uuid.UUID
	name                                 *string
	hosts                                *[]string
	appendhosts                          []string
	clearedFields                        map[string]struct{}
	_IncludedNetworkToTag                map[uuid.UUID]struct{}
	removed_IncludedNetworkToTag         map[uuid.UUID]struct{}
	cleared_IncludedNetworkToTag         bool
	_IncludedNetworkToHost               map[uuid.UUID]struct{}
	removed_IncludedNetworkToHost        map[uuid.UUID]struct{}
	cleared_IncludedNetworkToHost        bool
	_IncludedNetworkToNetwork            *uuid.UUID
	cleared_IncludedNetworkToNetwork     bool
	_IncludedNetworkToEnvironment        map[uuid.UUID]struct{}
	removed_IncludedNetworkToEnvironment map[uuid.UUID]struct{}
	cleared_IncludedNetworkToEnvironment bool
	done                                 bool
	oldValue                             func(context.Context) (*IncludedNetwork, error)
	predicates                           []predicate.IncludedNetwork
}

var _ ent.Mutation = (*IncludedNetworkMutation)(nil)

// includednetworkOption allows management of the mutation configuration using functional options.
type includednetworkOption func(*IncludedNetworkMutation)

// newIncludedNetworkMutation creates new mutation for the IncludedNetwork entity.
func newIncludedNetworkMutation(c config, op Op, opts ...includednetworkOption) *IncludedNetworkMutation {
	m := &IncludedNetworkMutation{
		config:        c,
		op:            op,
		typ:           TypeIncludedNetwork,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncludedNetworkID sets the ID field of the mutation.
func withIncludedNetworkID(id uuid.UUID) includednetworkOption {
	return func(m *IncludedNetworkMutation) {
		var (
			err   error
			once  sync.Once
			value *IncludedNetwork
		)
		m.oldValue = func(ctx context.Context) (*IncludedNetwork, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IncludedNetwork.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncludedNetwork sets the old IncludedNetwork of the mutation.
func withIncludedNetwork(node *IncludedNetwork) includednetworkOption {
	return func(m *IncludedNetworkMutation) {
		m.oldValue = func(context.Context) (*IncludedNetwork, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncludedNetworkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncludedNetworkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IncludedNetwork entities.
func (m *IncludedNetworkMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncludedNetworkMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncludedNetworkMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IncludedNetwork.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *IncludedNetworkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IncludedNetworkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the IncludedNetwork entity.
// If the IncludedNetwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncludedNetworkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IncludedNetworkMutation) ResetName() {
	m.name = nil
}

// SetHosts sets the "hosts" field.
func (m *IncludedNetworkMutation) SetHosts(s []string) {
	m.hosts = &s
	m.appendhosts = nil
}

// Hosts returns the value of the "hosts" field in the mutation.
func (m *IncludedNetworkMutation) Hosts() (r []string, exists bool) {
	v := m.hosts
	if v == nil {
		return
	}
	return *v, true
}

// OldHosts returns the old "hosts" field's value of the IncludedNetwork entity.
// If the IncludedNetwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncludedNetworkMutation) OldHosts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHosts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHosts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHosts: %w", err)
	}
	return oldValue.Hosts, nil
}

// AppendHosts adds s to the "hosts" field.
func (m *IncludedNetworkMutation) AppendHosts(s []string) {
	m.appendhosts = append(m.appendhosts, s...)
}

// AppendedHosts returns the list of values that were appended to the "hosts" field in this mutation.
func (m *IncludedNetworkMutation) AppendedHosts() ([]string, bool) {
	if len(m.appendhosts) == 0 {
		return nil, false
	}
	return m.appendhosts, true
}

// ResetHosts resets all changes to the "hosts" field.
func (m *IncludedNetworkMutation) ResetHosts() {
	m.hosts = nil
	m.appendhosts = nil
}

// AddIncludedNetworkToTagIDs adds the "IncludedNetworkToTag" edge to the Tag entity by ids.
func (m *IncludedNetworkMutation) AddIncludedNetworkToTagIDs(ids ...uuid.UUID) {
	if m._IncludedNetworkToTag == nil {
		m._IncludedNetworkToTag = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._IncludedNetworkToTag[ids[i]] = struct{}{}
	}
}

// ClearIncludedNetworkToTag clears the "IncludedNetworkToTag" edge to the Tag entity.
func (m *IncludedNetworkMutation) ClearIncludedNetworkToTag() {
	m.cleared_IncludedNetworkToTag = true
}

// IncludedNetworkToTagCleared reports if the "IncludedNetworkToTag" edge to the Tag entity was cleared.
func (m *IncludedNetworkMutation) IncludedNetworkToTagCleared() bool {
	return m.cleared_IncludedNetworkToTag
}

// RemoveIncludedNetworkToTagIDs removes the "IncludedNetworkToTag" edge to the Tag entity by IDs.
func (m *IncludedNetworkMutation) RemoveIncludedNetworkToTagIDs(ids ...uuid.UUID) {
	if m.removed_IncludedNetworkToTag == nil {
		m.removed_IncludedNetworkToTag = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._IncludedNetworkToTag, ids[i])
		m.removed_IncludedNetworkToTag[ids[i]] = struct{}{}
	}
}

// RemovedIncludedNetworkToTag returns the removed IDs of the "IncludedNetworkToTag" edge to the Tag entity.
func (m *IncludedNetworkMutation) RemovedIncludedNetworkToTagIDs() (ids []uuid.UUID) {
	for id := range m.removed_IncludedNetworkToTag {
		ids = append(ids, id)
	}
	return
}

// IncludedNetworkToTagIDs returns the "IncludedNetworkToTag" edge IDs in the mutation.
func (m *IncludedNetworkMutation) IncludedNetworkToTagIDs() (ids []uuid.UUID) {
	for id := range m._IncludedNetworkToTag {
		ids = append(ids, id)
	}
	return
}

// ResetIncludedNetworkToTag resets all changes to the "IncludedNetworkToTag" edge.
func (m *IncludedNetworkMutation) ResetIncludedNetworkToTag() {
	m._IncludedNetworkToTag = nil
	m.cleared_IncludedNetworkToTag = false
	m.removed_IncludedNetworkToTag = nil
}

// AddIncludedNetworkToHostIDs adds the "IncludedNetworkToHost" edge to the Host entity by ids.
func (m *IncludedNetworkMutation) AddIncludedNetworkToHostIDs(ids ...uuid.UUID) {
	if m._IncludedNetworkToHost == nil {
		m._IncludedNetworkToHost = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._IncludedNetworkToHost[ids[i]] = struct{}{}
	}
}

// ClearIncludedNetworkToHost clears the "IncludedNetworkToHost" edge to the Host entity.
func (m *IncludedNetworkMutation) ClearIncludedNetworkToHost() {
	m.cleared_IncludedNetworkToHost = true
}

// IncludedNetworkToHostCleared reports if the "IncludedNetworkToHost" edge to the Host entity was cleared.
func (m *IncludedNetworkMutation) IncludedNetworkToHostCleared() bool {
	return m.cleared_IncludedNetworkToHost
}

// RemoveIncludedNetworkToHostIDs removes the "IncludedNetworkToHost" edge to the Host entity by IDs.
func (m *IncludedNetworkMutation) RemoveIncludedNetworkToHostIDs(ids ...uuid.UUID) {
	if m.removed_IncludedNetworkToHost == nil {
		m.removed_IncludedNetworkToHost = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._IncludedNetworkToHost, ids[i])
		m.removed_IncludedNetworkToHost[ids[i]] = struct{}{}
	}
}

// RemovedIncludedNetworkToHost returns the removed IDs of the "IncludedNetworkToHost" edge to the Host entity.
func (m *IncludedNetworkMutation) RemovedIncludedNetworkToHostIDs() (ids []uuid.UUID) {
	for id := range m.removed_IncludedNetworkToHost {
		ids = append(ids, id)
	}
	return
}

// IncludedNetworkToHostIDs returns the "IncludedNetworkToHost" edge IDs in the mutation.
func (m *IncludedNetworkMutation) IncludedNetworkToHostIDs() (ids []uuid.UUID) {
	for id := range m._IncludedNetworkToHost {
		ids = append(ids, id)
	}
	return
}

// ResetIncludedNetworkToHost resets all changes to the "IncludedNetworkToHost" edge.
func (m *IncludedNetworkMutation) ResetIncludedNetworkToHost() {
	m._IncludedNetworkToHost = nil
	m.cleared_IncludedNetworkToHost = false
	m.removed_IncludedNetworkToHost = nil
}

// SetIncludedNetworkToNetworkID sets the "IncludedNetworkToNetwork" edge to the Network entity by id.
func (m *IncludedNetworkMutation) SetIncludedNetworkToNetworkID(id uuid.UUID) {
	m._IncludedNetworkToNetwork = &id
}

// ClearIncludedNetworkToNetwork clears the "IncludedNetworkToNetwork" edge to the Network entity.
func (m *IncludedNetworkMutation) ClearIncludedNetworkToNetwork() {
	m.cleared_IncludedNetworkToNetwork = true
}

// IncludedNetworkToNetworkCleared reports if the "IncludedNetworkToNetwork" edge to the Network entity was cleared.
func (m *IncludedNetworkMutation) IncludedNetworkToNetworkCleared() bool {
	return m.cleared_IncludedNetworkToNetwork
}

// IncludedNetworkToNetworkID returns the "IncludedNetworkToNetwork" edge ID in the mutation.
func (m *IncludedNetworkMutation) IncludedNetworkToNetworkID() (id uuid.UUID, exists bool) {
	if m._IncludedNetworkToNetwork != nil {
		return *m._IncludedNetworkToNetwork, true
	}
	return
}

// IncludedNetworkToNetworkIDs returns the "IncludedNetworkToNetwork" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IncludedNetworkToNetworkID instead. It exists only for internal usage by the builders.
func (m *IncludedNetworkMutation) IncludedNetworkToNetworkIDs() (ids []uuid.UUID) {
	if id := m._IncludedNetworkToNetwork; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIncludedNetworkToNetwork resets all changes to the "IncludedNetworkToNetwork" edge.
func (m *IncludedNetworkMutation) ResetIncludedNetworkToNetwork() {
	m._IncludedNetworkToNetwork = nil
	m.cleared_IncludedNetworkToNetwork = false
}

// AddIncludedNetworkToEnvironmentIDs adds the "IncludedNetworkToEnvironment" edge to the Environment entity by ids.
func (m *IncludedNetworkMutation) AddIncludedNetworkToEnvironmentIDs(ids ...uuid.UUID) {
	if m._IncludedNetworkToEnvironment == nil {
		m._IncludedNetworkToEnvironment = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._IncludedNetworkToEnvironment[ids[i]] = struct{}{}
	}
}

// ClearIncludedNetworkToEnvironment clears the "IncludedNetworkToEnvironment" edge to the Environment entity.
func (m *IncludedNetworkMutation) ClearIncludedNetworkToEnvironment() {
	m.cleared_IncludedNetworkToEnvironment = true
}

// IncludedNetworkToEnvironmentCleared reports if the "IncludedNetworkToEnvironment" edge to the Environment entity was cleared.
func (m *IncludedNetworkMutation) IncludedNetworkToEnvironmentCleared() bool {
	return m.cleared_IncludedNetworkToEnvironment
}

// RemoveIncludedNetworkToEnvironmentIDs removes the "IncludedNetworkToEnvironment" edge to the Environment entity by IDs.
func (m *IncludedNetworkMutation) RemoveIncludedNetworkToEnvironmentIDs(ids ...uuid.UUID) {
	if m.removed_IncludedNetworkToEnvironment == nil {
		m.removed_IncludedNetworkToEnvironment = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._IncludedNetworkToEnvironment, ids[i])
		m.removed_IncludedNetworkToEnvironment[ids[i]] = struct{}{}
	}
}

// RemovedIncludedNetworkToEnvironment returns the removed IDs of the "IncludedNetworkToEnvironment" edge to the Environment entity.
func (m *IncludedNetworkMutation) RemovedIncludedNetworkToEnvironmentIDs() (ids []uuid.UUID) {
	for id := range m.removed_IncludedNetworkToEnvironment {
		ids = append(ids, id)
	}
	return
}

// IncludedNetworkToEnvironmentIDs returns the "IncludedNetworkToEnvironment" edge IDs in the mutation.
func (m *IncludedNetworkMutation) IncludedNetworkToEnvironmentIDs() (ids []uuid.UUID) {
	for id := range m._IncludedNetworkToEnvironment {
		ids = append(ids, id)
	}
	return
}

// ResetIncludedNetworkToEnvironment resets all changes to the "IncludedNetworkToEnvironment" edge.
func (m *IncludedNetworkMutation) ResetIncludedNetworkToEnvironment() {
	m._IncludedNetworkToEnvironment = nil
	m.cleared_IncludedNetworkToEnvironment = false
	m.removed_IncludedNetworkToEnvironment = nil
}

// Where appends a list predicates to the IncludedNetworkMutation builder.
func (m *IncludedNetworkMutation) Where(ps ...predicate.IncludedNetwork) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IncludedNetworkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IncludedNetworkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IncludedNetwork, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IncludedNetworkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IncludedNetworkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IncludedNetwork).
func (m *IncludedNetworkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncludedNetworkMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, includednetwork.FieldName)
	}
	if m.hosts != nil {
		fields = append(fields, includednetwork.FieldHosts)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncludedNetworkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case includednetwork.FieldName:
		return m.Name()
	case includednetwork.FieldHosts:
		return m.Hosts()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncludedNetworkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case includednetwork.FieldName:
		return m.OldName(ctx)
	case includednetwork.FieldHosts:
		return m.OldHosts(ctx)
	}
	return nil, fmt.Errorf("unknown IncludedNetwork field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncludedNetworkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case includednetwork.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case includednetwork.FieldHosts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHosts(v)
		return nil
	}
	return fmt.Errorf("unknown IncludedNetwork field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncludedNetworkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncludedNetworkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncludedNetworkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IncludedNetwork numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncludedNetworkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncludedNetworkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncludedNetworkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IncludedNetwork nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncludedNetworkMutation) ResetField(name string) error {
	switch name {
	case includednetwork.FieldName:
		m.ResetName()
		return nil
	case includednetwork.FieldHosts:
		m.ResetHosts()
		return nil
	}
	return fmt.Errorf("unknown IncludedNetwork field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncludedNetworkMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._IncludedNetworkToTag != nil {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToTag)
	}
	if m._IncludedNetworkToHost != nil {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToHost)
	}
	if m._IncludedNetworkToNetwork != nil {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToNetwork)
	}
	if m._IncludedNetworkToEnvironment != nil {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncludedNetworkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case includednetwork.EdgeIncludedNetworkToTag:
		ids := make([]ent.Value, 0, len(m._IncludedNetworkToTag))
		for id := range m._IncludedNetworkToTag {
			ids = append(ids, id)
		}
		return ids
	case includednetwork.EdgeIncludedNetworkToHost:
		ids := make([]ent.Value, 0, len(m._IncludedNetworkToHost))
		for id := range m._IncludedNetworkToHost {
			ids = append(ids, id)
		}
		return ids
	case includednetwork.EdgeIncludedNetworkToNetwork:
		if id := m._IncludedNetworkToNetwork; id != nil {
			return []ent.Value{*id}
		}
	case includednetwork.EdgeIncludedNetworkToEnvironment:
		ids := make([]ent.Value, 0, len(m._IncludedNetworkToEnvironment))
		for id := range m._IncludedNetworkToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncludedNetworkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removed_IncludedNetworkToTag != nil {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToTag)
	}
	if m.removed_IncludedNetworkToHost != nil {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToHost)
	}
	if m.removed_IncludedNetworkToEnvironment != nil {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToEnvironment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncludedNetworkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case includednetwork.EdgeIncludedNetworkToTag:
		ids := make([]ent.Value, 0, len(m.removed_IncludedNetworkToTag))
		for id := range m.removed_IncludedNetworkToTag {
			ids = append(ids, id)
		}
		return ids
	case includednetwork.EdgeIncludedNetworkToHost:
		ids := make([]ent.Value, 0, len(m.removed_IncludedNetworkToHost))
		for id := range m.removed_IncludedNetworkToHost {
			ids = append(ids, id)
		}
		return ids
	case includednetwork.EdgeIncludedNetworkToEnvironment:
		ids := make([]ent.Value, 0, len(m.removed_IncludedNetworkToEnvironment))
		for id := range m.removed_IncludedNetworkToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncludedNetworkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_IncludedNetworkToTag {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToTag)
	}
	if m.cleared_IncludedNetworkToHost {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToHost)
	}
	if m.cleared_IncludedNetworkToNetwork {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToNetwork)
	}
	if m.cleared_IncludedNetworkToEnvironment {
		edges = append(edges, includednetwork.EdgeIncludedNetworkToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncludedNetworkMutation) EdgeCleared(name string) bool {
	switch name {
	case includednetwork.EdgeIncludedNetworkToTag:
		return m.cleared_IncludedNetworkToTag
	case includednetwork.EdgeIncludedNetworkToHost:
		return m.cleared_IncludedNetworkToHost
	case includednetwork.EdgeIncludedNetworkToNetwork:
		return m.cleared_IncludedNetworkToNetwork
	case includednetwork.EdgeIncludedNetworkToEnvironment:
		return m.cleared_IncludedNetworkToEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncludedNetworkMutation) ClearEdge(name string) error {
	switch name {
	case includednetwork.EdgeIncludedNetworkToNetwork:
		m.ClearIncludedNetworkToNetwork()
		return nil
	}
	return fmt.Errorf("unknown IncludedNetwork unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncludedNetworkMutation) ResetEdge(name string) error {
	switch name {
	case includednetwork.EdgeIncludedNetworkToTag:
		m.ResetIncludedNetworkToTag()
		return nil
	case includednetwork.EdgeIncludedNetworkToHost:
		m.ResetIncludedNetworkToHost()
		return nil
	case includednetwork.EdgeIncludedNetworkToNetwork:
		m.ResetIncludedNetworkToNetwork()
		return nil
	case includednetwork.EdgeIncludedNetworkToEnvironment:
		m.ResetIncludedNetworkToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown IncludedNetwork edge %s", name)
}

// NetworkMutation represents an operation that mutates the Network nodes in the graph.
type NetworkMutation struct {
	config
	op                               Op
	typ                              string
	id                               *uuid.UUID
	hcl_id                           *string
	name                             *string
	cidr                             *string
	vdi_visible                      *bool
	vars                             *map[string]string
	tags                             *map[string]string
	clearedFields                    map[string]struct{}
	_NetworkToEnvironment            *uuid.UUID
	cleared_NetworkToEnvironment     bool
	_NetworkToHostDependency         map[uuid.UUID]struct{}
	removed_NetworkToHostDependency  map[uuid.UUID]struct{}
	cleared_NetworkToHostDependency  bool
	_NetworkToIncludedNetwork        map[uuid.UUID]struct{}
	removed_NetworkToIncludedNetwork map[uuid.UUID]struct{}
	cleared_NetworkToIncludedNetwork bool
	done                             bool
	oldValue                         func(context.Context) (*Network, error)
	predicates                       []predicate.Network
}

var _ ent.Mutation = (*NetworkMutation)(nil)

// networkOption allows management of the mutation configuration using functional options.
type networkOption func(*NetworkMutation)

// newNetworkMutation creates new mutation for the Network entity.
func newNetworkMutation(c config, op Op, opts ...networkOption) *NetworkMutation {
	m := &NetworkMutation{
		config:        c,
		op:            op,
		typ:           TypeNetwork,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNetworkID sets the ID field of the mutation.
func withNetworkID(id uuid.UUID) networkOption {
	return func(m *NetworkMutation) {
		var (
			err   error
			once  sync.Once
			value *Network
		)
		m.oldValue = func(ctx context.Context) (*Network, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Network.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNetwork sets the old Network of the mutation.
func withNetwork(node *Network) networkOption {
	return func(m *NetworkMutation) {
		m.oldValue = func(context.Context) (*Network, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NetworkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NetworkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Network entities.
func (m *NetworkMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NetworkMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NetworkMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Network.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHCLID sets the "hcl_id" field.
func (m *NetworkMutation) SetHCLID(s string) {
	m.hcl_id = &s
}

// HCLID returns the value of the "hcl_id" field in the mutation.
func (m *NetworkMutation) HCLID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHCLID returns the old "hcl_id" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldHCLID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHCLID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHCLID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHCLID: %w", err)
	}
	return oldValue.HCLID, nil
}

// ResetHCLID resets all changes to the "hcl_id" field.
func (m *NetworkMutation) ResetHCLID() {
	m.hcl_id = nil
}

// SetName sets the "name" field.
func (m *NetworkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NetworkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NetworkMutation) ResetName() {
	m.name = nil
}

// SetCidr sets the "cidr" field.
func (m *NetworkMutation) SetCidr(s string) {
	m.cidr = &s
}

// Cidr returns the value of the "cidr" field in the mutation.
func (m *NetworkMutation) Cidr() (r string, exists bool) {
	v := m.cidr
	if v == nil {
		return
	}
	return *v, true
}

// OldCidr returns the old "cidr" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldCidr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCidr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCidr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCidr: %w", err)
	}
	return oldValue.Cidr, nil
}

// ResetCidr resets all changes to the "cidr" field.
func (m *NetworkMutation) ResetCidr() {
	m.cidr = nil
}

// SetVdiVisible sets the "vdi_visible" field.
func (m *NetworkMutation) SetVdiVisible(b bool) {
	m.vdi_visible = &b
}

// VdiVisible returns the value of the "vdi_visible" field in the mutation.
func (m *NetworkMutation) VdiVisible() (r bool, exists bool) {
	v := m.vdi_visible
	if v == nil {
		return
	}
	return *v, true
}

// OldVdiVisible returns the old "vdi_visible" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldVdiVisible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVdiVisible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVdiVisible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVdiVisible: %w", err)
	}
	return oldValue.VdiVisible, nil
}

// ResetVdiVisible resets all changes to the "vdi_visible" field.
func (m *NetworkMutation) ResetVdiVisible() {
	m.vdi_visible = nil
}

// SetVars sets the "vars" field.
func (m *NetworkMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *NetworkMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *NetworkMutation) ResetVars() {
	m.vars = nil
}

// SetTags sets the "tags" field.
func (m *NetworkMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *NetworkMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Network entity.
// If the Network object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NetworkMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *NetworkMutation) ResetTags() {
	m.tags = nil
}

// SetNetworkToEnvironmentID sets the "NetworkToEnvironment" edge to the Environment entity by id.
func (m *NetworkMutation) SetNetworkToEnvironmentID(id uuid.UUID) {
	m._NetworkToEnvironment = &id
}

// ClearNetworkToEnvironment clears the "NetworkToEnvironment" edge to the Environment entity.
func (m *NetworkMutation) ClearNetworkToEnvironment() {
	m.cleared_NetworkToEnvironment = true
}

// NetworkToEnvironmentCleared reports if the "NetworkToEnvironment" edge to the Environment entity was cleared.
func (m *NetworkMutation) NetworkToEnvironmentCleared() bool {
	return m.cleared_NetworkToEnvironment
}

// NetworkToEnvironmentID returns the "NetworkToEnvironment" edge ID in the mutation.
func (m *NetworkMutation) NetworkToEnvironmentID() (id uuid.UUID, exists bool) {
	if m._NetworkToEnvironment != nil {
		return *m._NetworkToEnvironment, true
	}
	return
}

// NetworkToEnvironmentIDs returns the "NetworkToEnvironment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NetworkToEnvironmentID instead. It exists only for internal usage by the builders.
func (m *NetworkMutation) NetworkToEnvironmentIDs() (ids []uuid.UUID) {
	if id := m._NetworkToEnvironment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNetworkToEnvironment resets all changes to the "NetworkToEnvironment" edge.
func (m *NetworkMutation) ResetNetworkToEnvironment() {
	m._NetworkToEnvironment = nil
	m.cleared_NetworkToEnvironment = false
}

// AddNetworkToHostDependencyIDs adds the "NetworkToHostDependency" edge to the HostDependency entity by ids.
func (m *NetworkMutation) AddNetworkToHostDependencyIDs(ids ...uuid.UUID) {
	if m._NetworkToHostDependency == nil {
		m._NetworkToHostDependency = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._NetworkToHostDependency[ids[i]] = struct{}{}
	}
}

// ClearNetworkToHostDependency clears the "NetworkToHostDependency" edge to the HostDependency entity.
func (m *NetworkMutation) ClearNetworkToHostDependency() {
	m.cleared_NetworkToHostDependency = true
}

// NetworkToHostDependencyCleared reports if the "NetworkToHostDependency" edge to the HostDependency entity was cleared.
func (m *NetworkMutation) NetworkToHostDependencyCleared() bool {
	return m.cleared_NetworkToHostDependency
}

// RemoveNetworkToHostDependencyIDs removes the "NetworkToHostDependency" edge to the HostDependency entity by IDs.
func (m *NetworkMutation) RemoveNetworkToHostDependencyIDs(ids ...uuid.UUID) {
	if m.removed_NetworkToHostDependency == nil {
		m.removed_NetworkToHostDependency = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._NetworkToHostDependency, ids[i])
		m.removed_NetworkToHostDependency[ids[i]] = struct{}{}
	}
}

// RemovedNetworkToHostDependency returns the removed IDs of the "NetworkToHostDependency" edge to the HostDependency entity.
func (m *NetworkMutation) RemovedNetworkToHostDependencyIDs() (ids []uuid.UUID) {
	for id := range m.removed_NetworkToHostDependency {
		ids = append(ids, id)
	}
	return
}

// NetworkToHostDependencyIDs returns the "NetworkToHostDependency" edge IDs in the mutation.
func (m *NetworkMutation) NetworkToHostDependencyIDs() (ids []uuid.UUID) {
	for id := range m._NetworkToHostDependency {
		ids = append(ids, id)
	}
	return
}

// ResetNetworkToHostDependency resets all changes to the "NetworkToHostDependency" edge.
func (m *NetworkMutation) ResetNetworkToHostDependency() {
	m._NetworkToHostDependency = nil
	m.cleared_NetworkToHostDependency = false
	m.removed_NetworkToHostDependency = nil
}

// AddNetworkToIncludedNetworkIDs adds the "NetworkToIncludedNetwork" edge to the IncludedNetwork entity by ids.
func (m *NetworkMutation) AddNetworkToIncludedNetworkIDs(ids ...uuid.UUID) {
	if m._NetworkToIncludedNetwork == nil {
		m._NetworkToIncludedNetwork = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._NetworkToIncludedNetwork[ids[i]] = struct{}{}
	}
}

// ClearNetworkToIncludedNetwork clears the "NetworkToIncludedNetwork" edge to the IncludedNetwork entity.
func (m *NetworkMutation) ClearNetworkToIncludedNetwork() {
	m.cleared_NetworkToIncludedNetwork = true
}

// NetworkToIncludedNetworkCleared reports if the "NetworkToIncludedNetwork" edge to the IncludedNetwork entity was cleared.
func (m *NetworkMutation) NetworkToIncludedNetworkCleared() bool {
	return m.cleared_NetworkToIncludedNetwork
}

// RemoveNetworkToIncludedNetworkIDs removes the "NetworkToIncludedNetwork" edge to the IncludedNetwork entity by IDs.
func (m *NetworkMutation) RemoveNetworkToIncludedNetworkIDs(ids ...uuid.UUID) {
	if m.removed_NetworkToIncludedNetwork == nil {
		m.removed_NetworkToIncludedNetwork = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._NetworkToIncludedNetwork, ids[i])
		m.removed_NetworkToIncludedNetwork[ids[i]] = struct{}{}
	}
}

// RemovedNetworkToIncludedNetwork returns the removed IDs of the "NetworkToIncludedNetwork" edge to the IncludedNetwork entity.
func (m *NetworkMutation) RemovedNetworkToIncludedNetworkIDs() (ids []uuid.UUID) {
	for id := range m.removed_NetworkToIncludedNetwork {
		ids = append(ids, id)
	}
	return
}

// NetworkToIncludedNetworkIDs returns the "NetworkToIncludedNetwork" edge IDs in the mutation.
func (m *NetworkMutation) NetworkToIncludedNetworkIDs() (ids []uuid.UUID) {
	for id := range m._NetworkToIncludedNetwork {
		ids = append(ids, id)
	}
	return
}

// ResetNetworkToIncludedNetwork resets all changes to the "NetworkToIncludedNetwork" edge.
func (m *NetworkMutation) ResetNetworkToIncludedNetwork() {
	m._NetworkToIncludedNetwork = nil
	m.cleared_NetworkToIncludedNetwork = false
	m.removed_NetworkToIncludedNetwork = nil
}

// Where appends a list predicates to the NetworkMutation builder.
func (m *NetworkMutation) Where(ps ...predicate.Network) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NetworkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NetworkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Network, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NetworkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NetworkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Network).
func (m *NetworkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NetworkMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.hcl_id != nil {
		fields = append(fields, network.FieldHCLID)
	}
	if m.name != nil {
		fields = append(fields, network.FieldName)
	}
	if m.cidr != nil {
		fields = append(fields, network.FieldCidr)
	}
	if m.vdi_visible != nil {
		fields = append(fields, network.FieldVdiVisible)
	}
	if m.vars != nil {
		fields = append(fields, network.FieldVars)
	}
	if m.tags != nil {
		fields = append(fields, network.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NetworkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case network.FieldHCLID:
		return m.HCLID()
	case network.FieldName:
		return m.Name()
	case network.FieldCidr:
		return m.Cidr()
	case network.FieldVdiVisible:
		return m.VdiVisible()
	case network.FieldVars:
		return m.Vars()
	case network.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NetworkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case network.FieldHCLID:
		return m.OldHCLID(ctx)
	case network.FieldName:
		return m.OldName(ctx)
	case network.FieldCidr:
		return m.OldCidr(ctx)
	case network.FieldVdiVisible:
		return m.OldVdiVisible(ctx)
	case network.FieldVars:
		return m.OldVars(ctx)
	case network.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Network field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case network.FieldHCLID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHCLID(v)
		return nil
	case network.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case network.FieldCidr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCidr(v)
		return nil
	case network.FieldVdiVisible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVdiVisible(v)
		return nil
	case network.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	case network.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Network field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NetworkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NetworkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NetworkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Network numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NetworkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NetworkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NetworkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Network nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NetworkMutation) ResetField(name string) error {
	switch name {
	case network.FieldHCLID:
		m.ResetHCLID()
		return nil
	case network.FieldName:
		m.ResetName()
		return nil
	case network.FieldCidr:
		m.ResetCidr()
		return nil
	case network.FieldVdiVisible:
		m.ResetVdiVisible()
		return nil
	case network.FieldVars:
		m.ResetVars()
		return nil
	case network.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Network field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NetworkMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._NetworkToEnvironment != nil {
		edges = append(edges, network.EdgeNetworkToEnvironment)
	}
	if m._NetworkToHostDependency != nil {
		edges = append(edges, network.EdgeNetworkToHostDependency)
	}
	if m._NetworkToIncludedNetwork != nil {
		edges = append(edges, network.EdgeNetworkToIncludedNetwork)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NetworkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case network.EdgeNetworkToEnvironment:
		if id := m._NetworkToEnvironment; id != nil {
			return []ent.Value{*id}
		}
	case network.EdgeNetworkToHostDependency:
		ids := make([]ent.Value, 0, len(m._NetworkToHostDependency))
		for id := range m._NetworkToHostDependency {
			ids = append(ids, id)
		}
		return ids
	case network.EdgeNetworkToIncludedNetwork:
		ids := make([]ent.Value, 0, len(m._NetworkToIncludedNetwork))
		for id := range m._NetworkToIncludedNetwork {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NetworkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_NetworkToHostDependency != nil {
		edges = append(edges, network.EdgeNetworkToHostDependency)
	}
	if m.removed_NetworkToIncludedNetwork != nil {
		edges = append(edges, network.EdgeNetworkToIncludedNetwork)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NetworkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case network.EdgeNetworkToHostDependency:
		ids := make([]ent.Value, 0, len(m.removed_NetworkToHostDependency))
		for id := range m.removed_NetworkToHostDependency {
			ids = append(ids, id)
		}
		return ids
	case network.EdgeNetworkToIncludedNetwork:
		ids := make([]ent.Value, 0, len(m.removed_NetworkToIncludedNetwork))
		for id := range m.removed_NetworkToIncludedNetwork {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NetworkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_NetworkToEnvironment {
		edges = append(edges, network.EdgeNetworkToEnvironment)
	}
	if m.cleared_NetworkToHostDependency {
		edges = append(edges, network.EdgeNetworkToHostDependency)
	}
	if m.cleared_NetworkToIncludedNetwork {
		edges = append(edges, network.EdgeNetworkToIncludedNetwork)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NetworkMutation) EdgeCleared(name string) bool {
	switch name {
	case network.EdgeNetworkToEnvironment:
		return m.cleared_NetworkToEnvironment
	case network.EdgeNetworkToHostDependency:
		return m.cleared_NetworkToHostDependency
	case network.EdgeNetworkToIncludedNetwork:
		return m.cleared_NetworkToIncludedNetwork
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NetworkMutation) ClearEdge(name string) error {
	switch name {
	case network.EdgeNetworkToEnvironment:
		m.ClearNetworkToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Network unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NetworkMutation) ResetEdge(name string) error {
	switch name {
	case network.EdgeNetworkToEnvironment:
		m.ResetNetworkToEnvironment()
		return nil
	case network.EdgeNetworkToHostDependency:
		m.ResetNetworkToHostDependency()
		return nil
	case network.EdgeNetworkToIncludedNetwork:
		m.ResetNetworkToIncludedNetwork()
		return nil
	}
	return fmt.Errorf("unknown Network edge %s", name)
}

// PlanMutation represents an operation that mutates the Plan nodes in the graph.
type PlanMutation struct {
	config
	op                               Op
	typ                              string
	id                               *uuid.UUID
	step_number                      *int
	addstep_number                   *int
	_type                            *plan.Type
	build_id                         *string
	clearedFields                    map[string]struct{}
	_PrevPlan                        map[uuid.UUID]struct{}
	removed_PrevPlan                 map[uuid.UUID]struct{}
	cleared_PrevPlan                 bool
	_NextPlan                        map[uuid.UUID]struct{}
	removed_NextPlan                 map[uuid.UUID]struct{}
	cleared_NextPlan                 bool
	_PlanToBuild                     *uuid.UUID
	cleared_PlanToBuild              bool
	_PlanToTeam                      *uuid.UUID
	cleared_PlanToTeam               bool
	_PlanToProvisionedNetwork        *uuid.UUID
	cleared_PlanToProvisionedNetwork bool
	_PlanToProvisionedHost           *uuid.UUID
	cleared_PlanToProvisionedHost    bool
	_PlanToProvisioningStep          *uuid.UUID
	cleared_PlanToProvisioningStep   bool
	_PlanToStatus                    *uuid.UUID
	cleared_PlanToStatus             bool
	_PlanToPlanDiffs                 map[uuid.UUID]struct{}
	removed_PlanToPlanDiffs          map[uuid.UUID]struct{}
	cleared_PlanToPlanDiffs          bool
	done                             bool
	oldValue                         func(context.Context) (*Plan, error)
	predicates                       []predicate.Plan
}

var _ ent.Mutation = (*PlanMutation)(nil)

// planOption allows management of the mutation configuration using functional options.
type planOption func(*PlanMutation)

// newPlanMutation creates new mutation for the Plan entity.
func newPlanMutation(c config, op Op, opts ...planOption) *PlanMutation {
	m := &PlanMutation{
		config:        c,
		op:            op,
		typ:           TypePlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlanID sets the ID field of the mutation.
func withPlanID(id uuid.UUID) planOption {
	return func(m *PlanMutation) {
		var (
			err   error
			once  sync.Once
			value *Plan
		)
		m.oldValue = func(ctx context.Context) (*Plan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Plan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlan sets the old Plan of the mutation.
func withPlan(node *Plan) planOption {
	return func(m *PlanMutation) {
		m.oldValue = func(context.Context) (*Plan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Plan entities.
func (m *PlanMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlanMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlanMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Plan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStepNumber sets the "step_number" field.
func (m *PlanMutation) SetStepNumber(i int) {
	m.step_number = &i
	m.addstep_number = nil
}

// StepNumber returns the value of the "step_number" field in the mutation.
func (m *PlanMutation) StepNumber() (r int, exists bool) {
	v := m.step_number
	if v == nil {
		return
	}
	return *v, true
}

// OldStepNumber returns the old "step_number" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldStepNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepNumber: %w", err)
	}
	return oldValue.StepNumber, nil
}

// AddStepNumber adds i to the "step_number" field.
func (m *PlanMutation) AddStepNumber(i int) {
	if m.addstep_number != nil {
		*m.addstep_number += i
	} else {
		m.addstep_number = &i
	}
}

// AddedStepNumber returns the value that was added to the "step_number" field in this mutation.
func (m *PlanMutation) AddedStepNumber() (r int, exists bool) {
	v := m.addstep_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetStepNumber resets all changes to the "step_number" field.
func (m *PlanMutation) ResetStepNumber() {
	m.step_number = nil
	m.addstep_number = nil
}

// SetType sets the "type" field.
func (m *PlanMutation) SetType(pl plan.Type) {
	m._type = &pl
}

// GetType returns the value of the "type" field in the mutation.
func (m *PlanMutation) GetType() (r plan.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldType(ctx context.Context) (v plan.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PlanMutation) ResetType() {
	m._type = nil
}

// SetBuildID sets the "build_id" field.
func (m *PlanMutation) SetBuildID(s string) {
	m.build_id = &s
}

// BuildID returns the value of the "build_id" field in the mutation.
func (m *PlanMutation) BuildID() (r string, exists bool) {
	v := m.build_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBuildID returns the old "build_id" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldBuildID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuildID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuildID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuildID: %w", err)
	}
	return oldValue.BuildID, nil
}

// ResetBuildID resets all changes to the "build_id" field.
func (m *PlanMutation) ResetBuildID() {
	m.build_id = nil
}

// AddPrevPlanIDs adds the "PrevPlan" edge to the Plan entity by ids.
func (m *PlanMutation) AddPrevPlanIDs(ids ...uuid.UUID) {
	if m._PrevPlan == nil {
		m._PrevPlan = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._PrevPlan[ids[i]] = struct{}{}
	}
}

// ClearPrevPlan clears the "PrevPlan" edge to the Plan entity.
func (m *PlanMutation) ClearPrevPlan() {
	m.cleared_PrevPlan = true
}

// PrevPlanCleared reports if the "PrevPlan" edge to the Plan entity was cleared.
func (m *PlanMutation) PrevPlanCleared() bool {
	return m.cleared_PrevPlan
}

// RemovePrevPlanIDs removes the "PrevPlan" edge to the Plan entity by IDs.
func (m *PlanMutation) RemovePrevPlanIDs(ids ...uuid.UUID) {
	if m.removed_PrevPlan == nil {
		m.removed_PrevPlan = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._PrevPlan, ids[i])
		m.removed_PrevPlan[ids[i]] = struct{}{}
	}
}

// RemovedPrevPlan returns the removed IDs of the "PrevPlan" edge to the Plan entity.
func (m *PlanMutation) RemovedPrevPlanIDs() (ids []uuid.UUID) {
	for id := range m.removed_PrevPlan {
		ids = append(ids, id)
	}
	return
}

// PrevPlanIDs returns the "PrevPlan" edge IDs in the mutation.
func (m *PlanMutation) PrevPlanIDs() (ids []uuid.UUID) {
	for id := range m._PrevPlan {
		ids = append(ids, id)
	}
	return
}

// ResetPrevPlan resets all changes to the "PrevPlan" edge.
func (m *PlanMutation) ResetPrevPlan() {
	m._PrevPlan = nil
	m.cleared_PrevPlan = false
	m.removed_PrevPlan = nil
}

// AddNextPlanIDs adds the "NextPlan" edge to the Plan entity by ids.
func (m *PlanMutation) AddNextPlanIDs(ids ...uuid.UUID) {
	if m._NextPlan == nil {
		m._NextPlan = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._NextPlan[ids[i]] = struct{}{}
	}
}

// ClearNextPlan clears the "NextPlan" edge to the Plan entity.
func (m *PlanMutation) ClearNextPlan() {
	m.cleared_NextPlan = true
}

// NextPlanCleared reports if the "NextPlan" edge to the Plan entity was cleared.
func (m *PlanMutation) NextPlanCleared() bool {
	return m.cleared_NextPlan
}

// RemoveNextPlanIDs removes the "NextPlan" edge to the Plan entity by IDs.
func (m *PlanMutation) RemoveNextPlanIDs(ids ...uuid.UUID) {
	if m.removed_NextPlan == nil {
		m.removed_NextPlan = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._NextPlan, ids[i])
		m.removed_NextPlan[ids[i]] = struct{}{}
	}
}

// RemovedNextPlan returns the removed IDs of the "NextPlan" edge to the Plan entity.
func (m *PlanMutation) RemovedNextPlanIDs() (ids []uuid.UUID) {
	for id := range m.removed_NextPlan {
		ids = append(ids, id)
	}
	return
}

// NextPlanIDs returns the "NextPlan" edge IDs in the mutation.
func (m *PlanMutation) NextPlanIDs() (ids []uuid.UUID) {
	for id := range m._NextPlan {
		ids = append(ids, id)
	}
	return
}

// ResetNextPlan resets all changes to the "NextPlan" edge.
func (m *PlanMutation) ResetNextPlan() {
	m._NextPlan = nil
	m.cleared_NextPlan = false
	m.removed_NextPlan = nil
}

// SetPlanToBuildID sets the "PlanToBuild" edge to the Build entity by id.
func (m *PlanMutation) SetPlanToBuildID(id uuid.UUID) {
	m._PlanToBuild = &id
}

// ClearPlanToBuild clears the "PlanToBuild" edge to the Build entity.
func (m *PlanMutation) ClearPlanToBuild() {
	m.cleared_PlanToBuild = true
}

// PlanToBuildCleared reports if the "PlanToBuild" edge to the Build entity was cleared.
func (m *PlanMutation) PlanToBuildCleared() bool {
	return m.cleared_PlanToBuild
}

// PlanToBuildID returns the "PlanToBuild" edge ID in the mutation.
func (m *PlanMutation) PlanToBuildID() (id uuid.UUID, exists bool) {
	if m._PlanToBuild != nil {
		return *m._PlanToBuild, true
	}
	return
}

// PlanToBuildIDs returns the "PlanToBuild" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanToBuildID instead. It exists only for internal usage by the builders.
func (m *PlanMutation) PlanToBuildIDs() (ids []uuid.UUID) {
	if id := m._PlanToBuild; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlanToBuild resets all changes to the "PlanToBuild" edge.
func (m *PlanMutation) ResetPlanToBuild() {
	m._PlanToBuild = nil
	m.cleared_PlanToBuild = false
}

// SetPlanToTeamID sets the "PlanToTeam" edge to the Team entity by id.
func (m *PlanMutation) SetPlanToTeamID(id uuid.UUID) {
	m._PlanToTeam = &id
}

// ClearPlanToTeam clears the "PlanToTeam" edge to the Team entity.
func (m *PlanMutation) ClearPlanToTeam() {
	m.cleared_PlanToTeam = true
}

// PlanToTeamCleared reports if the "PlanToTeam" edge to the Team entity was cleared.
func (m *PlanMutation) PlanToTeamCleared() bool {
	return m.cleared_PlanToTeam
}

// PlanToTeamID returns the "PlanToTeam" edge ID in the mutation.
func (m *PlanMutation) PlanToTeamID() (id uuid.UUID, exists bool) {
	if m._PlanToTeam != nil {
		return *m._PlanToTeam, true
	}
	return
}

// PlanToTeamIDs returns the "PlanToTeam" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanToTeamID instead. It exists only for internal usage by the builders.
func (m *PlanMutation) PlanToTeamIDs() (ids []uuid.UUID) {
	if id := m._PlanToTeam; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlanToTeam resets all changes to the "PlanToTeam" edge.
func (m *PlanMutation) ResetPlanToTeam() {
	m._PlanToTeam = nil
	m.cleared_PlanToTeam = false
}

// SetPlanToProvisionedNetworkID sets the "PlanToProvisionedNetwork" edge to the ProvisionedNetwork entity by id.
func (m *PlanMutation) SetPlanToProvisionedNetworkID(id uuid.UUID) {
	m._PlanToProvisionedNetwork = &id
}

// ClearPlanToProvisionedNetwork clears the "PlanToProvisionedNetwork" edge to the ProvisionedNetwork entity.
func (m *PlanMutation) ClearPlanToProvisionedNetwork() {
	m.cleared_PlanToProvisionedNetwork = true
}

// PlanToProvisionedNetworkCleared reports if the "PlanToProvisionedNetwork" edge to the ProvisionedNetwork entity was cleared.
func (m *PlanMutation) PlanToProvisionedNetworkCleared() bool {
	return m.cleared_PlanToProvisionedNetwork
}

// PlanToProvisionedNetworkID returns the "PlanToProvisionedNetwork" edge ID in the mutation.
func (m *PlanMutation) PlanToProvisionedNetworkID() (id uuid.UUID, exists bool) {
	if m._PlanToProvisionedNetwork != nil {
		return *m._PlanToProvisionedNetwork, true
	}
	return
}

// PlanToProvisionedNetworkIDs returns the "PlanToProvisionedNetwork" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanToProvisionedNetworkID instead. It exists only for internal usage by the builders.
func (m *PlanMutation) PlanToProvisionedNetworkIDs() (ids []uuid.UUID) {
	if id := m._PlanToProvisionedNetwork; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlanToProvisionedNetwork resets all changes to the "PlanToProvisionedNetwork" edge.
func (m *PlanMutation) ResetPlanToProvisionedNetwork() {
	m._PlanToProvisionedNetwork = nil
	m.cleared_PlanToProvisionedNetwork = false
}

// SetPlanToProvisionedHostID sets the "PlanToProvisionedHost" edge to the ProvisionedHost entity by id.
func (m *PlanMutation) SetPlanToProvisionedHostID(id uuid.UUID) {
	m._PlanToProvisionedHost = &id
}

// ClearPlanToProvisionedHost clears the "PlanToProvisionedHost" edge to the ProvisionedHost entity.
func (m *PlanMutation) ClearPlanToProvisionedHost() {
	m.cleared_PlanToProvisionedHost = true
}

// PlanToProvisionedHostCleared reports if the "PlanToProvisionedHost" edge to the ProvisionedHost entity was cleared.
func (m *PlanMutation) PlanToProvisionedHostCleared() bool {
	return m.cleared_PlanToProvisionedHost
}

// PlanToProvisionedHostID returns the "PlanToProvisionedHost" edge ID in the mutation.
func (m *PlanMutation) PlanToProvisionedHostID() (id uuid.UUID, exists bool) {
	if m._PlanToProvisionedHost != nil {
		return *m._PlanToProvisionedHost, true
	}
	return
}

// PlanToProvisionedHostIDs returns the "PlanToProvisionedHost" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanToProvisionedHostID instead. It exists only for internal usage by the builders.
func (m *PlanMutation) PlanToProvisionedHostIDs() (ids []uuid.UUID) {
	if id := m._PlanToProvisionedHost; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlanToProvisionedHost resets all changes to the "PlanToProvisionedHost" edge.
func (m *PlanMutation) ResetPlanToProvisionedHost() {
	m._PlanToProvisionedHost = nil
	m.cleared_PlanToProvisionedHost = false
}

// SetPlanToProvisioningStepID sets the "PlanToProvisioningStep" edge to the ProvisioningStep entity by id.
func (m *PlanMutation) SetPlanToProvisioningStepID(id uuid.UUID) {
	m._PlanToProvisioningStep = &id
}

// ClearPlanToProvisioningStep clears the "PlanToProvisioningStep" edge to the ProvisioningStep entity.
func (m *PlanMutation) ClearPlanToProvisioningStep() {
	m.cleared_PlanToProvisioningStep = true
}

// PlanToProvisioningStepCleared reports if the "PlanToProvisioningStep" edge to the ProvisioningStep entity was cleared.
func (m *PlanMutation) PlanToProvisioningStepCleared() bool {
	return m.cleared_PlanToProvisioningStep
}

// PlanToProvisioningStepID returns the "PlanToProvisioningStep" edge ID in the mutation.
func (m *PlanMutation) PlanToProvisioningStepID() (id uuid.UUID, exists bool) {
	if m._PlanToProvisioningStep != nil {
		return *m._PlanToProvisioningStep, true
	}
	return
}

// PlanToProvisioningStepIDs returns the "PlanToProvisioningStep" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanToProvisioningStepID instead. It exists only for internal usage by the builders.
func (m *PlanMutation) PlanToProvisioningStepIDs() (ids []uuid.UUID) {
	if id := m._PlanToProvisioningStep; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlanToProvisioningStep resets all changes to the "PlanToProvisioningStep" edge.
func (m *PlanMutation) ResetPlanToProvisioningStep() {
	m._PlanToProvisioningStep = nil
	m.cleared_PlanToProvisioningStep = false
}

// SetPlanToStatusID sets the "PlanToStatus" edge to the Status entity by id.
func (m *PlanMutation) SetPlanToStatusID(id uuid.UUID) {
	m._PlanToStatus = &id
}

// ClearPlanToStatus clears the "PlanToStatus" edge to the Status entity.
func (m *PlanMutation) ClearPlanToStatus() {
	m.cleared_PlanToStatus = true
}

// PlanToStatusCleared reports if the "PlanToStatus" edge to the Status entity was cleared.
func (m *PlanMutation) PlanToStatusCleared() bool {
	return m.cleared_PlanToStatus
}

// PlanToStatusID returns the "PlanToStatus" edge ID in the mutation.
func (m *PlanMutation) PlanToStatusID() (id uuid.UUID, exists bool) {
	if m._PlanToStatus != nil {
		return *m._PlanToStatus, true
	}
	return
}

// PlanToStatusIDs returns the "PlanToStatus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanToStatusID instead. It exists only for internal usage by the builders.
func (m *PlanMutation) PlanToStatusIDs() (ids []uuid.UUID) {
	if id := m._PlanToStatus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlanToStatus resets all changes to the "PlanToStatus" edge.
func (m *PlanMutation) ResetPlanToStatus() {
	m._PlanToStatus = nil
	m.cleared_PlanToStatus = false
}

// AddPlanToPlanDiffIDs adds the "PlanToPlanDiffs" edge to the PlanDiff entity by ids.
func (m *PlanMutation) AddPlanToPlanDiffIDs(ids ...uuid.UUID) {
	if m._PlanToPlanDiffs == nil {
		m._PlanToPlanDiffs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._PlanToPlanDiffs[ids[i]] = struct{}{}
	}
}

// ClearPlanToPlanDiffs clears the "PlanToPlanDiffs" edge to the PlanDiff entity.
func (m *PlanMutation) ClearPlanToPlanDiffs() {
	m.cleared_PlanToPlanDiffs = true
}

// PlanToPlanDiffsCleared reports if the "PlanToPlanDiffs" edge to the PlanDiff entity was cleared.
func (m *PlanMutation) PlanToPlanDiffsCleared() bool {
	return m.cleared_PlanToPlanDiffs
}

// RemovePlanToPlanDiffIDs removes the "PlanToPlanDiffs" edge to the PlanDiff entity by IDs.
func (m *PlanMutation) RemovePlanToPlanDiffIDs(ids ...uuid.UUID) {
	if m.removed_PlanToPlanDiffs == nil {
		m.removed_PlanToPlanDiffs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._PlanToPlanDiffs, ids[i])
		m.removed_PlanToPlanDiffs[ids[i]] = struct{}{}
	}
}

// RemovedPlanToPlanDiffs returns the removed IDs of the "PlanToPlanDiffs" edge to the PlanDiff entity.
func (m *PlanMutation) RemovedPlanToPlanDiffsIDs() (ids []uuid.UUID) {
	for id := range m.removed_PlanToPlanDiffs {
		ids = append(ids, id)
	}
	return
}

// PlanToPlanDiffsIDs returns the "PlanToPlanDiffs" edge IDs in the mutation.
func (m *PlanMutation) PlanToPlanDiffsIDs() (ids []uuid.UUID) {
	for id := range m._PlanToPlanDiffs {
		ids = append(ids, id)
	}
	return
}

// ResetPlanToPlanDiffs resets all changes to the "PlanToPlanDiffs" edge.
func (m *PlanMutation) ResetPlanToPlanDiffs() {
	m._PlanToPlanDiffs = nil
	m.cleared_PlanToPlanDiffs = false
	m.removed_PlanToPlanDiffs = nil
}

// Where appends a list predicates to the PlanMutation builder.
func (m *PlanMutation) Where(ps ...predicate.Plan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Plan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Plan).
func (m *PlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlanMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.step_number != nil {
		fields = append(fields, plan.FieldStepNumber)
	}
	if m._type != nil {
		fields = append(fields, plan.FieldType)
	}
	if m.build_id != nil {
		fields = append(fields, plan.FieldBuildID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case plan.FieldStepNumber:
		return m.StepNumber()
	case plan.FieldType:
		return m.GetType()
	case plan.FieldBuildID:
		return m.BuildID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case plan.FieldStepNumber:
		return m.OldStepNumber(ctx)
	case plan.FieldType:
		return m.OldType(ctx)
	case plan.FieldBuildID:
		return m.OldBuildID(ctx)
	}
	return nil, fmt.Errorf("unknown Plan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case plan.FieldStepNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepNumber(v)
		return nil
	case plan.FieldType:
		v, ok := value.(plan.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case plan.FieldBuildID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuildID(v)
		return nil
	}
	return fmt.Errorf("unknown Plan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlanMutation) AddedFields() []string {
	var fields []string
	if m.addstep_number != nil {
		fields = append(fields, plan.FieldStepNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case plan.FieldStepNumber:
		return m.AddedStepNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case plan.FieldStepNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStepNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Plan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlanMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Plan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlanMutation) ResetField(name string) error {
	switch name {
	case plan.FieldStepNumber:
		m.ResetStepNumber()
		return nil
	case plan.FieldType:
		m.ResetType()
		return nil
	case plan.FieldBuildID:
		m.ResetBuildID()
		return nil
	}
	return fmt.Errorf("unknown Plan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m._PrevPlan != nil {
		edges = append(edges, plan.EdgePrevPlan)
	}
	if m._NextPlan != nil {
		edges = append(edges, plan.EdgeNextPlan)
	}
	if m._PlanToBuild != nil {
		edges = append(edges, plan.EdgePlanToBuild)
	}
	if m._PlanToTeam != nil {
		edges = append(edges, plan.EdgePlanToTeam)
	}
	if m._PlanToProvisionedNetwork != nil {
		edges = append(edges, plan.EdgePlanToProvisionedNetwork)
	}
	if m._PlanToProvisionedHost != nil {
		edges = append(edges, plan.EdgePlanToProvisionedHost)
	}
	if m._PlanToProvisioningStep != nil {
		edges = append(edges, plan.EdgePlanToProvisioningStep)
	}
	if m._PlanToStatus != nil {
		edges = append(edges, plan.EdgePlanToStatus)
	}
	if m._PlanToPlanDiffs != nil {
		edges = append(edges, plan.EdgePlanToPlanDiffs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case plan.EdgePrevPlan:
		ids := make([]ent.Value, 0, len(m._PrevPlan))
		for id := range m._PrevPlan {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeNextPlan:
		ids := make([]ent.Value, 0, len(m._NextPlan))
		for id := range m._NextPlan {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgePlanToBuild:
		if id := m._PlanToBuild; id != nil {
			return []ent.Value{*id}
		}
	case plan.EdgePlanToTeam:
		if id := m._PlanToTeam; id != nil {
			return []ent.Value{*id}
		}
	case plan.EdgePlanToProvisionedNetwork:
		if id := m._PlanToProvisionedNetwork; id != nil {
			return []ent.Value{*id}
		}
	case plan.EdgePlanToProvisionedHost:
		if id := m._PlanToProvisionedHost; id != nil {
			return []ent.Value{*id}
		}
	case plan.EdgePlanToProvisioningStep:
		if id := m._PlanToProvisioningStep; id != nil {
			return []ent.Value{*id}
		}
	case plan.EdgePlanToStatus:
		if id := m._PlanToStatus; id != nil {
			return []ent.Value{*id}
		}
	case plan.EdgePlanToPlanDiffs:
		ids := make([]ent.Value, 0, len(m._PlanToPlanDiffs))
		for id := range m._PlanToPlanDiffs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removed_PrevPlan != nil {
		edges = append(edges, plan.EdgePrevPlan)
	}
	if m.removed_NextPlan != nil {
		edges = append(edges, plan.EdgeNextPlan)
	}
	if m.removed_PlanToPlanDiffs != nil {
		edges = append(edges, plan.EdgePlanToPlanDiffs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case plan.EdgePrevPlan:
		ids := make([]ent.Value, 0, len(m.removed_PrevPlan))
		for id := range m.removed_PrevPlan {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeNextPlan:
		ids := make([]ent.Value, 0, len(m.removed_NextPlan))
		for id := range m.removed_NextPlan {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgePlanToPlanDiffs:
		ids := make([]ent.Value, 0, len(m.removed_PlanToPlanDiffs))
		for id := range m.removed_PlanToPlanDiffs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.cleared_PrevPlan {
		edges = append(edges, plan.EdgePrevPlan)
	}
	if m.cleared_NextPlan {
		edges = append(edges, plan.EdgeNextPlan)
	}
	if m.cleared_PlanToBuild {
		edges = append(edges, plan.EdgePlanToBuild)
	}
	if m.cleared_PlanToTeam {
		edges = append(edges, plan.EdgePlanToTeam)
	}
	if m.cleared_PlanToProvisionedNetwork {
		edges = append(edges, plan.EdgePlanToProvisionedNetwork)
	}
	if m.cleared_PlanToProvisionedHost {
		edges = append(edges, plan.EdgePlanToProvisionedHost)
	}
	if m.cleared_PlanToProvisioningStep {
		edges = append(edges, plan.EdgePlanToProvisioningStep)
	}
	if m.cleared_PlanToStatus {
		edges = append(edges, plan.EdgePlanToStatus)
	}
	if m.cleared_PlanToPlanDiffs {
		edges = append(edges, plan.EdgePlanToPlanDiffs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlanMutation) EdgeCleared(name string) bool {
	switch name {
	case plan.EdgePrevPlan:
		return m.cleared_PrevPlan
	case plan.EdgeNextPlan:
		return m.cleared_NextPlan
	case plan.EdgePlanToBuild:
		return m.cleared_PlanToBuild
	case plan.EdgePlanToTeam:
		return m.cleared_PlanToTeam
	case plan.EdgePlanToProvisionedNetwork:
		return m.cleared_PlanToProvisionedNetwork
	case plan.EdgePlanToProvisionedHost:
		return m.cleared_PlanToProvisionedHost
	case plan.EdgePlanToProvisioningStep:
		return m.cleared_PlanToProvisioningStep
	case plan.EdgePlanToStatus:
		return m.cleared_PlanToStatus
	case plan.EdgePlanToPlanDiffs:
		return m.cleared_PlanToPlanDiffs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlanMutation) ClearEdge(name string) error {
	switch name {
	case plan.EdgePlanToBuild:
		m.ClearPlanToBuild()
		return nil
	case plan.EdgePlanToTeam:
		m.ClearPlanToTeam()
		return nil
	case plan.EdgePlanToProvisionedNetwork:
		m.ClearPlanToProvisionedNetwork()
		return nil
	case plan.EdgePlanToProvisionedHost:
		m.ClearPlanToProvisionedHost()
		return nil
	case plan.EdgePlanToProvisioningStep:
		m.ClearPlanToProvisioningStep()
		return nil
	case plan.EdgePlanToStatus:
		m.ClearPlanToStatus()
		return nil
	}
	return fmt.Errorf("unknown Plan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlanMutation) ResetEdge(name string) error {
	switch name {
	case plan.EdgePrevPlan:
		m.ResetPrevPlan()
		return nil
	case plan.EdgeNextPlan:
		m.ResetNextPlan()
		return nil
	case plan.EdgePlanToBuild:
		m.ResetPlanToBuild()
		return nil
	case plan.EdgePlanToTeam:
		m.ResetPlanToTeam()
		return nil
	case plan.EdgePlanToProvisionedNetwork:
		m.ResetPlanToProvisionedNetwork()
		return nil
	case plan.EdgePlanToProvisionedHost:
		m.ResetPlanToProvisionedHost()
		return nil
	case plan.EdgePlanToProvisioningStep:
		m.ResetPlanToProvisioningStep()
		return nil
	case plan.EdgePlanToStatus:
		m.ResetPlanToStatus()
		return nil
	case plan.EdgePlanToPlanDiffs:
		m.ResetPlanToPlanDiffs()
		return nil
	}
	return fmt.Errorf("unknown Plan edge %s", name)
}

// PlanDiffMutation represents an operation that mutates the PlanDiff nodes in the graph.
type PlanDiffMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	revision                      *int
	addrevision                   *int
	new_state                     *plandiff.NewState
	clearedFields                 map[string]struct{}
	_PlanDiffToBuildCommit        *uuid.UUID
	cleared_PlanDiffToBuildCommit bool
	_PlanDiffToPlan               *uuid.UUID
	cleared_PlanDiffToPlan        bool
	done                          bool
	oldValue                      func(context.Context) (*PlanDiff, error)
	predicates                    []predicate.PlanDiff
}

var _ ent.Mutation = (*PlanDiffMutation)(nil)

// plandiffOption allows management of the mutation configuration using functional options.
type plandiffOption func(*PlanDiffMutation)

// newPlanDiffMutation creates new mutation for the PlanDiff entity.
func newPlanDiffMutation(c config, op Op, opts ...plandiffOption) *PlanDiffMutation {
	m := &PlanDiffMutation{
		config:        c,
		op:            op,
		typ:           TypePlanDiff,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlanDiffID sets the ID field of the mutation.
func withPlanDiffID(id uuid.UUID) plandiffOption {
	return func(m *PlanDiffMutation) {
		var (
			err   error
			once  sync.Once
			value *PlanDiff
		)
		m.oldValue = func(ctx context.Context) (*PlanDiff, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlanDiff.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlanDiff sets the old PlanDiff of the mutation.
func withPlanDiff(node *PlanDiff) plandiffOption {
	return func(m *PlanDiffMutation) {
		m.oldValue = func(context.Context) (*PlanDiff, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanDiffMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanDiffMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PlanDiff entities.
func (m *PlanDiffMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlanDiffMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlanDiffMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlanDiff.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRevision sets the "revision" field.
func (m *PlanDiffMutation) SetRevision(i int) {
	m.revision = &i
	m.addrevision = nil
}

// Revision returns the value of the "revision" field in the mutation.
func (m *PlanDiffMutation) Revision() (r int, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the PlanDiff entity.
// If the PlanDiff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanDiffMutation) OldRevision(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// AddRevision adds i to the "revision" field.
func (m *PlanDiffMutation) AddRevision(i int) {
	if m.addrevision != nil {
		*m.addrevision += i
	} else {
		m.addrevision = &i
	}
}

// AddedRevision returns the value that was added to the "revision" field in this mutation.
func (m *PlanDiffMutation) AddedRevision() (r int, exists bool) {
	v := m.addrevision
	if v == nil {
		return
	}
	return *v, true
}

// ResetRevision resets all changes to the "revision" field.
func (m *PlanDiffMutation) ResetRevision() {
	m.revision = nil
	m.addrevision = nil
}

// SetNewState sets the "new_state" field.
func (m *PlanDiffMutation) SetNewState(ps plandiff.NewState) {
	m.new_state = &ps
}

// NewState returns the value of the "new_state" field in the mutation.
func (m *PlanDiffMutation) NewState() (r plandiff.NewState, exists bool) {
	v := m.new_state
	if v == nil {
		return
	}
	return *v, true
}

// OldNewState returns the old "new_state" field's value of the PlanDiff entity.
// If the PlanDiff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanDiffMutation) OldNewState(ctx context.Context) (v plandiff.NewState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNewState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNewState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNewState: %w", err)
	}
	return oldValue.NewState, nil
}

// ResetNewState resets all changes to the "new_state" field.
func (m *PlanDiffMutation) ResetNewState() {
	m.new_state = nil
}

// SetPlanDiffToBuildCommitID sets the "PlanDiffToBuildCommit" edge to the BuildCommit entity by id.
func (m *PlanDiffMutation) SetPlanDiffToBuildCommitID(id uuid.UUID) {
	m._PlanDiffToBuildCommit = &id
}

// ClearPlanDiffToBuildCommit clears the "PlanDiffToBuildCommit" edge to the BuildCommit entity.
func (m *PlanDiffMutation) ClearPlanDiffToBuildCommit() {
	m.cleared_PlanDiffToBuildCommit = true
}

// PlanDiffToBuildCommitCleared reports if the "PlanDiffToBuildCommit" edge to the BuildCommit entity was cleared.
func (m *PlanDiffMutation) PlanDiffToBuildCommitCleared() bool {
	return m.cleared_PlanDiffToBuildCommit
}

// PlanDiffToBuildCommitID returns the "PlanDiffToBuildCommit" edge ID in the mutation.
func (m *PlanDiffMutation) PlanDiffToBuildCommitID() (id uuid.UUID, exists bool) {
	if m._PlanDiffToBuildCommit != nil {
		return *m._PlanDiffToBuildCommit, true
	}
	return
}

// PlanDiffToBuildCommitIDs returns the "PlanDiffToBuildCommit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanDiffToBuildCommitID instead. It exists only for internal usage by the builders.
func (m *PlanDiffMutation) PlanDiffToBuildCommitIDs() (ids []uuid.UUID) {
	if id := m._PlanDiffToBuildCommit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlanDiffToBuildCommit resets all changes to the "PlanDiffToBuildCommit" edge.
func (m *PlanDiffMutation) ResetPlanDiffToBuildCommit() {
	m._PlanDiffToBuildCommit = nil
	m.cleared_PlanDiffToBuildCommit = false
}

// SetPlanDiffToPlanID sets the "PlanDiffToPlan" edge to the Plan entity by id.
func (m *PlanDiffMutation) SetPlanDiffToPlanID(id uuid.UUID) {
	m._PlanDiffToPlan = &id
}

// ClearPlanDiffToPlan clears the "PlanDiffToPlan" edge to the Plan entity.
func (m *PlanDiffMutation) ClearPlanDiffToPlan() {
	m.cleared_PlanDiffToPlan = true
}

// PlanDiffToPlanCleared reports if the "PlanDiffToPlan" edge to the Plan entity was cleared.
func (m *PlanDiffMutation) PlanDiffToPlanCleared() bool {
	return m.cleared_PlanDiffToPlan
}

// PlanDiffToPlanID returns the "PlanDiffToPlan" edge ID in the mutation.
func (m *PlanDiffMutation) PlanDiffToPlanID() (id uuid.UUID, exists bool) {
	if m._PlanDiffToPlan != nil {
		return *m._PlanDiffToPlan, true
	}
	return
}

// PlanDiffToPlanIDs returns the "PlanDiffToPlan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanDiffToPlanID instead. It exists only for internal usage by the builders.
func (m *PlanDiffMutation) PlanDiffToPlanIDs() (ids []uuid.UUID) {
	if id := m._PlanDiffToPlan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlanDiffToPlan resets all changes to the "PlanDiffToPlan" edge.
func (m *PlanDiffMutation) ResetPlanDiffToPlan() {
	m._PlanDiffToPlan = nil
	m.cleared_PlanDiffToPlan = false
}

// Where appends a list predicates to the PlanDiffMutation builder.
func (m *PlanDiffMutation) Where(ps ...predicate.PlanDiff) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlanDiffMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlanDiffMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlanDiff, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlanDiffMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlanDiffMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlanDiff).
func (m *PlanDiffMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlanDiffMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.revision != nil {
		fields = append(fields, plandiff.FieldRevision)
	}
	if m.new_state != nil {
		fields = append(fields, plandiff.FieldNewState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlanDiffMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case plandiff.FieldRevision:
		return m.Revision()
	case plandiff.FieldNewState:
		return m.NewState()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlanDiffMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case plandiff.FieldRevision:
		return m.OldRevision(ctx)
	case plandiff.FieldNewState:
		return m.OldNewState(ctx)
	}
	return nil, fmt.Errorf("unknown PlanDiff field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanDiffMutation) SetField(name string, value ent.Value) error {
	switch name {
	case plandiff.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case plandiff.FieldNewState:
		v, ok := value.(plandiff.NewState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNewState(v)
		return nil
	}
	return fmt.Errorf("unknown PlanDiff field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlanDiffMutation) AddedFields() []string {
	var fields []string
	if m.addrevision != nil {
		fields = append(fields, plandiff.FieldRevision)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlanDiffMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case plandiff.FieldRevision:
		return m.AddedRevision()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanDiffMutation) AddField(name string, value ent.Value) error {
	switch name {
	case plandiff.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevision(v)
		return nil
	}
	return fmt.Errorf("unknown PlanDiff numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlanDiffMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlanDiffMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanDiffMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PlanDiff nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlanDiffMutation) ResetField(name string) error {
	switch name {
	case plandiff.FieldRevision:
		m.ResetRevision()
		return nil
	case plandiff.FieldNewState:
		m.ResetNewState()
		return nil
	}
	return fmt.Errorf("unknown PlanDiff field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlanDiffMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._PlanDiffToBuildCommit != nil {
		edges = append(edges, plandiff.EdgePlanDiffToBuildCommit)
	}
	if m._PlanDiffToPlan != nil {
		edges = append(edges, plandiff.EdgePlanDiffToPlan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlanDiffMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case plandiff.EdgePlanDiffToBuildCommit:
		if id := m._PlanDiffToBuildCommit; id != nil {
			return []ent.Value{*id}
		}
	case plandiff.EdgePlanDiffToPlan:
		if id := m._PlanDiffToPlan; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlanDiffMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlanDiffMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlanDiffMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_PlanDiffToBuildCommit {
		edges = append(edges, plandiff.EdgePlanDiffToBuildCommit)
	}
	if m.cleared_PlanDiffToPlan {
		edges = append(edges, plandiff.EdgePlanDiffToPlan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlanDiffMutation) EdgeCleared(name string) bool {
	switch name {
	case plandiff.EdgePlanDiffToBuildCommit:
		return m.cleared_PlanDiffToBuildCommit
	case plandiff.EdgePlanDiffToPlan:
		return m.cleared_PlanDiffToPlan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlanDiffMutation) ClearEdge(name string) error {
	switch name {
	case plandiff.EdgePlanDiffToBuildCommit:
		m.ClearPlanDiffToBuildCommit()
		return nil
	case plandiff.EdgePlanDiffToPlan:
		m.ClearPlanDiffToPlan()
		return nil
	}
	return fmt.Errorf("unknown PlanDiff unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlanDiffMutation) ResetEdge(name string) error {
	switch name {
	case plandiff.EdgePlanDiffToBuildCommit:
		m.ResetPlanDiffToBuildCommit()
		return nil
	case plandiff.EdgePlanDiffToPlan:
		m.ResetPlanDiffToPlan()
		return nil
	}
	return fmt.Errorf("unknown PlanDiff edge %s", name)
}

// ProvisionedHostMutation represents an operation that mutates the ProvisionedHost nodes in the graph.
type ProvisionedHostMutation struct {
	config
	op                                          Op
	typ                                         string
	id                                          *uuid.UUID
	subnet_ip                                   *string
	addon_type                                  *provisionedhost.AddonType
	vars                                        *map[string]string
	clearedFields                               map[string]struct{}
	_ProvisionedHostToStatus                    *uuid.UUID
	cleared_ProvisionedHostToStatus             bool
	_ProvisionedHostToProvisionedNetwork        *uuid.UUID
	cleared_ProvisionedHostToProvisionedNetwork bool
	_ProvisionedHostToHost                      *uuid.UUID
	cleared_ProvisionedHostToHost               bool
	_ProvisionedHostToEndStepPlan               *uuid.UUID
	cleared_ProvisionedHostToEndStepPlan        bool
	_ProvisionedHostToBuild                     *uuid.UUID
	cleared_ProvisionedHostToBuild              bool
	_ProvisionedHostToProvisioningStep          map[uuid.UUID]struct{}
	removed_ProvisionedHostToProvisioningStep   map[uuid.UUID]struct{}
	cleared_ProvisionedHostToProvisioningStep   bool
	_ProvisionedHostToAgentStatus               map[uuid.UUID]struct{}
	removed_ProvisionedHostToAgentStatus        map[uuid.UUID]struct{}
	cleared_ProvisionedHostToAgentStatus        bool
	_ProvisionedHostToAgentTask                 map[uuid.UUID]struct{}
	removed_ProvisionedHostToAgentTask          map[uuid.UUID]struct{}
	cleared_ProvisionedHostToAgentTask          bool
	_ProvisionedHostToPlan                      *uuid.UUID
	cleared_ProvisionedHostToPlan               bool
	_ProvisionedHostToGinFileMiddleware         *uuid.UUID
	cleared_ProvisionedHostToGinFileMiddleware  bool
	done                                        bool
	oldValue                                    func(context.Context) (*ProvisionedHost, error)
	predicates                                  []predicate.ProvisionedHost
}

var _ ent.Mutation = (*ProvisionedHostMutation)(nil)

// provisionedhostOption allows management of the mutation configuration using functional options.
type provisionedhostOption func(*ProvisionedHostMutation)

// newProvisionedHostMutation creates new mutation for the ProvisionedHost entity.
func newProvisionedHostMutation(c config, op Op, opts ...provisionedhostOption) *ProvisionedHostMutation {
	m := &ProvisionedHostMutation{
		config:        c,
		op:            op,
		typ:           TypeProvisionedHost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProvisionedHostID sets the ID field of the mutation.
func withProvisionedHostID(id uuid.UUID) provisionedhostOption {
	return func(m *ProvisionedHostMutation) {
		var (
			err   error
			once  sync.Once
			value *ProvisionedHost
		)
		m.oldValue = func(ctx context.Context) (*ProvisionedHost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProvisionedHost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvisionedHost sets the old ProvisionedHost of the mutation.
func withProvisionedHost(node *ProvisionedHost) provisionedhostOption {
	return func(m *ProvisionedHostMutation) {
		m.oldValue = func(context.Context) (*ProvisionedHost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProvisionedHostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProvisionedHostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProvisionedHost entities.
func (m *ProvisionedHostMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProvisionedHostMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProvisionedHostMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProvisionedHost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSubnetIP sets the "subnet_ip" field.
func (m *ProvisionedHostMutation) SetSubnetIP(s string) {
	m.subnet_ip = &s
}

// SubnetIP returns the value of the "subnet_ip" field in the mutation.
func (m *ProvisionedHostMutation) SubnetIP() (r string, exists bool) {
	v := m.subnet_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldSubnetIP returns the old "subnet_ip" field's value of the ProvisionedHost entity.
// If the ProvisionedHost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvisionedHostMutation) OldSubnetIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubnetIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubnetIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubnetIP: %w", err)
	}
	return oldValue.SubnetIP, nil
}

// ResetSubnetIP resets all changes to the "subnet_ip" field.
func (m *ProvisionedHostMutation) ResetSubnetIP() {
	m.subnet_ip = nil
}

// SetAddonType sets the "addon_type" field.
func (m *ProvisionedHostMutation) SetAddonType(pt provisionedhost.AddonType) {
	m.addon_type = &pt
}

// AddonType returns the value of the "addon_type" field in the mutation.
func (m *ProvisionedHostMutation) AddonType() (r provisionedhost.AddonType, exists bool) {
	v := m.addon_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAddonType returns the old "addon_type" field's value of the ProvisionedHost entity.
// If the ProvisionedHost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvisionedHostMutation) OldAddonType(ctx context.Context) (v *provisionedhost.AddonType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddonType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddonType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddonType: %w", err)
	}
	return oldValue.AddonType, nil
}

// ClearAddonType clears the value of the "addon_type" field.
func (m *ProvisionedHostMutation) ClearAddonType() {
	m.addon_type = nil
	m.clearedFields[provisionedhost.FieldAddonType] = struct{}{}
}

// AddonTypeCleared returns if the "addon_type" field was cleared in this mutation.
func (m *ProvisionedHostMutation) AddonTypeCleared() bool {
	_, ok := m.clearedFields[provisionedhost.FieldAddonType]
	return ok
}

// ResetAddonType resets all changes to the "addon_type" field.
func (m *ProvisionedHostMutation) ResetAddonType() {
	m.addon_type = nil
	delete(m.clearedFields, provisionedhost.FieldAddonType)
}

// SetVars sets the "vars" field.
func (m *ProvisionedHostMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *ProvisionedHostMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the ProvisionedHost entity.
// If the ProvisionedHost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvisionedHostMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *ProvisionedHostMutation) ResetVars() {
	m.vars = nil
}

// SetProvisionedHostToStatusID sets the "ProvisionedHostToStatus" edge to the Status entity by id.
func (m *ProvisionedHostMutation) SetProvisionedHostToStatusID(id uuid.UUID) {
	m._ProvisionedHostToStatus = &id
}

// ClearProvisionedHostToStatus clears the "ProvisionedHostToStatus" edge to the Status entity.
func (m *ProvisionedHostMutation) ClearProvisionedHostToStatus() {
	m.cleared_ProvisionedHostToStatus = true
}

// ProvisionedHostToStatusCleared reports if the "ProvisionedHostToStatus" edge to the Status entity was cleared.
func (m *ProvisionedHostMutation) ProvisionedHostToStatusCleared() bool {
	return m.cleared_ProvisionedHostToStatus
}

// ProvisionedHostToStatusID returns the "ProvisionedHostToStatus" edge ID in the mutation.
func (m *ProvisionedHostMutation) ProvisionedHostToStatusID() (id uuid.UUID, exists bool) {
	if m._ProvisionedHostToStatus != nil {
		return *m._ProvisionedHostToStatus, true
	}
	return
}

// ProvisionedHostToStatusIDs returns the "ProvisionedHostToStatus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisionedHostToStatusID instead. It exists only for internal usage by the builders.
func (m *ProvisionedHostMutation) ProvisionedHostToStatusIDs() (ids []uuid.UUID) {
	if id := m._ProvisionedHostToStatus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisionedHostToStatus resets all changes to the "ProvisionedHostToStatus" edge.
func (m *ProvisionedHostMutation) ResetProvisionedHostToStatus() {
	m._ProvisionedHostToStatus = nil
	m.cleared_ProvisionedHostToStatus = false
}

// SetProvisionedHostToProvisionedNetworkID sets the "ProvisionedHostToProvisionedNetwork" edge to the ProvisionedNetwork entity by id.
func (m *ProvisionedHostMutation) SetProvisionedHostToProvisionedNetworkID(id uuid.UUID) {
	m._ProvisionedHostToProvisionedNetwork = &id
}

// ClearProvisionedHostToProvisionedNetwork clears the "ProvisionedHostToProvisionedNetwork" edge to the ProvisionedNetwork entity.
func (m *ProvisionedHostMutation) ClearProvisionedHostToProvisionedNetwork() {
	m.cleared_ProvisionedHostToProvisionedNetwork = true
}

// ProvisionedHostToProvisionedNetworkCleared reports if the "ProvisionedHostToProvisionedNetwork" edge to the ProvisionedNetwork entity was cleared.
func (m *ProvisionedHostMutation) ProvisionedHostToProvisionedNetworkCleared() bool {
	return m.cleared_ProvisionedHostToProvisionedNetwork
}

// ProvisionedHostToProvisionedNetworkID returns the "ProvisionedHostToProvisionedNetwork" edge ID in the mutation.
func (m *ProvisionedHostMutation) ProvisionedHostToProvisionedNetworkID() (id uuid.UUID, exists bool) {
	if m._ProvisionedHostToProvisionedNetwork != nil {
		return *m._ProvisionedHostToProvisionedNetwork, true
	}
	return
}

// ProvisionedHostToProvisionedNetworkIDs returns the "ProvisionedHostToProvisionedNetwork" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisionedHostToProvisionedNetworkID instead. It exists only for internal usage by the builders.
func (m *ProvisionedHostMutation) ProvisionedHostToProvisionedNetworkIDs() (ids []uuid.UUID) {
	if id := m._ProvisionedHostToProvisionedNetwork; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisionedHostToProvisionedNetwork resets all changes to the "ProvisionedHostToProvisionedNetwork" edge.
func (m *ProvisionedHostMutation) ResetProvisionedHostToProvisionedNetwork() {
	m._ProvisionedHostToProvisionedNetwork = nil
	m.cleared_ProvisionedHostToProvisionedNetwork = false
}

// SetProvisionedHostToHostID sets the "ProvisionedHostToHost" edge to the Host entity by id.
func (m *ProvisionedHostMutation) SetProvisionedHostToHostID(id uuid.UUID) {
	m._ProvisionedHostToHost = &id
}

// ClearProvisionedHostToHost clears the "ProvisionedHostToHost" edge to the Host entity.
func (m *ProvisionedHostMutation) ClearProvisionedHostToHost() {
	m.cleared_ProvisionedHostToHost = true
}

// ProvisionedHostToHostCleared reports if the "ProvisionedHostToHost" edge to the Host entity was cleared.
func (m *ProvisionedHostMutation) ProvisionedHostToHostCleared() bool {
	return m.cleared_ProvisionedHostToHost
}

// ProvisionedHostToHostID returns the "ProvisionedHostToHost" edge ID in the mutation.
func (m *ProvisionedHostMutation) ProvisionedHostToHostID() (id uuid.UUID, exists bool) {
	if m._ProvisionedHostToHost != nil {
		return *m._ProvisionedHostToHost, true
	}
	return
}

// ProvisionedHostToHostIDs returns the "ProvisionedHostToHost" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisionedHostToHostID instead. It exists only for internal usage by the builders.
func (m *ProvisionedHostMutation) ProvisionedHostToHostIDs() (ids []uuid.UUID) {
	if id := m._ProvisionedHostToHost; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisionedHostToHost resets all changes to the "ProvisionedHostToHost" edge.
func (m *ProvisionedHostMutation) ResetProvisionedHostToHost() {
	m._ProvisionedHostToHost = nil
	m.cleared_ProvisionedHostToHost = false
}

// SetProvisionedHostToEndStepPlanID sets the "ProvisionedHostToEndStepPlan" edge to the Plan entity by id.
func (m *ProvisionedHostMutation) SetProvisionedHostToEndStepPlanID(id uuid.UUID) {
	m._ProvisionedHostToEndStepPlan = &id
}

// ClearProvisionedHostToEndStepPlan clears the "ProvisionedHostToEndStepPlan" edge to the Plan entity.
func (m *ProvisionedHostMutation) ClearProvisionedHostToEndStepPlan() {
	m.cleared_ProvisionedHostToEndStepPlan = true
}

// ProvisionedHostToEndStepPlanCleared reports if the "ProvisionedHostToEndStepPlan" edge to the Plan entity was cleared.
func (m *ProvisionedHostMutation) ProvisionedHostToEndStepPlanCleared() bool {
	return m.cleared_ProvisionedHostToEndStepPlan
}

// ProvisionedHostToEndStepPlanID returns the "ProvisionedHostToEndStepPlan" edge ID in the mutation.
func (m *ProvisionedHostMutation) ProvisionedHostToEndStepPlanID() (id uuid.UUID, exists bool) {
	if m._ProvisionedHostToEndStepPlan != nil {
		return *m._ProvisionedHostToEndStepPlan, true
	}
	return
}

// ProvisionedHostToEndStepPlanIDs returns the "ProvisionedHostToEndStepPlan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisionedHostToEndStepPlanID instead. It exists only for internal usage by the builders.
func (m *ProvisionedHostMutation) ProvisionedHostToEndStepPlanIDs() (ids []uuid.UUID) {
	if id := m._ProvisionedHostToEndStepPlan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisionedHostToEndStepPlan resets all changes to the "ProvisionedHostToEndStepPlan" edge.
func (m *ProvisionedHostMutation) ResetProvisionedHostToEndStepPlan() {
	m._ProvisionedHostToEndStepPlan = nil
	m.cleared_ProvisionedHostToEndStepPlan = false
}

// SetProvisionedHostToBuildID sets the "ProvisionedHostToBuild" edge to the Build entity by id.
func (m *ProvisionedHostMutation) SetProvisionedHostToBuildID(id uuid.UUID) {
	m._ProvisionedHostToBuild = &id
}

// ClearProvisionedHostToBuild clears the "ProvisionedHostToBuild" edge to the Build entity.
func (m *ProvisionedHostMutation) ClearProvisionedHostToBuild() {
	m.cleared_ProvisionedHostToBuild = true
}

// ProvisionedHostToBuildCleared reports if the "ProvisionedHostToBuild" edge to the Build entity was cleared.
func (m *ProvisionedHostMutation) ProvisionedHostToBuildCleared() bool {
	return m.cleared_ProvisionedHostToBuild
}

// ProvisionedHostToBuildID returns the "ProvisionedHostToBuild" edge ID in the mutation.
func (m *ProvisionedHostMutation) ProvisionedHostToBuildID() (id uuid.UUID, exists bool) {
	if m._ProvisionedHostToBuild != nil {
		return *m._ProvisionedHostToBuild, true
	}
	return
}

// ProvisionedHostToBuildIDs returns the "ProvisionedHostToBuild" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisionedHostToBuildID instead. It exists only for internal usage by the builders.
func (m *ProvisionedHostMutation) ProvisionedHostToBuildIDs() (ids []uuid.UUID) {
	if id := m._ProvisionedHostToBuild; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisionedHostToBuild resets all changes to the "ProvisionedHostToBuild" edge.
func (m *ProvisionedHostMutation) ResetProvisionedHostToBuild() {
	m._ProvisionedHostToBuild = nil
	m.cleared_ProvisionedHostToBuild = false
}

// AddProvisionedHostToProvisioningStepIDs adds the "ProvisionedHostToProvisioningStep" edge to the ProvisioningStep entity by ids.
func (m *ProvisionedHostMutation) AddProvisionedHostToProvisioningStepIDs(ids ...uuid.UUID) {
	if m._ProvisionedHostToProvisioningStep == nil {
		m._ProvisionedHostToProvisioningStep = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ProvisionedHostToProvisioningStep[ids[i]] = struct{}{}
	}
}

// ClearProvisionedHostToProvisioningStep clears the "ProvisionedHostToProvisioningStep" edge to the ProvisioningStep entity.
func (m *ProvisionedHostMutation) ClearProvisionedHostToProvisioningStep() {
	m.cleared_ProvisionedHostToProvisioningStep = true
}

// ProvisionedHostToProvisioningStepCleared reports if the "ProvisionedHostToProvisioningStep" edge to the ProvisioningStep entity was cleared.
func (m *ProvisionedHostMutation) ProvisionedHostToProvisioningStepCleared() bool {
	return m.cleared_ProvisionedHostToProvisioningStep
}

// RemoveProvisionedHostToProvisioningStepIDs removes the "ProvisionedHostToProvisioningStep" edge to the ProvisioningStep entity by IDs.
func (m *ProvisionedHostMutation) RemoveProvisionedHostToProvisioningStepIDs(ids ...uuid.UUID) {
	if m.removed_ProvisionedHostToProvisioningStep == nil {
		m.removed_ProvisionedHostToProvisioningStep = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._ProvisionedHostToProvisioningStep, ids[i])
		m.removed_ProvisionedHostToProvisioningStep[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedHostToProvisioningStep returns the removed IDs of the "ProvisionedHostToProvisioningStep" edge to the ProvisioningStep entity.
func (m *ProvisionedHostMutation) RemovedProvisionedHostToProvisioningStepIDs() (ids []uuid.UUID) {
	for id := range m.removed_ProvisionedHostToProvisioningStep {
		ids = append(ids, id)
	}
	return
}

// ProvisionedHostToProvisioningStepIDs returns the "ProvisionedHostToProvisioningStep" edge IDs in the mutation.
func (m *ProvisionedHostMutation) ProvisionedHostToProvisioningStepIDs() (ids []uuid.UUID) {
	for id := range m._ProvisionedHostToProvisioningStep {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedHostToProvisioningStep resets all changes to the "ProvisionedHostToProvisioningStep" edge.
func (m *ProvisionedHostMutation) ResetProvisionedHostToProvisioningStep() {
	m._ProvisionedHostToProvisioningStep = nil
	m.cleared_ProvisionedHostToProvisioningStep = false
	m.removed_ProvisionedHostToProvisioningStep = nil
}

// AddProvisionedHostToAgentStatuIDs adds the "ProvisionedHostToAgentStatus" edge to the AgentStatus entity by ids.
func (m *ProvisionedHostMutation) AddProvisionedHostToAgentStatuIDs(ids ...uuid.UUID) {
	if m._ProvisionedHostToAgentStatus == nil {
		m._ProvisionedHostToAgentStatus = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ProvisionedHostToAgentStatus[ids[i]] = struct{}{}
	}
}

// ClearProvisionedHostToAgentStatus clears the "ProvisionedHostToAgentStatus" edge to the AgentStatus entity.
func (m *ProvisionedHostMutation) ClearProvisionedHostToAgentStatus() {
	m.cleared_ProvisionedHostToAgentStatus = true
}

// ProvisionedHostToAgentStatusCleared reports if the "ProvisionedHostToAgentStatus" edge to the AgentStatus entity was cleared.
func (m *ProvisionedHostMutation) ProvisionedHostToAgentStatusCleared() bool {
	return m.cleared_ProvisionedHostToAgentStatus
}

// RemoveProvisionedHostToAgentStatuIDs removes the "ProvisionedHostToAgentStatus" edge to the AgentStatus entity by IDs.
func (m *ProvisionedHostMutation) RemoveProvisionedHostToAgentStatuIDs(ids ...uuid.UUID) {
	if m.removed_ProvisionedHostToAgentStatus == nil {
		m.removed_ProvisionedHostToAgentStatus = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._ProvisionedHostToAgentStatus, ids[i])
		m.removed_ProvisionedHostToAgentStatus[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedHostToAgentStatus returns the removed IDs of the "ProvisionedHostToAgentStatus" edge to the AgentStatus entity.
func (m *ProvisionedHostMutation) RemovedProvisionedHostToAgentStatusIDs() (ids []uuid.UUID) {
	for id := range m.removed_ProvisionedHostToAgentStatus {
		ids = append(ids, id)
	}
	return
}

// ProvisionedHostToAgentStatusIDs returns the "ProvisionedHostToAgentStatus" edge IDs in the mutation.
func (m *ProvisionedHostMutation) ProvisionedHostToAgentStatusIDs() (ids []uuid.UUID) {
	for id := range m._ProvisionedHostToAgentStatus {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedHostToAgentStatus resets all changes to the "ProvisionedHostToAgentStatus" edge.
func (m *ProvisionedHostMutation) ResetProvisionedHostToAgentStatus() {
	m._ProvisionedHostToAgentStatus = nil
	m.cleared_ProvisionedHostToAgentStatus = false
	m.removed_ProvisionedHostToAgentStatus = nil
}

// AddProvisionedHostToAgentTaskIDs adds the "ProvisionedHostToAgentTask" edge to the AgentTask entity by ids.
func (m *ProvisionedHostMutation) AddProvisionedHostToAgentTaskIDs(ids ...uuid.UUID) {
	if m._ProvisionedHostToAgentTask == nil {
		m._ProvisionedHostToAgentTask = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ProvisionedHostToAgentTask[ids[i]] = struct{}{}
	}
}

// ClearProvisionedHostToAgentTask clears the "ProvisionedHostToAgentTask" edge to the AgentTask entity.
func (m *ProvisionedHostMutation) ClearProvisionedHostToAgentTask() {
	m.cleared_ProvisionedHostToAgentTask = true
}

// ProvisionedHostToAgentTaskCleared reports if the "ProvisionedHostToAgentTask" edge to the AgentTask entity was cleared.
func (m *ProvisionedHostMutation) ProvisionedHostToAgentTaskCleared() bool {
	return m.cleared_ProvisionedHostToAgentTask
}

// RemoveProvisionedHostToAgentTaskIDs removes the "ProvisionedHostToAgentTask" edge to the AgentTask entity by IDs.
func (m *ProvisionedHostMutation) RemoveProvisionedHostToAgentTaskIDs(ids ...uuid.UUID) {
	if m.removed_ProvisionedHostToAgentTask == nil {
		m.removed_ProvisionedHostToAgentTask = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._ProvisionedHostToAgentTask, ids[i])
		m.removed_ProvisionedHostToAgentTask[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedHostToAgentTask returns the removed IDs of the "ProvisionedHostToAgentTask" edge to the AgentTask entity.
func (m *ProvisionedHostMutation) RemovedProvisionedHostToAgentTaskIDs() (ids []uuid.UUID) {
	for id := range m.removed_ProvisionedHostToAgentTask {
		ids = append(ids, id)
	}
	return
}

// ProvisionedHostToAgentTaskIDs returns the "ProvisionedHostToAgentTask" edge IDs in the mutation.
func (m *ProvisionedHostMutation) ProvisionedHostToAgentTaskIDs() (ids []uuid.UUID) {
	for id := range m._ProvisionedHostToAgentTask {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedHostToAgentTask resets all changes to the "ProvisionedHostToAgentTask" edge.
func (m *ProvisionedHostMutation) ResetProvisionedHostToAgentTask() {
	m._ProvisionedHostToAgentTask = nil
	m.cleared_ProvisionedHostToAgentTask = false
	m.removed_ProvisionedHostToAgentTask = nil
}

// SetProvisionedHostToPlanID sets the "ProvisionedHostToPlan" edge to the Plan entity by id.
func (m *ProvisionedHostMutation) SetProvisionedHostToPlanID(id uuid.UUID) {
	m._ProvisionedHostToPlan = &id
}

// ClearProvisionedHostToPlan clears the "ProvisionedHostToPlan" edge to the Plan entity.
func (m *ProvisionedHostMutation) ClearProvisionedHostToPlan() {
	m.cleared_ProvisionedHostToPlan = true
}

// ProvisionedHostToPlanCleared reports if the "ProvisionedHostToPlan" edge to the Plan entity was cleared.
func (m *ProvisionedHostMutation) ProvisionedHostToPlanCleared() bool {
	return m.cleared_ProvisionedHostToPlan
}

// ProvisionedHostToPlanID returns the "ProvisionedHostToPlan" edge ID in the mutation.
func (m *ProvisionedHostMutation) ProvisionedHostToPlanID() (id uuid.UUID, exists bool) {
	if m._ProvisionedHostToPlan != nil {
		return *m._ProvisionedHostToPlan, true
	}
	return
}

// ProvisionedHostToPlanIDs returns the "ProvisionedHostToPlan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisionedHostToPlanID instead. It exists only for internal usage by the builders.
func (m *ProvisionedHostMutation) ProvisionedHostToPlanIDs() (ids []uuid.UUID) {
	if id := m._ProvisionedHostToPlan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisionedHostToPlan resets all changes to the "ProvisionedHostToPlan" edge.
func (m *ProvisionedHostMutation) ResetProvisionedHostToPlan() {
	m._ProvisionedHostToPlan = nil
	m.cleared_ProvisionedHostToPlan = false
}

// SetProvisionedHostToGinFileMiddlewareID sets the "ProvisionedHostToGinFileMiddleware" edge to the GinFileMiddleware entity by id.
func (m *ProvisionedHostMutation) SetProvisionedHostToGinFileMiddlewareID(id uuid.UUID) {
	m._ProvisionedHostToGinFileMiddleware = &id
}

// ClearProvisionedHostToGinFileMiddleware clears the "ProvisionedHostToGinFileMiddleware" edge to the GinFileMiddleware entity.
func (m *ProvisionedHostMutation) ClearProvisionedHostToGinFileMiddleware() {
	m.cleared_ProvisionedHostToGinFileMiddleware = true
}

// ProvisionedHostToGinFileMiddlewareCleared reports if the "ProvisionedHostToGinFileMiddleware" edge to the GinFileMiddleware entity was cleared.
func (m *ProvisionedHostMutation) ProvisionedHostToGinFileMiddlewareCleared() bool {
	return m.cleared_ProvisionedHostToGinFileMiddleware
}

// ProvisionedHostToGinFileMiddlewareID returns the "ProvisionedHostToGinFileMiddleware" edge ID in the mutation.
func (m *ProvisionedHostMutation) ProvisionedHostToGinFileMiddlewareID() (id uuid.UUID, exists bool) {
	if m._ProvisionedHostToGinFileMiddleware != nil {
		return *m._ProvisionedHostToGinFileMiddleware, true
	}
	return
}

// ProvisionedHostToGinFileMiddlewareIDs returns the "ProvisionedHostToGinFileMiddleware" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisionedHostToGinFileMiddlewareID instead. It exists only for internal usage by the builders.
func (m *ProvisionedHostMutation) ProvisionedHostToGinFileMiddlewareIDs() (ids []uuid.UUID) {
	if id := m._ProvisionedHostToGinFileMiddleware; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisionedHostToGinFileMiddleware resets all changes to the "ProvisionedHostToGinFileMiddleware" edge.
func (m *ProvisionedHostMutation) ResetProvisionedHostToGinFileMiddleware() {
	m._ProvisionedHostToGinFileMiddleware = nil
	m.cleared_ProvisionedHostToGinFileMiddleware = false
}

// Where appends a list predicates to the ProvisionedHostMutation builder.
func (m *ProvisionedHostMutation) Where(ps ...predicate.ProvisionedHost) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProvisionedHostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProvisionedHostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProvisionedHost, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProvisionedHostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProvisionedHostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProvisionedHost).
func (m *ProvisionedHostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProvisionedHostMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.subnet_ip != nil {
		fields = append(fields, provisionedhost.FieldSubnetIP)
	}
	if m.addon_type != nil {
		fields = append(fields, provisionedhost.FieldAddonType)
	}
	if m.vars != nil {
		fields = append(fields, provisionedhost.FieldVars)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProvisionedHostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case provisionedhost.FieldSubnetIP:
		return m.SubnetIP()
	case provisionedhost.FieldAddonType:
		return m.AddonType()
	case provisionedhost.FieldVars:
		return m.Vars()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProvisionedHostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case provisionedhost.FieldSubnetIP:
		return m.OldSubnetIP(ctx)
	case provisionedhost.FieldAddonType:
		return m.OldAddonType(ctx)
	case provisionedhost.FieldVars:
		return m.OldVars(ctx)
	}
	return nil, fmt.Errorf("unknown ProvisionedHost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvisionedHostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case provisionedhost.FieldSubnetIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubnetIP(v)
		return nil
	case provisionedhost.FieldAddonType:
		v, ok := value.(provisionedhost.AddonType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddonType(v)
		return nil
	case provisionedhost.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	}
	return fmt.Errorf("unknown ProvisionedHost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProvisionedHostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProvisionedHostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvisionedHostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProvisionedHost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProvisionedHostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(provisionedhost.FieldAddonType) {
		fields = append(fields, provisionedhost.FieldAddonType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProvisionedHostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProvisionedHostMutation) ClearField(name string) error {
	switch name {
	case provisionedhost.FieldAddonType:
		m.ClearAddonType()
		return nil
	}
	return fmt.Errorf("unknown ProvisionedHost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProvisionedHostMutation) ResetField(name string) error {
	switch name {
	case provisionedhost.FieldSubnetIP:
		m.ResetSubnetIP()
		return nil
	case provisionedhost.FieldAddonType:
		m.ResetAddonType()
		return nil
	case provisionedhost.FieldVars:
		m.ResetVars()
		return nil
	}
	return fmt.Errorf("unknown ProvisionedHost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProvisionedHostMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m._ProvisionedHostToStatus != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToStatus)
	}
	if m._ProvisionedHostToProvisionedNetwork != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToProvisionedNetwork)
	}
	if m._ProvisionedHostToHost != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToHost)
	}
	if m._ProvisionedHostToEndStepPlan != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToEndStepPlan)
	}
	if m._ProvisionedHostToBuild != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToBuild)
	}
	if m._ProvisionedHostToProvisioningStep != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToProvisioningStep)
	}
	if m._ProvisionedHostToAgentStatus != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToAgentStatus)
	}
	if m._ProvisionedHostToAgentTask != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToAgentTask)
	}
	if m._ProvisionedHostToPlan != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToPlan)
	}
	if m._ProvisionedHostToGinFileMiddleware != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToGinFileMiddleware)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProvisionedHostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case provisionedhost.EdgeProvisionedHostToStatus:
		if id := m._ProvisionedHostToStatus; id != nil {
			return []ent.Value{*id}
		}
	case provisionedhost.EdgeProvisionedHostToProvisionedNetwork:
		if id := m._ProvisionedHostToProvisionedNetwork; id != nil {
			return []ent.Value{*id}
		}
	case provisionedhost.EdgeProvisionedHostToHost:
		if id := m._ProvisionedHostToHost; id != nil {
			return []ent.Value{*id}
		}
	case provisionedhost.EdgeProvisionedHostToEndStepPlan:
		if id := m._ProvisionedHostToEndStepPlan; id != nil {
			return []ent.Value{*id}
		}
	case provisionedhost.EdgeProvisionedHostToBuild:
		if id := m._ProvisionedHostToBuild; id != nil {
			return []ent.Value{*id}
		}
	case provisionedhost.EdgeProvisionedHostToProvisioningStep:
		ids := make([]ent.Value, 0, len(m._ProvisionedHostToProvisioningStep))
		for id := range m._ProvisionedHostToProvisioningStep {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeProvisionedHostToAgentStatus:
		ids := make([]ent.Value, 0, len(m._ProvisionedHostToAgentStatus))
		for id := range m._ProvisionedHostToAgentStatus {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeProvisionedHostToAgentTask:
		ids := make([]ent.Value, 0, len(m._ProvisionedHostToAgentTask))
		for id := range m._ProvisionedHostToAgentTask {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeProvisionedHostToPlan:
		if id := m._ProvisionedHostToPlan; id != nil {
			return []ent.Value{*id}
		}
	case provisionedhost.EdgeProvisionedHostToGinFileMiddleware:
		if id := m._ProvisionedHostToGinFileMiddleware; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProvisionedHostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removed_ProvisionedHostToProvisioningStep != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToProvisioningStep)
	}
	if m.removed_ProvisionedHostToAgentStatus != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToAgentStatus)
	}
	if m.removed_ProvisionedHostToAgentTask != nil {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToAgentTask)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProvisionedHostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case provisionedhost.EdgeProvisionedHostToProvisioningStep:
		ids := make([]ent.Value, 0, len(m.removed_ProvisionedHostToProvisioningStep))
		for id := range m.removed_ProvisionedHostToProvisioningStep {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeProvisionedHostToAgentStatus:
		ids := make([]ent.Value, 0, len(m.removed_ProvisionedHostToAgentStatus))
		for id := range m.removed_ProvisionedHostToAgentStatus {
			ids = append(ids, id)
		}
		return ids
	case provisionedhost.EdgeProvisionedHostToAgentTask:
		ids := make([]ent.Value, 0, len(m.removed_ProvisionedHostToAgentTask))
		for id := range m.removed_ProvisionedHostToAgentTask {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProvisionedHostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.cleared_ProvisionedHostToStatus {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToStatus)
	}
	if m.cleared_ProvisionedHostToProvisionedNetwork {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToProvisionedNetwork)
	}
	if m.cleared_ProvisionedHostToHost {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToHost)
	}
	if m.cleared_ProvisionedHostToEndStepPlan {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToEndStepPlan)
	}
	if m.cleared_ProvisionedHostToBuild {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToBuild)
	}
	if m.cleared_ProvisionedHostToProvisioningStep {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToProvisioningStep)
	}
	if m.cleared_ProvisionedHostToAgentStatus {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToAgentStatus)
	}
	if m.cleared_ProvisionedHostToAgentTask {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToAgentTask)
	}
	if m.cleared_ProvisionedHostToPlan {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToPlan)
	}
	if m.cleared_ProvisionedHostToGinFileMiddleware {
		edges = append(edges, provisionedhost.EdgeProvisionedHostToGinFileMiddleware)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProvisionedHostMutation) EdgeCleared(name string) bool {
	switch name {
	case provisionedhost.EdgeProvisionedHostToStatus:
		return m.cleared_ProvisionedHostToStatus
	case provisionedhost.EdgeProvisionedHostToProvisionedNetwork:
		return m.cleared_ProvisionedHostToProvisionedNetwork
	case provisionedhost.EdgeProvisionedHostToHost:
		return m.cleared_ProvisionedHostToHost
	case provisionedhost.EdgeProvisionedHostToEndStepPlan:
		return m.cleared_ProvisionedHostToEndStepPlan
	case provisionedhost.EdgeProvisionedHostToBuild:
		return m.cleared_ProvisionedHostToBuild
	case provisionedhost.EdgeProvisionedHostToProvisioningStep:
		return m.cleared_ProvisionedHostToProvisioningStep
	case provisionedhost.EdgeProvisionedHostToAgentStatus:
		return m.cleared_ProvisionedHostToAgentStatus
	case provisionedhost.EdgeProvisionedHostToAgentTask:
		return m.cleared_ProvisionedHostToAgentTask
	case provisionedhost.EdgeProvisionedHostToPlan:
		return m.cleared_ProvisionedHostToPlan
	case provisionedhost.EdgeProvisionedHostToGinFileMiddleware:
		return m.cleared_ProvisionedHostToGinFileMiddleware
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProvisionedHostMutation) ClearEdge(name string) error {
	switch name {
	case provisionedhost.EdgeProvisionedHostToStatus:
		m.ClearProvisionedHostToStatus()
		return nil
	case provisionedhost.EdgeProvisionedHostToProvisionedNetwork:
		m.ClearProvisionedHostToProvisionedNetwork()
		return nil
	case provisionedhost.EdgeProvisionedHostToHost:
		m.ClearProvisionedHostToHost()
		return nil
	case provisionedhost.EdgeProvisionedHostToEndStepPlan:
		m.ClearProvisionedHostToEndStepPlan()
		return nil
	case provisionedhost.EdgeProvisionedHostToBuild:
		m.ClearProvisionedHostToBuild()
		return nil
	case provisionedhost.EdgeProvisionedHostToPlan:
		m.ClearProvisionedHostToPlan()
		return nil
	case provisionedhost.EdgeProvisionedHostToGinFileMiddleware:
		m.ClearProvisionedHostToGinFileMiddleware()
		return nil
	}
	return fmt.Errorf("unknown ProvisionedHost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProvisionedHostMutation) ResetEdge(name string) error {
	switch name {
	case provisionedhost.EdgeProvisionedHostToStatus:
		m.ResetProvisionedHostToStatus()
		return nil
	case provisionedhost.EdgeProvisionedHostToProvisionedNetwork:
		m.ResetProvisionedHostToProvisionedNetwork()
		return nil
	case provisionedhost.EdgeProvisionedHostToHost:
		m.ResetProvisionedHostToHost()
		return nil
	case provisionedhost.EdgeProvisionedHostToEndStepPlan:
		m.ResetProvisionedHostToEndStepPlan()
		return nil
	case provisionedhost.EdgeProvisionedHostToBuild:
		m.ResetProvisionedHostToBuild()
		return nil
	case provisionedhost.EdgeProvisionedHostToProvisioningStep:
		m.ResetProvisionedHostToProvisioningStep()
		return nil
	case provisionedhost.EdgeProvisionedHostToAgentStatus:
		m.ResetProvisionedHostToAgentStatus()
		return nil
	case provisionedhost.EdgeProvisionedHostToAgentTask:
		m.ResetProvisionedHostToAgentTask()
		return nil
	case provisionedhost.EdgeProvisionedHostToPlan:
		m.ResetProvisionedHostToPlan()
		return nil
	case provisionedhost.EdgeProvisionedHostToGinFileMiddleware:
		m.ResetProvisionedHostToGinFileMiddleware()
		return nil
	}
	return fmt.Errorf("unknown ProvisionedHost edge %s", name)
}

// ProvisionedNetworkMutation represents an operation that mutates the ProvisionedNetwork nodes in the graph.
type ProvisionedNetworkMutation struct {
	config
	op                                          Op
	typ                                         string
	id                                          *uuid.UUID
	name                                        *string
	cidr                                        *string
	vars                                        *map[string]string
	clearedFields                               map[string]struct{}
	_ProvisionedNetworkToStatus                 *uuid.UUID
	cleared_ProvisionedNetworkToStatus          bool
	_ProvisionedNetworkToNetwork                *uuid.UUID
	cleared_ProvisionedNetworkToNetwork         bool
	_ProvisionedNetworkToBuild                  *uuid.UUID
	cleared_ProvisionedNetworkToBuild           bool
	_ProvisionedNetworkToTeam                   *uuid.UUID
	cleared_ProvisionedNetworkToTeam            bool
	_ProvisionedNetworkToProvisionedHost        map[uuid.UUID]struct{}
	removed_ProvisionedNetworkToProvisionedHost map[uuid.UUID]struct{}
	cleared_ProvisionedNetworkToProvisionedHost bool
	_ProvisionedNetworkToPlan                   *uuid.UUID
	cleared_ProvisionedNetworkToPlan            bool
	done                                        bool
	oldValue                                    func(context.Context) (*ProvisionedNetwork, error)
	predicates                                  []predicate.ProvisionedNetwork
}

var _ ent.Mutation = (*ProvisionedNetworkMutation)(nil)

// provisionednetworkOption allows management of the mutation configuration using functional options.
type provisionednetworkOption func(*ProvisionedNetworkMutation)

// newProvisionedNetworkMutation creates new mutation for the ProvisionedNetwork entity.
func newProvisionedNetworkMutation(c config, op Op, opts ...provisionednetworkOption) *ProvisionedNetworkMutation {
	m := &ProvisionedNetworkMutation{
		config:        c,
		op:            op,
		typ:           TypeProvisionedNetwork,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProvisionedNetworkID sets the ID field of the mutation.
func withProvisionedNetworkID(id uuid.UUID) provisionednetworkOption {
	return func(m *ProvisionedNetworkMutation) {
		var (
			err   error
			once  sync.Once
			value *ProvisionedNetwork
		)
		m.oldValue = func(ctx context.Context) (*ProvisionedNetwork, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProvisionedNetwork.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvisionedNetwork sets the old ProvisionedNetwork of the mutation.
func withProvisionedNetwork(node *ProvisionedNetwork) provisionednetworkOption {
	return func(m *ProvisionedNetworkMutation) {
		m.oldValue = func(context.Context) (*ProvisionedNetwork, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProvisionedNetworkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProvisionedNetworkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProvisionedNetwork entities.
func (m *ProvisionedNetworkMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProvisionedNetworkMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProvisionedNetworkMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProvisionedNetwork.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProvisionedNetworkMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProvisionedNetworkMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProvisionedNetwork entity.
// If the ProvisionedNetwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvisionedNetworkMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProvisionedNetworkMutation) ResetName() {
	m.name = nil
}

// SetCidr sets the "cidr" field.
func (m *ProvisionedNetworkMutation) SetCidr(s string) {
	m.cidr = &s
}

// Cidr returns the value of the "cidr" field in the mutation.
func (m *ProvisionedNetworkMutation) Cidr() (r string, exists bool) {
	v := m.cidr
	if v == nil {
		return
	}
	return *v, true
}

// OldCidr returns the old "cidr" field's value of the ProvisionedNetwork entity.
// If the ProvisionedNetwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvisionedNetworkMutation) OldCidr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCidr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCidr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCidr: %w", err)
	}
	return oldValue.Cidr, nil
}

// ResetCidr resets all changes to the "cidr" field.
func (m *ProvisionedNetworkMutation) ResetCidr() {
	m.cidr = nil
}

// SetVars sets the "vars" field.
func (m *ProvisionedNetworkMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *ProvisionedNetworkMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the ProvisionedNetwork entity.
// If the ProvisionedNetwork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvisionedNetworkMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *ProvisionedNetworkMutation) ResetVars() {
	m.vars = nil
}

// SetProvisionedNetworkToStatusID sets the "ProvisionedNetworkToStatus" edge to the Status entity by id.
func (m *ProvisionedNetworkMutation) SetProvisionedNetworkToStatusID(id uuid.UUID) {
	m._ProvisionedNetworkToStatus = &id
}

// ClearProvisionedNetworkToStatus clears the "ProvisionedNetworkToStatus" edge to the Status entity.
func (m *ProvisionedNetworkMutation) ClearProvisionedNetworkToStatus() {
	m.cleared_ProvisionedNetworkToStatus = true
}

// ProvisionedNetworkToStatusCleared reports if the "ProvisionedNetworkToStatus" edge to the Status entity was cleared.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToStatusCleared() bool {
	return m.cleared_ProvisionedNetworkToStatus
}

// ProvisionedNetworkToStatusID returns the "ProvisionedNetworkToStatus" edge ID in the mutation.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToStatusID() (id uuid.UUID, exists bool) {
	if m._ProvisionedNetworkToStatus != nil {
		return *m._ProvisionedNetworkToStatus, true
	}
	return
}

// ProvisionedNetworkToStatusIDs returns the "ProvisionedNetworkToStatus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisionedNetworkToStatusID instead. It exists only for internal usage by the builders.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToStatusIDs() (ids []uuid.UUID) {
	if id := m._ProvisionedNetworkToStatus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisionedNetworkToStatus resets all changes to the "ProvisionedNetworkToStatus" edge.
func (m *ProvisionedNetworkMutation) ResetProvisionedNetworkToStatus() {
	m._ProvisionedNetworkToStatus = nil
	m.cleared_ProvisionedNetworkToStatus = false
}

// SetProvisionedNetworkToNetworkID sets the "ProvisionedNetworkToNetwork" edge to the Network entity by id.
func (m *ProvisionedNetworkMutation) SetProvisionedNetworkToNetworkID(id uuid.UUID) {
	m._ProvisionedNetworkToNetwork = &id
}

// ClearProvisionedNetworkToNetwork clears the "ProvisionedNetworkToNetwork" edge to the Network entity.
func (m *ProvisionedNetworkMutation) ClearProvisionedNetworkToNetwork() {
	m.cleared_ProvisionedNetworkToNetwork = true
}

// ProvisionedNetworkToNetworkCleared reports if the "ProvisionedNetworkToNetwork" edge to the Network entity was cleared.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToNetworkCleared() bool {
	return m.cleared_ProvisionedNetworkToNetwork
}

// ProvisionedNetworkToNetworkID returns the "ProvisionedNetworkToNetwork" edge ID in the mutation.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToNetworkID() (id uuid.UUID, exists bool) {
	if m._ProvisionedNetworkToNetwork != nil {
		return *m._ProvisionedNetworkToNetwork, true
	}
	return
}

// ProvisionedNetworkToNetworkIDs returns the "ProvisionedNetworkToNetwork" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisionedNetworkToNetworkID instead. It exists only for internal usage by the builders.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToNetworkIDs() (ids []uuid.UUID) {
	if id := m._ProvisionedNetworkToNetwork; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisionedNetworkToNetwork resets all changes to the "ProvisionedNetworkToNetwork" edge.
func (m *ProvisionedNetworkMutation) ResetProvisionedNetworkToNetwork() {
	m._ProvisionedNetworkToNetwork = nil
	m.cleared_ProvisionedNetworkToNetwork = false
}

// SetProvisionedNetworkToBuildID sets the "ProvisionedNetworkToBuild" edge to the Build entity by id.
func (m *ProvisionedNetworkMutation) SetProvisionedNetworkToBuildID(id uuid.UUID) {
	m._ProvisionedNetworkToBuild = &id
}

// ClearProvisionedNetworkToBuild clears the "ProvisionedNetworkToBuild" edge to the Build entity.
func (m *ProvisionedNetworkMutation) ClearProvisionedNetworkToBuild() {
	m.cleared_ProvisionedNetworkToBuild = true
}

// ProvisionedNetworkToBuildCleared reports if the "ProvisionedNetworkToBuild" edge to the Build entity was cleared.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToBuildCleared() bool {
	return m.cleared_ProvisionedNetworkToBuild
}

// ProvisionedNetworkToBuildID returns the "ProvisionedNetworkToBuild" edge ID in the mutation.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToBuildID() (id uuid.UUID, exists bool) {
	if m._ProvisionedNetworkToBuild != nil {
		return *m._ProvisionedNetworkToBuild, true
	}
	return
}

// ProvisionedNetworkToBuildIDs returns the "ProvisionedNetworkToBuild" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisionedNetworkToBuildID instead. It exists only for internal usage by the builders.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToBuildIDs() (ids []uuid.UUID) {
	if id := m._ProvisionedNetworkToBuild; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisionedNetworkToBuild resets all changes to the "ProvisionedNetworkToBuild" edge.
func (m *ProvisionedNetworkMutation) ResetProvisionedNetworkToBuild() {
	m._ProvisionedNetworkToBuild = nil
	m.cleared_ProvisionedNetworkToBuild = false
}

// SetProvisionedNetworkToTeamID sets the "ProvisionedNetworkToTeam" edge to the Team entity by id.
func (m *ProvisionedNetworkMutation) SetProvisionedNetworkToTeamID(id uuid.UUID) {
	m._ProvisionedNetworkToTeam = &id
}

// ClearProvisionedNetworkToTeam clears the "ProvisionedNetworkToTeam" edge to the Team entity.
func (m *ProvisionedNetworkMutation) ClearProvisionedNetworkToTeam() {
	m.cleared_ProvisionedNetworkToTeam = true
}

// ProvisionedNetworkToTeamCleared reports if the "ProvisionedNetworkToTeam" edge to the Team entity was cleared.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToTeamCleared() bool {
	return m.cleared_ProvisionedNetworkToTeam
}

// ProvisionedNetworkToTeamID returns the "ProvisionedNetworkToTeam" edge ID in the mutation.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToTeamID() (id uuid.UUID, exists bool) {
	if m._ProvisionedNetworkToTeam != nil {
		return *m._ProvisionedNetworkToTeam, true
	}
	return
}

// ProvisionedNetworkToTeamIDs returns the "ProvisionedNetworkToTeam" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisionedNetworkToTeamID instead. It exists only for internal usage by the builders.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToTeamIDs() (ids []uuid.UUID) {
	if id := m._ProvisionedNetworkToTeam; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisionedNetworkToTeam resets all changes to the "ProvisionedNetworkToTeam" edge.
func (m *ProvisionedNetworkMutation) ResetProvisionedNetworkToTeam() {
	m._ProvisionedNetworkToTeam = nil
	m.cleared_ProvisionedNetworkToTeam = false
}

// AddProvisionedNetworkToProvisionedHostIDs adds the "ProvisionedNetworkToProvisionedHost" edge to the ProvisionedHost entity by ids.
func (m *ProvisionedNetworkMutation) AddProvisionedNetworkToProvisionedHostIDs(ids ...uuid.UUID) {
	if m._ProvisionedNetworkToProvisionedHost == nil {
		m._ProvisionedNetworkToProvisionedHost = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ProvisionedNetworkToProvisionedHost[ids[i]] = struct{}{}
	}
}

// ClearProvisionedNetworkToProvisionedHost clears the "ProvisionedNetworkToProvisionedHost" edge to the ProvisionedHost entity.
func (m *ProvisionedNetworkMutation) ClearProvisionedNetworkToProvisionedHost() {
	m.cleared_ProvisionedNetworkToProvisionedHost = true
}

// ProvisionedNetworkToProvisionedHostCleared reports if the "ProvisionedNetworkToProvisionedHost" edge to the ProvisionedHost entity was cleared.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToProvisionedHostCleared() bool {
	return m.cleared_ProvisionedNetworkToProvisionedHost
}

// RemoveProvisionedNetworkToProvisionedHostIDs removes the "ProvisionedNetworkToProvisionedHost" edge to the ProvisionedHost entity by IDs.
func (m *ProvisionedNetworkMutation) RemoveProvisionedNetworkToProvisionedHostIDs(ids ...uuid.UUID) {
	if m.removed_ProvisionedNetworkToProvisionedHost == nil {
		m.removed_ProvisionedNetworkToProvisionedHost = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._ProvisionedNetworkToProvisionedHost, ids[i])
		m.removed_ProvisionedNetworkToProvisionedHost[ids[i]] = struct{}{}
	}
}

// RemovedProvisionedNetworkToProvisionedHost returns the removed IDs of the "ProvisionedNetworkToProvisionedHost" edge to the ProvisionedHost entity.
func (m *ProvisionedNetworkMutation) RemovedProvisionedNetworkToProvisionedHostIDs() (ids []uuid.UUID) {
	for id := range m.removed_ProvisionedNetworkToProvisionedHost {
		ids = append(ids, id)
	}
	return
}

// ProvisionedNetworkToProvisionedHostIDs returns the "ProvisionedNetworkToProvisionedHost" edge IDs in the mutation.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToProvisionedHostIDs() (ids []uuid.UUID) {
	for id := range m._ProvisionedNetworkToProvisionedHost {
		ids = append(ids, id)
	}
	return
}

// ResetProvisionedNetworkToProvisionedHost resets all changes to the "ProvisionedNetworkToProvisionedHost" edge.
func (m *ProvisionedNetworkMutation) ResetProvisionedNetworkToProvisionedHost() {
	m._ProvisionedNetworkToProvisionedHost = nil
	m.cleared_ProvisionedNetworkToProvisionedHost = false
	m.removed_ProvisionedNetworkToProvisionedHost = nil
}

// SetProvisionedNetworkToPlanID sets the "ProvisionedNetworkToPlan" edge to the Plan entity by id.
func (m *ProvisionedNetworkMutation) SetProvisionedNetworkToPlanID(id uuid.UUID) {
	m._ProvisionedNetworkToPlan = &id
}

// ClearProvisionedNetworkToPlan clears the "ProvisionedNetworkToPlan" edge to the Plan entity.
func (m *ProvisionedNetworkMutation) ClearProvisionedNetworkToPlan() {
	m.cleared_ProvisionedNetworkToPlan = true
}

// ProvisionedNetworkToPlanCleared reports if the "ProvisionedNetworkToPlan" edge to the Plan entity was cleared.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToPlanCleared() bool {
	return m.cleared_ProvisionedNetworkToPlan
}

// ProvisionedNetworkToPlanID returns the "ProvisionedNetworkToPlan" edge ID in the mutation.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToPlanID() (id uuid.UUID, exists bool) {
	if m._ProvisionedNetworkToPlan != nil {
		return *m._ProvisionedNetworkToPlan, true
	}
	return
}

// ProvisionedNetworkToPlanIDs returns the "ProvisionedNetworkToPlan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisionedNetworkToPlanID instead. It exists only for internal usage by the builders.
func (m *ProvisionedNetworkMutation) ProvisionedNetworkToPlanIDs() (ids []uuid.UUID) {
	if id := m._ProvisionedNetworkToPlan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisionedNetworkToPlan resets all changes to the "ProvisionedNetworkToPlan" edge.
func (m *ProvisionedNetworkMutation) ResetProvisionedNetworkToPlan() {
	m._ProvisionedNetworkToPlan = nil
	m.cleared_ProvisionedNetworkToPlan = false
}

// Where appends a list predicates to the ProvisionedNetworkMutation builder.
func (m *ProvisionedNetworkMutation) Where(ps ...predicate.ProvisionedNetwork) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProvisionedNetworkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProvisionedNetworkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProvisionedNetwork, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProvisionedNetworkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProvisionedNetworkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProvisionedNetwork).
func (m *ProvisionedNetworkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProvisionedNetworkMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, provisionednetwork.FieldName)
	}
	if m.cidr != nil {
		fields = append(fields, provisionednetwork.FieldCidr)
	}
	if m.vars != nil {
		fields = append(fields, provisionednetwork.FieldVars)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProvisionedNetworkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case provisionednetwork.FieldName:
		return m.Name()
	case provisionednetwork.FieldCidr:
		return m.Cidr()
	case provisionednetwork.FieldVars:
		return m.Vars()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProvisionedNetworkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case provisionednetwork.FieldName:
		return m.OldName(ctx)
	case provisionednetwork.FieldCidr:
		return m.OldCidr(ctx)
	case provisionednetwork.FieldVars:
		return m.OldVars(ctx)
	}
	return nil, fmt.Errorf("unknown ProvisionedNetwork field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvisionedNetworkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case provisionednetwork.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case provisionednetwork.FieldCidr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCidr(v)
		return nil
	case provisionednetwork.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	}
	return fmt.Errorf("unknown ProvisionedNetwork field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProvisionedNetworkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProvisionedNetworkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvisionedNetworkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProvisionedNetwork numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProvisionedNetworkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProvisionedNetworkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProvisionedNetworkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProvisionedNetwork nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProvisionedNetworkMutation) ResetField(name string) error {
	switch name {
	case provisionednetwork.FieldName:
		m.ResetName()
		return nil
	case provisionednetwork.FieldCidr:
		m.ResetCidr()
		return nil
	case provisionednetwork.FieldVars:
		m.ResetVars()
		return nil
	}
	return fmt.Errorf("unknown ProvisionedNetwork field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProvisionedNetworkMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m._ProvisionedNetworkToStatus != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToStatus)
	}
	if m._ProvisionedNetworkToNetwork != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToNetwork)
	}
	if m._ProvisionedNetworkToBuild != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToBuild)
	}
	if m._ProvisionedNetworkToTeam != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToTeam)
	}
	if m._ProvisionedNetworkToProvisionedHost != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToProvisionedHost)
	}
	if m._ProvisionedNetworkToPlan != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToPlan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProvisionedNetworkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case provisionednetwork.EdgeProvisionedNetworkToStatus:
		if id := m._ProvisionedNetworkToStatus; id != nil {
			return []ent.Value{*id}
		}
	case provisionednetwork.EdgeProvisionedNetworkToNetwork:
		if id := m._ProvisionedNetworkToNetwork; id != nil {
			return []ent.Value{*id}
		}
	case provisionednetwork.EdgeProvisionedNetworkToBuild:
		if id := m._ProvisionedNetworkToBuild; id != nil {
			return []ent.Value{*id}
		}
	case provisionednetwork.EdgeProvisionedNetworkToTeam:
		if id := m._ProvisionedNetworkToTeam; id != nil {
			return []ent.Value{*id}
		}
	case provisionednetwork.EdgeProvisionedNetworkToProvisionedHost:
		ids := make([]ent.Value, 0, len(m._ProvisionedNetworkToProvisionedHost))
		for id := range m._ProvisionedNetworkToProvisionedHost {
			ids = append(ids, id)
		}
		return ids
	case provisionednetwork.EdgeProvisionedNetworkToPlan:
		if id := m._ProvisionedNetworkToPlan; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProvisionedNetworkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removed_ProvisionedNetworkToProvisionedHost != nil {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToProvisionedHost)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProvisionedNetworkMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case provisionednetwork.EdgeProvisionedNetworkToProvisionedHost:
		ids := make([]ent.Value, 0, len(m.removed_ProvisionedNetworkToProvisionedHost))
		for id := range m.removed_ProvisionedNetworkToProvisionedHost {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProvisionedNetworkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleared_ProvisionedNetworkToStatus {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToStatus)
	}
	if m.cleared_ProvisionedNetworkToNetwork {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToNetwork)
	}
	if m.cleared_ProvisionedNetworkToBuild {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToBuild)
	}
	if m.cleared_ProvisionedNetworkToTeam {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToTeam)
	}
	if m.cleared_ProvisionedNetworkToProvisionedHost {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToProvisionedHost)
	}
	if m.cleared_ProvisionedNetworkToPlan {
		edges = append(edges, provisionednetwork.EdgeProvisionedNetworkToPlan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProvisionedNetworkMutation) EdgeCleared(name string) bool {
	switch name {
	case provisionednetwork.EdgeProvisionedNetworkToStatus:
		return m.cleared_ProvisionedNetworkToStatus
	case provisionednetwork.EdgeProvisionedNetworkToNetwork:
		return m.cleared_ProvisionedNetworkToNetwork
	case provisionednetwork.EdgeProvisionedNetworkToBuild:
		return m.cleared_ProvisionedNetworkToBuild
	case provisionednetwork.EdgeProvisionedNetworkToTeam:
		return m.cleared_ProvisionedNetworkToTeam
	case provisionednetwork.EdgeProvisionedNetworkToProvisionedHost:
		return m.cleared_ProvisionedNetworkToProvisionedHost
	case provisionednetwork.EdgeProvisionedNetworkToPlan:
		return m.cleared_ProvisionedNetworkToPlan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProvisionedNetworkMutation) ClearEdge(name string) error {
	switch name {
	case provisionednetwork.EdgeProvisionedNetworkToStatus:
		m.ClearProvisionedNetworkToStatus()
		return nil
	case provisionednetwork.EdgeProvisionedNetworkToNetwork:
		m.ClearProvisionedNetworkToNetwork()
		return nil
	case provisionednetwork.EdgeProvisionedNetworkToBuild:
		m.ClearProvisionedNetworkToBuild()
		return nil
	case provisionednetwork.EdgeProvisionedNetworkToTeam:
		m.ClearProvisionedNetworkToTeam()
		return nil
	case provisionednetwork.EdgeProvisionedNetworkToPlan:
		m.ClearProvisionedNetworkToPlan()
		return nil
	}
	return fmt.Errorf("unknown ProvisionedNetwork unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProvisionedNetworkMutation) ResetEdge(name string) error {
	switch name {
	case provisionednetwork.EdgeProvisionedNetworkToStatus:
		m.ResetProvisionedNetworkToStatus()
		return nil
	case provisionednetwork.EdgeProvisionedNetworkToNetwork:
		m.ResetProvisionedNetworkToNetwork()
		return nil
	case provisionednetwork.EdgeProvisionedNetworkToBuild:
		m.ResetProvisionedNetworkToBuild()
		return nil
	case provisionednetwork.EdgeProvisionedNetworkToTeam:
		m.ResetProvisionedNetworkToTeam()
		return nil
	case provisionednetwork.EdgeProvisionedNetworkToProvisionedHost:
		m.ResetProvisionedNetworkToProvisionedHost()
		return nil
	case provisionednetwork.EdgeProvisionedNetworkToPlan:
		m.ResetProvisionedNetworkToPlan()
		return nil
	}
	return fmt.Errorf("unknown ProvisionedNetwork edge %s", name)
}

// ProvisioningStepMutation represents an operation that mutates the ProvisioningStep nodes in the graph.
type ProvisioningStepMutation struct {
	config
	op                                          Op
	typ                                         string
	id                                          *uuid.UUID
	_type                                       *provisioningstep.Type
	step_number                                 *int
	addstep_number                              *int
	clearedFields                               map[string]struct{}
	_ProvisioningStepToStatus                   *uuid.UUID
	cleared_ProvisioningStepToStatus            bool
	_ProvisioningStepToProvisionedHost          *uuid.UUID
	cleared_ProvisioningStepToProvisionedHost   bool
	_ProvisioningStepToScript                   *uuid.UUID
	cleared_ProvisioningStepToScript            bool
	_ProvisioningStepToCommand                  *uuid.UUID
	cleared_ProvisioningStepToCommand           bool
	_ProvisioningStepToDNSRecord                *uuid.UUID
	cleared_ProvisioningStepToDNSRecord         bool
	_ProvisioningStepToFileDelete               *uuid.UUID
	cleared_ProvisioningStepToFileDelete        bool
	_ProvisioningStepToFileDownload             *uuid.UUID
	cleared_ProvisioningStepToFileDownload      bool
	_ProvisioningStepToFileExtract              *uuid.UUID
	cleared_ProvisioningStepToFileExtract       bool
	_ProvisioningStepToAnsible                  *uuid.UUID
	cleared_ProvisioningStepToAnsible           bool
	_ProvisioningStepToPlan                     *uuid.UUID
	cleared_ProvisioningStepToPlan              bool
	_ProvisioningStepToAgentTask                map[uuid.UUID]struct{}
	removed_ProvisioningStepToAgentTask         map[uuid.UUID]struct{}
	cleared_ProvisioningStepToAgentTask         bool
	_ProvisioningStepToGinFileMiddleware        *uuid.UUID
	cleared_ProvisioningStepToGinFileMiddleware bool
	done                                        bool
	oldValue                                    func(context.Context) (*ProvisioningStep, error)
	predicates                                  []predicate.ProvisioningStep
}

var _ ent.Mutation = (*ProvisioningStepMutation)(nil)

// provisioningstepOption allows management of the mutation configuration using functional options.
type provisioningstepOption func(*ProvisioningStepMutation)

// newProvisioningStepMutation creates new mutation for the ProvisioningStep entity.
func newProvisioningStepMutation(c config, op Op, opts ...provisioningstepOption) *ProvisioningStepMutation {
	m := &ProvisioningStepMutation{
		config:        c,
		op:            op,
		typ:           TypeProvisioningStep,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProvisioningStepID sets the ID field of the mutation.
func withProvisioningStepID(id uuid.UUID) provisioningstepOption {
	return func(m *ProvisioningStepMutation) {
		var (
			err   error
			once  sync.Once
			value *ProvisioningStep
		)
		m.oldValue = func(ctx context.Context) (*ProvisioningStep, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProvisioningStep.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProvisioningStep sets the old ProvisioningStep of the mutation.
func withProvisioningStep(node *ProvisioningStep) provisioningstepOption {
	return func(m *ProvisioningStepMutation) {
		m.oldValue = func(context.Context) (*ProvisioningStep, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProvisioningStepMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProvisioningStepMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProvisioningStep entities.
func (m *ProvisioningStepMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProvisioningStepMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProvisioningStepMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProvisioningStep.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *ProvisioningStepMutation) SetType(pr provisioningstep.Type) {
	m._type = &pr
}

// GetType returns the value of the "type" field in the mutation.
func (m *ProvisioningStepMutation) GetType() (r provisioningstep.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ProvisioningStep entity.
// If the ProvisioningStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvisioningStepMutation) OldType(ctx context.Context) (v provisioningstep.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ProvisioningStepMutation) ResetType() {
	m._type = nil
}

// SetStepNumber sets the "step_number" field.
func (m *ProvisioningStepMutation) SetStepNumber(i int) {
	m.step_number = &i
	m.addstep_number = nil
}

// StepNumber returns the value of the "step_number" field in the mutation.
func (m *ProvisioningStepMutation) StepNumber() (r int, exists bool) {
	v := m.step_number
	if v == nil {
		return
	}
	return *v, true
}

// OldStepNumber returns the old "step_number" field's value of the ProvisioningStep entity.
// If the ProvisioningStep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProvisioningStepMutation) OldStepNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStepNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStepNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStepNumber: %w", err)
	}
	return oldValue.StepNumber, nil
}

// AddStepNumber adds i to the "step_number" field.
func (m *ProvisioningStepMutation) AddStepNumber(i int) {
	if m.addstep_number != nil {
		*m.addstep_number += i
	} else {
		m.addstep_number = &i
	}
}

// AddedStepNumber returns the value that was added to the "step_number" field in this mutation.
func (m *ProvisioningStepMutation) AddedStepNumber() (r int, exists bool) {
	v := m.addstep_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetStepNumber resets all changes to the "step_number" field.
func (m *ProvisioningStepMutation) ResetStepNumber() {
	m.step_number = nil
	m.addstep_number = nil
}

// SetProvisioningStepToStatusID sets the "ProvisioningStepToStatus" edge to the Status entity by id.
func (m *ProvisioningStepMutation) SetProvisioningStepToStatusID(id uuid.UUID) {
	m._ProvisioningStepToStatus = &id
}

// ClearProvisioningStepToStatus clears the "ProvisioningStepToStatus" edge to the Status entity.
func (m *ProvisioningStepMutation) ClearProvisioningStepToStatus() {
	m.cleared_ProvisioningStepToStatus = true
}

// ProvisioningStepToStatusCleared reports if the "ProvisioningStepToStatus" edge to the Status entity was cleared.
func (m *ProvisioningStepMutation) ProvisioningStepToStatusCleared() bool {
	return m.cleared_ProvisioningStepToStatus
}

// ProvisioningStepToStatusID returns the "ProvisioningStepToStatus" edge ID in the mutation.
func (m *ProvisioningStepMutation) ProvisioningStepToStatusID() (id uuid.UUID, exists bool) {
	if m._ProvisioningStepToStatus != nil {
		return *m._ProvisioningStepToStatus, true
	}
	return
}

// ProvisioningStepToStatusIDs returns the "ProvisioningStepToStatus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisioningStepToStatusID instead. It exists only for internal usage by the builders.
func (m *ProvisioningStepMutation) ProvisioningStepToStatusIDs() (ids []uuid.UUID) {
	if id := m._ProvisioningStepToStatus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisioningStepToStatus resets all changes to the "ProvisioningStepToStatus" edge.
func (m *ProvisioningStepMutation) ResetProvisioningStepToStatus() {
	m._ProvisioningStepToStatus = nil
	m.cleared_ProvisioningStepToStatus = false
}

// SetProvisioningStepToProvisionedHostID sets the "ProvisioningStepToProvisionedHost" edge to the ProvisionedHost entity by id.
func (m *ProvisioningStepMutation) SetProvisioningStepToProvisionedHostID(id uuid.UUID) {
	m._ProvisioningStepToProvisionedHost = &id
}

// ClearProvisioningStepToProvisionedHost clears the "ProvisioningStepToProvisionedHost" edge to the ProvisionedHost entity.
func (m *ProvisioningStepMutation) ClearProvisioningStepToProvisionedHost() {
	m.cleared_ProvisioningStepToProvisionedHost = true
}

// ProvisioningStepToProvisionedHostCleared reports if the "ProvisioningStepToProvisionedHost" edge to the ProvisionedHost entity was cleared.
func (m *ProvisioningStepMutation) ProvisioningStepToProvisionedHostCleared() bool {
	return m.cleared_ProvisioningStepToProvisionedHost
}

// ProvisioningStepToProvisionedHostID returns the "ProvisioningStepToProvisionedHost" edge ID in the mutation.
func (m *ProvisioningStepMutation) ProvisioningStepToProvisionedHostID() (id uuid.UUID, exists bool) {
	if m._ProvisioningStepToProvisionedHost != nil {
		return *m._ProvisioningStepToProvisionedHost, true
	}
	return
}

// ProvisioningStepToProvisionedHostIDs returns the "ProvisioningStepToProvisionedHost" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisioningStepToProvisionedHostID instead. It exists only for internal usage by the builders.
func (m *ProvisioningStepMutation) ProvisioningStepToProvisionedHostIDs() (ids []uuid.UUID) {
	if id := m._ProvisioningStepToProvisionedHost; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisioningStepToProvisionedHost resets all changes to the "ProvisioningStepToProvisionedHost" edge.
func (m *ProvisioningStepMutation) ResetProvisioningStepToProvisionedHost() {
	m._ProvisioningStepToProvisionedHost = nil
	m.cleared_ProvisioningStepToProvisionedHost = false
}

// SetProvisioningStepToScriptID sets the "ProvisioningStepToScript" edge to the Script entity by id.
func (m *ProvisioningStepMutation) SetProvisioningStepToScriptID(id uuid.UUID) {
	m._ProvisioningStepToScript = &id
}

// ClearProvisioningStepToScript clears the "ProvisioningStepToScript" edge to the Script entity.
func (m *ProvisioningStepMutation) ClearProvisioningStepToScript() {
	m.cleared_ProvisioningStepToScript = true
}

// ProvisioningStepToScriptCleared reports if the "ProvisioningStepToScript" edge to the Script entity was cleared.
func (m *ProvisioningStepMutation) ProvisioningStepToScriptCleared() bool {
	return m.cleared_ProvisioningStepToScript
}

// ProvisioningStepToScriptID returns the "ProvisioningStepToScript" edge ID in the mutation.
func (m *ProvisioningStepMutation) ProvisioningStepToScriptID() (id uuid.UUID, exists bool) {
	if m._ProvisioningStepToScript != nil {
		return *m._ProvisioningStepToScript, true
	}
	return
}

// ProvisioningStepToScriptIDs returns the "ProvisioningStepToScript" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisioningStepToScriptID instead. It exists only for internal usage by the builders.
func (m *ProvisioningStepMutation) ProvisioningStepToScriptIDs() (ids []uuid.UUID) {
	if id := m._ProvisioningStepToScript; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisioningStepToScript resets all changes to the "ProvisioningStepToScript" edge.
func (m *ProvisioningStepMutation) ResetProvisioningStepToScript() {
	m._ProvisioningStepToScript = nil
	m.cleared_ProvisioningStepToScript = false
}

// SetProvisioningStepToCommandID sets the "ProvisioningStepToCommand" edge to the Command entity by id.
func (m *ProvisioningStepMutation) SetProvisioningStepToCommandID(id uuid.UUID) {
	m._ProvisioningStepToCommand = &id
}

// ClearProvisioningStepToCommand clears the "ProvisioningStepToCommand" edge to the Command entity.
func (m *ProvisioningStepMutation) ClearProvisioningStepToCommand() {
	m.cleared_ProvisioningStepToCommand = true
}

// ProvisioningStepToCommandCleared reports if the "ProvisioningStepToCommand" edge to the Command entity was cleared.
func (m *ProvisioningStepMutation) ProvisioningStepToCommandCleared() bool {
	return m.cleared_ProvisioningStepToCommand
}

// ProvisioningStepToCommandID returns the "ProvisioningStepToCommand" edge ID in the mutation.
func (m *ProvisioningStepMutation) ProvisioningStepToCommandID() (id uuid.UUID, exists bool) {
	if m._ProvisioningStepToCommand != nil {
		return *m._ProvisioningStepToCommand, true
	}
	return
}

// ProvisioningStepToCommandIDs returns the "ProvisioningStepToCommand" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisioningStepToCommandID instead. It exists only for internal usage by the builders.
func (m *ProvisioningStepMutation) ProvisioningStepToCommandIDs() (ids []uuid.UUID) {
	if id := m._ProvisioningStepToCommand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisioningStepToCommand resets all changes to the "ProvisioningStepToCommand" edge.
func (m *ProvisioningStepMutation) ResetProvisioningStepToCommand() {
	m._ProvisioningStepToCommand = nil
	m.cleared_ProvisioningStepToCommand = false
}

// SetProvisioningStepToDNSRecordID sets the "ProvisioningStepToDNSRecord" edge to the DNSRecord entity by id.
func (m *ProvisioningStepMutation) SetProvisioningStepToDNSRecordID(id uuid.UUID) {
	m._ProvisioningStepToDNSRecord = &id
}

// ClearProvisioningStepToDNSRecord clears the "ProvisioningStepToDNSRecord" edge to the DNSRecord entity.
func (m *ProvisioningStepMutation) ClearProvisioningStepToDNSRecord() {
	m.cleared_ProvisioningStepToDNSRecord = true
}

// ProvisioningStepToDNSRecordCleared reports if the "ProvisioningStepToDNSRecord" edge to the DNSRecord entity was cleared.
func (m *ProvisioningStepMutation) ProvisioningStepToDNSRecordCleared() bool {
	return m.cleared_ProvisioningStepToDNSRecord
}

// ProvisioningStepToDNSRecordID returns the "ProvisioningStepToDNSRecord" edge ID in the mutation.
func (m *ProvisioningStepMutation) ProvisioningStepToDNSRecordID() (id uuid.UUID, exists bool) {
	if m._ProvisioningStepToDNSRecord != nil {
		return *m._ProvisioningStepToDNSRecord, true
	}
	return
}

// ProvisioningStepToDNSRecordIDs returns the "ProvisioningStepToDNSRecord" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisioningStepToDNSRecordID instead. It exists only for internal usage by the builders.
func (m *ProvisioningStepMutation) ProvisioningStepToDNSRecordIDs() (ids []uuid.UUID) {
	if id := m._ProvisioningStepToDNSRecord; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisioningStepToDNSRecord resets all changes to the "ProvisioningStepToDNSRecord" edge.
func (m *ProvisioningStepMutation) ResetProvisioningStepToDNSRecord() {
	m._ProvisioningStepToDNSRecord = nil
	m.cleared_ProvisioningStepToDNSRecord = false
}

// SetProvisioningStepToFileDeleteID sets the "ProvisioningStepToFileDelete" edge to the FileDelete entity by id.
func (m *ProvisioningStepMutation) SetProvisioningStepToFileDeleteID(id uuid.UUID) {
	m._ProvisioningStepToFileDelete = &id
}

// ClearProvisioningStepToFileDelete clears the "ProvisioningStepToFileDelete" edge to the FileDelete entity.
func (m *ProvisioningStepMutation) ClearProvisioningStepToFileDelete() {
	m.cleared_ProvisioningStepToFileDelete = true
}

// ProvisioningStepToFileDeleteCleared reports if the "ProvisioningStepToFileDelete" edge to the FileDelete entity was cleared.
func (m *ProvisioningStepMutation) ProvisioningStepToFileDeleteCleared() bool {
	return m.cleared_ProvisioningStepToFileDelete
}

// ProvisioningStepToFileDeleteID returns the "ProvisioningStepToFileDelete" edge ID in the mutation.
func (m *ProvisioningStepMutation) ProvisioningStepToFileDeleteID() (id uuid.UUID, exists bool) {
	if m._ProvisioningStepToFileDelete != nil {
		return *m._ProvisioningStepToFileDelete, true
	}
	return
}

// ProvisioningStepToFileDeleteIDs returns the "ProvisioningStepToFileDelete" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisioningStepToFileDeleteID instead. It exists only for internal usage by the builders.
func (m *ProvisioningStepMutation) ProvisioningStepToFileDeleteIDs() (ids []uuid.UUID) {
	if id := m._ProvisioningStepToFileDelete; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisioningStepToFileDelete resets all changes to the "ProvisioningStepToFileDelete" edge.
func (m *ProvisioningStepMutation) ResetProvisioningStepToFileDelete() {
	m._ProvisioningStepToFileDelete = nil
	m.cleared_ProvisioningStepToFileDelete = false
}

// SetProvisioningStepToFileDownloadID sets the "ProvisioningStepToFileDownload" edge to the FileDownload entity by id.
func (m *ProvisioningStepMutation) SetProvisioningStepToFileDownloadID(id uuid.UUID) {
	m._ProvisioningStepToFileDownload = &id
}

// ClearProvisioningStepToFileDownload clears the "ProvisioningStepToFileDownload" edge to the FileDownload entity.
func (m *ProvisioningStepMutation) ClearProvisioningStepToFileDownload() {
	m.cleared_ProvisioningStepToFileDownload = true
}

// ProvisioningStepToFileDownloadCleared reports if the "ProvisioningStepToFileDownload" edge to the FileDownload entity was cleared.
func (m *ProvisioningStepMutation) ProvisioningStepToFileDownloadCleared() bool {
	return m.cleared_ProvisioningStepToFileDownload
}

// ProvisioningStepToFileDownloadID returns the "ProvisioningStepToFileDownload" edge ID in the mutation.
func (m *ProvisioningStepMutation) ProvisioningStepToFileDownloadID() (id uuid.UUID, exists bool) {
	if m._ProvisioningStepToFileDownload != nil {
		return *m._ProvisioningStepToFileDownload, true
	}
	return
}

// ProvisioningStepToFileDownloadIDs returns the "ProvisioningStepToFileDownload" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisioningStepToFileDownloadID instead. It exists only for internal usage by the builders.
func (m *ProvisioningStepMutation) ProvisioningStepToFileDownloadIDs() (ids []uuid.UUID) {
	if id := m._ProvisioningStepToFileDownload; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisioningStepToFileDownload resets all changes to the "ProvisioningStepToFileDownload" edge.
func (m *ProvisioningStepMutation) ResetProvisioningStepToFileDownload() {
	m._ProvisioningStepToFileDownload = nil
	m.cleared_ProvisioningStepToFileDownload = false
}

// SetProvisioningStepToFileExtractID sets the "ProvisioningStepToFileExtract" edge to the FileExtract entity by id.
func (m *ProvisioningStepMutation) SetProvisioningStepToFileExtractID(id uuid.UUID) {
	m._ProvisioningStepToFileExtract = &id
}

// ClearProvisioningStepToFileExtract clears the "ProvisioningStepToFileExtract" edge to the FileExtract entity.
func (m *ProvisioningStepMutation) ClearProvisioningStepToFileExtract() {
	m.cleared_ProvisioningStepToFileExtract = true
}

// ProvisioningStepToFileExtractCleared reports if the "ProvisioningStepToFileExtract" edge to the FileExtract entity was cleared.
func (m *ProvisioningStepMutation) ProvisioningStepToFileExtractCleared() bool {
	return m.cleared_ProvisioningStepToFileExtract
}

// ProvisioningStepToFileExtractID returns the "ProvisioningStepToFileExtract" edge ID in the mutation.
func (m *ProvisioningStepMutation) ProvisioningStepToFileExtractID() (id uuid.UUID, exists bool) {
	if m._ProvisioningStepToFileExtract != nil {
		return *m._ProvisioningStepToFileExtract, true
	}
	return
}

// ProvisioningStepToFileExtractIDs returns the "ProvisioningStepToFileExtract" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisioningStepToFileExtractID instead. It exists only for internal usage by the builders.
func (m *ProvisioningStepMutation) ProvisioningStepToFileExtractIDs() (ids []uuid.UUID) {
	if id := m._ProvisioningStepToFileExtract; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisioningStepToFileExtract resets all changes to the "ProvisioningStepToFileExtract" edge.
func (m *ProvisioningStepMutation) ResetProvisioningStepToFileExtract() {
	m._ProvisioningStepToFileExtract = nil
	m.cleared_ProvisioningStepToFileExtract = false
}

// SetProvisioningStepToAnsibleID sets the "ProvisioningStepToAnsible" edge to the Ansible entity by id.
func (m *ProvisioningStepMutation) SetProvisioningStepToAnsibleID(id uuid.UUID) {
	m._ProvisioningStepToAnsible = &id
}

// ClearProvisioningStepToAnsible clears the "ProvisioningStepToAnsible" edge to the Ansible entity.
func (m *ProvisioningStepMutation) ClearProvisioningStepToAnsible() {
	m.cleared_ProvisioningStepToAnsible = true
}

// ProvisioningStepToAnsibleCleared reports if the "ProvisioningStepToAnsible" edge to the Ansible entity was cleared.
func (m *ProvisioningStepMutation) ProvisioningStepToAnsibleCleared() bool {
	return m.cleared_ProvisioningStepToAnsible
}

// ProvisioningStepToAnsibleID returns the "ProvisioningStepToAnsible" edge ID in the mutation.
func (m *ProvisioningStepMutation) ProvisioningStepToAnsibleID() (id uuid.UUID, exists bool) {
	if m._ProvisioningStepToAnsible != nil {
		return *m._ProvisioningStepToAnsible, true
	}
	return
}

// ProvisioningStepToAnsibleIDs returns the "ProvisioningStepToAnsible" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisioningStepToAnsibleID instead. It exists only for internal usage by the builders.
func (m *ProvisioningStepMutation) ProvisioningStepToAnsibleIDs() (ids []uuid.UUID) {
	if id := m._ProvisioningStepToAnsible; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisioningStepToAnsible resets all changes to the "ProvisioningStepToAnsible" edge.
func (m *ProvisioningStepMutation) ResetProvisioningStepToAnsible() {
	m._ProvisioningStepToAnsible = nil
	m.cleared_ProvisioningStepToAnsible = false
}

// SetProvisioningStepToPlanID sets the "ProvisioningStepToPlan" edge to the Plan entity by id.
func (m *ProvisioningStepMutation) SetProvisioningStepToPlanID(id uuid.UUID) {
	m._ProvisioningStepToPlan = &id
}

// ClearProvisioningStepToPlan clears the "ProvisioningStepToPlan" edge to the Plan entity.
func (m *ProvisioningStepMutation) ClearProvisioningStepToPlan() {
	m.cleared_ProvisioningStepToPlan = true
}

// ProvisioningStepToPlanCleared reports if the "ProvisioningStepToPlan" edge to the Plan entity was cleared.
func (m *ProvisioningStepMutation) ProvisioningStepToPlanCleared() bool {
	return m.cleared_ProvisioningStepToPlan
}

// ProvisioningStepToPlanID returns the "ProvisioningStepToPlan" edge ID in the mutation.
func (m *ProvisioningStepMutation) ProvisioningStepToPlanID() (id uuid.UUID, exists bool) {
	if m._ProvisioningStepToPlan != nil {
		return *m._ProvisioningStepToPlan, true
	}
	return
}

// ProvisioningStepToPlanIDs returns the "ProvisioningStepToPlan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisioningStepToPlanID instead. It exists only for internal usage by the builders.
func (m *ProvisioningStepMutation) ProvisioningStepToPlanIDs() (ids []uuid.UUID) {
	if id := m._ProvisioningStepToPlan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisioningStepToPlan resets all changes to the "ProvisioningStepToPlan" edge.
func (m *ProvisioningStepMutation) ResetProvisioningStepToPlan() {
	m._ProvisioningStepToPlan = nil
	m.cleared_ProvisioningStepToPlan = false
}

// AddProvisioningStepToAgentTaskIDs adds the "ProvisioningStepToAgentTask" edge to the AgentTask entity by ids.
func (m *ProvisioningStepMutation) AddProvisioningStepToAgentTaskIDs(ids ...uuid.UUID) {
	if m._ProvisioningStepToAgentTask == nil {
		m._ProvisioningStepToAgentTask = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ProvisioningStepToAgentTask[ids[i]] = struct{}{}
	}
}

// ClearProvisioningStepToAgentTask clears the "ProvisioningStepToAgentTask" edge to the AgentTask entity.
func (m *ProvisioningStepMutation) ClearProvisioningStepToAgentTask() {
	m.cleared_ProvisioningStepToAgentTask = true
}

// ProvisioningStepToAgentTaskCleared reports if the "ProvisioningStepToAgentTask" edge to the AgentTask entity was cleared.
func (m *ProvisioningStepMutation) ProvisioningStepToAgentTaskCleared() bool {
	return m.cleared_ProvisioningStepToAgentTask
}

// RemoveProvisioningStepToAgentTaskIDs removes the "ProvisioningStepToAgentTask" edge to the AgentTask entity by IDs.
func (m *ProvisioningStepMutation) RemoveProvisioningStepToAgentTaskIDs(ids ...uuid.UUID) {
	if m.removed_ProvisioningStepToAgentTask == nil {
		m.removed_ProvisioningStepToAgentTask = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._ProvisioningStepToAgentTask, ids[i])
		m.removed_ProvisioningStepToAgentTask[ids[i]] = struct{}{}
	}
}

// RemovedProvisioningStepToAgentTask returns the removed IDs of the "ProvisioningStepToAgentTask" edge to the AgentTask entity.
func (m *ProvisioningStepMutation) RemovedProvisioningStepToAgentTaskIDs() (ids []uuid.UUID) {
	for id := range m.removed_ProvisioningStepToAgentTask {
		ids = append(ids, id)
	}
	return
}

// ProvisioningStepToAgentTaskIDs returns the "ProvisioningStepToAgentTask" edge IDs in the mutation.
func (m *ProvisioningStepMutation) ProvisioningStepToAgentTaskIDs() (ids []uuid.UUID) {
	for id := range m._ProvisioningStepToAgentTask {
		ids = append(ids, id)
	}
	return
}

// ResetProvisioningStepToAgentTask resets all changes to the "ProvisioningStepToAgentTask" edge.
func (m *ProvisioningStepMutation) ResetProvisioningStepToAgentTask() {
	m._ProvisioningStepToAgentTask = nil
	m.cleared_ProvisioningStepToAgentTask = false
	m.removed_ProvisioningStepToAgentTask = nil
}

// SetProvisioningStepToGinFileMiddlewareID sets the "ProvisioningStepToGinFileMiddleware" edge to the GinFileMiddleware entity by id.
func (m *ProvisioningStepMutation) SetProvisioningStepToGinFileMiddlewareID(id uuid.UUID) {
	m._ProvisioningStepToGinFileMiddleware = &id
}

// ClearProvisioningStepToGinFileMiddleware clears the "ProvisioningStepToGinFileMiddleware" edge to the GinFileMiddleware entity.
func (m *ProvisioningStepMutation) ClearProvisioningStepToGinFileMiddleware() {
	m.cleared_ProvisioningStepToGinFileMiddleware = true
}

// ProvisioningStepToGinFileMiddlewareCleared reports if the "ProvisioningStepToGinFileMiddleware" edge to the GinFileMiddleware entity was cleared.
func (m *ProvisioningStepMutation) ProvisioningStepToGinFileMiddlewareCleared() bool {
	return m.cleared_ProvisioningStepToGinFileMiddleware
}

// ProvisioningStepToGinFileMiddlewareID returns the "ProvisioningStepToGinFileMiddleware" edge ID in the mutation.
func (m *ProvisioningStepMutation) ProvisioningStepToGinFileMiddlewareID() (id uuid.UUID, exists bool) {
	if m._ProvisioningStepToGinFileMiddleware != nil {
		return *m._ProvisioningStepToGinFileMiddleware, true
	}
	return
}

// ProvisioningStepToGinFileMiddlewareIDs returns the "ProvisioningStepToGinFileMiddleware" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProvisioningStepToGinFileMiddlewareID instead. It exists only for internal usage by the builders.
func (m *ProvisioningStepMutation) ProvisioningStepToGinFileMiddlewareIDs() (ids []uuid.UUID) {
	if id := m._ProvisioningStepToGinFileMiddleware; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvisioningStepToGinFileMiddleware resets all changes to the "ProvisioningStepToGinFileMiddleware" edge.
func (m *ProvisioningStepMutation) ResetProvisioningStepToGinFileMiddleware() {
	m._ProvisioningStepToGinFileMiddleware = nil
	m.cleared_ProvisioningStepToGinFileMiddleware = false
}

// Where appends a list predicates to the ProvisioningStepMutation builder.
func (m *ProvisioningStepMutation) Where(ps ...predicate.ProvisioningStep) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProvisioningStepMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProvisioningStepMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProvisioningStep, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProvisioningStepMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProvisioningStepMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProvisioningStep).
func (m *ProvisioningStepMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProvisioningStepMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._type != nil {
		fields = append(fields, provisioningstep.FieldType)
	}
	if m.step_number != nil {
		fields = append(fields, provisioningstep.FieldStepNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProvisioningStepMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case provisioningstep.FieldType:
		return m.GetType()
	case provisioningstep.FieldStepNumber:
		return m.StepNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProvisioningStepMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case provisioningstep.FieldType:
		return m.OldType(ctx)
	case provisioningstep.FieldStepNumber:
		return m.OldStepNumber(ctx)
	}
	return nil, fmt.Errorf("unknown ProvisioningStep field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvisioningStepMutation) SetField(name string, value ent.Value) error {
	switch name {
	case provisioningstep.FieldType:
		v, ok := value.(provisioningstep.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case provisioningstep.FieldStepNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStepNumber(v)
		return nil
	}
	return fmt.Errorf("unknown ProvisioningStep field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProvisioningStepMutation) AddedFields() []string {
	var fields []string
	if m.addstep_number != nil {
		fields = append(fields, provisioningstep.FieldStepNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProvisioningStepMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case provisioningstep.FieldStepNumber:
		return m.AddedStepNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProvisioningStepMutation) AddField(name string, value ent.Value) error {
	switch name {
	case provisioningstep.FieldStepNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStepNumber(v)
		return nil
	}
	return fmt.Errorf("unknown ProvisioningStep numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProvisioningStepMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProvisioningStepMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProvisioningStepMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProvisioningStep nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProvisioningStepMutation) ResetField(name string) error {
	switch name {
	case provisioningstep.FieldType:
		m.ResetType()
		return nil
	case provisioningstep.FieldStepNumber:
		m.ResetStepNumber()
		return nil
	}
	return fmt.Errorf("unknown ProvisioningStep field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProvisioningStepMutation) AddedEdges() []string {
	edges := make([]string, 0, 12)
	if m._ProvisioningStepToStatus != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToStatus)
	}
	if m._ProvisioningStepToProvisionedHost != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToProvisionedHost)
	}
	if m._ProvisioningStepToScript != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToScript)
	}
	if m._ProvisioningStepToCommand != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToCommand)
	}
	if m._ProvisioningStepToDNSRecord != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToDNSRecord)
	}
	if m._ProvisioningStepToFileDelete != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToFileDelete)
	}
	if m._ProvisioningStepToFileDownload != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToFileDownload)
	}
	if m._ProvisioningStepToFileExtract != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToFileExtract)
	}
	if m._ProvisioningStepToAnsible != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToAnsible)
	}
	if m._ProvisioningStepToPlan != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToPlan)
	}
	if m._ProvisioningStepToAgentTask != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToAgentTask)
	}
	if m._ProvisioningStepToGinFileMiddleware != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToGinFileMiddleware)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProvisioningStepMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case provisioningstep.EdgeProvisioningStepToStatus:
		if id := m._ProvisioningStepToStatus; id != nil {
			return []ent.Value{*id}
		}
	case provisioningstep.EdgeProvisioningStepToProvisionedHost:
		if id := m._ProvisioningStepToProvisionedHost; id != nil {
			return []ent.Value{*id}
		}
	case provisioningstep.EdgeProvisioningStepToScript:
		if id := m._ProvisioningStepToScript; id != nil {
			return []ent.Value{*id}
		}
	case provisioningstep.EdgeProvisioningStepToCommand:
		if id := m._ProvisioningStepToCommand; id != nil {
			return []ent.Value{*id}
		}
	case provisioningstep.EdgeProvisioningStepToDNSRecord:
		if id := m._ProvisioningStepToDNSRecord; id != nil {
			return []ent.Value{*id}
		}
	case provisioningstep.EdgeProvisioningStepToFileDelete:
		if id := m._ProvisioningStepToFileDelete; id != nil {
			return []ent.Value{*id}
		}
	case provisioningstep.EdgeProvisioningStepToFileDownload:
		if id := m._ProvisioningStepToFileDownload; id != nil {
			return []ent.Value{*id}
		}
	case provisioningstep.EdgeProvisioningStepToFileExtract:
		if id := m._ProvisioningStepToFileExtract; id != nil {
			return []ent.Value{*id}
		}
	case provisioningstep.EdgeProvisioningStepToAnsible:
		if id := m._ProvisioningStepToAnsible; id != nil {
			return []ent.Value{*id}
		}
	case provisioningstep.EdgeProvisioningStepToPlan:
		if id := m._ProvisioningStepToPlan; id != nil {
			return []ent.Value{*id}
		}
	case provisioningstep.EdgeProvisioningStepToAgentTask:
		ids := make([]ent.Value, 0, len(m._ProvisioningStepToAgentTask))
		for id := range m._ProvisioningStepToAgentTask {
			ids = append(ids, id)
		}
		return ids
	case provisioningstep.EdgeProvisioningStepToGinFileMiddleware:
		if id := m._ProvisioningStepToGinFileMiddleware; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProvisioningStepMutation) RemovedEdges() []string {
	edges := make([]string, 0, 12)
	if m.removed_ProvisioningStepToAgentTask != nil {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToAgentTask)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProvisioningStepMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case provisioningstep.EdgeProvisioningStepToAgentTask:
		ids := make([]ent.Value, 0, len(m.removed_ProvisioningStepToAgentTask))
		for id := range m.removed_ProvisioningStepToAgentTask {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProvisioningStepMutation) ClearedEdges() []string {
	edges := make([]string, 0, 12)
	if m.cleared_ProvisioningStepToStatus {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToStatus)
	}
	if m.cleared_ProvisioningStepToProvisionedHost {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToProvisionedHost)
	}
	if m.cleared_ProvisioningStepToScript {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToScript)
	}
	if m.cleared_ProvisioningStepToCommand {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToCommand)
	}
	if m.cleared_ProvisioningStepToDNSRecord {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToDNSRecord)
	}
	if m.cleared_ProvisioningStepToFileDelete {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToFileDelete)
	}
	if m.cleared_ProvisioningStepToFileDownload {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToFileDownload)
	}
	if m.cleared_ProvisioningStepToFileExtract {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToFileExtract)
	}
	if m.cleared_ProvisioningStepToAnsible {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToAnsible)
	}
	if m.cleared_ProvisioningStepToPlan {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToPlan)
	}
	if m.cleared_ProvisioningStepToAgentTask {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToAgentTask)
	}
	if m.cleared_ProvisioningStepToGinFileMiddleware {
		edges = append(edges, provisioningstep.EdgeProvisioningStepToGinFileMiddleware)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProvisioningStepMutation) EdgeCleared(name string) bool {
	switch name {
	case provisioningstep.EdgeProvisioningStepToStatus:
		return m.cleared_ProvisioningStepToStatus
	case provisioningstep.EdgeProvisioningStepToProvisionedHost:
		return m.cleared_ProvisioningStepToProvisionedHost
	case provisioningstep.EdgeProvisioningStepToScript:
		return m.cleared_ProvisioningStepToScript
	case provisioningstep.EdgeProvisioningStepToCommand:
		return m.cleared_ProvisioningStepToCommand
	case provisioningstep.EdgeProvisioningStepToDNSRecord:
		return m.cleared_ProvisioningStepToDNSRecord
	case provisioningstep.EdgeProvisioningStepToFileDelete:
		return m.cleared_ProvisioningStepToFileDelete
	case provisioningstep.EdgeProvisioningStepToFileDownload:
		return m.cleared_ProvisioningStepToFileDownload
	case provisioningstep.EdgeProvisioningStepToFileExtract:
		return m.cleared_ProvisioningStepToFileExtract
	case provisioningstep.EdgeProvisioningStepToAnsible:
		return m.cleared_ProvisioningStepToAnsible
	case provisioningstep.EdgeProvisioningStepToPlan:
		return m.cleared_ProvisioningStepToPlan
	case provisioningstep.EdgeProvisioningStepToAgentTask:
		return m.cleared_ProvisioningStepToAgentTask
	case provisioningstep.EdgeProvisioningStepToGinFileMiddleware:
		return m.cleared_ProvisioningStepToGinFileMiddleware
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProvisioningStepMutation) ClearEdge(name string) error {
	switch name {
	case provisioningstep.EdgeProvisioningStepToStatus:
		m.ClearProvisioningStepToStatus()
		return nil
	case provisioningstep.EdgeProvisioningStepToProvisionedHost:
		m.ClearProvisioningStepToProvisionedHost()
		return nil
	case provisioningstep.EdgeProvisioningStepToScript:
		m.ClearProvisioningStepToScript()
		return nil
	case provisioningstep.EdgeProvisioningStepToCommand:
		m.ClearProvisioningStepToCommand()
		return nil
	case provisioningstep.EdgeProvisioningStepToDNSRecord:
		m.ClearProvisioningStepToDNSRecord()
		return nil
	case provisioningstep.EdgeProvisioningStepToFileDelete:
		m.ClearProvisioningStepToFileDelete()
		return nil
	case provisioningstep.EdgeProvisioningStepToFileDownload:
		m.ClearProvisioningStepToFileDownload()
		return nil
	case provisioningstep.EdgeProvisioningStepToFileExtract:
		m.ClearProvisioningStepToFileExtract()
		return nil
	case provisioningstep.EdgeProvisioningStepToAnsible:
		m.ClearProvisioningStepToAnsible()
		return nil
	case provisioningstep.EdgeProvisioningStepToPlan:
		m.ClearProvisioningStepToPlan()
		return nil
	case provisioningstep.EdgeProvisioningStepToGinFileMiddleware:
		m.ClearProvisioningStepToGinFileMiddleware()
		return nil
	}
	return fmt.Errorf("unknown ProvisioningStep unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProvisioningStepMutation) ResetEdge(name string) error {
	switch name {
	case provisioningstep.EdgeProvisioningStepToStatus:
		m.ResetProvisioningStepToStatus()
		return nil
	case provisioningstep.EdgeProvisioningStepToProvisionedHost:
		m.ResetProvisioningStepToProvisionedHost()
		return nil
	case provisioningstep.EdgeProvisioningStepToScript:
		m.ResetProvisioningStepToScript()
		return nil
	case provisioningstep.EdgeProvisioningStepToCommand:
		m.ResetProvisioningStepToCommand()
		return nil
	case provisioningstep.EdgeProvisioningStepToDNSRecord:
		m.ResetProvisioningStepToDNSRecord()
		return nil
	case provisioningstep.EdgeProvisioningStepToFileDelete:
		m.ResetProvisioningStepToFileDelete()
		return nil
	case provisioningstep.EdgeProvisioningStepToFileDownload:
		m.ResetProvisioningStepToFileDownload()
		return nil
	case provisioningstep.EdgeProvisioningStepToFileExtract:
		m.ResetProvisioningStepToFileExtract()
		return nil
	case provisioningstep.EdgeProvisioningStepToAnsible:
		m.ResetProvisioningStepToAnsible()
		return nil
	case provisioningstep.EdgeProvisioningStepToPlan:
		m.ResetProvisioningStepToPlan()
		return nil
	case provisioningstep.EdgeProvisioningStepToAgentTask:
		m.ResetProvisioningStepToAgentTask()
		return nil
	case provisioningstep.EdgeProvisioningStepToGinFileMiddleware:
		m.ResetProvisioningStepToGinFileMiddleware()
		return nil
	}
	return fmt.Errorf("unknown ProvisioningStep edge %s", name)
}

// RepoCommitMutation represents an operation that mutates the RepoCommit nodes in the graph.
type RepoCommitMutation struct {
	config
	op                             Op
	typ                            string
	id                             *uuid.UUID
	revision                       *int
	addrevision                    *int
	hash                           *string
	author                         *object.Signature
	committer                      *object.Signature
	pgp_signature                  *string
	message                        *string
	tree_hash                      *string
	parent_hashes                  *[]string
	appendparent_hashes            []string
	clearedFields                  map[string]struct{}
	_RepoCommitToRepository        *uuid.UUID
	cleared_RepoCommitToRepository bool
	done                           bool
	oldValue                       func(context.Context) (*RepoCommit, error)
	predicates                     []predicate.RepoCommit
}

var _ ent.Mutation = (*RepoCommitMutation)(nil)

// repocommitOption allows management of the mutation configuration using functional options.
type repocommitOption func(*RepoCommitMutation)

// newRepoCommitMutation creates new mutation for the RepoCommit entity.
func newRepoCommitMutation(c config, op Op, opts ...repocommitOption) *RepoCommitMutation {
	m := &RepoCommitMutation{
		config:        c,
		op:            op,
		typ:           TypeRepoCommit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRepoCommitID sets the ID field of the mutation.
func withRepoCommitID(id uuid.UUID) repocommitOption {
	return func(m *RepoCommitMutation) {
		var (
			err   error
			once  sync.Once
			value *RepoCommit
		)
		m.oldValue = func(ctx context.Context) (*RepoCommit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RepoCommit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRepoCommit sets the old RepoCommit of the mutation.
func withRepoCommit(node *RepoCommit) repocommitOption {
	return func(m *RepoCommitMutation) {
		m.oldValue = func(context.Context) (*RepoCommit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RepoCommitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RepoCommitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RepoCommit entities.
func (m *RepoCommitMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RepoCommitMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RepoCommitMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RepoCommit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRevision sets the "revision" field.
func (m *RepoCommitMutation) SetRevision(i int) {
	m.revision = &i
	m.addrevision = nil
}

// Revision returns the value of the "revision" field in the mutation.
func (m *RepoCommitMutation) Revision() (r int, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the RepoCommit entity.
// If the RepoCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoCommitMutation) OldRevision(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// AddRevision adds i to the "revision" field.
func (m *RepoCommitMutation) AddRevision(i int) {
	if m.addrevision != nil {
		*m.addrevision += i
	} else {
		m.addrevision = &i
	}
}

// AddedRevision returns the value that was added to the "revision" field in this mutation.
func (m *RepoCommitMutation) AddedRevision() (r int, exists bool) {
	v := m.addrevision
	if v == nil {
		return
	}
	return *v, true
}

// ResetRevision resets all changes to the "revision" field.
func (m *RepoCommitMutation) ResetRevision() {
	m.revision = nil
	m.addrevision = nil
}

// SetHash sets the "hash" field.
func (m *RepoCommitMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *RepoCommitMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the RepoCommit entity.
// If the RepoCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoCommitMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *RepoCommitMutation) ResetHash() {
	m.hash = nil
}

// SetAuthor sets the "author" field.
func (m *RepoCommitMutation) SetAuthor(o object.Signature) {
	m.author = &o
}

// Author returns the value of the "author" field in the mutation.
func (m *RepoCommitMutation) Author() (r object.Signature, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the RepoCommit entity.
// If the RepoCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoCommitMutation) OldAuthor(ctx context.Context) (v object.Signature, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ResetAuthor resets all changes to the "author" field.
func (m *RepoCommitMutation) ResetAuthor() {
	m.author = nil
}

// SetCommitter sets the "committer" field.
func (m *RepoCommitMutation) SetCommitter(o object.Signature) {
	m.committer = &o
}

// Committer returns the value of the "committer" field in the mutation.
func (m *RepoCommitMutation) Committer() (r object.Signature, exists bool) {
	v := m.committer
	if v == nil {
		return
	}
	return *v, true
}

// OldCommitter returns the old "committer" field's value of the RepoCommit entity.
// If the RepoCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoCommitMutation) OldCommitter(ctx context.Context) (v object.Signature, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommitter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommitter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommitter: %w", err)
	}
	return oldValue.Committer, nil
}

// ResetCommitter resets all changes to the "committer" field.
func (m *RepoCommitMutation) ResetCommitter() {
	m.committer = nil
}

// SetPgpSignature sets the "pgp_signature" field.
func (m *RepoCommitMutation) SetPgpSignature(s string) {
	m.pgp_signature = &s
}

// PgpSignature returns the value of the "pgp_signature" field in the mutation.
func (m *RepoCommitMutation) PgpSignature() (r string, exists bool) {
	v := m.pgp_signature
	if v == nil {
		return
	}
	return *v, true
}

// OldPgpSignature returns the old "pgp_signature" field's value of the RepoCommit entity.
// If the RepoCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoCommitMutation) OldPgpSignature(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPgpSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPgpSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPgpSignature: %w", err)
	}
	return oldValue.PgpSignature, nil
}

// ResetPgpSignature resets all changes to the "pgp_signature" field.
func (m *RepoCommitMutation) ResetPgpSignature() {
	m.pgp_signature = nil
}

// SetMessage sets the "message" field.
func (m *RepoCommitMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *RepoCommitMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the RepoCommit entity.
// If the RepoCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoCommitMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *RepoCommitMutation) ResetMessage() {
	m.message = nil
}

// SetTreeHash sets the "tree_hash" field.
func (m *RepoCommitMutation) SetTreeHash(s string) {
	m.tree_hash = &s
}

// TreeHash returns the value of the "tree_hash" field in the mutation.
func (m *RepoCommitMutation) TreeHash() (r string, exists bool) {
	v := m.tree_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTreeHash returns the old "tree_hash" field's value of the RepoCommit entity.
// If the RepoCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoCommitMutation) OldTreeHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTreeHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTreeHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTreeHash: %w", err)
	}
	return oldValue.TreeHash, nil
}

// ResetTreeHash resets all changes to the "tree_hash" field.
func (m *RepoCommitMutation) ResetTreeHash() {
	m.tree_hash = nil
}

// SetParentHashes sets the "parent_hashes" field.
func (m *RepoCommitMutation) SetParentHashes(s []string) {
	m.parent_hashes = &s
	m.appendparent_hashes = nil
}

// ParentHashes returns the value of the "parent_hashes" field in the mutation.
func (m *RepoCommitMutation) ParentHashes() (r []string, exists bool) {
	v := m.parent_hashes
	if v == nil {
		return
	}
	return *v, true
}

// OldParentHashes returns the old "parent_hashes" field's value of the RepoCommit entity.
// If the RepoCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoCommitMutation) OldParentHashes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentHashes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentHashes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentHashes: %w", err)
	}
	return oldValue.ParentHashes, nil
}

// AppendParentHashes adds s to the "parent_hashes" field.
func (m *RepoCommitMutation) AppendParentHashes(s []string) {
	m.appendparent_hashes = append(m.appendparent_hashes, s...)
}

// AppendedParentHashes returns the list of values that were appended to the "parent_hashes" field in this mutation.
func (m *RepoCommitMutation) AppendedParentHashes() ([]string, bool) {
	if len(m.appendparent_hashes) == 0 {
		return nil, false
	}
	return m.appendparent_hashes, true
}

// ResetParentHashes resets all changes to the "parent_hashes" field.
func (m *RepoCommitMutation) ResetParentHashes() {
	m.parent_hashes = nil
	m.appendparent_hashes = nil
}

// SetRepoCommitToRepositoryID sets the "RepoCommitToRepository" edge to the Repository entity by id.
func (m *RepoCommitMutation) SetRepoCommitToRepositoryID(id uuid.UUID) {
	m._RepoCommitToRepository = &id
}

// ClearRepoCommitToRepository clears the "RepoCommitToRepository" edge to the Repository entity.
func (m *RepoCommitMutation) ClearRepoCommitToRepository() {
	m.cleared_RepoCommitToRepository = true
}

// RepoCommitToRepositoryCleared reports if the "RepoCommitToRepository" edge to the Repository entity was cleared.
func (m *RepoCommitMutation) RepoCommitToRepositoryCleared() bool {
	return m.cleared_RepoCommitToRepository
}

// RepoCommitToRepositoryID returns the "RepoCommitToRepository" edge ID in the mutation.
func (m *RepoCommitMutation) RepoCommitToRepositoryID() (id uuid.UUID, exists bool) {
	if m._RepoCommitToRepository != nil {
		return *m._RepoCommitToRepository, true
	}
	return
}

// RepoCommitToRepositoryIDs returns the "RepoCommitToRepository" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RepoCommitToRepositoryID instead. It exists only for internal usage by the builders.
func (m *RepoCommitMutation) RepoCommitToRepositoryIDs() (ids []uuid.UUID) {
	if id := m._RepoCommitToRepository; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepoCommitToRepository resets all changes to the "RepoCommitToRepository" edge.
func (m *RepoCommitMutation) ResetRepoCommitToRepository() {
	m._RepoCommitToRepository = nil
	m.cleared_RepoCommitToRepository = false
}

// Where appends a list predicates to the RepoCommitMutation builder.
func (m *RepoCommitMutation) Where(ps ...predicate.RepoCommit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RepoCommitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RepoCommitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RepoCommit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RepoCommitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RepoCommitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RepoCommit).
func (m *RepoCommitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RepoCommitMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.revision != nil {
		fields = append(fields, repocommit.FieldRevision)
	}
	if m.hash != nil {
		fields = append(fields, repocommit.FieldHash)
	}
	if m.author != nil {
		fields = append(fields, repocommit.FieldAuthor)
	}
	if m.committer != nil {
		fields = append(fields, repocommit.FieldCommitter)
	}
	if m.pgp_signature != nil {
		fields = append(fields, repocommit.FieldPgpSignature)
	}
	if m.message != nil {
		fields = append(fields, repocommit.FieldMessage)
	}
	if m.tree_hash != nil {
		fields = append(fields, repocommit.FieldTreeHash)
	}
	if m.parent_hashes != nil {
		fields = append(fields, repocommit.FieldParentHashes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RepoCommitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case repocommit.FieldRevision:
		return m.Revision()
	case repocommit.FieldHash:
		return m.Hash()
	case repocommit.FieldAuthor:
		return m.Author()
	case repocommit.FieldCommitter:
		return m.Committer()
	case repocommit.FieldPgpSignature:
		return m.PgpSignature()
	case repocommit.FieldMessage:
		return m.Message()
	case repocommit.FieldTreeHash:
		return m.TreeHash()
	case repocommit.FieldParentHashes:
		return m.ParentHashes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RepoCommitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case repocommit.FieldRevision:
		return m.OldRevision(ctx)
	case repocommit.FieldHash:
		return m.OldHash(ctx)
	case repocommit.FieldAuthor:
		return m.OldAuthor(ctx)
	case repocommit.FieldCommitter:
		return m.OldCommitter(ctx)
	case repocommit.FieldPgpSignature:
		return m.OldPgpSignature(ctx)
	case repocommit.FieldMessage:
		return m.OldMessage(ctx)
	case repocommit.FieldTreeHash:
		return m.OldTreeHash(ctx)
	case repocommit.FieldParentHashes:
		return m.OldParentHashes(ctx)
	}
	return nil, fmt.Errorf("unknown RepoCommit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepoCommitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case repocommit.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case repocommit.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case repocommit.FieldAuthor:
		v, ok := value.(object.Signature)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case repocommit.FieldCommitter:
		v, ok := value.(object.Signature)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommitter(v)
		return nil
	case repocommit.FieldPgpSignature:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPgpSignature(v)
		return nil
	case repocommit.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case repocommit.FieldTreeHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTreeHash(v)
		return nil
	case repocommit.FieldParentHashes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentHashes(v)
		return nil
	}
	return fmt.Errorf("unknown RepoCommit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RepoCommitMutation) AddedFields() []string {
	var fields []string
	if m.addrevision != nil {
		fields = append(fields, repocommit.FieldRevision)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RepoCommitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case repocommit.FieldRevision:
		return m.AddedRevision()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepoCommitMutation) AddField(name string, value ent.Value) error {
	switch name {
	case repocommit.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevision(v)
		return nil
	}
	return fmt.Errorf("unknown RepoCommit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RepoCommitMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RepoCommitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RepoCommitMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RepoCommit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RepoCommitMutation) ResetField(name string) error {
	switch name {
	case repocommit.FieldRevision:
		m.ResetRevision()
		return nil
	case repocommit.FieldHash:
		m.ResetHash()
		return nil
	case repocommit.FieldAuthor:
		m.ResetAuthor()
		return nil
	case repocommit.FieldCommitter:
		m.ResetCommitter()
		return nil
	case repocommit.FieldPgpSignature:
		m.ResetPgpSignature()
		return nil
	case repocommit.FieldMessage:
		m.ResetMessage()
		return nil
	case repocommit.FieldTreeHash:
		m.ResetTreeHash()
		return nil
	case repocommit.FieldParentHashes:
		m.ResetParentHashes()
		return nil
	}
	return fmt.Errorf("unknown RepoCommit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RepoCommitMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._RepoCommitToRepository != nil {
		edges = append(edges, repocommit.EdgeRepoCommitToRepository)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RepoCommitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case repocommit.EdgeRepoCommitToRepository:
		if id := m._RepoCommitToRepository; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RepoCommitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RepoCommitMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RepoCommitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_RepoCommitToRepository {
		edges = append(edges, repocommit.EdgeRepoCommitToRepository)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RepoCommitMutation) EdgeCleared(name string) bool {
	switch name {
	case repocommit.EdgeRepoCommitToRepository:
		return m.cleared_RepoCommitToRepository
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RepoCommitMutation) ClearEdge(name string) error {
	switch name {
	case repocommit.EdgeRepoCommitToRepository:
		m.ClearRepoCommitToRepository()
		return nil
	}
	return fmt.Errorf("unknown RepoCommit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RepoCommitMutation) ResetEdge(name string) error {
	switch name {
	case repocommit.EdgeRepoCommitToRepository:
		m.ResetRepoCommitToRepository()
		return nil
	}
	return fmt.Errorf("unknown RepoCommit edge %s", name)
}

// RepositoryMutation represents an operation that mutates the Repository nodes in the graph.
type RepositoryMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	repo_url                        *string
	branch_name                     *string
	enviroment_filepath             *string
	folder_path                     *string
	clearedFields                   map[string]struct{}
	_RepositoryToEnvironment        map[uuid.UUID]struct{}
	removed_RepositoryToEnvironment map[uuid.UUID]struct{}
	cleared_RepositoryToEnvironment bool
	_RepositoryToRepoCommit         map[uuid.UUID]struct{}
	removed_RepositoryToRepoCommit  map[uuid.UUID]struct{}
	cleared_RepositoryToRepoCommit  bool
	done                            bool
	oldValue                        func(context.Context) (*Repository, error)
	predicates                      []predicate.Repository
}

var _ ent.Mutation = (*RepositoryMutation)(nil)

// repositoryOption allows management of the mutation configuration using functional options.
type repositoryOption func(*RepositoryMutation)

// newRepositoryMutation creates new mutation for the Repository entity.
func newRepositoryMutation(c config, op Op, opts ...repositoryOption) *RepositoryMutation {
	m := &RepositoryMutation{
		config:        c,
		op:            op,
		typ:           TypeRepository,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRepositoryID sets the ID field of the mutation.
func withRepositoryID(id uuid.UUID) repositoryOption {
	return func(m *RepositoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Repository
		)
		m.oldValue = func(ctx context.Context) (*Repository, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Repository.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRepository sets the old Repository of the mutation.
func withRepository(node *Repository) repositoryOption {
	return func(m *RepositoryMutation) {
		m.oldValue = func(context.Context) (*Repository, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RepositoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RepositoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Repository entities.
func (m *RepositoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RepositoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RepositoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Repository.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRepoURL sets the "repo_url" field.
func (m *RepositoryMutation) SetRepoURL(s string) {
	m.repo_url = &s
}

// RepoURL returns the value of the "repo_url" field in the mutation.
func (m *RepositoryMutation) RepoURL() (r string, exists bool) {
	v := m.repo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRepoURL returns the old "repo_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldRepoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepoURL: %w", err)
	}
	return oldValue.RepoURL, nil
}

// ResetRepoURL resets all changes to the "repo_url" field.
func (m *RepositoryMutation) ResetRepoURL() {
	m.repo_url = nil
}

// SetBranchName sets the "branch_name" field.
func (m *RepositoryMutation) SetBranchName(s string) {
	m.branch_name = &s
}

// BranchName returns the value of the "branch_name" field in the mutation.
func (m *RepositoryMutation) BranchName() (r string, exists bool) {
	v := m.branch_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBranchName returns the old "branch_name" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldBranchName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBranchName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBranchName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranchName: %w", err)
	}
	return oldValue.BranchName, nil
}

// ResetBranchName resets all changes to the "branch_name" field.
func (m *RepositoryMutation) ResetBranchName() {
	m.branch_name = nil
}

// SetEnviromentFilepath sets the "enviroment_filepath" field.
func (m *RepositoryMutation) SetEnviromentFilepath(s string) {
	m.enviroment_filepath = &s
}

// EnviromentFilepath returns the value of the "enviroment_filepath" field in the mutation.
func (m *RepositoryMutation) EnviromentFilepath() (r string, exists bool) {
	v := m.enviroment_filepath
	if v == nil {
		return
	}
	return *v, true
}

// OldEnviromentFilepath returns the old "enviroment_filepath" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldEnviromentFilepath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnviromentFilepath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnviromentFilepath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnviromentFilepath: %w", err)
	}
	return oldValue.EnviromentFilepath, nil
}

// ResetEnviromentFilepath resets all changes to the "enviroment_filepath" field.
func (m *RepositoryMutation) ResetEnviromentFilepath() {
	m.enviroment_filepath = nil
}

// SetFolderPath sets the "folder_path" field.
func (m *RepositoryMutation) SetFolderPath(s string) {
	m.folder_path = &s
}

// FolderPath returns the value of the "folder_path" field in the mutation.
func (m *RepositoryMutation) FolderPath() (r string, exists bool) {
	v := m.folder_path
	if v == nil {
		return
	}
	return *v, true
}

// OldFolderPath returns the old "folder_path" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldFolderPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFolderPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFolderPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFolderPath: %w", err)
	}
	return oldValue.FolderPath, nil
}

// ResetFolderPath resets all changes to the "folder_path" field.
func (m *RepositoryMutation) ResetFolderPath() {
	m.folder_path = nil
}

// AddRepositoryToEnvironmentIDs adds the "RepositoryToEnvironment" edge to the Environment entity by ids.
func (m *RepositoryMutation) AddRepositoryToEnvironmentIDs(ids ...uuid.UUID) {
	if m._RepositoryToEnvironment == nil {
		m._RepositoryToEnvironment = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._RepositoryToEnvironment[ids[i]] = struct{}{}
	}
}

// ClearRepositoryToEnvironment clears the "RepositoryToEnvironment" edge to the Environment entity.
func (m *RepositoryMutation) ClearRepositoryToEnvironment() {
	m.cleared_RepositoryToEnvironment = true
}

// RepositoryToEnvironmentCleared reports if the "RepositoryToEnvironment" edge to the Environment entity was cleared.
func (m *RepositoryMutation) RepositoryToEnvironmentCleared() bool {
	return m.cleared_RepositoryToEnvironment
}

// RemoveRepositoryToEnvironmentIDs removes the "RepositoryToEnvironment" edge to the Environment entity by IDs.
func (m *RepositoryMutation) RemoveRepositoryToEnvironmentIDs(ids ...uuid.UUID) {
	if m.removed_RepositoryToEnvironment == nil {
		m.removed_RepositoryToEnvironment = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._RepositoryToEnvironment, ids[i])
		m.removed_RepositoryToEnvironment[ids[i]] = struct{}{}
	}
}

// RemovedRepositoryToEnvironment returns the removed IDs of the "RepositoryToEnvironment" edge to the Environment entity.
func (m *RepositoryMutation) RemovedRepositoryToEnvironmentIDs() (ids []uuid.UUID) {
	for id := range m.removed_RepositoryToEnvironment {
		ids = append(ids, id)
	}
	return
}

// RepositoryToEnvironmentIDs returns the "RepositoryToEnvironment" edge IDs in the mutation.
func (m *RepositoryMutation) RepositoryToEnvironmentIDs() (ids []uuid.UUID) {
	for id := range m._RepositoryToEnvironment {
		ids = append(ids, id)
	}
	return
}

// ResetRepositoryToEnvironment resets all changes to the "RepositoryToEnvironment" edge.
func (m *RepositoryMutation) ResetRepositoryToEnvironment() {
	m._RepositoryToEnvironment = nil
	m.cleared_RepositoryToEnvironment = false
	m.removed_RepositoryToEnvironment = nil
}

// AddRepositoryToRepoCommitIDs adds the "RepositoryToRepoCommit" edge to the RepoCommit entity by ids.
func (m *RepositoryMutation) AddRepositoryToRepoCommitIDs(ids ...uuid.UUID) {
	if m._RepositoryToRepoCommit == nil {
		m._RepositoryToRepoCommit = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._RepositoryToRepoCommit[ids[i]] = struct{}{}
	}
}

// ClearRepositoryToRepoCommit clears the "RepositoryToRepoCommit" edge to the RepoCommit entity.
func (m *RepositoryMutation) ClearRepositoryToRepoCommit() {
	m.cleared_RepositoryToRepoCommit = true
}

// RepositoryToRepoCommitCleared reports if the "RepositoryToRepoCommit" edge to the RepoCommit entity was cleared.
func (m *RepositoryMutation) RepositoryToRepoCommitCleared() bool {
	return m.cleared_RepositoryToRepoCommit
}

// RemoveRepositoryToRepoCommitIDs removes the "RepositoryToRepoCommit" edge to the RepoCommit entity by IDs.
func (m *RepositoryMutation) RemoveRepositoryToRepoCommitIDs(ids ...uuid.UUID) {
	if m.removed_RepositoryToRepoCommit == nil {
		m.removed_RepositoryToRepoCommit = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._RepositoryToRepoCommit, ids[i])
		m.removed_RepositoryToRepoCommit[ids[i]] = struct{}{}
	}
}

// RemovedRepositoryToRepoCommit returns the removed IDs of the "RepositoryToRepoCommit" edge to the RepoCommit entity.
func (m *RepositoryMutation) RemovedRepositoryToRepoCommitIDs() (ids []uuid.UUID) {
	for id := range m.removed_RepositoryToRepoCommit {
		ids = append(ids, id)
	}
	return
}

// RepositoryToRepoCommitIDs returns the "RepositoryToRepoCommit" edge IDs in the mutation.
func (m *RepositoryMutation) RepositoryToRepoCommitIDs() (ids []uuid.UUID) {
	for id := range m._RepositoryToRepoCommit {
		ids = append(ids, id)
	}
	return
}

// ResetRepositoryToRepoCommit resets all changes to the "RepositoryToRepoCommit" edge.
func (m *RepositoryMutation) ResetRepositoryToRepoCommit() {
	m._RepositoryToRepoCommit = nil
	m.cleared_RepositoryToRepoCommit = false
	m.removed_RepositoryToRepoCommit = nil
}

// Where appends a list predicates to the RepositoryMutation builder.
func (m *RepositoryMutation) Where(ps ...predicate.Repository) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RepositoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RepositoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Repository, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RepositoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RepositoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Repository).
func (m *RepositoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RepositoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.repo_url != nil {
		fields = append(fields, repository.FieldRepoURL)
	}
	if m.branch_name != nil {
		fields = append(fields, repository.FieldBranchName)
	}
	if m.enviroment_filepath != nil {
		fields = append(fields, repository.FieldEnviromentFilepath)
	}
	if m.folder_path != nil {
		fields = append(fields, repository.FieldFolderPath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RepositoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case repository.FieldRepoURL:
		return m.RepoURL()
	case repository.FieldBranchName:
		return m.BranchName()
	case repository.FieldEnviromentFilepath:
		return m.EnviromentFilepath()
	case repository.FieldFolderPath:
		return m.FolderPath()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RepositoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case repository.FieldRepoURL:
		return m.OldRepoURL(ctx)
	case repository.FieldBranchName:
		return m.OldBranchName(ctx)
	case repository.FieldEnviromentFilepath:
		return m.OldEnviromentFilepath(ctx)
	case repository.FieldFolderPath:
		return m.OldFolderPath(ctx)
	}
	return nil, fmt.Errorf("unknown Repository field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepositoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case repository.FieldRepoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepoURL(v)
		return nil
	case repository.FieldBranchName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranchName(v)
		return nil
	case repository.FieldEnviromentFilepath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnviromentFilepath(v)
		return nil
	case repository.FieldFolderPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFolderPath(v)
		return nil
	}
	return fmt.Errorf("unknown Repository field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RepositoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RepositoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepositoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Repository numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RepositoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RepositoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RepositoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Repository nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RepositoryMutation) ResetField(name string) error {
	switch name {
	case repository.FieldRepoURL:
		m.ResetRepoURL()
		return nil
	case repository.FieldBranchName:
		m.ResetBranchName()
		return nil
	case repository.FieldEnviromentFilepath:
		m.ResetEnviromentFilepath()
		return nil
	case repository.FieldFolderPath:
		m.ResetFolderPath()
		return nil
	}
	return fmt.Errorf("unknown Repository field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RepositoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._RepositoryToEnvironment != nil {
		edges = append(edges, repository.EdgeRepositoryToEnvironment)
	}
	if m._RepositoryToRepoCommit != nil {
		edges = append(edges, repository.EdgeRepositoryToRepoCommit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RepositoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case repository.EdgeRepositoryToEnvironment:
		ids := make([]ent.Value, 0, len(m._RepositoryToEnvironment))
		for id := range m._RepositoryToEnvironment {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeRepositoryToRepoCommit:
		ids := make([]ent.Value, 0, len(m._RepositoryToRepoCommit))
		for id := range m._RepositoryToRepoCommit {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RepositoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_RepositoryToEnvironment != nil {
		edges = append(edges, repository.EdgeRepositoryToEnvironment)
	}
	if m.removed_RepositoryToRepoCommit != nil {
		edges = append(edges, repository.EdgeRepositoryToRepoCommit)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RepositoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case repository.EdgeRepositoryToEnvironment:
		ids := make([]ent.Value, 0, len(m.removed_RepositoryToEnvironment))
		for id := range m.removed_RepositoryToEnvironment {
			ids = append(ids, id)
		}
		return ids
	case repository.EdgeRepositoryToRepoCommit:
		ids := make([]ent.Value, 0, len(m.removed_RepositoryToRepoCommit))
		for id := range m.removed_RepositoryToRepoCommit {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RepositoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_RepositoryToEnvironment {
		edges = append(edges, repository.EdgeRepositoryToEnvironment)
	}
	if m.cleared_RepositoryToRepoCommit {
		edges = append(edges, repository.EdgeRepositoryToRepoCommit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RepositoryMutation) EdgeCleared(name string) bool {
	switch name {
	case repository.EdgeRepositoryToEnvironment:
		return m.cleared_RepositoryToEnvironment
	case repository.EdgeRepositoryToRepoCommit:
		return m.cleared_RepositoryToRepoCommit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RepositoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Repository unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RepositoryMutation) ResetEdge(name string) error {
	switch name {
	case repository.EdgeRepositoryToEnvironment:
		m.ResetRepositoryToEnvironment()
		return nil
	case repository.EdgeRepositoryToRepoCommit:
		m.ResetRepositoryToRepoCommit()
		return nil
	}
	return fmt.Errorf("unknown Repository edge %s", name)
}

// ScriptMutation represents an operation that mutates the Script nodes in the graph.
type ScriptMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uuid.UUID
	hcl_id                      *string
	name                        *string
	language                    *string
	description                 *string
	source                      *string
	source_type                 *string
	cooldown                    *int
	addcooldown                 *int
	timeout                     *int
	addtimeout                  *int
	ignore_errors               *bool
	args                        *[]string
	appendargs                  []string
	disabled                    *bool
	vars                        *map[string]string
	abs_path                    *string
	tags                        *map[string]string
	clearedFields               map[string]struct{}
	_ScriptToUser               map[uuid.UUID]struct{}
	removed_ScriptToUser        map[uuid.UUID]struct{}
	cleared_ScriptToUser        bool
	_ScriptToFinding            map[uuid.UUID]struct{}
	removed_ScriptToFinding     map[uuid.UUID]struct{}
	cleared_ScriptToFinding     bool
	_ScriptToEnvironment        *uuid.UUID
	cleared_ScriptToEnvironment bool
	done                        bool
	oldValue                    func(context.Context) (*Script, error)
	predicates                  []predicate.Script
}

var _ ent.Mutation = (*ScriptMutation)(nil)

// scriptOption allows management of the mutation configuration using functional options.
type scriptOption func(*ScriptMutation)

// newScriptMutation creates new mutation for the Script entity.
func newScriptMutation(c config, op Op, opts ...scriptOption) *ScriptMutation {
	m := &ScriptMutation{
		config:        c,
		op:            op,
		typ:           TypeScript,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScriptID sets the ID field of the mutation.
func withScriptID(id uuid.UUID) scriptOption {
	return func(m *ScriptMutation) {
		var (
			err   error
			once  sync.Once
			value *Script
		)
		m.oldValue = func(ctx context.Context) (*Script, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Script.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withScript sets the old Script of the mutation.
func withScript(node *Script) scriptOption {
	return func(m *ScriptMutation) {
		m.oldValue = func(context.Context) (*Script, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScriptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScriptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Script entities.
func (m *ScriptMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScriptMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScriptMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Script.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHCLID sets the "hcl_id" field.
func (m *ScriptMutation) SetHCLID(s string) {
	m.hcl_id = &s
}

// HCLID returns the value of the "hcl_id" field in the mutation.
func (m *ScriptMutation) HCLID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHCLID returns the old "hcl_id" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldHCLID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHCLID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHCLID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHCLID: %w", err)
	}
	return oldValue.HCLID, nil
}

// ResetHCLID resets all changes to the "hcl_id" field.
func (m *ScriptMutation) ResetHCLID() {
	m.hcl_id = nil
}

// SetName sets the "name" field.
func (m *ScriptMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ScriptMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ScriptMutation) ResetName() {
	m.name = nil
}

// SetLanguage sets the "language" field.
func (m *ScriptMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *ScriptMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *ScriptMutation) ResetLanguage() {
	m.language = nil
}

// SetDescription sets the "description" field.
func (m *ScriptMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ScriptMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ScriptMutation) ResetDescription() {
	m.description = nil
}

// SetSource sets the "source" field.
func (m *ScriptMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *ScriptMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *ScriptMutation) ResetSource() {
	m.source = nil
}

// SetSourceType sets the "source_type" field.
func (m *ScriptMutation) SetSourceType(s string) {
	m.source_type = &s
}

// SourceType returns the value of the "source_type" field in the mutation.
func (m *ScriptMutation) SourceType() (r string, exists bool) {
	v := m.source_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceType returns the old "source_type" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldSourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceType: %w", err)
	}
	return oldValue.SourceType, nil
}

// ResetSourceType resets all changes to the "source_type" field.
func (m *ScriptMutation) ResetSourceType() {
	m.source_type = nil
}

// SetCooldown sets the "cooldown" field.
func (m *ScriptMutation) SetCooldown(i int) {
	m.cooldown = &i
	m.addcooldown = nil
}

// Cooldown returns the value of the "cooldown" field in the mutation.
func (m *ScriptMutation) Cooldown() (r int, exists bool) {
	v := m.cooldown
	if v == nil {
		return
	}
	return *v, true
}

// OldCooldown returns the old "cooldown" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldCooldown(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCooldown is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCooldown requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCooldown: %w", err)
	}
	return oldValue.Cooldown, nil
}

// AddCooldown adds i to the "cooldown" field.
func (m *ScriptMutation) AddCooldown(i int) {
	if m.addcooldown != nil {
		*m.addcooldown += i
	} else {
		m.addcooldown = &i
	}
}

// AddedCooldown returns the value that was added to the "cooldown" field in this mutation.
func (m *ScriptMutation) AddedCooldown() (r int, exists bool) {
	v := m.addcooldown
	if v == nil {
		return
	}
	return *v, true
}

// ResetCooldown resets all changes to the "cooldown" field.
func (m *ScriptMutation) ResetCooldown() {
	m.cooldown = nil
	m.addcooldown = nil
}

// SetTimeout sets the "timeout" field.
func (m *ScriptMutation) SetTimeout(i int) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *ScriptMutation) Timeout() (r int, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldTimeout(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to the "timeout" field.
func (m *ScriptMutation) AddTimeout(i int) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the "timeout" field in this mutation.
func (m *ScriptMutation) AddedTimeout() (r int, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *ScriptMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
}

// SetIgnoreErrors sets the "ignore_errors" field.
func (m *ScriptMutation) SetIgnoreErrors(b bool) {
	m.ignore_errors = &b
}

// IgnoreErrors returns the value of the "ignore_errors" field in the mutation.
func (m *ScriptMutation) IgnoreErrors() (r bool, exists bool) {
	v := m.ignore_errors
	if v == nil {
		return
	}
	return *v, true
}

// OldIgnoreErrors returns the old "ignore_errors" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldIgnoreErrors(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIgnoreErrors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIgnoreErrors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIgnoreErrors: %w", err)
	}
	return oldValue.IgnoreErrors, nil
}

// ResetIgnoreErrors resets all changes to the "ignore_errors" field.
func (m *ScriptMutation) ResetIgnoreErrors() {
	m.ignore_errors = nil
}

// SetArgs sets the "args" field.
func (m *ScriptMutation) SetArgs(s []string) {
	m.args = &s
	m.appendargs = nil
}

// Args returns the value of the "args" field in the mutation.
func (m *ScriptMutation) Args() (r []string, exists bool) {
	v := m.args
	if v == nil {
		return
	}
	return *v, true
}

// OldArgs returns the old "args" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldArgs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArgs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArgs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArgs: %w", err)
	}
	return oldValue.Args, nil
}

// AppendArgs adds s to the "args" field.
func (m *ScriptMutation) AppendArgs(s []string) {
	m.appendargs = append(m.appendargs, s...)
}

// AppendedArgs returns the list of values that were appended to the "args" field in this mutation.
func (m *ScriptMutation) AppendedArgs() ([]string, bool) {
	if len(m.appendargs) == 0 {
		return nil, false
	}
	return m.appendargs, true
}

// ResetArgs resets all changes to the "args" field.
func (m *ScriptMutation) ResetArgs() {
	m.args = nil
	m.appendargs = nil
}

// SetDisabled sets the "disabled" field.
func (m *ScriptMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *ScriptMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *ScriptMutation) ResetDisabled() {
	m.disabled = nil
}

// SetVars sets the "vars" field.
func (m *ScriptMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *ScriptMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *ScriptMutation) ResetVars() {
	m.vars = nil
}

// SetAbsPath sets the "abs_path" field.
func (m *ScriptMutation) SetAbsPath(s string) {
	m.abs_path = &s
}

// AbsPath returns the value of the "abs_path" field in the mutation.
func (m *ScriptMutation) AbsPath() (r string, exists bool) {
	v := m.abs_path
	if v == nil {
		return
	}
	return *v, true
}

// OldAbsPath returns the old "abs_path" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldAbsPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbsPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbsPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbsPath: %w", err)
	}
	return oldValue.AbsPath, nil
}

// ResetAbsPath resets all changes to the "abs_path" field.
func (m *ScriptMutation) ResetAbsPath() {
	m.abs_path = nil
}

// SetTags sets the "tags" field.
func (m *ScriptMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *ScriptMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Script entity.
// If the Script object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScriptMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *ScriptMutation) ResetTags() {
	m.tags = nil
}

// AddScriptToUserIDs adds the "ScriptToUser" edge to the User entity by ids.
func (m *ScriptMutation) AddScriptToUserIDs(ids ...uuid.UUID) {
	if m._ScriptToUser == nil {
		m._ScriptToUser = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ScriptToUser[ids[i]] = struct{}{}
	}
}

// ClearScriptToUser clears the "ScriptToUser" edge to the User entity.
func (m *ScriptMutation) ClearScriptToUser() {
	m.cleared_ScriptToUser = true
}

// ScriptToUserCleared reports if the "ScriptToUser" edge to the User entity was cleared.
func (m *ScriptMutation) ScriptToUserCleared() bool {
	return m.cleared_ScriptToUser
}

// RemoveScriptToUserIDs removes the "ScriptToUser" edge to the User entity by IDs.
func (m *ScriptMutation) RemoveScriptToUserIDs(ids ...uuid.UUID) {
	if m.removed_ScriptToUser == nil {
		m.removed_ScriptToUser = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._ScriptToUser, ids[i])
		m.removed_ScriptToUser[ids[i]] = struct{}{}
	}
}

// RemovedScriptToUser returns the removed IDs of the "ScriptToUser" edge to the User entity.
func (m *ScriptMutation) RemovedScriptToUserIDs() (ids []uuid.UUID) {
	for id := range m.removed_ScriptToUser {
		ids = append(ids, id)
	}
	return
}

// ScriptToUserIDs returns the "ScriptToUser" edge IDs in the mutation.
func (m *ScriptMutation) ScriptToUserIDs() (ids []uuid.UUID) {
	for id := range m._ScriptToUser {
		ids = append(ids, id)
	}
	return
}

// ResetScriptToUser resets all changes to the "ScriptToUser" edge.
func (m *ScriptMutation) ResetScriptToUser() {
	m._ScriptToUser = nil
	m.cleared_ScriptToUser = false
	m.removed_ScriptToUser = nil
}

// AddScriptToFindingIDs adds the "ScriptToFinding" edge to the Finding entity by ids.
func (m *ScriptMutation) AddScriptToFindingIDs(ids ...uuid.UUID) {
	if m._ScriptToFinding == nil {
		m._ScriptToFinding = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ScriptToFinding[ids[i]] = struct{}{}
	}
}

// ClearScriptToFinding clears the "ScriptToFinding" edge to the Finding entity.
func (m *ScriptMutation) ClearScriptToFinding() {
	m.cleared_ScriptToFinding = true
}

// ScriptToFindingCleared reports if the "ScriptToFinding" edge to the Finding entity was cleared.
func (m *ScriptMutation) ScriptToFindingCleared() bool {
	return m.cleared_ScriptToFinding
}

// RemoveScriptToFindingIDs removes the "ScriptToFinding" edge to the Finding entity by IDs.
func (m *ScriptMutation) RemoveScriptToFindingIDs(ids ...uuid.UUID) {
	if m.removed_ScriptToFinding == nil {
		m.removed_ScriptToFinding = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._ScriptToFinding, ids[i])
		m.removed_ScriptToFinding[ids[i]] = struct{}{}
	}
}

// RemovedScriptToFinding returns the removed IDs of the "ScriptToFinding" edge to the Finding entity.
func (m *ScriptMutation) RemovedScriptToFindingIDs() (ids []uuid.UUID) {
	for id := range m.removed_ScriptToFinding {
		ids = append(ids, id)
	}
	return
}

// ScriptToFindingIDs returns the "ScriptToFinding" edge IDs in the mutation.
func (m *ScriptMutation) ScriptToFindingIDs() (ids []uuid.UUID) {
	for id := range m._ScriptToFinding {
		ids = append(ids, id)
	}
	return
}

// ResetScriptToFinding resets all changes to the "ScriptToFinding" edge.
func (m *ScriptMutation) ResetScriptToFinding() {
	m._ScriptToFinding = nil
	m.cleared_ScriptToFinding = false
	m.removed_ScriptToFinding = nil
}

// SetScriptToEnvironmentID sets the "ScriptToEnvironment" edge to the Environment entity by id.
func (m *ScriptMutation) SetScriptToEnvironmentID(id uuid.UUID) {
	m._ScriptToEnvironment = &id
}

// ClearScriptToEnvironment clears the "ScriptToEnvironment" edge to the Environment entity.
func (m *ScriptMutation) ClearScriptToEnvironment() {
	m.cleared_ScriptToEnvironment = true
}

// ScriptToEnvironmentCleared reports if the "ScriptToEnvironment" edge to the Environment entity was cleared.
func (m *ScriptMutation) ScriptToEnvironmentCleared() bool {
	return m.cleared_ScriptToEnvironment
}

// ScriptToEnvironmentID returns the "ScriptToEnvironment" edge ID in the mutation.
func (m *ScriptMutation) ScriptToEnvironmentID() (id uuid.UUID, exists bool) {
	if m._ScriptToEnvironment != nil {
		return *m._ScriptToEnvironment, true
	}
	return
}

// ScriptToEnvironmentIDs returns the "ScriptToEnvironment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ScriptToEnvironmentID instead. It exists only for internal usage by the builders.
func (m *ScriptMutation) ScriptToEnvironmentIDs() (ids []uuid.UUID) {
	if id := m._ScriptToEnvironment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetScriptToEnvironment resets all changes to the "ScriptToEnvironment" edge.
func (m *ScriptMutation) ResetScriptToEnvironment() {
	m._ScriptToEnvironment = nil
	m.cleared_ScriptToEnvironment = false
}

// Where appends a list predicates to the ScriptMutation builder.
func (m *ScriptMutation) Where(ps ...predicate.Script) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ScriptMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ScriptMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Script, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ScriptMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ScriptMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Script).
func (m *ScriptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScriptMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.hcl_id != nil {
		fields = append(fields, script.FieldHCLID)
	}
	if m.name != nil {
		fields = append(fields, script.FieldName)
	}
	if m.language != nil {
		fields = append(fields, script.FieldLanguage)
	}
	if m.description != nil {
		fields = append(fields, script.FieldDescription)
	}
	if m.source != nil {
		fields = append(fields, script.FieldSource)
	}
	if m.source_type != nil {
		fields = append(fields, script.FieldSourceType)
	}
	if m.cooldown != nil {
		fields = append(fields, script.FieldCooldown)
	}
	if m.timeout != nil {
		fields = append(fields, script.FieldTimeout)
	}
	if m.ignore_errors != nil {
		fields = append(fields, script.FieldIgnoreErrors)
	}
	if m.args != nil {
		fields = append(fields, script.FieldArgs)
	}
	if m.disabled != nil {
		fields = append(fields, script.FieldDisabled)
	}
	if m.vars != nil {
		fields = append(fields, script.FieldVars)
	}
	if m.abs_path != nil {
		fields = append(fields, script.FieldAbsPath)
	}
	if m.tags != nil {
		fields = append(fields, script.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScriptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case script.FieldHCLID:
		return m.HCLID()
	case script.FieldName:
		return m.Name()
	case script.FieldLanguage:
		return m.Language()
	case script.FieldDescription:
		return m.Description()
	case script.FieldSource:
		return m.Source()
	case script.FieldSourceType:
		return m.SourceType()
	case script.FieldCooldown:
		return m.Cooldown()
	case script.FieldTimeout:
		return m.Timeout()
	case script.FieldIgnoreErrors:
		return m.IgnoreErrors()
	case script.FieldArgs:
		return m.Args()
	case script.FieldDisabled:
		return m.Disabled()
	case script.FieldVars:
		return m.Vars()
	case script.FieldAbsPath:
		return m.AbsPath()
	case script.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScriptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case script.FieldHCLID:
		return m.OldHCLID(ctx)
	case script.FieldName:
		return m.OldName(ctx)
	case script.FieldLanguage:
		return m.OldLanguage(ctx)
	case script.FieldDescription:
		return m.OldDescription(ctx)
	case script.FieldSource:
		return m.OldSource(ctx)
	case script.FieldSourceType:
		return m.OldSourceType(ctx)
	case script.FieldCooldown:
		return m.OldCooldown(ctx)
	case script.FieldTimeout:
		return m.OldTimeout(ctx)
	case script.FieldIgnoreErrors:
		return m.OldIgnoreErrors(ctx)
	case script.FieldArgs:
		return m.OldArgs(ctx)
	case script.FieldDisabled:
		return m.OldDisabled(ctx)
	case script.FieldVars:
		return m.OldVars(ctx)
	case script.FieldAbsPath:
		return m.OldAbsPath(ctx)
	case script.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Script field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScriptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case script.FieldHCLID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHCLID(v)
		return nil
	case script.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case script.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case script.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case script.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case script.FieldSourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceType(v)
		return nil
	case script.FieldCooldown:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCooldown(v)
		return nil
	case script.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case script.FieldIgnoreErrors:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIgnoreErrors(v)
		return nil
	case script.FieldArgs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArgs(v)
		return nil
	case script.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case script.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	case script.FieldAbsPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbsPath(v)
		return nil
	case script.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Script field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScriptMutation) AddedFields() []string {
	var fields []string
	if m.addcooldown != nil {
		fields = append(fields, script.FieldCooldown)
	}
	if m.addtimeout != nil {
		fields = append(fields, script.FieldTimeout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScriptMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case script.FieldCooldown:
		return m.AddedCooldown()
	case script.FieldTimeout:
		return m.AddedTimeout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScriptMutation) AddField(name string, value ent.Value) error {
	switch name {
	case script.FieldCooldown:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCooldown(v)
		return nil
	case script.FieldTimeout:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown Script numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScriptMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScriptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScriptMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Script nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScriptMutation) ResetField(name string) error {
	switch name {
	case script.FieldHCLID:
		m.ResetHCLID()
		return nil
	case script.FieldName:
		m.ResetName()
		return nil
	case script.FieldLanguage:
		m.ResetLanguage()
		return nil
	case script.FieldDescription:
		m.ResetDescription()
		return nil
	case script.FieldSource:
		m.ResetSource()
		return nil
	case script.FieldSourceType:
		m.ResetSourceType()
		return nil
	case script.FieldCooldown:
		m.ResetCooldown()
		return nil
	case script.FieldTimeout:
		m.ResetTimeout()
		return nil
	case script.FieldIgnoreErrors:
		m.ResetIgnoreErrors()
		return nil
	case script.FieldArgs:
		m.ResetArgs()
		return nil
	case script.FieldDisabled:
		m.ResetDisabled()
		return nil
	case script.FieldVars:
		m.ResetVars()
		return nil
	case script.FieldAbsPath:
		m.ResetAbsPath()
		return nil
	case script.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Script field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScriptMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._ScriptToUser != nil {
		edges = append(edges, script.EdgeScriptToUser)
	}
	if m._ScriptToFinding != nil {
		edges = append(edges, script.EdgeScriptToFinding)
	}
	if m._ScriptToEnvironment != nil {
		edges = append(edges, script.EdgeScriptToEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScriptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case script.EdgeScriptToUser:
		ids := make([]ent.Value, 0, len(m._ScriptToUser))
		for id := range m._ScriptToUser {
			ids = append(ids, id)
		}
		return ids
	case script.EdgeScriptToFinding:
		ids := make([]ent.Value, 0, len(m._ScriptToFinding))
		for id := range m._ScriptToFinding {
			ids = append(ids, id)
		}
		return ids
	case script.EdgeScriptToEnvironment:
		if id := m._ScriptToEnvironment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScriptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_ScriptToUser != nil {
		edges = append(edges, script.EdgeScriptToUser)
	}
	if m.removed_ScriptToFinding != nil {
		edges = append(edges, script.EdgeScriptToFinding)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScriptMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case script.EdgeScriptToUser:
		ids := make([]ent.Value, 0, len(m.removed_ScriptToUser))
		for id := range m.removed_ScriptToUser {
			ids = append(ids, id)
		}
		return ids
	case script.EdgeScriptToFinding:
		ids := make([]ent.Value, 0, len(m.removed_ScriptToFinding))
		for id := range m.removed_ScriptToFinding {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScriptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_ScriptToUser {
		edges = append(edges, script.EdgeScriptToUser)
	}
	if m.cleared_ScriptToFinding {
		edges = append(edges, script.EdgeScriptToFinding)
	}
	if m.cleared_ScriptToEnvironment {
		edges = append(edges, script.EdgeScriptToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScriptMutation) EdgeCleared(name string) bool {
	switch name {
	case script.EdgeScriptToUser:
		return m.cleared_ScriptToUser
	case script.EdgeScriptToFinding:
		return m.cleared_ScriptToFinding
	case script.EdgeScriptToEnvironment:
		return m.cleared_ScriptToEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScriptMutation) ClearEdge(name string) error {
	switch name {
	case script.EdgeScriptToEnvironment:
		m.ClearScriptToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Script unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScriptMutation) ResetEdge(name string) error {
	switch name {
	case script.EdgeScriptToUser:
		m.ResetScriptToUser()
		return nil
	case script.EdgeScriptToFinding:
		m.ResetScriptToFinding()
		return nil
	case script.EdgeScriptToEnvironment:
		m.ResetScriptToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown Script edge %s", name)
}

// ServerTaskMutation represents an operation that mutates the ServerTask nodes in the graph.
type ServerTaskMutation struct {
	config
	op                                    Op
	typ                                   string
	id                                    *uuid.UUID
	_type                                 *servertask.Type
	start_time                            *time.Time
	end_time                              *time.Time
	errors                                *[]string
	appenderrors                          []string
	log_file_path                         *string
	clearedFields                         map[string]struct{}
	_ServerTaskToAuthUser                 *uuid.UUID
	cleared_ServerTaskToAuthUser          bool
	_ServerTaskToStatus                   *uuid.UUID
	cleared_ServerTaskToStatus            bool
	_ServerTaskToEnvironment              *uuid.UUID
	cleared_ServerTaskToEnvironment       bool
	_ServerTaskToBuild                    *uuid.UUID
	cleared_ServerTaskToBuild             bool
	_ServerTaskToBuildCommit              *uuid.UUID
	cleared_ServerTaskToBuildCommit       bool
	_ServerTaskToGinFileMiddleware        map[uuid.UUID]struct{}
	removed_ServerTaskToGinFileMiddleware map[uuid.UUID]struct{}
	cleared_ServerTaskToGinFileMiddleware bool
	done                                  bool
	oldValue                              func(context.Context) (*ServerTask, error)
	predicates                            []predicate.ServerTask
}

var _ ent.Mutation = (*ServerTaskMutation)(nil)

// servertaskOption allows management of the mutation configuration using functional options.
type servertaskOption func(*ServerTaskMutation)

// newServerTaskMutation creates new mutation for the ServerTask entity.
func newServerTaskMutation(c config, op Op, opts ...servertaskOption) *ServerTaskMutation {
	m := &ServerTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeServerTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerTaskID sets the ID field of the mutation.
func withServerTaskID(id uuid.UUID) servertaskOption {
	return func(m *ServerTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *ServerTask
		)
		m.oldValue = func(ctx context.Context) (*ServerTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServerTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServerTask sets the old ServerTask of the mutation.
func withServerTask(node *ServerTask) servertaskOption {
	return func(m *ServerTaskMutation) {
		m.oldValue = func(context.Context) (*ServerTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServerTask entities.
func (m *ServerTaskMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerTaskMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerTaskMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServerTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *ServerTaskMutation) SetType(s servertask.Type) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ServerTaskMutation) GetType() (r servertask.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ServerTask entity.
// If the ServerTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerTaskMutation) OldType(ctx context.Context) (v servertask.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ServerTaskMutation) ResetType() {
	m._type = nil
}

// SetStartTime sets the "start_time" field.
func (m *ServerTaskMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ServerTaskMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the ServerTask entity.
// If the ServerTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerTaskMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *ServerTaskMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[servertask.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *ServerTaskMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[servertask.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ServerTaskMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, servertask.FieldStartTime)
}

// SetEndTime sets the "end_time" field.
func (m *ServerTaskMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *ServerTaskMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the ServerTask entity.
// If the ServerTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerTaskMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *ServerTaskMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[servertask.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *ServerTaskMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[servertask.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *ServerTaskMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, servertask.FieldEndTime)
}

// SetErrors sets the "errors" field.
func (m *ServerTaskMutation) SetErrors(s []string) {
	m.errors = &s
	m.appenderrors = nil
}

// Errors returns the value of the "errors" field in the mutation.
func (m *ServerTaskMutation) Errors() (r []string, exists bool) {
	v := m.errors
	if v == nil {
		return
	}
	return *v, true
}

// OldErrors returns the old "errors" field's value of the ServerTask entity.
// If the ServerTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerTaskMutation) OldErrors(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrors: %w", err)
	}
	return oldValue.Errors, nil
}

// AppendErrors adds s to the "errors" field.
func (m *ServerTaskMutation) AppendErrors(s []string) {
	m.appenderrors = append(m.appenderrors, s...)
}

// AppendedErrors returns the list of values that were appended to the "errors" field in this mutation.
func (m *ServerTaskMutation) AppendedErrors() ([]string, bool) {
	if len(m.appenderrors) == 0 {
		return nil, false
	}
	return m.appenderrors, true
}

// ClearErrors clears the value of the "errors" field.
func (m *ServerTaskMutation) ClearErrors() {
	m.errors = nil
	m.appenderrors = nil
	m.clearedFields[servertask.FieldErrors] = struct{}{}
}

// ErrorsCleared returns if the "errors" field was cleared in this mutation.
func (m *ServerTaskMutation) ErrorsCleared() bool {
	_, ok := m.clearedFields[servertask.FieldErrors]
	return ok
}

// ResetErrors resets all changes to the "errors" field.
func (m *ServerTaskMutation) ResetErrors() {
	m.errors = nil
	m.appenderrors = nil
	delete(m.clearedFields, servertask.FieldErrors)
}

// SetLogFilePath sets the "log_file_path" field.
func (m *ServerTaskMutation) SetLogFilePath(s string) {
	m.log_file_path = &s
}

// LogFilePath returns the value of the "log_file_path" field in the mutation.
func (m *ServerTaskMutation) LogFilePath() (r string, exists bool) {
	v := m.log_file_path
	if v == nil {
		return
	}
	return *v, true
}

// OldLogFilePath returns the old "log_file_path" field's value of the ServerTask entity.
// If the ServerTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerTaskMutation) OldLogFilePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogFilePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogFilePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogFilePath: %w", err)
	}
	return oldValue.LogFilePath, nil
}

// ClearLogFilePath clears the value of the "log_file_path" field.
func (m *ServerTaskMutation) ClearLogFilePath() {
	m.log_file_path = nil
	m.clearedFields[servertask.FieldLogFilePath] = struct{}{}
}

// LogFilePathCleared returns if the "log_file_path" field was cleared in this mutation.
func (m *ServerTaskMutation) LogFilePathCleared() bool {
	_, ok := m.clearedFields[servertask.FieldLogFilePath]
	return ok
}

// ResetLogFilePath resets all changes to the "log_file_path" field.
func (m *ServerTaskMutation) ResetLogFilePath() {
	m.log_file_path = nil
	delete(m.clearedFields, servertask.FieldLogFilePath)
}

// SetServerTaskToAuthUserID sets the "ServerTaskToAuthUser" edge to the AuthUser entity by id.
func (m *ServerTaskMutation) SetServerTaskToAuthUserID(id uuid.UUID) {
	m._ServerTaskToAuthUser = &id
}

// ClearServerTaskToAuthUser clears the "ServerTaskToAuthUser" edge to the AuthUser entity.
func (m *ServerTaskMutation) ClearServerTaskToAuthUser() {
	m.cleared_ServerTaskToAuthUser = true
}

// ServerTaskToAuthUserCleared reports if the "ServerTaskToAuthUser" edge to the AuthUser entity was cleared.
func (m *ServerTaskMutation) ServerTaskToAuthUserCleared() bool {
	return m.cleared_ServerTaskToAuthUser
}

// ServerTaskToAuthUserID returns the "ServerTaskToAuthUser" edge ID in the mutation.
func (m *ServerTaskMutation) ServerTaskToAuthUserID() (id uuid.UUID, exists bool) {
	if m._ServerTaskToAuthUser != nil {
		return *m._ServerTaskToAuthUser, true
	}
	return
}

// ServerTaskToAuthUserIDs returns the "ServerTaskToAuthUser" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerTaskToAuthUserID instead. It exists only for internal usage by the builders.
func (m *ServerTaskMutation) ServerTaskToAuthUserIDs() (ids []uuid.UUID) {
	if id := m._ServerTaskToAuthUser; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServerTaskToAuthUser resets all changes to the "ServerTaskToAuthUser" edge.
func (m *ServerTaskMutation) ResetServerTaskToAuthUser() {
	m._ServerTaskToAuthUser = nil
	m.cleared_ServerTaskToAuthUser = false
}

// SetServerTaskToStatusID sets the "ServerTaskToStatus" edge to the Status entity by id.
func (m *ServerTaskMutation) SetServerTaskToStatusID(id uuid.UUID) {
	m._ServerTaskToStatus = &id
}

// ClearServerTaskToStatus clears the "ServerTaskToStatus" edge to the Status entity.
func (m *ServerTaskMutation) ClearServerTaskToStatus() {
	m.cleared_ServerTaskToStatus = true
}

// ServerTaskToStatusCleared reports if the "ServerTaskToStatus" edge to the Status entity was cleared.
func (m *ServerTaskMutation) ServerTaskToStatusCleared() bool {
	return m.cleared_ServerTaskToStatus
}

// ServerTaskToStatusID returns the "ServerTaskToStatus" edge ID in the mutation.
func (m *ServerTaskMutation) ServerTaskToStatusID() (id uuid.UUID, exists bool) {
	if m._ServerTaskToStatus != nil {
		return *m._ServerTaskToStatus, true
	}
	return
}

// ServerTaskToStatusIDs returns the "ServerTaskToStatus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerTaskToStatusID instead. It exists only for internal usage by the builders.
func (m *ServerTaskMutation) ServerTaskToStatusIDs() (ids []uuid.UUID) {
	if id := m._ServerTaskToStatus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServerTaskToStatus resets all changes to the "ServerTaskToStatus" edge.
func (m *ServerTaskMutation) ResetServerTaskToStatus() {
	m._ServerTaskToStatus = nil
	m.cleared_ServerTaskToStatus = false
}

// SetServerTaskToEnvironmentID sets the "ServerTaskToEnvironment" edge to the Environment entity by id.
func (m *ServerTaskMutation) SetServerTaskToEnvironmentID(id uuid.UUID) {
	m._ServerTaskToEnvironment = &id
}

// ClearServerTaskToEnvironment clears the "ServerTaskToEnvironment" edge to the Environment entity.
func (m *ServerTaskMutation) ClearServerTaskToEnvironment() {
	m.cleared_ServerTaskToEnvironment = true
}

// ServerTaskToEnvironmentCleared reports if the "ServerTaskToEnvironment" edge to the Environment entity was cleared.
func (m *ServerTaskMutation) ServerTaskToEnvironmentCleared() bool {
	return m.cleared_ServerTaskToEnvironment
}

// ServerTaskToEnvironmentID returns the "ServerTaskToEnvironment" edge ID in the mutation.
func (m *ServerTaskMutation) ServerTaskToEnvironmentID() (id uuid.UUID, exists bool) {
	if m._ServerTaskToEnvironment != nil {
		return *m._ServerTaskToEnvironment, true
	}
	return
}

// ServerTaskToEnvironmentIDs returns the "ServerTaskToEnvironment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerTaskToEnvironmentID instead. It exists only for internal usage by the builders.
func (m *ServerTaskMutation) ServerTaskToEnvironmentIDs() (ids []uuid.UUID) {
	if id := m._ServerTaskToEnvironment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServerTaskToEnvironment resets all changes to the "ServerTaskToEnvironment" edge.
func (m *ServerTaskMutation) ResetServerTaskToEnvironment() {
	m._ServerTaskToEnvironment = nil
	m.cleared_ServerTaskToEnvironment = false
}

// SetServerTaskToBuildID sets the "ServerTaskToBuild" edge to the Build entity by id.
func (m *ServerTaskMutation) SetServerTaskToBuildID(id uuid.UUID) {
	m._ServerTaskToBuild = &id
}

// ClearServerTaskToBuild clears the "ServerTaskToBuild" edge to the Build entity.
func (m *ServerTaskMutation) ClearServerTaskToBuild() {
	m.cleared_ServerTaskToBuild = true
}

// ServerTaskToBuildCleared reports if the "ServerTaskToBuild" edge to the Build entity was cleared.
func (m *ServerTaskMutation) ServerTaskToBuildCleared() bool {
	return m.cleared_ServerTaskToBuild
}

// ServerTaskToBuildID returns the "ServerTaskToBuild" edge ID in the mutation.
func (m *ServerTaskMutation) ServerTaskToBuildID() (id uuid.UUID, exists bool) {
	if m._ServerTaskToBuild != nil {
		return *m._ServerTaskToBuild, true
	}
	return
}

// ServerTaskToBuildIDs returns the "ServerTaskToBuild" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerTaskToBuildID instead. It exists only for internal usage by the builders.
func (m *ServerTaskMutation) ServerTaskToBuildIDs() (ids []uuid.UUID) {
	if id := m._ServerTaskToBuild; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServerTaskToBuild resets all changes to the "ServerTaskToBuild" edge.
func (m *ServerTaskMutation) ResetServerTaskToBuild() {
	m._ServerTaskToBuild = nil
	m.cleared_ServerTaskToBuild = false
}

// SetServerTaskToBuildCommitID sets the "ServerTaskToBuildCommit" edge to the BuildCommit entity by id.
func (m *ServerTaskMutation) SetServerTaskToBuildCommitID(id uuid.UUID) {
	m._ServerTaskToBuildCommit = &id
}

// ClearServerTaskToBuildCommit clears the "ServerTaskToBuildCommit" edge to the BuildCommit entity.
func (m *ServerTaskMutation) ClearServerTaskToBuildCommit() {
	m.cleared_ServerTaskToBuildCommit = true
}

// ServerTaskToBuildCommitCleared reports if the "ServerTaskToBuildCommit" edge to the BuildCommit entity was cleared.
func (m *ServerTaskMutation) ServerTaskToBuildCommitCleared() bool {
	return m.cleared_ServerTaskToBuildCommit
}

// ServerTaskToBuildCommitID returns the "ServerTaskToBuildCommit" edge ID in the mutation.
func (m *ServerTaskMutation) ServerTaskToBuildCommitID() (id uuid.UUID, exists bool) {
	if m._ServerTaskToBuildCommit != nil {
		return *m._ServerTaskToBuildCommit, true
	}
	return
}

// ServerTaskToBuildCommitIDs returns the "ServerTaskToBuildCommit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServerTaskToBuildCommitID instead. It exists only for internal usage by the builders.
func (m *ServerTaskMutation) ServerTaskToBuildCommitIDs() (ids []uuid.UUID) {
	if id := m._ServerTaskToBuildCommit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServerTaskToBuildCommit resets all changes to the "ServerTaskToBuildCommit" edge.
func (m *ServerTaskMutation) ResetServerTaskToBuildCommit() {
	m._ServerTaskToBuildCommit = nil
	m.cleared_ServerTaskToBuildCommit = false
}

// AddServerTaskToGinFileMiddlewareIDs adds the "ServerTaskToGinFileMiddleware" edge to the GinFileMiddleware entity by ids.
func (m *ServerTaskMutation) AddServerTaskToGinFileMiddlewareIDs(ids ...uuid.UUID) {
	if m._ServerTaskToGinFileMiddleware == nil {
		m._ServerTaskToGinFileMiddleware = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ServerTaskToGinFileMiddleware[ids[i]] = struct{}{}
	}
}

// ClearServerTaskToGinFileMiddleware clears the "ServerTaskToGinFileMiddleware" edge to the GinFileMiddleware entity.
func (m *ServerTaskMutation) ClearServerTaskToGinFileMiddleware() {
	m.cleared_ServerTaskToGinFileMiddleware = true
}

// ServerTaskToGinFileMiddlewareCleared reports if the "ServerTaskToGinFileMiddleware" edge to the GinFileMiddleware entity was cleared.
func (m *ServerTaskMutation) ServerTaskToGinFileMiddlewareCleared() bool {
	return m.cleared_ServerTaskToGinFileMiddleware
}

// RemoveServerTaskToGinFileMiddlewareIDs removes the "ServerTaskToGinFileMiddleware" edge to the GinFileMiddleware entity by IDs.
func (m *ServerTaskMutation) RemoveServerTaskToGinFileMiddlewareIDs(ids ...uuid.UUID) {
	if m.removed_ServerTaskToGinFileMiddleware == nil {
		m.removed_ServerTaskToGinFileMiddleware = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._ServerTaskToGinFileMiddleware, ids[i])
		m.removed_ServerTaskToGinFileMiddleware[ids[i]] = struct{}{}
	}
}

// RemovedServerTaskToGinFileMiddleware returns the removed IDs of the "ServerTaskToGinFileMiddleware" edge to the GinFileMiddleware entity.
func (m *ServerTaskMutation) RemovedServerTaskToGinFileMiddlewareIDs() (ids []uuid.UUID) {
	for id := range m.removed_ServerTaskToGinFileMiddleware {
		ids = append(ids, id)
	}
	return
}

// ServerTaskToGinFileMiddlewareIDs returns the "ServerTaskToGinFileMiddleware" edge IDs in the mutation.
func (m *ServerTaskMutation) ServerTaskToGinFileMiddlewareIDs() (ids []uuid.UUID) {
	for id := range m._ServerTaskToGinFileMiddleware {
		ids = append(ids, id)
	}
	return
}

// ResetServerTaskToGinFileMiddleware resets all changes to the "ServerTaskToGinFileMiddleware" edge.
func (m *ServerTaskMutation) ResetServerTaskToGinFileMiddleware() {
	m._ServerTaskToGinFileMiddleware = nil
	m.cleared_ServerTaskToGinFileMiddleware = false
	m.removed_ServerTaskToGinFileMiddleware = nil
}

// Where appends a list predicates to the ServerTaskMutation builder.
func (m *ServerTaskMutation) Where(ps ...predicate.ServerTask) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerTaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerTaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServerTask, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerTaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerTaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServerTask).
func (m *ServerTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerTaskMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._type != nil {
		fields = append(fields, servertask.FieldType)
	}
	if m.start_time != nil {
		fields = append(fields, servertask.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, servertask.FieldEndTime)
	}
	if m.errors != nil {
		fields = append(fields, servertask.FieldErrors)
	}
	if m.log_file_path != nil {
		fields = append(fields, servertask.FieldLogFilePath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servertask.FieldType:
		return m.GetType()
	case servertask.FieldStartTime:
		return m.StartTime()
	case servertask.FieldEndTime:
		return m.EndTime()
	case servertask.FieldErrors:
		return m.Errors()
	case servertask.FieldLogFilePath:
		return m.LogFilePath()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servertask.FieldType:
		return m.OldType(ctx)
	case servertask.FieldStartTime:
		return m.OldStartTime(ctx)
	case servertask.FieldEndTime:
		return m.OldEndTime(ctx)
	case servertask.FieldErrors:
		return m.OldErrors(ctx)
	case servertask.FieldLogFilePath:
		return m.OldLogFilePath(ctx)
	}
	return nil, fmt.Errorf("unknown ServerTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servertask.FieldType:
		v, ok := value.(servertask.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case servertask.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case servertask.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case servertask.FieldErrors:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrors(v)
		return nil
	case servertask.FieldLogFilePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogFilePath(v)
		return nil
	}
	return fmt.Errorf("unknown ServerTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerTaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerTaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServerTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerTaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(servertask.FieldStartTime) {
		fields = append(fields, servertask.FieldStartTime)
	}
	if m.FieldCleared(servertask.FieldEndTime) {
		fields = append(fields, servertask.FieldEndTime)
	}
	if m.FieldCleared(servertask.FieldErrors) {
		fields = append(fields, servertask.FieldErrors)
	}
	if m.FieldCleared(servertask.FieldLogFilePath) {
		fields = append(fields, servertask.FieldLogFilePath)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerTaskMutation) ClearField(name string) error {
	switch name {
	case servertask.FieldStartTime:
		m.ClearStartTime()
		return nil
	case servertask.FieldEndTime:
		m.ClearEndTime()
		return nil
	case servertask.FieldErrors:
		m.ClearErrors()
		return nil
	case servertask.FieldLogFilePath:
		m.ClearLogFilePath()
		return nil
	}
	return fmt.Errorf("unknown ServerTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerTaskMutation) ResetField(name string) error {
	switch name {
	case servertask.FieldType:
		m.ResetType()
		return nil
	case servertask.FieldStartTime:
		m.ResetStartTime()
		return nil
	case servertask.FieldEndTime:
		m.ResetEndTime()
		return nil
	case servertask.FieldErrors:
		m.ResetErrors()
		return nil
	case servertask.FieldLogFilePath:
		m.ResetLogFilePath()
		return nil
	}
	return fmt.Errorf("unknown ServerTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m._ServerTaskToAuthUser != nil {
		edges = append(edges, servertask.EdgeServerTaskToAuthUser)
	}
	if m._ServerTaskToStatus != nil {
		edges = append(edges, servertask.EdgeServerTaskToStatus)
	}
	if m._ServerTaskToEnvironment != nil {
		edges = append(edges, servertask.EdgeServerTaskToEnvironment)
	}
	if m._ServerTaskToBuild != nil {
		edges = append(edges, servertask.EdgeServerTaskToBuild)
	}
	if m._ServerTaskToBuildCommit != nil {
		edges = append(edges, servertask.EdgeServerTaskToBuildCommit)
	}
	if m._ServerTaskToGinFileMiddleware != nil {
		edges = append(edges, servertask.EdgeServerTaskToGinFileMiddleware)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerTaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servertask.EdgeServerTaskToAuthUser:
		if id := m._ServerTaskToAuthUser; id != nil {
			return []ent.Value{*id}
		}
	case servertask.EdgeServerTaskToStatus:
		if id := m._ServerTaskToStatus; id != nil {
			return []ent.Value{*id}
		}
	case servertask.EdgeServerTaskToEnvironment:
		if id := m._ServerTaskToEnvironment; id != nil {
			return []ent.Value{*id}
		}
	case servertask.EdgeServerTaskToBuild:
		if id := m._ServerTaskToBuild; id != nil {
			return []ent.Value{*id}
		}
	case servertask.EdgeServerTaskToBuildCommit:
		if id := m._ServerTaskToBuildCommit; id != nil {
			return []ent.Value{*id}
		}
	case servertask.EdgeServerTaskToGinFileMiddleware:
		ids := make([]ent.Value, 0, len(m._ServerTaskToGinFileMiddleware))
		for id := range m._ServerTaskToGinFileMiddleware {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removed_ServerTaskToGinFileMiddleware != nil {
		edges = append(edges, servertask.EdgeServerTaskToGinFileMiddleware)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerTaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case servertask.EdgeServerTaskToGinFileMiddleware:
		ids := make([]ent.Value, 0, len(m.removed_ServerTaskToGinFileMiddleware))
		for id := range m.removed_ServerTaskToGinFileMiddleware {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleared_ServerTaskToAuthUser {
		edges = append(edges, servertask.EdgeServerTaskToAuthUser)
	}
	if m.cleared_ServerTaskToStatus {
		edges = append(edges, servertask.EdgeServerTaskToStatus)
	}
	if m.cleared_ServerTaskToEnvironment {
		edges = append(edges, servertask.EdgeServerTaskToEnvironment)
	}
	if m.cleared_ServerTaskToBuild {
		edges = append(edges, servertask.EdgeServerTaskToBuild)
	}
	if m.cleared_ServerTaskToBuildCommit {
		edges = append(edges, servertask.EdgeServerTaskToBuildCommit)
	}
	if m.cleared_ServerTaskToGinFileMiddleware {
		edges = append(edges, servertask.EdgeServerTaskToGinFileMiddleware)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerTaskMutation) EdgeCleared(name string) bool {
	switch name {
	case servertask.EdgeServerTaskToAuthUser:
		return m.cleared_ServerTaskToAuthUser
	case servertask.EdgeServerTaskToStatus:
		return m.cleared_ServerTaskToStatus
	case servertask.EdgeServerTaskToEnvironment:
		return m.cleared_ServerTaskToEnvironment
	case servertask.EdgeServerTaskToBuild:
		return m.cleared_ServerTaskToBuild
	case servertask.EdgeServerTaskToBuildCommit:
		return m.cleared_ServerTaskToBuildCommit
	case servertask.EdgeServerTaskToGinFileMiddleware:
		return m.cleared_ServerTaskToGinFileMiddleware
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerTaskMutation) ClearEdge(name string) error {
	switch name {
	case servertask.EdgeServerTaskToAuthUser:
		m.ClearServerTaskToAuthUser()
		return nil
	case servertask.EdgeServerTaskToStatus:
		m.ClearServerTaskToStatus()
		return nil
	case servertask.EdgeServerTaskToEnvironment:
		m.ClearServerTaskToEnvironment()
		return nil
	case servertask.EdgeServerTaskToBuild:
		m.ClearServerTaskToBuild()
		return nil
	case servertask.EdgeServerTaskToBuildCommit:
		m.ClearServerTaskToBuildCommit()
		return nil
	}
	return fmt.Errorf("unknown ServerTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerTaskMutation) ResetEdge(name string) error {
	switch name {
	case servertask.EdgeServerTaskToAuthUser:
		m.ResetServerTaskToAuthUser()
		return nil
	case servertask.EdgeServerTaskToStatus:
		m.ResetServerTaskToStatus()
		return nil
	case servertask.EdgeServerTaskToEnvironment:
		m.ResetServerTaskToEnvironment()
		return nil
	case servertask.EdgeServerTaskToBuild:
		m.ResetServerTaskToBuild()
		return nil
	case servertask.EdgeServerTaskToBuildCommit:
		m.ResetServerTaskToBuildCommit()
		return nil
	case servertask.EdgeServerTaskToGinFileMiddleware:
		m.ResetServerTaskToGinFileMiddleware()
		return nil
	}
	return fmt.Errorf("unknown ServerTask edge %s", name)
}

// StatusMutation represents an operation that mutates the Status nodes in the graph.
type StatusMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *uuid.UUID
	state                              *status.State
	status_for                         *status.StatusFor
	started_at                         *time.Time
	ended_at                           *time.Time
	failed                             *bool
	completed                          *bool
	error                              *string
	clearedFields                      map[string]struct{}
	_StatusToBuild                     *uuid.UUID
	cleared_StatusToBuild              bool
	_StatusToProvisionedNetwork        *uuid.UUID
	cleared_StatusToProvisionedNetwork bool
	_StatusToProvisionedHost           *uuid.UUID
	cleared_StatusToProvisionedHost    bool
	_StatusToProvisioningStep          *uuid.UUID
	cleared_StatusToProvisioningStep   bool
	_StatusToTeam                      *uuid.UUID
	cleared_StatusToTeam               bool
	_StatusToPlan                      *uuid.UUID
	cleared_StatusToPlan               bool
	_StatusToServerTask                *uuid.UUID
	cleared_StatusToServerTask         bool
	_StatusToAdhocPlan                 *uuid.UUID
	cleared_StatusToAdhocPlan          bool
	done                               bool
	oldValue                           func(context.Context) (*Status, error)
	predicates                         []predicate.Status
}

var _ ent.Mutation = (*StatusMutation)(nil)

// statusOption allows management of the mutation configuration using functional options.
type statusOption func(*StatusMutation)

// newStatusMutation creates new mutation for the Status entity.
func newStatusMutation(c config, op Op, opts ...statusOption) *StatusMutation {
	m := &StatusMutation{
		config:        c,
		op:            op,
		typ:           TypeStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatusID sets the ID field of the mutation.
func withStatusID(id uuid.UUID) statusOption {
	return func(m *StatusMutation) {
		var (
			err   error
			once  sync.Once
			value *Status
		)
		m.oldValue = func(ctx context.Context) (*Status, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Status.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatus sets the old Status of the mutation.
func withStatus(node *Status) statusOption {
	return func(m *StatusMutation) {
		m.oldValue = func(context.Context) (*Status, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Status entities.
func (m *StatusMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StatusMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StatusMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Status.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetState sets the "state" field.
func (m *StatusMutation) SetState(s status.State) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *StatusMutation) State() (r status.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldState(ctx context.Context) (v status.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *StatusMutation) ResetState() {
	m.state = nil
}

// SetStatusFor sets the "status_for" field.
func (m *StatusMutation) SetStatusFor(sf status.StatusFor) {
	m.status_for = &sf
}

// StatusFor returns the value of the "status_for" field in the mutation.
func (m *StatusMutation) StatusFor() (r status.StatusFor, exists bool) {
	v := m.status_for
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusFor returns the old "status_for" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldStatusFor(ctx context.Context) (v status.StatusFor, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusFor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusFor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusFor: %w", err)
	}
	return oldValue.StatusFor, nil
}

// ResetStatusFor resets all changes to the "status_for" field.
func (m *StatusMutation) ResetStatusFor() {
	m.status_for = nil
}

// SetStartedAt sets the "started_at" field.
func (m *StatusMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *StatusMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *StatusMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[status.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *StatusMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[status.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *StatusMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, status.FieldStartedAt)
}

// SetEndedAt sets the "ended_at" field.
func (m *StatusMutation) SetEndedAt(t time.Time) {
	m.ended_at = &t
}

// EndedAt returns the value of the "ended_at" field in the mutation.
func (m *StatusMutation) EndedAt() (r time.Time, exists bool) {
	v := m.ended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old "ended_at" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldEndedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ClearEndedAt clears the value of the "ended_at" field.
func (m *StatusMutation) ClearEndedAt() {
	m.ended_at = nil
	m.clearedFields[status.FieldEndedAt] = struct{}{}
}

// EndedAtCleared returns if the "ended_at" field was cleared in this mutation.
func (m *StatusMutation) EndedAtCleared() bool {
	_, ok := m.clearedFields[status.FieldEndedAt]
	return ok
}

// ResetEndedAt resets all changes to the "ended_at" field.
func (m *StatusMutation) ResetEndedAt() {
	m.ended_at = nil
	delete(m.clearedFields, status.FieldEndedAt)
}

// SetFailed sets the "failed" field.
func (m *StatusMutation) SetFailed(b bool) {
	m.failed = &b
}

// Failed returns the value of the "failed" field in the mutation.
func (m *StatusMutation) Failed() (r bool, exists bool) {
	v := m.failed
	if v == nil {
		return
	}
	return *v, true
}

// OldFailed returns the old "failed" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldFailed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailed: %w", err)
	}
	return oldValue.Failed, nil
}

// ResetFailed resets all changes to the "failed" field.
func (m *StatusMutation) ResetFailed() {
	m.failed = nil
}

// SetCompleted sets the "completed" field.
func (m *StatusMutation) SetCompleted(b bool) {
	m.completed = &b
}

// Completed returns the value of the "completed" field in the mutation.
func (m *StatusMutation) Completed() (r bool, exists bool) {
	v := m.completed
	if v == nil {
		return
	}
	return *v, true
}

// OldCompleted returns the old "completed" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldCompleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompleted: %w", err)
	}
	return oldValue.Completed, nil
}

// ResetCompleted resets all changes to the "completed" field.
func (m *StatusMutation) ResetCompleted() {
	m.completed = nil
}

// SetError sets the "error" field.
func (m *StatusMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *StatusMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *StatusMutation) ClearError() {
	m.error = nil
	m.clearedFields[status.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *StatusMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[status.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *StatusMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, status.FieldError)
}

// SetStatusToBuildID sets the "StatusToBuild" edge to the Build entity by id.
func (m *StatusMutation) SetStatusToBuildID(id uuid.UUID) {
	m._StatusToBuild = &id
}

// ClearStatusToBuild clears the "StatusToBuild" edge to the Build entity.
func (m *StatusMutation) ClearStatusToBuild() {
	m.cleared_StatusToBuild = true
}

// StatusToBuildCleared reports if the "StatusToBuild" edge to the Build entity was cleared.
func (m *StatusMutation) StatusToBuildCleared() bool {
	return m.cleared_StatusToBuild
}

// StatusToBuildID returns the "StatusToBuild" edge ID in the mutation.
func (m *StatusMutation) StatusToBuildID() (id uuid.UUID, exists bool) {
	if m._StatusToBuild != nil {
		return *m._StatusToBuild, true
	}
	return
}

// StatusToBuildIDs returns the "StatusToBuild" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusToBuildID instead. It exists only for internal usage by the builders.
func (m *StatusMutation) StatusToBuildIDs() (ids []uuid.UUID) {
	if id := m._StatusToBuild; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatusToBuild resets all changes to the "StatusToBuild" edge.
func (m *StatusMutation) ResetStatusToBuild() {
	m._StatusToBuild = nil
	m.cleared_StatusToBuild = false
}

// SetStatusToProvisionedNetworkID sets the "StatusToProvisionedNetwork" edge to the ProvisionedNetwork entity by id.
func (m *StatusMutation) SetStatusToProvisionedNetworkID(id uuid.UUID) {
	m._StatusToProvisionedNetwork = &id
}

// ClearStatusToProvisionedNetwork clears the "StatusToProvisionedNetwork" edge to the ProvisionedNetwork entity.
func (m *StatusMutation) ClearStatusToProvisionedNetwork() {
	m.cleared_StatusToProvisionedNetwork = true
}

// StatusToProvisionedNetworkCleared reports if the "StatusToProvisionedNetwork" edge to the ProvisionedNetwork entity was cleared.
func (m *StatusMutation) StatusToProvisionedNetworkCleared() bool {
	return m.cleared_StatusToProvisionedNetwork
}

// StatusToProvisionedNetworkID returns the "StatusToProvisionedNetwork" edge ID in the mutation.
func (m *StatusMutation) StatusToProvisionedNetworkID() (id uuid.UUID, exists bool) {
	if m._StatusToProvisionedNetwork != nil {
		return *m._StatusToProvisionedNetwork, true
	}
	return
}

// StatusToProvisionedNetworkIDs returns the "StatusToProvisionedNetwork" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusToProvisionedNetworkID instead. It exists only for internal usage by the builders.
func (m *StatusMutation) StatusToProvisionedNetworkIDs() (ids []uuid.UUID) {
	if id := m._StatusToProvisionedNetwork; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatusToProvisionedNetwork resets all changes to the "StatusToProvisionedNetwork" edge.
func (m *StatusMutation) ResetStatusToProvisionedNetwork() {
	m._StatusToProvisionedNetwork = nil
	m.cleared_StatusToProvisionedNetwork = false
}

// SetStatusToProvisionedHostID sets the "StatusToProvisionedHost" edge to the ProvisionedHost entity by id.
func (m *StatusMutation) SetStatusToProvisionedHostID(id uuid.UUID) {
	m._StatusToProvisionedHost = &id
}

// ClearStatusToProvisionedHost clears the "StatusToProvisionedHost" edge to the ProvisionedHost entity.
func (m *StatusMutation) ClearStatusToProvisionedHost() {
	m.cleared_StatusToProvisionedHost = true
}

// StatusToProvisionedHostCleared reports if the "StatusToProvisionedHost" edge to the ProvisionedHost entity was cleared.
func (m *StatusMutation) StatusToProvisionedHostCleared() bool {
	return m.cleared_StatusToProvisionedHost
}

// StatusToProvisionedHostID returns the "StatusToProvisionedHost" edge ID in the mutation.
func (m *StatusMutation) StatusToProvisionedHostID() (id uuid.UUID, exists bool) {
	if m._StatusToProvisionedHost != nil {
		return *m._StatusToProvisionedHost, true
	}
	return
}

// StatusToProvisionedHostIDs returns the "StatusToProvisionedHost" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusToProvisionedHostID instead. It exists only for internal usage by the builders.
func (m *StatusMutation) StatusToProvisionedHostIDs() (ids []uuid.UUID) {
	if id := m._StatusToProvisionedHost; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatusToProvisionedHost resets all changes to the "StatusToProvisionedHost" edge.
func (m *StatusMutation) ResetStatusToProvisionedHost() {
	m._StatusToProvisionedHost = nil
	m.cleared_StatusToProvisionedHost = false
}

// SetStatusToProvisioningStepID sets the "StatusToProvisioningStep" edge to the ProvisioningStep entity by id.
func (m *StatusMutation) SetStatusToProvisioningStepID(id uuid.UUID) {
	m._StatusToProvisioningStep = &id
}

// ClearStatusToProvisioningStep clears the "StatusToProvisioningStep" edge to the ProvisioningStep entity.
func (m *StatusMutation) ClearStatusToProvisioningStep() {
	m.cleared_StatusToProvisioningStep = true
}

// StatusToProvisioningStepCleared reports if the "StatusToProvisioningStep" edge to the ProvisioningStep entity was cleared.
func (m *StatusMutation) StatusToProvisioningStepCleared() bool {
	return m.cleared_StatusToProvisioningStep
}

// StatusToProvisioningStepID returns the "StatusToProvisioningStep" edge ID in the mutation.
func (m *StatusMutation) StatusToProvisioningStepID() (id uuid.UUID, exists bool) {
	if m._StatusToProvisioningStep != nil {
		return *m._StatusToProvisioningStep, true
	}
	return
}

// StatusToProvisioningStepIDs returns the "StatusToProvisioningStep" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusToProvisioningStepID instead. It exists only for internal usage by the builders.
func (m *StatusMutation) StatusToProvisioningStepIDs() (ids []uuid.UUID) {
	if id := m._StatusToProvisioningStep; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatusToProvisioningStep resets all changes to the "StatusToProvisioningStep" edge.
func (m *StatusMutation) ResetStatusToProvisioningStep() {
	m._StatusToProvisioningStep = nil
	m.cleared_StatusToProvisioningStep = false
}

// SetStatusToTeamID sets the "StatusToTeam" edge to the Team entity by id.
func (m *StatusMutation) SetStatusToTeamID(id uuid.UUID) {
	m._StatusToTeam = &id
}

// ClearStatusToTeam clears the "StatusToTeam" edge to the Team entity.
func (m *StatusMutation) ClearStatusToTeam() {
	m.cleared_StatusToTeam = true
}

// StatusToTeamCleared reports if the "StatusToTeam" edge to the Team entity was cleared.
func (m *StatusMutation) StatusToTeamCleared() bool {
	return m.cleared_StatusToTeam
}

// StatusToTeamID returns the "StatusToTeam" edge ID in the mutation.
func (m *StatusMutation) StatusToTeamID() (id uuid.UUID, exists bool) {
	if m._StatusToTeam != nil {
		return *m._StatusToTeam, true
	}
	return
}

// StatusToTeamIDs returns the "StatusToTeam" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusToTeamID instead. It exists only for internal usage by the builders.
func (m *StatusMutation) StatusToTeamIDs() (ids []uuid.UUID) {
	if id := m._StatusToTeam; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatusToTeam resets all changes to the "StatusToTeam" edge.
func (m *StatusMutation) ResetStatusToTeam() {
	m._StatusToTeam = nil
	m.cleared_StatusToTeam = false
}

// SetStatusToPlanID sets the "StatusToPlan" edge to the Plan entity by id.
func (m *StatusMutation) SetStatusToPlanID(id uuid.UUID) {
	m._StatusToPlan = &id
}

// ClearStatusToPlan clears the "StatusToPlan" edge to the Plan entity.
func (m *StatusMutation) ClearStatusToPlan() {
	m.cleared_StatusToPlan = true
}

// StatusToPlanCleared reports if the "StatusToPlan" edge to the Plan entity was cleared.
func (m *StatusMutation) StatusToPlanCleared() bool {
	return m.cleared_StatusToPlan
}

// StatusToPlanID returns the "StatusToPlan" edge ID in the mutation.
func (m *StatusMutation) StatusToPlanID() (id uuid.UUID, exists bool) {
	if m._StatusToPlan != nil {
		return *m._StatusToPlan, true
	}
	return
}

// StatusToPlanIDs returns the "StatusToPlan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusToPlanID instead. It exists only for internal usage by the builders.
func (m *StatusMutation) StatusToPlanIDs() (ids []uuid.UUID) {
	if id := m._StatusToPlan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatusToPlan resets all changes to the "StatusToPlan" edge.
func (m *StatusMutation) ResetStatusToPlan() {
	m._StatusToPlan = nil
	m.cleared_StatusToPlan = false
}

// SetStatusToServerTaskID sets the "StatusToServerTask" edge to the ServerTask entity by id.
func (m *StatusMutation) SetStatusToServerTaskID(id uuid.UUID) {
	m._StatusToServerTask = &id
}

// ClearStatusToServerTask clears the "StatusToServerTask" edge to the ServerTask entity.
func (m *StatusMutation) ClearStatusToServerTask() {
	m.cleared_StatusToServerTask = true
}

// StatusToServerTaskCleared reports if the "StatusToServerTask" edge to the ServerTask entity was cleared.
func (m *StatusMutation) StatusToServerTaskCleared() bool {
	return m.cleared_StatusToServerTask
}

// StatusToServerTaskID returns the "StatusToServerTask" edge ID in the mutation.
func (m *StatusMutation) StatusToServerTaskID() (id uuid.UUID, exists bool) {
	if m._StatusToServerTask != nil {
		return *m._StatusToServerTask, true
	}
	return
}

// StatusToServerTaskIDs returns the "StatusToServerTask" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusToServerTaskID instead. It exists only for internal usage by the builders.
func (m *StatusMutation) StatusToServerTaskIDs() (ids []uuid.UUID) {
	if id := m._StatusToServerTask; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatusToServerTask resets all changes to the "StatusToServerTask" edge.
func (m *StatusMutation) ResetStatusToServerTask() {
	m._StatusToServerTask = nil
	m.cleared_StatusToServerTask = false
}

// SetStatusToAdhocPlanID sets the "StatusToAdhocPlan" edge to the AdhocPlan entity by id.
func (m *StatusMutation) SetStatusToAdhocPlanID(id uuid.UUID) {
	m._StatusToAdhocPlan = &id
}

// ClearStatusToAdhocPlan clears the "StatusToAdhocPlan" edge to the AdhocPlan entity.
func (m *StatusMutation) ClearStatusToAdhocPlan() {
	m.cleared_StatusToAdhocPlan = true
}

// StatusToAdhocPlanCleared reports if the "StatusToAdhocPlan" edge to the AdhocPlan entity was cleared.
func (m *StatusMutation) StatusToAdhocPlanCleared() bool {
	return m.cleared_StatusToAdhocPlan
}

// StatusToAdhocPlanID returns the "StatusToAdhocPlan" edge ID in the mutation.
func (m *StatusMutation) StatusToAdhocPlanID() (id uuid.UUID, exists bool) {
	if m._StatusToAdhocPlan != nil {
		return *m._StatusToAdhocPlan, true
	}
	return
}

// StatusToAdhocPlanIDs returns the "StatusToAdhocPlan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatusToAdhocPlanID instead. It exists only for internal usage by the builders.
func (m *StatusMutation) StatusToAdhocPlanIDs() (ids []uuid.UUID) {
	if id := m._StatusToAdhocPlan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatusToAdhocPlan resets all changes to the "StatusToAdhocPlan" edge.
func (m *StatusMutation) ResetStatusToAdhocPlan() {
	m._StatusToAdhocPlan = nil
	m.cleared_StatusToAdhocPlan = false
}

// Where appends a list predicates to the StatusMutation builder.
func (m *StatusMutation) Where(ps ...predicate.Status) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StatusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StatusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Status, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StatusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StatusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Status).
func (m *StatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatusMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.state != nil {
		fields = append(fields, status.FieldState)
	}
	if m.status_for != nil {
		fields = append(fields, status.FieldStatusFor)
	}
	if m.started_at != nil {
		fields = append(fields, status.FieldStartedAt)
	}
	if m.ended_at != nil {
		fields = append(fields, status.FieldEndedAt)
	}
	if m.failed != nil {
		fields = append(fields, status.FieldFailed)
	}
	if m.completed != nil {
		fields = append(fields, status.FieldCompleted)
	}
	if m.error != nil {
		fields = append(fields, status.FieldError)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case status.FieldState:
		return m.State()
	case status.FieldStatusFor:
		return m.StatusFor()
	case status.FieldStartedAt:
		return m.StartedAt()
	case status.FieldEndedAt:
		return m.EndedAt()
	case status.FieldFailed:
		return m.Failed()
	case status.FieldCompleted:
		return m.Completed()
	case status.FieldError:
		return m.Error()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case status.FieldState:
		return m.OldState(ctx)
	case status.FieldStatusFor:
		return m.OldStatusFor(ctx)
	case status.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case status.FieldEndedAt:
		return m.OldEndedAt(ctx)
	case status.FieldFailed:
		return m.OldFailed(ctx)
	case status.FieldCompleted:
		return m.OldCompleted(ctx)
	case status.FieldError:
		return m.OldError(ctx)
	}
	return nil, fmt.Errorf("unknown Status field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case status.FieldState:
		v, ok := value.(status.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case status.FieldStatusFor:
		v, ok := value.(status.StatusFor)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusFor(v)
		return nil
	case status.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case status.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	case status.FieldFailed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailed(v)
		return nil
	case status.FieldCompleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompleted(v)
		return nil
	case status.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	}
	return fmt.Errorf("unknown Status field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Status numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatusMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(status.FieldStartedAt) {
		fields = append(fields, status.FieldStartedAt)
	}
	if m.FieldCleared(status.FieldEndedAt) {
		fields = append(fields, status.FieldEndedAt)
	}
	if m.FieldCleared(status.FieldError) {
		fields = append(fields, status.FieldError)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatusMutation) ClearField(name string) error {
	switch name {
	case status.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case status.FieldEndedAt:
		m.ClearEndedAt()
		return nil
	case status.FieldError:
		m.ClearError()
		return nil
	}
	return fmt.Errorf("unknown Status nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatusMutation) ResetField(name string) error {
	switch name {
	case status.FieldState:
		m.ResetState()
		return nil
	case status.FieldStatusFor:
		m.ResetStatusFor()
		return nil
	case status.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case status.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	case status.FieldFailed:
		m.ResetFailed()
		return nil
	case status.FieldCompleted:
		m.ResetCompleted()
		return nil
	case status.FieldError:
		m.ResetError()
		return nil
	}
	return fmt.Errorf("unknown Status field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m._StatusToBuild != nil {
		edges = append(edges, status.EdgeStatusToBuild)
	}
	if m._StatusToProvisionedNetwork != nil {
		edges = append(edges, status.EdgeStatusToProvisionedNetwork)
	}
	if m._StatusToProvisionedHost != nil {
		edges = append(edges, status.EdgeStatusToProvisionedHost)
	}
	if m._StatusToProvisioningStep != nil {
		edges = append(edges, status.EdgeStatusToProvisioningStep)
	}
	if m._StatusToTeam != nil {
		edges = append(edges, status.EdgeStatusToTeam)
	}
	if m._StatusToPlan != nil {
		edges = append(edges, status.EdgeStatusToPlan)
	}
	if m._StatusToServerTask != nil {
		edges = append(edges, status.EdgeStatusToServerTask)
	}
	if m._StatusToAdhocPlan != nil {
		edges = append(edges, status.EdgeStatusToAdhocPlan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case status.EdgeStatusToBuild:
		if id := m._StatusToBuild; id != nil {
			return []ent.Value{*id}
		}
	case status.EdgeStatusToProvisionedNetwork:
		if id := m._StatusToProvisionedNetwork; id != nil {
			return []ent.Value{*id}
		}
	case status.EdgeStatusToProvisionedHost:
		if id := m._StatusToProvisionedHost; id != nil {
			return []ent.Value{*id}
		}
	case status.EdgeStatusToProvisioningStep:
		if id := m._StatusToProvisioningStep; id != nil {
			return []ent.Value{*id}
		}
	case status.EdgeStatusToTeam:
		if id := m._StatusToTeam; id != nil {
			return []ent.Value{*id}
		}
	case status.EdgeStatusToPlan:
		if id := m._StatusToPlan; id != nil {
			return []ent.Value{*id}
		}
	case status.EdgeStatusToServerTask:
		if id := m._StatusToServerTask; id != nil {
			return []ent.Value{*id}
		}
	case status.EdgeStatusToAdhocPlan:
		if id := m._StatusToAdhocPlan; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatusMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.cleared_StatusToBuild {
		edges = append(edges, status.EdgeStatusToBuild)
	}
	if m.cleared_StatusToProvisionedNetwork {
		edges = append(edges, status.EdgeStatusToProvisionedNetwork)
	}
	if m.cleared_StatusToProvisionedHost {
		edges = append(edges, status.EdgeStatusToProvisionedHost)
	}
	if m.cleared_StatusToProvisioningStep {
		edges = append(edges, status.EdgeStatusToProvisioningStep)
	}
	if m.cleared_StatusToTeam {
		edges = append(edges, status.EdgeStatusToTeam)
	}
	if m.cleared_StatusToPlan {
		edges = append(edges, status.EdgeStatusToPlan)
	}
	if m.cleared_StatusToServerTask {
		edges = append(edges, status.EdgeStatusToServerTask)
	}
	if m.cleared_StatusToAdhocPlan {
		edges = append(edges, status.EdgeStatusToAdhocPlan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatusMutation) EdgeCleared(name string) bool {
	switch name {
	case status.EdgeStatusToBuild:
		return m.cleared_StatusToBuild
	case status.EdgeStatusToProvisionedNetwork:
		return m.cleared_StatusToProvisionedNetwork
	case status.EdgeStatusToProvisionedHost:
		return m.cleared_StatusToProvisionedHost
	case status.EdgeStatusToProvisioningStep:
		return m.cleared_StatusToProvisioningStep
	case status.EdgeStatusToTeam:
		return m.cleared_StatusToTeam
	case status.EdgeStatusToPlan:
		return m.cleared_StatusToPlan
	case status.EdgeStatusToServerTask:
		return m.cleared_StatusToServerTask
	case status.EdgeStatusToAdhocPlan:
		return m.cleared_StatusToAdhocPlan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatusMutation) ClearEdge(name string) error {
	switch name {
	case status.EdgeStatusToBuild:
		m.ClearStatusToBuild()
		return nil
	case status.EdgeStatusToProvisionedNetwork:
		m.ClearStatusToProvisionedNetwork()
		return nil
	case status.EdgeStatusToProvisionedHost:
		m.ClearStatusToProvisionedHost()
		return nil
	case status.EdgeStatusToProvisioningStep:
		m.ClearStatusToProvisioningStep()
		return nil
	case status.EdgeStatusToTeam:
		m.ClearStatusToTeam()
		return nil
	case status.EdgeStatusToPlan:
		m.ClearStatusToPlan()
		return nil
	case status.EdgeStatusToServerTask:
		m.ClearStatusToServerTask()
		return nil
	case status.EdgeStatusToAdhocPlan:
		m.ClearStatusToAdhocPlan()
		return nil
	}
	return fmt.Errorf("unknown Status unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatusMutation) ResetEdge(name string) error {
	switch name {
	case status.EdgeStatusToBuild:
		m.ResetStatusToBuild()
		return nil
	case status.EdgeStatusToProvisionedNetwork:
		m.ResetStatusToProvisionedNetwork()
		return nil
	case status.EdgeStatusToProvisionedHost:
		m.ResetStatusToProvisionedHost()
		return nil
	case status.EdgeStatusToProvisioningStep:
		m.ResetStatusToProvisioningStep()
		return nil
	case status.EdgeStatusToTeam:
		m.ResetStatusToTeam()
		return nil
	case status.EdgeStatusToPlan:
		m.ResetStatusToPlan()
		return nil
	case status.EdgeStatusToServerTask:
		m.ResetStatusToServerTask()
		return nil
	case status.EdgeStatusToAdhocPlan:
		m.ResetStatusToAdhocPlan()
		return nil
	}
	return fmt.Errorf("unknown Status edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	uuid          *uuid.UUID
	name          *string
	description   *map[string]string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Tag, error)
	predicates    []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id uuid.UUID) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "uuid" field.
func (m *TagMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *TagMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *TagMutation) ResetUUID() {
	m.uuid = nil
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TagMutation) SetDescription(value map[string]string) {
	m.description = &value
}

// Description returns the value of the "description" field in the mutation.
func (m *TagMutation) Description() (r map[string]string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDescription(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TagMutation) ResetDescription() {
	m.description = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.uuid != nil {
		fields = append(fields, tag.FieldUUID)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.description != nil {
		fields = append(fields, tag.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldUUID:
		return m.UUID()
	case tag.FieldName:
		return m.Name()
	case tag.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldUUID:
		return m.OldUUID(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldDescription:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldUUID:
		m.ResetUUID()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Tag edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op                               Op
	typ                              string
	id                               *uuid.UUID
	team_number                      *int
	addteam_number                   *int
	vars                             *map[string]string
	clearedFields                    map[string]struct{}
	_TeamToBuild                     *uuid.UUID
	cleared_TeamToBuild              bool
	_TeamToStatus                    *uuid.UUID
	cleared_TeamToStatus             bool
	_TeamToProvisionedNetwork        map[uuid.UUID]struct{}
	removed_TeamToProvisionedNetwork map[uuid.UUID]struct{}
	cleared_TeamToProvisionedNetwork bool
	_TeamToPlan                      *uuid.UUID
	cleared_TeamToPlan               bool
	done                             bool
	oldValue                         func(context.Context) (*Team, error)
	predicates                       []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id uuid.UUID) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Team entities.
func (m *TeamMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Team.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTeamNumber sets the "team_number" field.
func (m *TeamMutation) SetTeamNumber(i int) {
	m.team_number = &i
	m.addteam_number = nil
}

// TeamNumber returns the value of the "team_number" field in the mutation.
func (m *TeamMutation) TeamNumber() (r int, exists bool) {
	v := m.team_number
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamNumber returns the old "team_number" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldTeamNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamNumber: %w", err)
	}
	return oldValue.TeamNumber, nil
}

// AddTeamNumber adds i to the "team_number" field.
func (m *TeamMutation) AddTeamNumber(i int) {
	if m.addteam_number != nil {
		*m.addteam_number += i
	} else {
		m.addteam_number = &i
	}
}

// AddedTeamNumber returns the value that was added to the "team_number" field in this mutation.
func (m *TeamMutation) AddedTeamNumber() (r int, exists bool) {
	v := m.addteam_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetTeamNumber resets all changes to the "team_number" field.
func (m *TeamMutation) ResetTeamNumber() {
	m.team_number = nil
	m.addteam_number = nil
}

// SetVars sets the "vars" field.
func (m *TeamMutation) SetVars(value map[string]string) {
	m.vars = &value
}

// Vars returns the value of the "vars" field in the mutation.
func (m *TeamMutation) Vars() (r map[string]string, exists bool) {
	v := m.vars
	if v == nil {
		return
	}
	return *v, true
}

// OldVars returns the old "vars" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldVars(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVars is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVars requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVars: %w", err)
	}
	return oldValue.Vars, nil
}

// ResetVars resets all changes to the "vars" field.
func (m *TeamMutation) ResetVars() {
	m.vars = nil
}

// SetTeamToBuildID sets the "TeamToBuild" edge to the Build entity by id.
func (m *TeamMutation) SetTeamToBuildID(id uuid.UUID) {
	m._TeamToBuild = &id
}

// ClearTeamToBuild clears the "TeamToBuild" edge to the Build entity.
func (m *TeamMutation) ClearTeamToBuild() {
	m.cleared_TeamToBuild = true
}

// TeamToBuildCleared reports if the "TeamToBuild" edge to the Build entity was cleared.
func (m *TeamMutation) TeamToBuildCleared() bool {
	return m.cleared_TeamToBuild
}

// TeamToBuildID returns the "TeamToBuild" edge ID in the mutation.
func (m *TeamMutation) TeamToBuildID() (id uuid.UUID, exists bool) {
	if m._TeamToBuild != nil {
		return *m._TeamToBuild, true
	}
	return
}

// TeamToBuildIDs returns the "TeamToBuild" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamToBuildID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) TeamToBuildIDs() (ids []uuid.UUID) {
	if id := m._TeamToBuild; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeamToBuild resets all changes to the "TeamToBuild" edge.
func (m *TeamMutation) ResetTeamToBuild() {
	m._TeamToBuild = nil
	m.cleared_TeamToBuild = false
}

// SetTeamToStatusID sets the "TeamToStatus" edge to the Status entity by id.
func (m *TeamMutation) SetTeamToStatusID(id uuid.UUID) {
	m._TeamToStatus = &id
}

// ClearTeamToStatus clears the "TeamToStatus" edge to the Status entity.
func (m *TeamMutation) ClearTeamToStatus() {
	m.cleared_TeamToStatus = true
}

// TeamToStatusCleared reports if the "TeamToStatus" edge to the Status entity was cleared.
func (m *TeamMutation) TeamToStatusCleared() bool {
	return m.cleared_TeamToStatus
}

// TeamToStatusID returns the "TeamToStatus" edge ID in the mutation.
func (m *TeamMutation) TeamToStatusID() (id uuid.UUID, exists bool) {
	if m._TeamToStatus != nil {
		return *m._TeamToStatus, true
	}
	return
}

// TeamToStatusIDs returns the "TeamToStatus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamToStatusID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) TeamToStatusIDs() (ids []uuid.UUID) {
	if id := m._TeamToStatus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeamToStatus resets all changes to the "TeamToStatus" edge.
func (m *TeamMutation) ResetTeamToStatus() {
	m._TeamToStatus = nil
	m.cleared_TeamToStatus = false
}

// AddTeamToProvisionedNetworkIDs adds the "TeamToProvisionedNetwork" edge to the ProvisionedNetwork entity by ids.
func (m *TeamMutation) AddTeamToProvisionedNetworkIDs(ids ...uuid.UUID) {
	if m._TeamToProvisionedNetwork == nil {
		m._TeamToProvisionedNetwork = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._TeamToProvisionedNetwork[ids[i]] = struct{}{}
	}
}

// ClearTeamToProvisionedNetwork clears the "TeamToProvisionedNetwork" edge to the ProvisionedNetwork entity.
func (m *TeamMutation) ClearTeamToProvisionedNetwork() {
	m.cleared_TeamToProvisionedNetwork = true
}

// TeamToProvisionedNetworkCleared reports if the "TeamToProvisionedNetwork" edge to the ProvisionedNetwork entity was cleared.
func (m *TeamMutation) TeamToProvisionedNetworkCleared() bool {
	return m.cleared_TeamToProvisionedNetwork
}

// RemoveTeamToProvisionedNetworkIDs removes the "TeamToProvisionedNetwork" edge to the ProvisionedNetwork entity by IDs.
func (m *TeamMutation) RemoveTeamToProvisionedNetworkIDs(ids ...uuid.UUID) {
	if m.removed_TeamToProvisionedNetwork == nil {
		m.removed_TeamToProvisionedNetwork = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._TeamToProvisionedNetwork, ids[i])
		m.removed_TeamToProvisionedNetwork[ids[i]] = struct{}{}
	}
}

// RemovedTeamToProvisionedNetwork returns the removed IDs of the "TeamToProvisionedNetwork" edge to the ProvisionedNetwork entity.
func (m *TeamMutation) RemovedTeamToProvisionedNetworkIDs() (ids []uuid.UUID) {
	for id := range m.removed_TeamToProvisionedNetwork {
		ids = append(ids, id)
	}
	return
}

// TeamToProvisionedNetworkIDs returns the "TeamToProvisionedNetwork" edge IDs in the mutation.
func (m *TeamMutation) TeamToProvisionedNetworkIDs() (ids []uuid.UUID) {
	for id := range m._TeamToProvisionedNetwork {
		ids = append(ids, id)
	}
	return
}

// ResetTeamToProvisionedNetwork resets all changes to the "TeamToProvisionedNetwork" edge.
func (m *TeamMutation) ResetTeamToProvisionedNetwork() {
	m._TeamToProvisionedNetwork = nil
	m.cleared_TeamToProvisionedNetwork = false
	m.removed_TeamToProvisionedNetwork = nil
}

// SetTeamToPlanID sets the "TeamToPlan" edge to the Plan entity by id.
func (m *TeamMutation) SetTeamToPlanID(id uuid.UUID) {
	m._TeamToPlan = &id
}

// ClearTeamToPlan clears the "TeamToPlan" edge to the Plan entity.
func (m *TeamMutation) ClearTeamToPlan() {
	m.cleared_TeamToPlan = true
}

// TeamToPlanCleared reports if the "TeamToPlan" edge to the Plan entity was cleared.
func (m *TeamMutation) TeamToPlanCleared() bool {
	return m.cleared_TeamToPlan
}

// TeamToPlanID returns the "TeamToPlan" edge ID in the mutation.
func (m *TeamMutation) TeamToPlanID() (id uuid.UUID, exists bool) {
	if m._TeamToPlan != nil {
		return *m._TeamToPlan, true
	}
	return
}

// TeamToPlanIDs returns the "TeamToPlan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamToPlanID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) TeamToPlanIDs() (ids []uuid.UUID) {
	if id := m._TeamToPlan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeamToPlan resets all changes to the "TeamToPlan" edge.
func (m *TeamMutation) ResetTeamToPlan() {
	m._TeamToPlan = nil
	m.cleared_TeamToPlan = false
}

// Where appends a list predicates to the TeamMutation builder.
func (m *TeamMutation) Where(ps ...predicate.Team) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Team, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.team_number != nil {
		fields = append(fields, team.FieldTeamNumber)
	}
	if m.vars != nil {
		fields = append(fields, team.FieldVars)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldTeamNumber:
		return m.TeamNumber()
	case team.FieldVars:
		return m.Vars()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldTeamNumber:
		return m.OldTeamNumber(ctx)
	case team.FieldVars:
		return m.OldVars(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldTeamNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamNumber(v)
		return nil
	case team.FieldVars:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVars(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	var fields []string
	if m.addteam_number != nil {
		fields = append(fields, team.FieldTeamNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case team.FieldTeamNumber:
		return m.AddedTeamNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	case team.FieldTeamNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTeamNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldTeamNumber:
		m.ResetTeamNumber()
		return nil
	case team.FieldVars:
		m.ResetVars()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._TeamToBuild != nil {
		edges = append(edges, team.EdgeTeamToBuild)
	}
	if m._TeamToStatus != nil {
		edges = append(edges, team.EdgeTeamToStatus)
	}
	if m._TeamToProvisionedNetwork != nil {
		edges = append(edges, team.EdgeTeamToProvisionedNetwork)
	}
	if m._TeamToPlan != nil {
		edges = append(edges, team.EdgeTeamToPlan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeTeamToBuild:
		if id := m._TeamToBuild; id != nil {
			return []ent.Value{*id}
		}
	case team.EdgeTeamToStatus:
		if id := m._TeamToStatus; id != nil {
			return []ent.Value{*id}
		}
	case team.EdgeTeamToProvisionedNetwork:
		ids := make([]ent.Value, 0, len(m._TeamToProvisionedNetwork))
		for id := range m._TeamToProvisionedNetwork {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTeamToPlan:
		if id := m._TeamToPlan; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removed_TeamToProvisionedNetwork != nil {
		edges = append(edges, team.EdgeTeamToProvisionedNetwork)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeTeamToProvisionedNetwork:
		ids := make([]ent.Value, 0, len(m.removed_TeamToProvisionedNetwork))
		for id := range m.removed_TeamToProvisionedNetwork {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_TeamToBuild {
		edges = append(edges, team.EdgeTeamToBuild)
	}
	if m.cleared_TeamToStatus {
		edges = append(edges, team.EdgeTeamToStatus)
	}
	if m.cleared_TeamToProvisionedNetwork {
		edges = append(edges, team.EdgeTeamToProvisionedNetwork)
	}
	if m.cleared_TeamToPlan {
		edges = append(edges, team.EdgeTeamToPlan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeTeamToBuild:
		return m.cleared_TeamToBuild
	case team.EdgeTeamToStatus:
		return m.cleared_TeamToStatus
	case team.EdgeTeamToProvisionedNetwork:
		return m.cleared_TeamToProvisionedNetwork
	case team.EdgeTeamToPlan:
		return m.cleared_TeamToPlan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	case team.EdgeTeamToBuild:
		m.ClearTeamToBuild()
		return nil
	case team.EdgeTeamToStatus:
		m.ClearTeamToStatus()
		return nil
	case team.EdgeTeamToPlan:
		m.ClearTeamToPlan()
		return nil
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeTeamToBuild:
		m.ResetTeamToBuild()
		return nil
	case team.EdgeTeamToStatus:
		m.ResetTeamToStatus()
		return nil
	case team.EdgeTeamToProvisionedNetwork:
		m.ResetTeamToProvisionedNetwork()
		return nil
	case team.EdgeTeamToPlan:
		m.ResetTeamToPlan()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	token                   *string
	expire_at               *int64
	addexpire_at            *int64
	clearedFields           map[string]struct{}
	_TokenToAuthUser        *uuid.UUID
	cleared_TokenToAuthUser bool
	done                    bool
	oldValue                func(context.Context) (*Token, error)
	predicates              []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id uuid.UUID) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Token entities.
func (m *TokenMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetToken sets the "token" field.
func (m *TokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *TokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *TokenMutation) ResetToken() {
	m.token = nil
}

// SetExpireAt sets the "expire_at" field.
func (m *TokenMutation) SetExpireAt(i int64) {
	m.expire_at = &i
	m.addexpire_at = nil
}

// ExpireAt returns the value of the "expire_at" field in the mutation.
func (m *TokenMutation) ExpireAt() (r int64, exists bool) {
	v := m.expire_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireAt returns the old "expire_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldExpireAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpireAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpireAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireAt: %w", err)
	}
	return oldValue.ExpireAt, nil
}

// AddExpireAt adds i to the "expire_at" field.
func (m *TokenMutation) AddExpireAt(i int64) {
	if m.addexpire_at != nil {
		*m.addexpire_at += i
	} else {
		m.addexpire_at = &i
	}
}

// AddedExpireAt returns the value that was added to the "expire_at" field in this mutation.
func (m *TokenMutation) AddedExpireAt() (r int64, exists bool) {
	v := m.addexpire_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetExpireAt resets all changes to the "expire_at" field.
func (m *TokenMutation) ResetExpireAt() {
	m.expire_at = nil
	m.addexpire_at = nil
}

// SetTokenToAuthUserID sets the "TokenToAuthUser" edge to the AuthUser entity by id.
func (m *TokenMutation) SetTokenToAuthUserID(id uuid.UUID) {
	m._TokenToAuthUser = &id
}

// ClearTokenToAuthUser clears the "TokenToAuthUser" edge to the AuthUser entity.
func (m *TokenMutation) ClearTokenToAuthUser() {
	m.cleared_TokenToAuthUser = true
}

// TokenToAuthUserCleared reports if the "TokenToAuthUser" edge to the AuthUser entity was cleared.
func (m *TokenMutation) TokenToAuthUserCleared() bool {
	return m.cleared_TokenToAuthUser
}

// TokenToAuthUserID returns the "TokenToAuthUser" edge ID in the mutation.
func (m *TokenMutation) TokenToAuthUserID() (id uuid.UUID, exists bool) {
	if m._TokenToAuthUser != nil {
		return *m._TokenToAuthUser, true
	}
	return
}

// TokenToAuthUserIDs returns the "TokenToAuthUser" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TokenToAuthUserID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) TokenToAuthUserIDs() (ids []uuid.UUID) {
	if id := m._TokenToAuthUser; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTokenToAuthUser resets all changes to the "TokenToAuthUser" edge.
func (m *TokenMutation) ResetTokenToAuthUser() {
	m._TokenToAuthUser = nil
	m.cleared_TokenToAuthUser = false
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Token, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.token != nil {
		fields = append(fields, token.FieldToken)
	}
	if m.expire_at != nil {
		fields = append(fields, token.FieldExpireAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldToken:
		return m.Token()
	case token.FieldExpireAt:
		return m.ExpireAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldToken:
		return m.OldToken(ctx)
	case token.FieldExpireAt:
		return m.OldExpireAt(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case token.FieldExpireAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireAt(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	var fields []string
	if m.addexpire_at != nil {
		fields = append(fields, token.FieldExpireAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case token.FieldExpireAt:
		return m.AddedExpireAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case token.FieldExpireAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpireAt(v)
		return nil
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldToken:
		m.ResetToken()
		return nil
	case token.FieldExpireAt:
		m.ResetExpireAt()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._TokenToAuthUser != nil {
		edges = append(edges, token.EdgeTokenToAuthUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case token.EdgeTokenToAuthUser:
		if id := m._TokenToAuthUser; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_TokenToAuthUser {
		edges = append(edges, token.EdgeTokenToAuthUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	switch name {
	case token.EdgeTokenToAuthUser:
		return m.cleared_TokenToAuthUser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	switch name {
	case token.EdgeTokenToAuthUser:
		m.ClearTokenToAuthUser()
		return nil
	}
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	switch name {
	case token.EdgeTokenToAuthUser:
		m.ResetTokenToAuthUser()
		return nil
	}
	return fmt.Errorf("unknown Token edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	name                      *string
	uuid                      *string
	email                     *string
	hcl_id                    *string
	clearedFields             map[string]struct{}
	_UserToTag                map[uuid.UUID]struct{}
	removed_UserToTag         map[uuid.UUID]struct{}
	cleared_UserToTag         bool
	_UserToEnvironment        map[uuid.UUID]struct{}
	removed_UserToEnvironment map[uuid.UUID]struct{}
	cleared_UserToEnvironment bool
	done                      bool
	oldValue                  func(context.Context) (*User, error)
	predicates                []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetUUID sets the "uuid" field.
func (m *UserMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *UserMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *UserMutation) ResetUUID() {
	m.uuid = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetHCLID sets the "hcl_id" field.
func (m *UserMutation) SetHCLID(s string) {
	m.hcl_id = &s
}

// HCLID returns the value of the "hcl_id" field in the mutation.
func (m *UserMutation) HCLID() (r string, exists bool) {
	v := m.hcl_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHCLID returns the old "hcl_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHCLID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHCLID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHCLID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHCLID: %w", err)
	}
	return oldValue.HCLID, nil
}

// ResetHCLID resets all changes to the "hcl_id" field.
func (m *UserMutation) ResetHCLID() {
	m.hcl_id = nil
}

// AddUserToTagIDs adds the "UserToTag" edge to the Tag entity by ids.
func (m *UserMutation) AddUserToTagIDs(ids ...uuid.UUID) {
	if m._UserToTag == nil {
		m._UserToTag = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._UserToTag[ids[i]] = struct{}{}
	}
}

// ClearUserToTag clears the "UserToTag" edge to the Tag entity.
func (m *UserMutation) ClearUserToTag() {
	m.cleared_UserToTag = true
}

// UserToTagCleared reports if the "UserToTag" edge to the Tag entity was cleared.
func (m *UserMutation) UserToTagCleared() bool {
	return m.cleared_UserToTag
}

// RemoveUserToTagIDs removes the "UserToTag" edge to the Tag entity by IDs.
func (m *UserMutation) RemoveUserToTagIDs(ids ...uuid.UUID) {
	if m.removed_UserToTag == nil {
		m.removed_UserToTag = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._UserToTag, ids[i])
		m.removed_UserToTag[ids[i]] = struct{}{}
	}
}

// RemovedUserToTag returns the removed IDs of the "UserToTag" edge to the Tag entity.
func (m *UserMutation) RemovedUserToTagIDs() (ids []uuid.UUID) {
	for id := range m.removed_UserToTag {
		ids = append(ids, id)
	}
	return
}

// UserToTagIDs returns the "UserToTag" edge IDs in the mutation.
func (m *UserMutation) UserToTagIDs() (ids []uuid.UUID) {
	for id := range m._UserToTag {
		ids = append(ids, id)
	}
	return
}

// ResetUserToTag resets all changes to the "UserToTag" edge.
func (m *UserMutation) ResetUserToTag() {
	m._UserToTag = nil
	m.cleared_UserToTag = false
	m.removed_UserToTag = nil
}

// AddUserToEnvironmentIDs adds the "UserToEnvironment" edge to the Environment entity by ids.
func (m *UserMutation) AddUserToEnvironmentIDs(ids ...uuid.UUID) {
	if m._UserToEnvironment == nil {
		m._UserToEnvironment = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._UserToEnvironment[ids[i]] = struct{}{}
	}
}

// ClearUserToEnvironment clears the "UserToEnvironment" edge to the Environment entity.
func (m *UserMutation) ClearUserToEnvironment() {
	m.cleared_UserToEnvironment = true
}

// UserToEnvironmentCleared reports if the "UserToEnvironment" edge to the Environment entity was cleared.
func (m *UserMutation) UserToEnvironmentCleared() bool {
	return m.cleared_UserToEnvironment
}

// RemoveUserToEnvironmentIDs removes the "UserToEnvironment" edge to the Environment entity by IDs.
func (m *UserMutation) RemoveUserToEnvironmentIDs(ids ...uuid.UUID) {
	if m.removed_UserToEnvironment == nil {
		m.removed_UserToEnvironment = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._UserToEnvironment, ids[i])
		m.removed_UserToEnvironment[ids[i]] = struct{}{}
	}
}

// RemovedUserToEnvironment returns the removed IDs of the "UserToEnvironment" edge to the Environment entity.
func (m *UserMutation) RemovedUserToEnvironmentIDs() (ids []uuid.UUID) {
	for id := range m.removed_UserToEnvironment {
		ids = append(ids, id)
	}
	return
}

// UserToEnvironmentIDs returns the "UserToEnvironment" edge IDs in the mutation.
func (m *UserMutation) UserToEnvironmentIDs() (ids []uuid.UUID) {
	for id := range m._UserToEnvironment {
		ids = append(ids, id)
	}
	return
}

// ResetUserToEnvironment resets all changes to the "UserToEnvironment" edge.
func (m *UserMutation) ResetUserToEnvironment() {
	m._UserToEnvironment = nil
	m.cleared_UserToEnvironment = false
	m.removed_UserToEnvironment = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.uuid != nil {
		fields = append(fields, user.FieldUUID)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.hcl_id != nil {
		fields = append(fields, user.FieldHCLID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldUUID:
		return m.UUID()
	case user.FieldEmail:
		return m.Email()
	case user.FieldHCLID:
		return m.HCLID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldUUID:
		return m.OldUUID(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldHCLID:
		return m.OldHCLID(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldHCLID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHCLID(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldUUID:
		m.ResetUUID()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldHCLID:
		m.ResetHCLID()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._UserToTag != nil {
		edges = append(edges, user.EdgeUserToTag)
	}
	if m._UserToEnvironment != nil {
		edges = append(edges, user.EdgeUserToEnvironment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserToTag:
		ids := make([]ent.Value, 0, len(m._UserToTag))
		for id := range m._UserToTag {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserToEnvironment:
		ids := make([]ent.Value, 0, len(m._UserToEnvironment))
		for id := range m._UserToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_UserToTag != nil {
		edges = append(edges, user.EdgeUserToTag)
	}
	if m.removed_UserToEnvironment != nil {
		edges = append(edges, user.EdgeUserToEnvironment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserToTag:
		ids := make([]ent.Value, 0, len(m.removed_UserToTag))
		for id := range m.removed_UserToTag {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserToEnvironment:
		ids := make([]ent.Value, 0, len(m.removed_UserToEnvironment))
		for id := range m.removed_UserToEnvironment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_UserToTag {
		edges = append(edges, user.EdgeUserToTag)
	}
	if m.cleared_UserToEnvironment {
		edges = append(edges, user.EdgeUserToEnvironment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeUserToTag:
		return m.cleared_UserToTag
	case user.EdgeUserToEnvironment:
		return m.cleared_UserToEnvironment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserToTag:
		m.ResetUserToTag()
		return nil
	case user.EdgeUserToEnvironment:
		m.ResetUserToEnvironment()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
