// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/gen0cide/laforge/ent/agentstatus"
	"github.com/gen0cide/laforge/ent/agenttask"
	"github.com/gen0cide/laforge/ent/ansible"
	"github.com/gen0cide/laforge/ent/authuser"
	"github.com/gen0cide/laforge/ent/build"
	"github.com/gen0cide/laforge/ent/buildcommit"
	"github.com/gen0cide/laforge/ent/command"
	"github.com/gen0cide/laforge/ent/competition"
	"github.com/gen0cide/laforge/ent/disk"
	"github.com/gen0cide/laforge/ent/dns"
	"github.com/gen0cide/laforge/ent/dnsrecord"
	"github.com/gen0cide/laforge/ent/environment"
	"github.com/gen0cide/laforge/ent/filedelete"
	"github.com/gen0cide/laforge/ent/filedownload"
	"github.com/gen0cide/laforge/ent/fileextract"
	"github.com/gen0cide/laforge/ent/finding"
	"github.com/gen0cide/laforge/ent/ginfilemiddleware"
	"github.com/gen0cide/laforge/ent/host"
	"github.com/gen0cide/laforge/ent/hostdependency"
	"github.com/gen0cide/laforge/ent/identity"
	"github.com/gen0cide/laforge/ent/includednetwork"
	"github.com/gen0cide/laforge/ent/network"
	"github.com/gen0cide/laforge/ent/plan"
	"github.com/gen0cide/laforge/ent/plandiff"
	"github.com/gen0cide/laforge/ent/provisionedhost"
	"github.com/gen0cide/laforge/ent/provisionednetwork"
	"github.com/gen0cide/laforge/ent/provisioningstep"
	"github.com/gen0cide/laforge/ent/repocommit"
	"github.com/gen0cide/laforge/ent/repository"
	"github.com/gen0cide/laforge/ent/script"
	"github.com/gen0cide/laforge/ent/servertask"
	"github.com/gen0cide/laforge/ent/status"
	"github.com/gen0cide/laforge/ent/tag"
	"github.com/gen0cide/laforge/ent/team"
	"github.com/gen0cide/laforge/ent/token"
	"github.com/gen0cide/laforge/ent/user"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ap *AdhocPlanQuery) CollectFields(ctx context.Context, satisfies ...string) (*AdhocPlanQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ap, nil
	}
	if err := ap.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ap, nil
}

func (ap *AdhocPlanQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "prevadhocplan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AdhocPlanClient{config: ap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ap.WithNamedPrevAdhocPlan(alias, func(wq *AdhocPlanQuery) {
				*wq = *query
			})
		case "nextadhocplan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AdhocPlanClient{config: ap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ap.WithNamedNextAdhocPlan(alias, func(wq *AdhocPlanQuery) {
				*wq = *query
			})
		case "adhocplantobuild":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildClient{config: ap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ap.withAdhocPlanToBuild = query
		case "adhocplantostatus":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&StatusClient{config: ap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ap.withAdhocPlanToStatus = query
		case "adhocplantoagenttask":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AgentTaskClient{config: ap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ap.withAdhocPlanToAgentTask = query
		}
	}
	return nil
}

type adhocplanPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []AdhocPlanPaginateOption
}

func newAdhocPlanPaginateArgs(rv map[string]any) *adhocplanPaginateArgs {
	args := &adhocplanPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (as *AgentStatusQuery) CollectFields(ctx context.Context, satisfies ...string) (*AgentStatusQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return as, nil
	}
	if err := as.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return as, nil
}

func (as *AgentStatusQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(agentstatus.Columns))
		selectedFields = []string{agentstatus.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "agentstatustoprovisionedhost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedHostClient{config: as.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			as.withAgentStatusToProvisionedHost = query
		case "agentstatustoprovisionednetwork":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedNetworkClient{config: as.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			as.withAgentStatusToProvisionedNetwork = query
		case "agentstatustobuild":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildClient{config: as.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			as.withAgentStatusToBuild = query
		case "clientid":
			if _, ok := fieldSeen[agentstatus.FieldClientID]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldClientID)
				fieldSeen[agentstatus.FieldClientID] = struct{}{}
			}
		case "hostname":
			if _, ok := fieldSeen[agentstatus.FieldHostname]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldHostname)
				fieldSeen[agentstatus.FieldHostname] = struct{}{}
			}
		case "uptime":
			if _, ok := fieldSeen[agentstatus.FieldUpTime]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldUpTime)
				fieldSeen[agentstatus.FieldUpTime] = struct{}{}
			}
		case "boottime":
			if _, ok := fieldSeen[agentstatus.FieldBootTime]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldBootTime)
				fieldSeen[agentstatus.FieldBootTime] = struct{}{}
			}
		case "numprocs":
			if _, ok := fieldSeen[agentstatus.FieldNumProcs]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldNumProcs)
				fieldSeen[agentstatus.FieldNumProcs] = struct{}{}
			}
		case "os":
			if _, ok := fieldSeen[agentstatus.FieldOs]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldOs)
				fieldSeen[agentstatus.FieldOs] = struct{}{}
			}
		case "hostid":
			if _, ok := fieldSeen[agentstatus.FieldHostID]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldHostID)
				fieldSeen[agentstatus.FieldHostID] = struct{}{}
			}
		case "load1":
			if _, ok := fieldSeen[agentstatus.FieldLoad1]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldLoad1)
				fieldSeen[agentstatus.FieldLoad1] = struct{}{}
			}
		case "load5":
			if _, ok := fieldSeen[agentstatus.FieldLoad5]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldLoad5)
				fieldSeen[agentstatus.FieldLoad5] = struct{}{}
			}
		case "load15":
			if _, ok := fieldSeen[agentstatus.FieldLoad15]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldLoad15)
				fieldSeen[agentstatus.FieldLoad15] = struct{}{}
			}
		case "totalmem":
			if _, ok := fieldSeen[agentstatus.FieldTotalMem]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldTotalMem)
				fieldSeen[agentstatus.FieldTotalMem] = struct{}{}
			}
		case "freemem":
			if _, ok := fieldSeen[agentstatus.FieldFreeMem]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldFreeMem)
				fieldSeen[agentstatus.FieldFreeMem] = struct{}{}
			}
		case "usedmem":
			if _, ok := fieldSeen[agentstatus.FieldUsedMem]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldUsedMem)
				fieldSeen[agentstatus.FieldUsedMem] = struct{}{}
			}
		case "timestamp":
			if _, ok := fieldSeen[agentstatus.FieldTimestamp]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldTimestamp)
				fieldSeen[agentstatus.FieldTimestamp] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		as.Select(selectedFields...)
	}
	return nil
}

type agentstatusPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []AgentStatusPaginateOption
}

func newAgentStatusPaginateArgs(rv map[string]any) *agentstatusPaginateArgs {
	args := &agentstatusPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (at *AgentTaskQuery) CollectFields(ctx context.Context, satisfies ...string) (*AgentTaskQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return at, nil
	}
	if err := at.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return at, nil
}

func (at *AgentTaskQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(agenttask.Columns))
		selectedFields = []string{agenttask.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "agenttasktoprovisioningstep":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisioningStepClient{config: at.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			at.withAgentTaskToProvisioningStep = query
		case "agenttasktoprovisionedhost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedHostClient{config: at.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			at.withAgentTaskToProvisionedHost = query
		case "agenttasktoadhocplan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AdhocPlanClient{config: at.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			at.WithNamedAgentTaskToAdhocPlan(alias, func(wq *AdhocPlanQuery) {
				*wq = *query
			})
		case "command":
			if _, ok := fieldSeen[agenttask.FieldCommand]; !ok {
				selectedFields = append(selectedFields, agenttask.FieldCommand)
				fieldSeen[agenttask.FieldCommand] = struct{}{}
			}
		case "args":
			if _, ok := fieldSeen[agenttask.FieldArgs]; !ok {
				selectedFields = append(selectedFields, agenttask.FieldArgs)
				fieldSeen[agenttask.FieldArgs] = struct{}{}
			}
		case "number":
			if _, ok := fieldSeen[agenttask.FieldNumber]; !ok {
				selectedFields = append(selectedFields, agenttask.FieldNumber)
				fieldSeen[agenttask.FieldNumber] = struct{}{}
			}
		case "output":
			if _, ok := fieldSeen[agenttask.FieldOutput]; !ok {
				selectedFields = append(selectedFields, agenttask.FieldOutput)
				fieldSeen[agenttask.FieldOutput] = struct{}{}
			}
		case "state":
			if _, ok := fieldSeen[agenttask.FieldState]; !ok {
				selectedFields = append(selectedFields, agenttask.FieldState)
				fieldSeen[agenttask.FieldState] = struct{}{}
			}
		case "errorMessage":
			if _, ok := fieldSeen[agenttask.FieldErrorMessage]; !ok {
				selectedFields = append(selectedFields, agenttask.FieldErrorMessage)
				fieldSeen[agenttask.FieldErrorMessage] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		at.Select(selectedFields...)
	}
	return nil
}

type agenttaskPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []AgentTaskPaginateOption
}

func newAgentTaskPaginateArgs(rv map[string]any) *agenttaskPaginateArgs {
	args := &agenttaskPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (a *AnsibleQuery) CollectFields(ctx context.Context, satisfies ...string) (*AnsibleQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return a, nil
	}
	if err := a.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return a, nil
}

func (a *AnsibleQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(ansible.Columns))
		selectedFields = []string{ansible.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "ansibletouser":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			a.WithNamedAnsibleToUser(alias, func(wq *UserQuery) {
				*wq = *query
			})
		case "ansiblefromenvironment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			a.withAnsibleFromEnvironment = query
		case "name":
			if _, ok := fieldSeen[ansible.FieldName]; !ok {
				selectedFields = append(selectedFields, ansible.FieldName)
				fieldSeen[ansible.FieldName] = struct{}{}
			}
		case "hclID":
			if _, ok := fieldSeen[ansible.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, ansible.FieldHCLID)
				fieldSeen[ansible.FieldHCLID] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[ansible.FieldDescription]; !ok {
				selectedFields = append(selectedFields, ansible.FieldDescription)
				fieldSeen[ansible.FieldDescription] = struct{}{}
			}
		case "source":
			if _, ok := fieldSeen[ansible.FieldSource]; !ok {
				selectedFields = append(selectedFields, ansible.FieldSource)
				fieldSeen[ansible.FieldSource] = struct{}{}
			}
		case "playbookName":
			if _, ok := fieldSeen[ansible.FieldPlaybookName]; !ok {
				selectedFields = append(selectedFields, ansible.FieldPlaybookName)
				fieldSeen[ansible.FieldPlaybookName] = struct{}{}
			}
		case "method":
			if _, ok := fieldSeen[ansible.FieldMethod]; !ok {
				selectedFields = append(selectedFields, ansible.FieldMethod)
				fieldSeen[ansible.FieldMethod] = struct{}{}
			}
		case "inventory":
			if _, ok := fieldSeen[ansible.FieldInventory]; !ok {
				selectedFields = append(selectedFields, ansible.FieldInventory)
				fieldSeen[ansible.FieldInventory] = struct{}{}
			}
		case "absPath":
			if _, ok := fieldSeen[ansible.FieldAbsPath]; !ok {
				selectedFields = append(selectedFields, ansible.FieldAbsPath)
				fieldSeen[ansible.FieldAbsPath] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[ansible.FieldTags]; !ok {
				selectedFields = append(selectedFields, ansible.FieldTags)
				fieldSeen[ansible.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		a.Select(selectedFields...)
	}
	return nil
}

type ansiblePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []AnsiblePaginateOption
}

func newAnsiblePaginateArgs(rv map[string]any) *ansiblePaginateArgs {
	args := &ansiblePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (au *AuthUserQuery) CollectFields(ctx context.Context, satisfies ...string) (*AuthUserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return au, nil
	}
	if err := au.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return au, nil
}

func (au *AuthUserQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(authuser.Columns))
		selectedFields = []string{authuser.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "authusertotoken":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TokenClient{config: au.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			au.WithNamedAuthUserToToken(alias, func(wq *TokenQuery) {
				*wq = *query
			})
		case "authusertoservertasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ServerTaskClient{config: au.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			au.WithNamedAuthUserToServerTasks(alias, func(wq *ServerTaskQuery) {
				*wq = *query
			})
		case "username":
			if _, ok := fieldSeen[authuser.FieldUsername]; !ok {
				selectedFields = append(selectedFields, authuser.FieldUsername)
				fieldSeen[authuser.FieldUsername] = struct{}{}
			}
		case "firstName":
			if _, ok := fieldSeen[authuser.FieldFirstName]; !ok {
				selectedFields = append(selectedFields, authuser.FieldFirstName)
				fieldSeen[authuser.FieldFirstName] = struct{}{}
			}
		case "lastName":
			if _, ok := fieldSeen[authuser.FieldLastName]; !ok {
				selectedFields = append(selectedFields, authuser.FieldLastName)
				fieldSeen[authuser.FieldLastName] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[authuser.FieldEmail]; !ok {
				selectedFields = append(selectedFields, authuser.FieldEmail)
				fieldSeen[authuser.FieldEmail] = struct{}{}
			}
		case "phone":
			if _, ok := fieldSeen[authuser.FieldPhone]; !ok {
				selectedFields = append(selectedFields, authuser.FieldPhone)
				fieldSeen[authuser.FieldPhone] = struct{}{}
			}
		case "company":
			if _, ok := fieldSeen[authuser.FieldCompany]; !ok {
				selectedFields = append(selectedFields, authuser.FieldCompany)
				fieldSeen[authuser.FieldCompany] = struct{}{}
			}
		case "occupation":
			if _, ok := fieldSeen[authuser.FieldOccupation]; !ok {
				selectedFields = append(selectedFields, authuser.FieldOccupation)
				fieldSeen[authuser.FieldOccupation] = struct{}{}
			}
		case "privateKeyPath":
			if _, ok := fieldSeen[authuser.FieldPrivateKeyPath]; !ok {
				selectedFields = append(selectedFields, authuser.FieldPrivateKeyPath)
				fieldSeen[authuser.FieldPrivateKeyPath] = struct{}{}
			}
		case "role":
			if _, ok := fieldSeen[authuser.FieldRole]; !ok {
				selectedFields = append(selectedFields, authuser.FieldRole)
				fieldSeen[authuser.FieldRole] = struct{}{}
			}
		case "provider":
			if _, ok := fieldSeen[authuser.FieldProvider]; !ok {
				selectedFields = append(selectedFields, authuser.FieldProvider)
				fieldSeen[authuser.FieldProvider] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		au.Select(selectedFields...)
	}
	return nil
}

type authuserPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []AuthUserPaginateOption
}

func newAuthUserPaginateArgs(rv map[string]any) *authuserPaginateArgs {
	args := &authuserPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (b *BuildQuery) CollectFields(ctx context.Context, satisfies ...string) (*BuildQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return b, nil
	}
	if err := b.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return b, nil
}

func (b *BuildQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(build.Columns))
		selectedFields = []string{build.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "buildtostatus":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&StatusClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.withBuildToStatus = query
		case "buildtoenvironment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.withBuildToEnvironment = query
		case "buildtocompetition":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompetitionClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.withBuildToCompetition = query
		case "buildtolatestbuildcommit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildCommitClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.withBuildToLatestBuildCommit = query
		case "buildtorepocommit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RepoCommitClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.withBuildToRepoCommit = query
		case "buildtoprovisionednetwork":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedNetworkClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.WithNamedBuildToProvisionedNetwork(alias, func(wq *ProvisionedNetworkQuery) {
				*wq = *query
			})
		case "buildtoteam":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TeamClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.WithNamedBuildToTeam(alias, func(wq *TeamQuery) {
				*wq = *query
			})
		case "buildtoplan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.WithNamedBuildToPlan(alias, func(wq *PlanQuery) {
				*wq = *query
			})
		case "buildtobuildcommits":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildCommitClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.WithNamedBuildToBuildCommits(alias, func(wq *BuildCommitQuery) {
				*wq = *query
			})
		case "buildtoadhocplans":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AdhocPlanClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.WithNamedBuildToAdhocPlans(alias, func(wq *AdhocPlanQuery) {
				*wq = *query
			})
		case "buildtoagentstatuses":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AgentStatusClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.WithNamedBuildToAgentStatuses(alias, func(wq *AgentStatusQuery) {
				*wq = *query
			})
		case "buildtoservertasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ServerTaskClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.WithNamedBuildToServerTasks(alias, func(wq *ServerTaskQuery) {
				*wq = *query
			})
		case "revision":
			if _, ok := fieldSeen[build.FieldRevision]; !ok {
				selectedFields = append(selectedFields, build.FieldRevision)
				fieldSeen[build.FieldRevision] = struct{}{}
			}
		case "environmentRevision":
			if _, ok := fieldSeen[build.FieldEnvironmentRevision]; !ok {
				selectedFields = append(selectedFields, build.FieldEnvironmentRevision)
				fieldSeen[build.FieldEnvironmentRevision] = struct{}{}
			}
		case "vars":
			if _, ok := fieldSeen[build.FieldVars]; !ok {
				selectedFields = append(selectedFields, build.FieldVars)
				fieldSeen[build.FieldVars] = struct{}{}
			}
		case "completedPlan":
			if _, ok := fieldSeen[build.FieldCompletedPlan]; !ok {
				selectedFields = append(selectedFields, build.FieldCompletedPlan)
				fieldSeen[build.FieldCompletedPlan] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		b.Select(selectedFields...)
	}
	return nil
}

type buildPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []BuildPaginateOption
}

func newBuildPaginateArgs(rv map[string]any) *buildPaginateArgs {
	args := &buildPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (bc *BuildCommitQuery) CollectFields(ctx context.Context, satisfies ...string) (*BuildCommitQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return bc, nil
	}
	if err := bc.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return bc, nil
}

func (bc *BuildCommitQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(buildcommit.Columns))
		selectedFields = []string{buildcommit.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "buildcommittobuild":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildClient{config: bc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			bc.withBuildCommitToBuild = query
		case "buildcommittoservertask":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ServerTaskClient{config: bc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			bc.WithNamedBuildCommitToServerTask(alias, func(wq *ServerTaskQuery) {
				*wq = *query
			})
		case "buildcommittoplandiffs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanDiffClient{config: bc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			bc.WithNamedBuildCommitToPlanDiffs(alias, func(wq *PlanDiffQuery) {
				*wq = *query
			})
		case "type":
			if _, ok := fieldSeen[buildcommit.FieldType]; !ok {
				selectedFields = append(selectedFields, buildcommit.FieldType)
				fieldSeen[buildcommit.FieldType] = struct{}{}
			}
		case "revision":
			if _, ok := fieldSeen[buildcommit.FieldRevision]; !ok {
				selectedFields = append(selectedFields, buildcommit.FieldRevision)
				fieldSeen[buildcommit.FieldRevision] = struct{}{}
			}
		case "state":
			if _, ok := fieldSeen[buildcommit.FieldState]; !ok {
				selectedFields = append(selectedFields, buildcommit.FieldState)
				fieldSeen[buildcommit.FieldState] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[buildcommit.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, buildcommit.FieldCreatedAt)
				fieldSeen[buildcommit.FieldCreatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		bc.Select(selectedFields...)
	}
	return nil
}

type buildcommitPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []BuildCommitPaginateOption
}

func newBuildCommitPaginateArgs(rv map[string]any) *buildcommitPaginateArgs {
	args := &buildcommitPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *CommandQuery) CollectFields(ctx context.Context, satisfies ...string) (*CommandQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CommandQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(command.Columns))
		selectedFields = []string{command.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "commandtouser":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			c.WithNamedCommandToUser(alias, func(wq *UserQuery) {
				*wq = *query
			})
		case "commandtoenvironment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			c.withCommandToEnvironment = query
		case "hclID":
			if _, ok := fieldSeen[command.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, command.FieldHCLID)
				fieldSeen[command.FieldHCLID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[command.FieldName]; !ok {
				selectedFields = append(selectedFields, command.FieldName)
				fieldSeen[command.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[command.FieldDescription]; !ok {
				selectedFields = append(selectedFields, command.FieldDescription)
				fieldSeen[command.FieldDescription] = struct{}{}
			}
		case "program":
			if _, ok := fieldSeen[command.FieldProgram]; !ok {
				selectedFields = append(selectedFields, command.FieldProgram)
				fieldSeen[command.FieldProgram] = struct{}{}
			}
		case "args":
			if _, ok := fieldSeen[command.FieldArgs]; !ok {
				selectedFields = append(selectedFields, command.FieldArgs)
				fieldSeen[command.FieldArgs] = struct{}{}
			}
		case "ignoreErrors":
			if _, ok := fieldSeen[command.FieldIgnoreErrors]; !ok {
				selectedFields = append(selectedFields, command.FieldIgnoreErrors)
				fieldSeen[command.FieldIgnoreErrors] = struct{}{}
			}
		case "disabled":
			if _, ok := fieldSeen[command.FieldDisabled]; !ok {
				selectedFields = append(selectedFields, command.FieldDisabled)
				fieldSeen[command.FieldDisabled] = struct{}{}
			}
		case "cooldown":
			if _, ok := fieldSeen[command.FieldCooldown]; !ok {
				selectedFields = append(selectedFields, command.FieldCooldown)
				fieldSeen[command.FieldCooldown] = struct{}{}
			}
		case "timeout":
			if _, ok := fieldSeen[command.FieldTimeout]; !ok {
				selectedFields = append(selectedFields, command.FieldTimeout)
				fieldSeen[command.FieldTimeout] = struct{}{}
			}
		case "vars":
			if _, ok := fieldSeen[command.FieldVars]; !ok {
				selectedFields = append(selectedFields, command.FieldVars)
				fieldSeen[command.FieldVars] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[command.FieldTags]; !ok {
				selectedFields = append(selectedFields, command.FieldTags)
				fieldSeen[command.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type commandPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CommandPaginateOption
}

func newCommandPaginateArgs(rv map[string]any) *commandPaginateArgs {
	args := &commandPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *CompetitionQuery) CollectFields(ctx context.Context, satisfies ...string) (*CompetitionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CompetitionQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(competition.Columns))
		selectedFields = []string{competition.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "competitiontodns":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DNSClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			c.WithNamedCompetitionToDNS(alias, func(wq *DNSQuery) {
				*wq = *query
			})
		case "competitiontoenvironment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			c.withCompetitionToEnvironment = query
		case "competitiontobuild":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			c.WithNamedCompetitionToBuild(alias, func(wq *BuildQuery) {
				*wq = *query
			})
		case "hclID":
			if _, ok := fieldSeen[competition.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, competition.FieldHCLID)
				fieldSeen[competition.FieldHCLID] = struct{}{}
			}
		case "rootPassword":
			if _, ok := fieldSeen[competition.FieldRootPassword]; !ok {
				selectedFields = append(selectedFields, competition.FieldRootPassword)
				fieldSeen[competition.FieldRootPassword] = struct{}{}
			}
		case "config":
			if _, ok := fieldSeen[competition.FieldConfig]; !ok {
				selectedFields = append(selectedFields, competition.FieldConfig)
				fieldSeen[competition.FieldConfig] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[competition.FieldTags]; !ok {
				selectedFields = append(selectedFields, competition.FieldTags)
				fieldSeen[competition.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type competitionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CompetitionPaginateOption
}

func newCompetitionPaginateArgs(rv map[string]any) *competitionPaginateArgs {
	args := &competitionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (d *DNSQuery) CollectFields(ctx context.Context, satisfies ...string) (*DNSQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return d, nil
	}
	if err := d.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return d, nil
}

func (d *DNSQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(dns.Columns))
		selectedFields = []string{dns.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "dnstoenvironment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			d.WithNamedDNSToEnvironment(alias, func(wq *EnvironmentQuery) {
				*wq = *query
			})
		case "dnstocompetition":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompetitionClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			d.WithNamedDNSToCompetition(alias, func(wq *CompetitionQuery) {
				*wq = *query
			})
		case "hclID":
			if _, ok := fieldSeen[dns.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, dns.FieldHCLID)
				fieldSeen[dns.FieldHCLID] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[dns.FieldType]; !ok {
				selectedFields = append(selectedFields, dns.FieldType)
				fieldSeen[dns.FieldType] = struct{}{}
			}
		case "rootDomain":
			if _, ok := fieldSeen[dns.FieldRootDomain]; !ok {
				selectedFields = append(selectedFields, dns.FieldRootDomain)
				fieldSeen[dns.FieldRootDomain] = struct{}{}
			}
		case "dnsServers":
			if _, ok := fieldSeen[dns.FieldDNSServers]; !ok {
				selectedFields = append(selectedFields, dns.FieldDNSServers)
				fieldSeen[dns.FieldDNSServers] = struct{}{}
			}
		case "ntpServers":
			if _, ok := fieldSeen[dns.FieldNtpServers]; !ok {
				selectedFields = append(selectedFields, dns.FieldNtpServers)
				fieldSeen[dns.FieldNtpServers] = struct{}{}
			}
		case "config":
			if _, ok := fieldSeen[dns.FieldConfig]; !ok {
				selectedFields = append(selectedFields, dns.FieldConfig)
				fieldSeen[dns.FieldConfig] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		d.Select(selectedFields...)
	}
	return nil
}

type dnsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DNSPaginateOption
}

func newDNSPaginateArgs(rv map[string]any) *dnsPaginateArgs {
	args := &dnsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (dr *DNSRecordQuery) CollectFields(ctx context.Context, satisfies ...string) (*DNSRecordQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return dr, nil
	}
	if err := dr.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return dr, nil
}

func (dr *DNSRecordQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(dnsrecord.Columns))
		selectedFields = []string{dnsrecord.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "dnsrecordtoenvironment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: dr.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			dr.withDNSRecordToEnvironment = query
		case "hclID":
			if _, ok := fieldSeen[dnsrecord.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, dnsrecord.FieldHCLID)
				fieldSeen[dnsrecord.FieldHCLID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[dnsrecord.FieldName]; !ok {
				selectedFields = append(selectedFields, dnsrecord.FieldName)
				fieldSeen[dnsrecord.FieldName] = struct{}{}
			}
		case "values":
			if _, ok := fieldSeen[dnsrecord.FieldValues]; !ok {
				selectedFields = append(selectedFields, dnsrecord.FieldValues)
				fieldSeen[dnsrecord.FieldValues] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[dnsrecord.FieldType]; !ok {
				selectedFields = append(selectedFields, dnsrecord.FieldType)
				fieldSeen[dnsrecord.FieldType] = struct{}{}
			}
		case "zone":
			if _, ok := fieldSeen[dnsrecord.FieldZone]; !ok {
				selectedFields = append(selectedFields, dnsrecord.FieldZone)
				fieldSeen[dnsrecord.FieldZone] = struct{}{}
			}
		case "vars":
			if _, ok := fieldSeen[dnsrecord.FieldVars]; !ok {
				selectedFields = append(selectedFields, dnsrecord.FieldVars)
				fieldSeen[dnsrecord.FieldVars] = struct{}{}
			}
		case "disabled":
			if _, ok := fieldSeen[dnsrecord.FieldDisabled]; !ok {
				selectedFields = append(selectedFields, dnsrecord.FieldDisabled)
				fieldSeen[dnsrecord.FieldDisabled] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[dnsrecord.FieldTags]; !ok {
				selectedFields = append(selectedFields, dnsrecord.FieldTags)
				fieldSeen[dnsrecord.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		dr.Select(selectedFields...)
	}
	return nil
}

type dnsrecordPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DNSRecordPaginateOption
}

func newDNSRecordPaginateArgs(rv map[string]any) *dnsrecordPaginateArgs {
	args := &dnsrecordPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (d *DiskQuery) CollectFields(ctx context.Context, satisfies ...string) (*DiskQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return d, nil
	}
	if err := d.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return d, nil
}

func (d *DiskQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(disk.Columns))
		selectedFields = []string{disk.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "disktohost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HostClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			d.withDiskToHost = query
		case "size":
			if _, ok := fieldSeen[disk.FieldSize]; !ok {
				selectedFields = append(selectedFields, disk.FieldSize)
				fieldSeen[disk.FieldSize] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		d.Select(selectedFields...)
	}
	return nil
}

type diskPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DiskPaginateOption
}

func newDiskPaginateArgs(rv map[string]any) *diskPaginateArgs {
	args := &diskPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (e *EnvironmentQuery) CollectFields(ctx context.Context, satisfies ...string) (*EnvironmentQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return e, nil
	}
	if err := e.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return e, nil
}

func (e *EnvironmentQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(environment.Columns))
		selectedFields = []string{environment.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "environmenttouser":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedEnvironmentToUser(alias, func(wq *UserQuery) {
				*wq = *query
			})
		case "environmenttohost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HostClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedEnvironmentToHost(alias, func(wq *HostQuery) {
				*wq = *query
			})
		case "environmenttocompetition":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompetitionClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedEnvironmentToCompetition(alias, func(wq *CompetitionQuery) {
				*wq = *query
			})
		case "environmenttoidentity":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&IdentityClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedEnvironmentToIdentity(alias, func(wq *IdentityQuery) {
				*wq = *query
			})
		case "environmenttocommand":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CommandClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedEnvironmentToCommand(alias, func(wq *CommandQuery) {
				*wq = *query
			})
		case "environmenttoscript":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ScriptClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedEnvironmentToScript(alias, func(wq *ScriptQuery) {
				*wq = *query
			})
		case "environmenttofiledownload":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileDownloadClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedEnvironmentToFileDownload(alias, func(wq *FileDownloadQuery) {
				*wq = *query
			})
		case "environmenttofiledelete":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileDeleteClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedEnvironmentToFileDelete(alias, func(wq *FileDeleteQuery) {
				*wq = *query
			})
		case "environmenttofileextract":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileExtractClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedEnvironmentToFileExtract(alias, func(wq *FileExtractQuery) {
				*wq = *query
			})
		case "environmenttoincludednetwork":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&IncludedNetworkClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedEnvironmentToIncludedNetwork(alias, func(wq *IncludedNetworkQuery) {
				*wq = *query
			})
		case "environmenttofinding":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FindingClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedEnvironmentToFinding(alias, func(wq *FindingQuery) {
				*wq = *query
			})
		case "environmenttodnsrecord":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DNSRecordClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedEnvironmentToDNSRecord(alias, func(wq *DNSRecordQuery) {
				*wq = *query
			})
		case "environmenttodns":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DNSClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedEnvironmentToDNS(alias, func(wq *DNSQuery) {
				*wq = *query
			})
		case "environmenttonetwork":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NetworkClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedEnvironmentToNetwork(alias, func(wq *NetworkQuery) {
				*wq = *query
			})
		case "environmenttohostdependency":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HostDependencyClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedEnvironmentToHostDependency(alias, func(wq *HostDependencyQuery) {
				*wq = *query
			})
		case "environmenttoansible":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AnsibleClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedEnvironmentToAnsible(alias, func(wq *AnsibleQuery) {
				*wq = *query
			})
		case "environmenttobuild":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedEnvironmentToBuild(alias, func(wq *BuildQuery) {
				*wq = *query
			})
		case "environmenttorepository":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RepositoryClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedEnvironmentToRepository(alias, func(wq *RepositoryQuery) {
				*wq = *query
			})
		case "environmenttoservertask":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ServerTaskClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedEnvironmentToServerTask(alias, func(wq *ServerTaskQuery) {
				*wq = *query
			})
		case "hclID":
			if _, ok := fieldSeen[environment.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, environment.FieldHCLID)
				fieldSeen[environment.FieldHCLID] = struct{}{}
			}
		case "competitionID":
			if _, ok := fieldSeen[environment.FieldCompetitionID]; !ok {
				selectedFields = append(selectedFields, environment.FieldCompetitionID)
				fieldSeen[environment.FieldCompetitionID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[environment.FieldName]; !ok {
				selectedFields = append(selectedFields, environment.FieldName)
				fieldSeen[environment.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[environment.FieldDescription]; !ok {
				selectedFields = append(selectedFields, environment.FieldDescription)
				fieldSeen[environment.FieldDescription] = struct{}{}
			}
		case "builder":
			if _, ok := fieldSeen[environment.FieldBuilder]; !ok {
				selectedFields = append(selectedFields, environment.FieldBuilder)
				fieldSeen[environment.FieldBuilder] = struct{}{}
			}
		case "teamCount":
			if _, ok := fieldSeen[environment.FieldTeamCount]; !ok {
				selectedFields = append(selectedFields, environment.FieldTeamCount)
				fieldSeen[environment.FieldTeamCount] = struct{}{}
			}
		case "revision":
			if _, ok := fieldSeen[environment.FieldRevision]; !ok {
				selectedFields = append(selectedFields, environment.FieldRevision)
				fieldSeen[environment.FieldRevision] = struct{}{}
			}
		case "adminCidrs":
			if _, ok := fieldSeen[environment.FieldAdminCidrs]; !ok {
				selectedFields = append(selectedFields, environment.FieldAdminCidrs)
				fieldSeen[environment.FieldAdminCidrs] = struct{}{}
			}
		case "exposedVdiPorts":
			if _, ok := fieldSeen[environment.FieldExposedVdiPorts]; !ok {
				selectedFields = append(selectedFields, environment.FieldExposedVdiPorts)
				fieldSeen[environment.FieldExposedVdiPorts] = struct{}{}
			}
		case "config":
			if _, ok := fieldSeen[environment.FieldConfig]; !ok {
				selectedFields = append(selectedFields, environment.FieldConfig)
				fieldSeen[environment.FieldConfig] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[environment.FieldTags]; !ok {
				selectedFields = append(selectedFields, environment.FieldTags)
				fieldSeen[environment.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		e.Select(selectedFields...)
	}
	return nil
}

type environmentPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EnvironmentPaginateOption
}

func newEnvironmentPaginateArgs(rv map[string]any) *environmentPaginateArgs {
	args := &environmentPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (fd *FileDeleteQuery) CollectFields(ctx context.Context, satisfies ...string) (*FileDeleteQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return fd, nil
	}
	if err := fd.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return fd, nil
}

func (fd *FileDeleteQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(filedelete.Columns))
		selectedFields = []string{filedelete.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "filedeletetoenvironment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: fd.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			fd.withFileDeleteToEnvironment = query
		case "hclID":
			if _, ok := fieldSeen[filedelete.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, filedelete.FieldHCLID)
				fieldSeen[filedelete.FieldHCLID] = struct{}{}
			}
		case "path":
			if _, ok := fieldSeen[filedelete.FieldPath]; !ok {
				selectedFields = append(selectedFields, filedelete.FieldPath)
				fieldSeen[filedelete.FieldPath] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[filedelete.FieldTags]; !ok {
				selectedFields = append(selectedFields, filedelete.FieldTags)
				fieldSeen[filedelete.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		fd.Select(selectedFields...)
	}
	return nil
}

type filedeletePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []FileDeletePaginateOption
}

func newFileDeletePaginateArgs(rv map[string]any) *filedeletePaginateArgs {
	args := &filedeletePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (fd *FileDownloadQuery) CollectFields(ctx context.Context, satisfies ...string) (*FileDownloadQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return fd, nil
	}
	if err := fd.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return fd, nil
}

func (fd *FileDownloadQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(filedownload.Columns))
		selectedFields = []string{filedownload.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "filedownloadtoenvironment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: fd.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			fd.withFileDownloadToEnvironment = query
		case "hclID":
			if _, ok := fieldSeen[filedownload.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, filedownload.FieldHCLID)
				fieldSeen[filedownload.FieldHCLID] = struct{}{}
			}
		case "sourceType":
			if _, ok := fieldSeen[filedownload.FieldSourceType]; !ok {
				selectedFields = append(selectedFields, filedownload.FieldSourceType)
				fieldSeen[filedownload.FieldSourceType] = struct{}{}
			}
		case "source":
			if _, ok := fieldSeen[filedownload.FieldSource]; !ok {
				selectedFields = append(selectedFields, filedownload.FieldSource)
				fieldSeen[filedownload.FieldSource] = struct{}{}
			}
		case "destination":
			if _, ok := fieldSeen[filedownload.FieldDestination]; !ok {
				selectedFields = append(selectedFields, filedownload.FieldDestination)
				fieldSeen[filedownload.FieldDestination] = struct{}{}
			}
		case "template":
			if _, ok := fieldSeen[filedownload.FieldTemplate]; !ok {
				selectedFields = append(selectedFields, filedownload.FieldTemplate)
				fieldSeen[filedownload.FieldTemplate] = struct{}{}
			}
		case "perms":
			if _, ok := fieldSeen[filedownload.FieldPerms]; !ok {
				selectedFields = append(selectedFields, filedownload.FieldPerms)
				fieldSeen[filedownload.FieldPerms] = struct{}{}
			}
		case "disabled":
			if _, ok := fieldSeen[filedownload.FieldDisabled]; !ok {
				selectedFields = append(selectedFields, filedownload.FieldDisabled)
				fieldSeen[filedownload.FieldDisabled] = struct{}{}
			}
		case "md5":
			if _, ok := fieldSeen[filedownload.FieldMd5]; !ok {
				selectedFields = append(selectedFields, filedownload.FieldMd5)
				fieldSeen[filedownload.FieldMd5] = struct{}{}
			}
		case "absPath":
			if _, ok := fieldSeen[filedownload.FieldAbsPath]; !ok {
				selectedFields = append(selectedFields, filedownload.FieldAbsPath)
				fieldSeen[filedownload.FieldAbsPath] = struct{}{}
			}
		case "isTxt":
			if _, ok := fieldSeen[filedownload.FieldIsTxt]; !ok {
				selectedFields = append(selectedFields, filedownload.FieldIsTxt)
				fieldSeen[filedownload.FieldIsTxt] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[filedownload.FieldTags]; !ok {
				selectedFields = append(selectedFields, filedownload.FieldTags)
				fieldSeen[filedownload.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		fd.Select(selectedFields...)
	}
	return nil
}

type filedownloadPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []FileDownloadPaginateOption
}

func newFileDownloadPaginateArgs(rv map[string]any) *filedownloadPaginateArgs {
	args := &filedownloadPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (fe *FileExtractQuery) CollectFields(ctx context.Context, satisfies ...string) (*FileExtractQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return fe, nil
	}
	if err := fe.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return fe, nil
}

func (fe *FileExtractQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(fileextract.Columns))
		selectedFields = []string{fileextract.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "fileextracttoenvironment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: fe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			fe.withFileExtractToEnvironment = query
		case "hclID":
			if _, ok := fieldSeen[fileextract.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, fileextract.FieldHCLID)
				fieldSeen[fileextract.FieldHCLID] = struct{}{}
			}
		case "source":
			if _, ok := fieldSeen[fileextract.FieldSource]; !ok {
				selectedFields = append(selectedFields, fileextract.FieldSource)
				fieldSeen[fileextract.FieldSource] = struct{}{}
			}
		case "destination":
			if _, ok := fieldSeen[fileextract.FieldDestination]; !ok {
				selectedFields = append(selectedFields, fileextract.FieldDestination)
				fieldSeen[fileextract.FieldDestination] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[fileextract.FieldType]; !ok {
				selectedFields = append(selectedFields, fileextract.FieldType)
				fieldSeen[fileextract.FieldType] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[fileextract.FieldTags]; !ok {
				selectedFields = append(selectedFields, fileextract.FieldTags)
				fieldSeen[fileextract.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		fe.Select(selectedFields...)
	}
	return nil
}

type fileextractPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []FileExtractPaginateOption
}

func newFileExtractPaginateArgs(rv map[string]any) *fileextractPaginateArgs {
	args := &fileextractPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (f *FindingQuery) CollectFields(ctx context.Context, satisfies ...string) (*FindingQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return f, nil
	}
	if err := f.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return f, nil
}

func (f *FindingQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(finding.Columns))
		selectedFields = []string{finding.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "findingtouser":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			f.WithNamedFindingToUser(alias, func(wq *UserQuery) {
				*wq = *query
			})
		case "findingtohost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HostClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			f.withFindingToHost = query
		case "findingtoscript":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ScriptClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			f.withFindingToScript = query
		case "findingtoenvironment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			f.withFindingToEnvironment = query
		case "name":
			if _, ok := fieldSeen[finding.FieldName]; !ok {
				selectedFields = append(selectedFields, finding.FieldName)
				fieldSeen[finding.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[finding.FieldDescription]; !ok {
				selectedFields = append(selectedFields, finding.FieldDescription)
				fieldSeen[finding.FieldDescription] = struct{}{}
			}
		case "severity":
			if _, ok := fieldSeen[finding.FieldSeverity]; !ok {
				selectedFields = append(selectedFields, finding.FieldSeverity)
				fieldSeen[finding.FieldSeverity] = struct{}{}
			}
		case "difficulty":
			if _, ok := fieldSeen[finding.FieldDifficulty]; !ok {
				selectedFields = append(selectedFields, finding.FieldDifficulty)
				fieldSeen[finding.FieldDifficulty] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[finding.FieldTags]; !ok {
				selectedFields = append(selectedFields, finding.FieldTags)
				fieldSeen[finding.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		f.Select(selectedFields...)
	}
	return nil
}

type findingPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []FindingPaginateOption
}

func newFindingPaginateArgs(rv map[string]any) *findingPaginateArgs {
	args := &findingPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (gfm *GinFileMiddlewareQuery) CollectFields(ctx context.Context, satisfies ...string) (*GinFileMiddlewareQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return gfm, nil
	}
	if err := gfm.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return gfm, nil
}

func (gfm *GinFileMiddlewareQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(ginfilemiddleware.Columns))
		selectedFields = []string{ginfilemiddleware.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "ginfilemiddlewaretoprovisionedhost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedHostClient{config: gfm.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			gfm.withGinFileMiddlewareToProvisionedHost = query
		case "ginfilemiddlewaretoprovisioningstep":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisioningStepClient{config: gfm.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			gfm.withGinFileMiddlewareToProvisioningStep = query
		case "urlID":
			if _, ok := fieldSeen[ginfilemiddleware.FieldURLID]; !ok {
				selectedFields = append(selectedFields, ginfilemiddleware.FieldURLID)
				fieldSeen[ginfilemiddleware.FieldURLID] = struct{}{}
			}
		case "filePath":
			if _, ok := fieldSeen[ginfilemiddleware.FieldFilePath]; !ok {
				selectedFields = append(selectedFields, ginfilemiddleware.FieldFilePath)
				fieldSeen[ginfilemiddleware.FieldFilePath] = struct{}{}
			}
		case "accessed":
			if _, ok := fieldSeen[ginfilemiddleware.FieldAccessed]; !ok {
				selectedFields = append(selectedFields, ginfilemiddleware.FieldAccessed)
				fieldSeen[ginfilemiddleware.FieldAccessed] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		gfm.Select(selectedFields...)
	}
	return nil
}

type ginfilemiddlewarePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []GinFileMiddlewarePaginateOption
}

func newGinFileMiddlewarePaginateArgs(rv map[string]any) *ginfilemiddlewarePaginateArgs {
	args := &ginfilemiddlewarePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (h *HostQuery) CollectFields(ctx context.Context, satisfies ...string) (*HostQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return h, nil
	}
	if err := h.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return h, nil
}

func (h *HostQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(host.Columns))
		selectedFields = []string{host.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "hosttodisk":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DiskClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			h.withHostToDisk = query
		case "hosttouser":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			h.WithNamedHostToUser(alias, func(wq *UserQuery) {
				*wq = *query
			})
		case "hosttoenvironment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			h.withHostToEnvironment = query
		case "hosttoincludednetwork":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&IncludedNetworkClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			h.WithNamedHostToIncludedNetwork(alias, func(wq *IncludedNetworkQuery) {
				*wq = *query
			})
		case "dependonhosttohostdependency":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HostDependencyClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			h.WithNamedDependOnHostToHostDependency(alias, func(wq *HostDependencyQuery) {
				*wq = *query
			})
		case "dependbyhosttohostdependency":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HostDependencyClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			h.WithNamedDependByHostToHostDependency(alias, func(wq *HostDependencyQuery) {
				*wq = *query
			})
		case "hclID":
			if _, ok := fieldSeen[host.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, host.FieldHCLID)
				fieldSeen[host.FieldHCLID] = struct{}{}
			}
		case "hostname":
			if _, ok := fieldSeen[host.FieldHostname]; !ok {
				selectedFields = append(selectedFields, host.FieldHostname)
				fieldSeen[host.FieldHostname] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[host.FieldDescription]; !ok {
				selectedFields = append(selectedFields, host.FieldDescription)
				fieldSeen[host.FieldDescription] = struct{}{}
			}
		case "os":
			if _, ok := fieldSeen[host.FieldOS]; !ok {
				selectedFields = append(selectedFields, host.FieldOS)
				fieldSeen[host.FieldOS] = struct{}{}
			}
		case "lastOctet":
			if _, ok := fieldSeen[host.FieldLastOctet]; !ok {
				selectedFields = append(selectedFields, host.FieldLastOctet)
				fieldSeen[host.FieldLastOctet] = struct{}{}
			}
		case "instanceSize":
			if _, ok := fieldSeen[host.FieldInstanceSize]; !ok {
				selectedFields = append(selectedFields, host.FieldInstanceSize)
				fieldSeen[host.FieldInstanceSize] = struct{}{}
			}
		case "allowMACChanges":
			if _, ok := fieldSeen[host.FieldAllowMACChanges]; !ok {
				selectedFields = append(selectedFields, host.FieldAllowMACChanges)
				fieldSeen[host.FieldAllowMACChanges] = struct{}{}
			}
		case "exposedTCPPorts":
			if _, ok := fieldSeen[host.FieldExposedTCPPorts]; !ok {
				selectedFields = append(selectedFields, host.FieldExposedTCPPorts)
				fieldSeen[host.FieldExposedTCPPorts] = struct{}{}
			}
		case "exposedUDPPorts":
			if _, ok := fieldSeen[host.FieldExposedUDPPorts]; !ok {
				selectedFields = append(selectedFields, host.FieldExposedUDPPorts)
				fieldSeen[host.FieldExposedUDPPorts] = struct{}{}
			}
		case "overridePassword":
			if _, ok := fieldSeen[host.FieldOverridePassword]; !ok {
				selectedFields = append(selectedFields, host.FieldOverridePassword)
				fieldSeen[host.FieldOverridePassword] = struct{}{}
			}
		case "vars":
			if _, ok := fieldSeen[host.FieldVars]; !ok {
				selectedFields = append(selectedFields, host.FieldVars)
				fieldSeen[host.FieldVars] = struct{}{}
			}
		case "userGroups":
			if _, ok := fieldSeen[host.FieldUserGroups]; !ok {
				selectedFields = append(selectedFields, host.FieldUserGroups)
				fieldSeen[host.FieldUserGroups] = struct{}{}
			}
		case "provisionSteps":
			if _, ok := fieldSeen[host.FieldProvisionSteps]; !ok {
				selectedFields = append(selectedFields, host.FieldProvisionSteps)
				fieldSeen[host.FieldProvisionSteps] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[host.FieldTags]; !ok {
				selectedFields = append(selectedFields, host.FieldTags)
				fieldSeen[host.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		h.Select(selectedFields...)
	}
	return nil
}

type hostPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HostPaginateOption
}

func newHostPaginateArgs(rv map[string]any) *hostPaginateArgs {
	args := &hostPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (hd *HostDependencyQuery) CollectFields(ctx context.Context, satisfies ...string) (*HostDependencyQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return hd, nil
	}
	if err := hd.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return hd, nil
}

func (hd *HostDependencyQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hostdependency.Columns))
		selectedFields = []string{hostdependency.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "hostdependencytodependonhost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HostClient{config: hd.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hd.withHostDependencyToDependOnHost = query
		case "hostdependencytodependbyhost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HostClient{config: hd.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hd.withHostDependencyToDependByHost = query
		case "hostdependencytonetwork":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NetworkClient{config: hd.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hd.withHostDependencyToNetwork = query
		case "hostdependencytoenvironment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: hd.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hd.withHostDependencyToEnvironment = query
		case "hostID":
			if _, ok := fieldSeen[hostdependency.FieldHostID]; !ok {
				selectedFields = append(selectedFields, hostdependency.FieldHostID)
				fieldSeen[hostdependency.FieldHostID] = struct{}{}
			}
		case "networkID":
			if _, ok := fieldSeen[hostdependency.FieldNetworkID]; !ok {
				selectedFields = append(selectedFields, hostdependency.FieldNetworkID)
				fieldSeen[hostdependency.FieldNetworkID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		hd.Select(selectedFields...)
	}
	return nil
}

type hostdependencyPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HostDependencyPaginateOption
}

func newHostDependencyPaginateArgs(rv map[string]any) *hostdependencyPaginateArgs {
	args := &hostdependencyPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (i *IdentityQuery) CollectFields(ctx context.Context, satisfies ...string) (*IdentityQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return i, nil
	}
	if err := i.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return i, nil
}

func (i *IdentityQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(identity.Columns))
		selectedFields = []string{identity.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "identitytoenvironment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: i.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			i.withIdentityToEnvironment = query
		case "hclID":
			if _, ok := fieldSeen[identity.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, identity.FieldHCLID)
				fieldSeen[identity.FieldHCLID] = struct{}{}
			}
		case "firstName":
			if _, ok := fieldSeen[identity.FieldFirstName]; !ok {
				selectedFields = append(selectedFields, identity.FieldFirstName)
				fieldSeen[identity.FieldFirstName] = struct{}{}
			}
		case "lastName":
			if _, ok := fieldSeen[identity.FieldLastName]; !ok {
				selectedFields = append(selectedFields, identity.FieldLastName)
				fieldSeen[identity.FieldLastName] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[identity.FieldEmail]; !ok {
				selectedFields = append(selectedFields, identity.FieldEmail)
				fieldSeen[identity.FieldEmail] = struct{}{}
			}
		case "password":
			if _, ok := fieldSeen[identity.FieldPassword]; !ok {
				selectedFields = append(selectedFields, identity.FieldPassword)
				fieldSeen[identity.FieldPassword] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[identity.FieldDescription]; !ok {
				selectedFields = append(selectedFields, identity.FieldDescription)
				fieldSeen[identity.FieldDescription] = struct{}{}
			}
		case "avatarFile":
			if _, ok := fieldSeen[identity.FieldAvatarFile]; !ok {
				selectedFields = append(selectedFields, identity.FieldAvatarFile)
				fieldSeen[identity.FieldAvatarFile] = struct{}{}
			}
		case "vars":
			if _, ok := fieldSeen[identity.FieldVars]; !ok {
				selectedFields = append(selectedFields, identity.FieldVars)
				fieldSeen[identity.FieldVars] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[identity.FieldTags]; !ok {
				selectedFields = append(selectedFields, identity.FieldTags)
				fieldSeen[identity.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		i.Select(selectedFields...)
	}
	return nil
}

type identityPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []IdentityPaginateOption
}

func newIdentityPaginateArgs(rv map[string]any) *identityPaginateArgs {
	args := &identityPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (in *IncludedNetworkQuery) CollectFields(ctx context.Context, satisfies ...string) (*IncludedNetworkQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return in, nil
	}
	if err := in.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return in, nil
}

func (in *IncludedNetworkQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(includednetwork.Columns))
		selectedFields = []string{includednetwork.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "includednetworktotag":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TagClient{config: in.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			in.WithNamedIncludedNetworkToTag(alias, func(wq *TagQuery) {
				*wq = *query
			})
		case "includednetworktohost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HostClient{config: in.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			in.WithNamedIncludedNetworkToHost(alias, func(wq *HostQuery) {
				*wq = *query
			})
		case "includednetworktonetwork":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NetworkClient{config: in.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			in.withIncludedNetworkToNetwork = query
		case "includednetworktoenvironment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: in.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			in.WithNamedIncludedNetworkToEnvironment(alias, func(wq *EnvironmentQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[includednetwork.FieldName]; !ok {
				selectedFields = append(selectedFields, includednetwork.FieldName)
				fieldSeen[includednetwork.FieldName] = struct{}{}
			}
		case "hosts":
			if _, ok := fieldSeen[includednetwork.FieldHosts]; !ok {
				selectedFields = append(selectedFields, includednetwork.FieldHosts)
				fieldSeen[includednetwork.FieldHosts] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		in.Select(selectedFields...)
	}
	return nil
}

type includednetworkPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []IncludedNetworkPaginateOption
}

func newIncludedNetworkPaginateArgs(rv map[string]any) *includednetworkPaginateArgs {
	args := &includednetworkPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (n *NetworkQuery) CollectFields(ctx context.Context, satisfies ...string) (*NetworkQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return n, nil
	}
	if err := n.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return n, nil
}

func (n *NetworkQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(network.Columns))
		selectedFields = []string{network.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "networktoenvironment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			n.withNetworkToEnvironment = query
		case "networktohostdependency":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HostDependencyClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			n.WithNamedNetworkToHostDependency(alias, func(wq *HostDependencyQuery) {
				*wq = *query
			})
		case "networktoincludednetwork":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&IncludedNetworkClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			n.WithNamedNetworkToIncludedNetwork(alias, func(wq *IncludedNetworkQuery) {
				*wq = *query
			})
		case "hclID":
			if _, ok := fieldSeen[network.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, network.FieldHCLID)
				fieldSeen[network.FieldHCLID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[network.FieldName]; !ok {
				selectedFields = append(selectedFields, network.FieldName)
				fieldSeen[network.FieldName] = struct{}{}
			}
		case "cidr":
			if _, ok := fieldSeen[network.FieldCidr]; !ok {
				selectedFields = append(selectedFields, network.FieldCidr)
				fieldSeen[network.FieldCidr] = struct{}{}
			}
		case "vdiVisible":
			if _, ok := fieldSeen[network.FieldVdiVisible]; !ok {
				selectedFields = append(selectedFields, network.FieldVdiVisible)
				fieldSeen[network.FieldVdiVisible] = struct{}{}
			}
		case "vars":
			if _, ok := fieldSeen[network.FieldVars]; !ok {
				selectedFields = append(selectedFields, network.FieldVars)
				fieldSeen[network.FieldVars] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[network.FieldTags]; !ok {
				selectedFields = append(selectedFields, network.FieldTags)
				fieldSeen[network.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		n.Select(selectedFields...)
	}
	return nil
}

type networkPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []NetworkPaginateOption
}

func newNetworkPaginateArgs(rv map[string]any) *networkPaginateArgs {
	args := &networkPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pl *PlanQuery) CollectFields(ctx context.Context, satisfies ...string) (*PlanQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pl, nil
	}
	if err := pl.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pl, nil
}

func (pl *PlanQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(plan.Columns))
		selectedFields = []string{plan.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "prevplan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pl.WithNamedPrevPlan(alias, func(wq *PlanQuery) {
				*wq = *query
			})
		case "nextplan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pl.WithNamedNextPlan(alias, func(wq *PlanQuery) {
				*wq = *query
			})
		case "plantobuild":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pl.withPlanToBuild = query
		case "plantoteam":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TeamClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pl.withPlanToTeam = query
		case "plantoprovisionednetwork":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedNetworkClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pl.withPlanToProvisionedNetwork = query
		case "plantoprovisionedhost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedHostClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pl.withPlanToProvisionedHost = query
		case "plantoprovisioningstep":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisioningStepClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pl.withPlanToProvisioningStep = query
		case "plantostatus":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&StatusClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pl.withPlanToStatus = query
		case "plantoplandiffs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanDiffClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pl.WithNamedPlanToPlanDiffs(alias, func(wq *PlanDiffQuery) {
				*wq = *query
			})
		case "stepNumber":
			if _, ok := fieldSeen[plan.FieldStepNumber]; !ok {
				selectedFields = append(selectedFields, plan.FieldStepNumber)
				fieldSeen[plan.FieldStepNumber] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[plan.FieldType]; !ok {
				selectedFields = append(selectedFields, plan.FieldType)
				fieldSeen[plan.FieldType] = struct{}{}
			}
		case "buildID":
			if _, ok := fieldSeen[plan.FieldBuildID]; !ok {
				selectedFields = append(selectedFields, plan.FieldBuildID)
				fieldSeen[plan.FieldBuildID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pl.Select(selectedFields...)
	}
	return nil
}

type planPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PlanPaginateOption
}

func newPlanPaginateArgs(rv map[string]any) *planPaginateArgs {
	args := &planPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pd *PlanDiffQuery) CollectFields(ctx context.Context, satisfies ...string) (*PlanDiffQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pd, nil
	}
	if err := pd.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pd, nil
}

func (pd *PlanDiffQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(plandiff.Columns))
		selectedFields = []string{plandiff.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "plandifftobuildcommit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildCommitClient{config: pd.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pd.withPlanDiffToBuildCommit = query
		case "plandifftoplan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanClient{config: pd.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pd.withPlanDiffToPlan = query
		case "revision":
			if _, ok := fieldSeen[plandiff.FieldRevision]; !ok {
				selectedFields = append(selectedFields, plandiff.FieldRevision)
				fieldSeen[plandiff.FieldRevision] = struct{}{}
			}
		case "newState":
			if _, ok := fieldSeen[plandiff.FieldNewState]; !ok {
				selectedFields = append(selectedFields, plandiff.FieldNewState)
				fieldSeen[plandiff.FieldNewState] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pd.Select(selectedFields...)
	}
	return nil
}

type plandiffPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PlanDiffPaginateOption
}

func newPlanDiffPaginateArgs(rv map[string]any) *plandiffPaginateArgs {
	args := &plandiffPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ph *ProvisionedHostQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProvisionedHostQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ph, nil
	}
	if err := ph.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ph, nil
}

func (ph *ProvisionedHostQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(provisionedhost.Columns))
		selectedFields = []string{provisionedhost.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "provisionedhosttostatus":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&StatusClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ph.withProvisionedHostToStatus = query
		case "provisionedhosttoprovisionednetwork":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedNetworkClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ph.withProvisionedHostToProvisionedNetwork = query
		case "provisionedhosttohost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HostClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ph.withProvisionedHostToHost = query
		case "provisionedhosttoendstepplan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ph.withProvisionedHostToEndStepPlan = query
		case "provisionedhosttobuild":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ph.withProvisionedHostToBuild = query
		case "provisionedhosttoprovisioningstep":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisioningStepClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ph.WithNamedProvisionedHostToProvisioningStep(alias, func(wq *ProvisioningStepQuery) {
				*wq = *query
			})
		case "provisionedhosttoagentstatus":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AgentStatusClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ph.WithNamedProvisionedHostToAgentStatus(alias, func(wq *AgentStatusQuery) {
				*wq = *query
			})
		case "provisionedhosttoagenttask":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AgentTaskClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ph.WithNamedProvisionedHostToAgentTask(alias, func(wq *AgentTaskQuery) {
				*wq = *query
			})
		case "provisionedhosttoplan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ph.withProvisionedHostToPlan = query
		case "provisionedhosttoginfilemiddleware":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GinFileMiddlewareClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ph.withProvisionedHostToGinFileMiddleware = query
		case "subnetIP":
			if _, ok := fieldSeen[provisionedhost.FieldSubnetIP]; !ok {
				selectedFields = append(selectedFields, provisionedhost.FieldSubnetIP)
				fieldSeen[provisionedhost.FieldSubnetIP] = struct{}{}
			}
		case "addonType":
			if _, ok := fieldSeen[provisionedhost.FieldAddonType]; !ok {
				selectedFields = append(selectedFields, provisionedhost.FieldAddonType)
				fieldSeen[provisionedhost.FieldAddonType] = struct{}{}
			}
		case "vars":
			if _, ok := fieldSeen[provisionedhost.FieldVars]; !ok {
				selectedFields = append(selectedFields, provisionedhost.FieldVars)
				fieldSeen[provisionedhost.FieldVars] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ph.Select(selectedFields...)
	}
	return nil
}

type provisionedhostPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProvisionedHostPaginateOption
}

func newProvisionedHostPaginateArgs(rv map[string]any) *provisionedhostPaginateArgs {
	args := &provisionedhostPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pn *ProvisionedNetworkQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProvisionedNetworkQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pn, nil
	}
	if err := pn.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pn, nil
}

func (pn *ProvisionedNetworkQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(provisionednetwork.Columns))
		selectedFields = []string{provisionednetwork.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "provisionednetworktostatus":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&StatusClient{config: pn.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pn.withProvisionedNetworkToStatus = query
		case "provisionednetworktonetwork":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NetworkClient{config: pn.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pn.withProvisionedNetworkToNetwork = query
		case "provisionednetworktobuild":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildClient{config: pn.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pn.withProvisionedNetworkToBuild = query
		case "provisionednetworktoteam":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TeamClient{config: pn.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pn.withProvisionedNetworkToTeam = query
		case "provisionednetworktoprovisionedhost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedHostClient{config: pn.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pn.WithNamedProvisionedNetworkToProvisionedHost(alias, func(wq *ProvisionedHostQuery) {
				*wq = *query
			})
		case "provisionednetworktoplan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanClient{config: pn.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pn.withProvisionedNetworkToPlan = query
		case "name":
			if _, ok := fieldSeen[provisionednetwork.FieldName]; !ok {
				selectedFields = append(selectedFields, provisionednetwork.FieldName)
				fieldSeen[provisionednetwork.FieldName] = struct{}{}
			}
		case "cidr":
			if _, ok := fieldSeen[provisionednetwork.FieldCidr]; !ok {
				selectedFields = append(selectedFields, provisionednetwork.FieldCidr)
				fieldSeen[provisionednetwork.FieldCidr] = struct{}{}
			}
		case "vars":
			if _, ok := fieldSeen[provisionednetwork.FieldVars]; !ok {
				selectedFields = append(selectedFields, provisionednetwork.FieldVars)
				fieldSeen[provisionednetwork.FieldVars] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pn.Select(selectedFields...)
	}
	return nil
}

type provisionednetworkPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProvisionedNetworkPaginateOption
}

func newProvisionedNetworkPaginateArgs(rv map[string]any) *provisionednetworkPaginateArgs {
	args := &provisionednetworkPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ps *ProvisioningStepQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProvisioningStepQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ps, nil
	}
	if err := ps.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ps, nil
}

func (ps *ProvisioningStepQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(provisioningstep.Columns))
		selectedFields = []string{provisioningstep.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "provisioningsteptostatus":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&StatusClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.withProvisioningStepToStatus = query
		case "provisioningsteptoprovisionedhost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedHostClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.withProvisioningStepToProvisionedHost = query
		case "provisioningsteptoscript":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ScriptClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.withProvisioningStepToScript = query
		case "provisioningsteptocommand":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CommandClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.withProvisioningStepToCommand = query
		case "provisioningsteptodnsrecord":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DNSRecordClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.withProvisioningStepToDNSRecord = query
		case "provisioningsteptofiledelete":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileDeleteClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.withProvisioningStepToFileDelete = query
		case "provisioningsteptofiledownload":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileDownloadClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.withProvisioningStepToFileDownload = query
		case "provisioningsteptofileextract":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileExtractClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.withProvisioningStepToFileExtract = query
		case "provisioningsteptoansible":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AnsibleClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.withProvisioningStepToAnsible = query
		case "provisioningsteptoplan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.withProvisioningStepToPlan = query
		case "provisioningsteptoagenttask":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AgentTaskClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.WithNamedProvisioningStepToAgentTask(alias, func(wq *AgentTaskQuery) {
				*wq = *query
			})
		case "provisioningsteptoginfilemiddleware":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GinFileMiddlewareClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.withProvisioningStepToGinFileMiddleware = query
		case "type":
			if _, ok := fieldSeen[provisioningstep.FieldType]; !ok {
				selectedFields = append(selectedFields, provisioningstep.FieldType)
				fieldSeen[provisioningstep.FieldType] = struct{}{}
			}
		case "stepNumber":
			if _, ok := fieldSeen[provisioningstep.FieldStepNumber]; !ok {
				selectedFields = append(selectedFields, provisioningstep.FieldStepNumber)
				fieldSeen[provisioningstep.FieldStepNumber] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ps.Select(selectedFields...)
	}
	return nil
}

type provisioningstepPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProvisioningStepPaginateOption
}

func newProvisioningStepPaginateArgs(rv map[string]any) *provisioningstepPaginateArgs {
	args := &provisioningstepPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (rc *RepoCommitQuery) CollectFields(ctx context.Context, satisfies ...string) (*RepoCommitQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return rc, nil
	}
	if err := rc.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return rc, nil
}

func (rc *RepoCommitQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(repocommit.Columns))
		selectedFields = []string{repocommit.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "repocommittorepository":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RepositoryClient{config: rc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			rc.withRepoCommitToRepository = query
		case "revision":
			if _, ok := fieldSeen[repocommit.FieldRevision]; !ok {
				selectedFields = append(selectedFields, repocommit.FieldRevision)
				fieldSeen[repocommit.FieldRevision] = struct{}{}
			}
		case "hash":
			if _, ok := fieldSeen[repocommit.FieldHash]; !ok {
				selectedFields = append(selectedFields, repocommit.FieldHash)
				fieldSeen[repocommit.FieldHash] = struct{}{}
			}
		case "author":
			if _, ok := fieldSeen[repocommit.FieldAuthor]; !ok {
				selectedFields = append(selectedFields, repocommit.FieldAuthor)
				fieldSeen[repocommit.FieldAuthor] = struct{}{}
			}
		case "committer":
			if _, ok := fieldSeen[repocommit.FieldCommitter]; !ok {
				selectedFields = append(selectedFields, repocommit.FieldCommitter)
				fieldSeen[repocommit.FieldCommitter] = struct{}{}
			}
		case "pgpSignature":
			if _, ok := fieldSeen[repocommit.FieldPgpSignature]; !ok {
				selectedFields = append(selectedFields, repocommit.FieldPgpSignature)
				fieldSeen[repocommit.FieldPgpSignature] = struct{}{}
			}
		case "message":
			if _, ok := fieldSeen[repocommit.FieldMessage]; !ok {
				selectedFields = append(selectedFields, repocommit.FieldMessage)
				fieldSeen[repocommit.FieldMessage] = struct{}{}
			}
		case "treeHash":
			if _, ok := fieldSeen[repocommit.FieldTreeHash]; !ok {
				selectedFields = append(selectedFields, repocommit.FieldTreeHash)
				fieldSeen[repocommit.FieldTreeHash] = struct{}{}
			}
		case "parentHashes":
			if _, ok := fieldSeen[repocommit.FieldParentHashes]; !ok {
				selectedFields = append(selectedFields, repocommit.FieldParentHashes)
				fieldSeen[repocommit.FieldParentHashes] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		rc.Select(selectedFields...)
	}
	return nil
}

type repocommitPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []RepoCommitPaginateOption
}

func newRepoCommitPaginateArgs(rv map[string]any) *repocommitPaginateArgs {
	args := &repocommitPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (r *RepositoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*RepositoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return r, nil
	}
	if err := r.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return r, nil
}

func (r *RepositoryQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(repository.Columns))
		selectedFields = []string{repository.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "repositorytoenvironment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: r.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			r.WithNamedRepositoryToEnvironment(alias, func(wq *EnvironmentQuery) {
				*wq = *query
			})
		case "repositorytorepocommit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RepoCommitClient{config: r.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			r.WithNamedRepositoryToRepoCommit(alias, func(wq *RepoCommitQuery) {
				*wq = *query
			})
		case "repoURL":
			if _, ok := fieldSeen[repository.FieldRepoURL]; !ok {
				selectedFields = append(selectedFields, repository.FieldRepoURL)
				fieldSeen[repository.FieldRepoURL] = struct{}{}
			}
		case "branchName":
			if _, ok := fieldSeen[repository.FieldBranchName]; !ok {
				selectedFields = append(selectedFields, repository.FieldBranchName)
				fieldSeen[repository.FieldBranchName] = struct{}{}
			}
		case "enviromentFilepath":
			if _, ok := fieldSeen[repository.FieldEnviromentFilepath]; !ok {
				selectedFields = append(selectedFields, repository.FieldEnviromentFilepath)
				fieldSeen[repository.FieldEnviromentFilepath] = struct{}{}
			}
		case "folderPath":
			if _, ok := fieldSeen[repository.FieldFolderPath]; !ok {
				selectedFields = append(selectedFields, repository.FieldFolderPath)
				fieldSeen[repository.FieldFolderPath] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		r.Select(selectedFields...)
	}
	return nil
}

type repositoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []RepositoryPaginateOption
}

func newRepositoryPaginateArgs(rv map[string]any) *repositoryPaginateArgs {
	args := &repositoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (s *ScriptQuery) CollectFields(ctx context.Context, satisfies ...string) (*ScriptQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return s, nil
	}
	if err := s.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *ScriptQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(script.Columns))
		selectedFields = []string{script.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "scripttouser":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.WithNamedScriptToUser(alias, func(wq *UserQuery) {
				*wq = *query
			})
		case "scripttofinding":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FindingClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.WithNamedScriptToFinding(alias, func(wq *FindingQuery) {
				*wq = *query
			})
		case "scripttoenvironment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.withScriptToEnvironment = query
		case "hclID":
			if _, ok := fieldSeen[script.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, script.FieldHCLID)
				fieldSeen[script.FieldHCLID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[script.FieldName]; !ok {
				selectedFields = append(selectedFields, script.FieldName)
				fieldSeen[script.FieldName] = struct{}{}
			}
		case "language":
			if _, ok := fieldSeen[script.FieldLanguage]; !ok {
				selectedFields = append(selectedFields, script.FieldLanguage)
				fieldSeen[script.FieldLanguage] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[script.FieldDescription]; !ok {
				selectedFields = append(selectedFields, script.FieldDescription)
				fieldSeen[script.FieldDescription] = struct{}{}
			}
		case "source":
			if _, ok := fieldSeen[script.FieldSource]; !ok {
				selectedFields = append(selectedFields, script.FieldSource)
				fieldSeen[script.FieldSource] = struct{}{}
			}
		case "sourceType":
			if _, ok := fieldSeen[script.FieldSourceType]; !ok {
				selectedFields = append(selectedFields, script.FieldSourceType)
				fieldSeen[script.FieldSourceType] = struct{}{}
			}
		case "cooldown":
			if _, ok := fieldSeen[script.FieldCooldown]; !ok {
				selectedFields = append(selectedFields, script.FieldCooldown)
				fieldSeen[script.FieldCooldown] = struct{}{}
			}
		case "timeout":
			if _, ok := fieldSeen[script.FieldTimeout]; !ok {
				selectedFields = append(selectedFields, script.FieldTimeout)
				fieldSeen[script.FieldTimeout] = struct{}{}
			}
		case "ignoreErrors":
			if _, ok := fieldSeen[script.FieldIgnoreErrors]; !ok {
				selectedFields = append(selectedFields, script.FieldIgnoreErrors)
				fieldSeen[script.FieldIgnoreErrors] = struct{}{}
			}
		case "args":
			if _, ok := fieldSeen[script.FieldArgs]; !ok {
				selectedFields = append(selectedFields, script.FieldArgs)
				fieldSeen[script.FieldArgs] = struct{}{}
			}
		case "disabled":
			if _, ok := fieldSeen[script.FieldDisabled]; !ok {
				selectedFields = append(selectedFields, script.FieldDisabled)
				fieldSeen[script.FieldDisabled] = struct{}{}
			}
		case "vars":
			if _, ok := fieldSeen[script.FieldVars]; !ok {
				selectedFields = append(selectedFields, script.FieldVars)
				fieldSeen[script.FieldVars] = struct{}{}
			}
		case "absPath":
			if _, ok := fieldSeen[script.FieldAbsPath]; !ok {
				selectedFields = append(selectedFields, script.FieldAbsPath)
				fieldSeen[script.FieldAbsPath] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[script.FieldTags]; !ok {
				selectedFields = append(selectedFields, script.FieldTags)
				fieldSeen[script.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		s.Select(selectedFields...)
	}
	return nil
}

type scriptPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ScriptPaginateOption
}

func newScriptPaginateArgs(rv map[string]any) *scriptPaginateArgs {
	args := &scriptPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (st *ServerTaskQuery) CollectFields(ctx context.Context, satisfies ...string) (*ServerTaskQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return st, nil
	}
	if err := st.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return st, nil
}

func (st *ServerTaskQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(servertask.Columns))
		selectedFields = []string{servertask.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "servertasktoauthuser":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AuthUserClient{config: st.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			st.withServerTaskToAuthUser = query
		case "servertasktostatus":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&StatusClient{config: st.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			st.withServerTaskToStatus = query
		case "servertasktoenvironment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: st.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			st.withServerTaskToEnvironment = query
		case "servertasktobuild":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildClient{config: st.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			st.withServerTaskToBuild = query
		case "servertasktobuildcommit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildCommitClient{config: st.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			st.withServerTaskToBuildCommit = query
		case "servertasktoginfilemiddleware":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GinFileMiddlewareClient{config: st.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			st.WithNamedServerTaskToGinFileMiddleware(alias, func(wq *GinFileMiddlewareQuery) {
				*wq = *query
			})
		case "type":
			if _, ok := fieldSeen[servertask.FieldType]; !ok {
				selectedFields = append(selectedFields, servertask.FieldType)
				fieldSeen[servertask.FieldType] = struct{}{}
			}
		case "startTime":
			if _, ok := fieldSeen[servertask.FieldStartTime]; !ok {
				selectedFields = append(selectedFields, servertask.FieldStartTime)
				fieldSeen[servertask.FieldStartTime] = struct{}{}
			}
		case "endTime":
			if _, ok := fieldSeen[servertask.FieldEndTime]; !ok {
				selectedFields = append(selectedFields, servertask.FieldEndTime)
				fieldSeen[servertask.FieldEndTime] = struct{}{}
			}
		case "errors":
			if _, ok := fieldSeen[servertask.FieldErrors]; !ok {
				selectedFields = append(selectedFields, servertask.FieldErrors)
				fieldSeen[servertask.FieldErrors] = struct{}{}
			}
		case "logFilePath":
			if _, ok := fieldSeen[servertask.FieldLogFilePath]; !ok {
				selectedFields = append(selectedFields, servertask.FieldLogFilePath)
				fieldSeen[servertask.FieldLogFilePath] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		st.Select(selectedFields...)
	}
	return nil
}

type servertaskPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ServerTaskPaginateOption
}

func newServerTaskPaginateArgs(rv map[string]any) *servertaskPaginateArgs {
	args := &servertaskPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (s *StatusQuery) CollectFields(ctx context.Context, satisfies ...string) (*StatusQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return s, nil
	}
	if err := s.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *StatusQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(status.Columns))
		selectedFields = []string{status.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "statustobuild":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.withStatusToBuild = query
		case "statustoprovisionednetwork":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedNetworkClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.withStatusToProvisionedNetwork = query
		case "statustoprovisionedhost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedHostClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.withStatusToProvisionedHost = query
		case "statustoprovisioningstep":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisioningStepClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.withStatusToProvisioningStep = query
		case "statustoteam":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TeamClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.withStatusToTeam = query
		case "statustoplan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.withStatusToPlan = query
		case "statustoservertask":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ServerTaskClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.withStatusToServerTask = query
		case "statustoadhocplan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AdhocPlanClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.withStatusToAdhocPlan = query
		case "state":
			if _, ok := fieldSeen[status.FieldState]; !ok {
				selectedFields = append(selectedFields, status.FieldState)
				fieldSeen[status.FieldState] = struct{}{}
			}
		case "statusFor":
			if _, ok := fieldSeen[status.FieldStatusFor]; !ok {
				selectedFields = append(selectedFields, status.FieldStatusFor)
				fieldSeen[status.FieldStatusFor] = struct{}{}
			}
		case "startedAt":
			if _, ok := fieldSeen[status.FieldStartedAt]; !ok {
				selectedFields = append(selectedFields, status.FieldStartedAt)
				fieldSeen[status.FieldStartedAt] = struct{}{}
			}
		case "endedAt":
			if _, ok := fieldSeen[status.FieldEndedAt]; !ok {
				selectedFields = append(selectedFields, status.FieldEndedAt)
				fieldSeen[status.FieldEndedAt] = struct{}{}
			}
		case "failed":
			if _, ok := fieldSeen[status.FieldFailed]; !ok {
				selectedFields = append(selectedFields, status.FieldFailed)
				fieldSeen[status.FieldFailed] = struct{}{}
			}
		case "completed":
			if _, ok := fieldSeen[status.FieldCompleted]; !ok {
				selectedFields = append(selectedFields, status.FieldCompleted)
				fieldSeen[status.FieldCompleted] = struct{}{}
			}
		case "error":
			if _, ok := fieldSeen[status.FieldError]; !ok {
				selectedFields = append(selectedFields, status.FieldError)
				fieldSeen[status.FieldError] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		s.Select(selectedFields...)
	}
	return nil
}

type statusPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []StatusPaginateOption
}

func newStatusPaginateArgs(rv map[string]any) *statusPaginateArgs {
	args := &statusPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (t *TagQuery) CollectFields(ctx context.Context, satisfies ...string) (*TagQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return t, nil
	}
	if err := t.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return t, nil
}

func (t *TagQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(tag.Columns))
		selectedFields = []string{tag.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "uuid":
			if _, ok := fieldSeen[tag.FieldUUID]; !ok {
				selectedFields = append(selectedFields, tag.FieldUUID)
				fieldSeen[tag.FieldUUID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[tag.FieldName]; !ok {
				selectedFields = append(selectedFields, tag.FieldName)
				fieldSeen[tag.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[tag.FieldDescription]; !ok {
				selectedFields = append(selectedFields, tag.FieldDescription)
				fieldSeen[tag.FieldDescription] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		t.Select(selectedFields...)
	}
	return nil
}

type tagPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TagPaginateOption
}

func newTagPaginateArgs(rv map[string]any) *tagPaginateArgs {
	args := &tagPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (t *TeamQuery) CollectFields(ctx context.Context, satisfies ...string) (*TeamQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return t, nil
	}
	if err := t.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return t, nil
}

func (t *TeamQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(team.Columns))
		selectedFields = []string{team.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "teamtobuild":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			t.withTeamToBuild = query
		case "teamtostatus":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&StatusClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			t.withTeamToStatus = query
		case "teamtoprovisionednetwork":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedNetworkClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			t.WithNamedTeamToProvisionedNetwork(alias, func(wq *ProvisionedNetworkQuery) {
				*wq = *query
			})
		case "teamtoplan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			t.withTeamToPlan = query
		case "teamNumber":
			if _, ok := fieldSeen[team.FieldTeamNumber]; !ok {
				selectedFields = append(selectedFields, team.FieldTeamNumber)
				fieldSeen[team.FieldTeamNumber] = struct{}{}
			}
		case "vars":
			if _, ok := fieldSeen[team.FieldVars]; !ok {
				selectedFields = append(selectedFields, team.FieldVars)
				fieldSeen[team.FieldVars] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		t.Select(selectedFields...)
	}
	return nil
}

type teamPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TeamPaginateOption
}

func newTeamPaginateArgs(rv map[string]any) *teamPaginateArgs {
	args := &teamPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (t *TokenQuery) CollectFields(ctx context.Context, satisfies ...string) (*TokenQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return t, nil
	}
	if err := t.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return t, nil
}

func (t *TokenQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(token.Columns))
		selectedFields = []string{token.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "tokentoauthuser":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AuthUserClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			t.withTokenToAuthUser = query
		case "token":
			if _, ok := fieldSeen[token.FieldToken]; !ok {
				selectedFields = append(selectedFields, token.FieldToken)
				fieldSeen[token.FieldToken] = struct{}{}
			}
		case "expireAt":
			if _, ok := fieldSeen[token.FieldExpireAt]; !ok {
				selectedFields = append(selectedFields, token.FieldExpireAt)
				fieldSeen[token.FieldExpireAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		t.Select(selectedFields...)
	}
	return nil
}

type tokenPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TokenPaginateOption
}

func newTokenPaginateArgs(rv map[string]any) *tokenPaginateArgs {
	args := &tokenPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (u *UserQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return u, nil
	}
	if err := u.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return u, nil
}

func (u *UserQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(user.Columns))
		selectedFields = []string{user.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "usertotag":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TagClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedUserToTag(alias, func(wq *TagQuery) {
				*wq = *query
			})
		case "usertoenvironment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedUserToEnvironment(alias, func(wq *EnvironmentQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[user.FieldName]; !ok {
				selectedFields = append(selectedFields, user.FieldName)
				fieldSeen[user.FieldName] = struct{}{}
			}
		case "uuid":
			if _, ok := fieldSeen[user.FieldUUID]; !ok {
				selectedFields = append(selectedFields, user.FieldUUID)
				fieldSeen[user.FieldUUID] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[user.FieldEmail]; !ok {
				selectedFields = append(selectedFields, user.FieldEmail)
				fieldSeen[user.FieldEmail] = struct{}{}
			}
		case "hclID":
			if _, ok := fieldSeen[user.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, user.FieldHCLID)
				fieldSeen[user.FieldHCLID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		u.Select(selectedFields...)
	}
	return nil
}

type userPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserPaginateOption
}

func newUserPaginateArgs(rv map[string]any) *userPaginateArgs {
	args := &userPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput any, path ...string) map[string]any {
	field := collectedField(ctx, path...)
	if field == nil || field.Arguments == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	args := field.ArgumentMap(oc.Variables)
	return unmarshalArgs(ctx, whereInput, args)
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput any, args map[string]any) map[string]any {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

func limitRows(partitionBy string, limit int, orderBy ...sql.Querier) func(s *sql.Selector) {
	return func(s *sql.Selector) {
		d := sql.Dialect(s.Dialect())
		s.SetDistinct(false)
		with := d.With("src_query").
			As(s.Clone()).
			With("limited_query").
			As(
				d.Select("*").
					AppendSelectExprAs(
						sql.RowNumber().PartitionBy(partitionBy).OrderExpr(orderBy...),
						"row_number",
					).
					From(d.Table("src_query")),
			)
		t := d.Table("limited_query").As(s.TableName())
		*s = *d.Select(s.UnqualifiedColumns()...).
			From(t).
			Where(sql.LTE(t.C("row_number"), limit)).
			Prefix(with)
	}
}

// mayAddCondition appends another type condition to the satisfies list
// if condition is enabled (Node/Nodes) and it does not exist in the list.
func mayAddCondition(satisfies []string, typeCond string) []string {
	if len(satisfies) == 0 {
		return satisfies
	}
	for _, s := range satisfies {
		if typeCond == s {
			return satisfies
		}
	}
	return append(satisfies, typeCond)
}
