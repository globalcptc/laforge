// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/gen0cide/laforge/ent/agentstatus"
	"github.com/gen0cide/laforge/ent/agenttask"
	"github.com/gen0cide/laforge/ent/ansible"
	"github.com/gen0cide/laforge/ent/authuser"
	"github.com/gen0cide/laforge/ent/build"
	"github.com/gen0cide/laforge/ent/buildcommit"
	"github.com/gen0cide/laforge/ent/command"
	"github.com/gen0cide/laforge/ent/competition"
	"github.com/gen0cide/laforge/ent/disk"
	"github.com/gen0cide/laforge/ent/dns"
	"github.com/gen0cide/laforge/ent/dnsrecord"
	"github.com/gen0cide/laforge/ent/environment"
	"github.com/gen0cide/laforge/ent/filedelete"
	"github.com/gen0cide/laforge/ent/filedownload"
	"github.com/gen0cide/laforge/ent/fileextract"
	"github.com/gen0cide/laforge/ent/finding"
	"github.com/gen0cide/laforge/ent/ginfilemiddleware"
	"github.com/gen0cide/laforge/ent/host"
	"github.com/gen0cide/laforge/ent/hostdependency"
	"github.com/gen0cide/laforge/ent/identity"
	"github.com/gen0cide/laforge/ent/includednetwork"
	"github.com/gen0cide/laforge/ent/network"
	"github.com/gen0cide/laforge/ent/plan"
	"github.com/gen0cide/laforge/ent/plandiff"
	"github.com/gen0cide/laforge/ent/provisionedhost"
	"github.com/gen0cide/laforge/ent/provisionednetwork"
	"github.com/gen0cide/laforge/ent/provisioningscheduledstep"
	"github.com/gen0cide/laforge/ent/provisioningstep"
	"github.com/gen0cide/laforge/ent/repocommit"
	"github.com/gen0cide/laforge/ent/repository"
	"github.com/gen0cide/laforge/ent/scheduledstep"
	"github.com/gen0cide/laforge/ent/script"
	"github.com/gen0cide/laforge/ent/servertask"
	"github.com/gen0cide/laforge/ent/status"
	"github.com/gen0cide/laforge/ent/tag"
	"github.com/gen0cide/laforge/ent/team"
	"github.com/gen0cide/laforge/ent/token"
	"github.com/gen0cide/laforge/ent/user"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ap *AdhocPlanQuery) CollectFields(ctx context.Context, satisfies ...string) (*AdhocPlanQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ap, nil
	}
	if err := ap.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ap, nil
}

func (ap *AdhocPlanQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "prevadhocplans":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AdhocPlanClient{config: ap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ap.WithNamedPrevAdhocPlans(alias, func(wq *AdhocPlanQuery) {
				*wq = *query
			})
		case "nextadhocplans":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AdhocPlanClient{config: ap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ap.WithNamedNextAdhocPlans(alias, func(wq *AdhocPlanQuery) {
				*wq = *query
			})
		case "build":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildClient{config: ap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ap.withBuild = query
		case "status":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&StatusClient{config: ap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ap.withStatus = query
		case "agenttask":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AgentTaskClient{config: ap.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ap.withAgentTask = query
		}
	}
	return nil
}

type adhocplanPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []AdhocPlanPaginateOption
}

func newAdhocPlanPaginateArgs(rv map[string]any) *adhocplanPaginateArgs {
	args := &adhocplanPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (as *AgentStatusQuery) CollectFields(ctx context.Context, satisfies ...string) (*AgentStatusQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return as, nil
	}
	if err := as.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return as, nil
}

func (as *AgentStatusQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(agentstatus.Columns))
		selectedFields = []string{agentstatus.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "provisionedhost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedHostClient{config: as.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			as.withProvisionedHost = query
		case "provisionednetwork":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedNetworkClient{config: as.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			as.withProvisionedNetwork = query
		case "build":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildClient{config: as.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			as.withBuild = query
		case "clientid":
			if _, ok := fieldSeen[agentstatus.FieldClientID]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldClientID)
				fieldSeen[agentstatus.FieldClientID] = struct{}{}
			}
		case "hostname":
			if _, ok := fieldSeen[agentstatus.FieldHostname]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldHostname)
				fieldSeen[agentstatus.FieldHostname] = struct{}{}
			}
		case "uptime":
			if _, ok := fieldSeen[agentstatus.FieldUpTime]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldUpTime)
				fieldSeen[agentstatus.FieldUpTime] = struct{}{}
			}
		case "boottime":
			if _, ok := fieldSeen[agentstatus.FieldBootTime]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldBootTime)
				fieldSeen[agentstatus.FieldBootTime] = struct{}{}
			}
		case "numprocs":
			if _, ok := fieldSeen[agentstatus.FieldNumProcs]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldNumProcs)
				fieldSeen[agentstatus.FieldNumProcs] = struct{}{}
			}
		case "os":
			if _, ok := fieldSeen[agentstatus.FieldOs]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldOs)
				fieldSeen[agentstatus.FieldOs] = struct{}{}
			}
		case "hostid":
			if _, ok := fieldSeen[agentstatus.FieldHostID]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldHostID)
				fieldSeen[agentstatus.FieldHostID] = struct{}{}
			}
		case "load1":
			if _, ok := fieldSeen[agentstatus.FieldLoad1]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldLoad1)
				fieldSeen[agentstatus.FieldLoad1] = struct{}{}
			}
		case "load5":
			if _, ok := fieldSeen[agentstatus.FieldLoad5]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldLoad5)
				fieldSeen[agentstatus.FieldLoad5] = struct{}{}
			}
		case "load15":
			if _, ok := fieldSeen[agentstatus.FieldLoad15]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldLoad15)
				fieldSeen[agentstatus.FieldLoad15] = struct{}{}
			}
		case "totalmem":
			if _, ok := fieldSeen[agentstatus.FieldTotalMem]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldTotalMem)
				fieldSeen[agentstatus.FieldTotalMem] = struct{}{}
			}
		case "freemem":
			if _, ok := fieldSeen[agentstatus.FieldFreeMem]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldFreeMem)
				fieldSeen[agentstatus.FieldFreeMem] = struct{}{}
			}
		case "usedmem":
			if _, ok := fieldSeen[agentstatus.FieldUsedMem]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldUsedMem)
				fieldSeen[agentstatus.FieldUsedMem] = struct{}{}
			}
		case "timestamp":
			if _, ok := fieldSeen[agentstatus.FieldTimestamp]; !ok {
				selectedFields = append(selectedFields, agentstatus.FieldTimestamp)
				fieldSeen[agentstatus.FieldTimestamp] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		as.Select(selectedFields...)
	}
	return nil
}

type agentstatusPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []AgentStatusPaginateOption
}

func newAgentStatusPaginateArgs(rv map[string]any) *agentstatusPaginateArgs {
	args := &agentstatusPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (at *AgentTaskQuery) CollectFields(ctx context.Context, satisfies ...string) (*AgentTaskQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return at, nil
	}
	if err := at.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return at, nil
}

func (at *AgentTaskQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(agenttask.Columns))
		selectedFields = []string{agenttask.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "provisioningstep":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisioningStepClient{config: at.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			at.withProvisioningStep = query
		case "provisioningscheduledstep":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisioningScheduledStepClient{config: at.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			at.withProvisioningScheduledStep = query
		case "provisionedhost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedHostClient{config: at.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			at.withProvisionedHost = query
		case "adhocplans":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AdhocPlanClient{config: at.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			at.WithNamedAdhocPlans(alias, func(wq *AdhocPlanQuery) {
				*wq = *query
			})
		case "command":
			if _, ok := fieldSeen[agenttask.FieldCommand]; !ok {
				selectedFields = append(selectedFields, agenttask.FieldCommand)
				fieldSeen[agenttask.FieldCommand] = struct{}{}
			}
		case "args":
			if _, ok := fieldSeen[agenttask.FieldArgs]; !ok {
				selectedFields = append(selectedFields, agenttask.FieldArgs)
				fieldSeen[agenttask.FieldArgs] = struct{}{}
			}
		case "number":
			if _, ok := fieldSeen[agenttask.FieldNumber]; !ok {
				selectedFields = append(selectedFields, agenttask.FieldNumber)
				fieldSeen[agenttask.FieldNumber] = struct{}{}
			}
		case "output":
			if _, ok := fieldSeen[agenttask.FieldOutput]; !ok {
				selectedFields = append(selectedFields, agenttask.FieldOutput)
				fieldSeen[agenttask.FieldOutput] = struct{}{}
			}
		case "state":
			if _, ok := fieldSeen[agenttask.FieldState]; !ok {
				selectedFields = append(selectedFields, agenttask.FieldState)
				fieldSeen[agenttask.FieldState] = struct{}{}
			}
		case "errorMessage":
			if _, ok := fieldSeen[agenttask.FieldErrorMessage]; !ok {
				selectedFields = append(selectedFields, agenttask.FieldErrorMessage)
				fieldSeen[agenttask.FieldErrorMessage] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		at.Select(selectedFields...)
	}
	return nil
}

type agenttaskPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []AgentTaskPaginateOption
}

func newAgentTaskPaginateArgs(rv map[string]any) *agenttaskPaginateArgs {
	args := &agenttaskPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (a *AnsibleQuery) CollectFields(ctx context.Context, satisfies ...string) (*AnsibleQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return a, nil
	}
	if err := a.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return a, nil
}

func (a *AnsibleQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(ansible.Columns))
		selectedFields = []string{ansible.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "users":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			a.WithNamedUsers(alias, func(wq *UserQuery) {
				*wq = *query
			})
		case "environment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			a.withEnvironment = query
		case "name":
			if _, ok := fieldSeen[ansible.FieldName]; !ok {
				selectedFields = append(selectedFields, ansible.FieldName)
				fieldSeen[ansible.FieldName] = struct{}{}
			}
		case "hclID":
			if _, ok := fieldSeen[ansible.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, ansible.FieldHCLID)
				fieldSeen[ansible.FieldHCLID] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[ansible.FieldDescription]; !ok {
				selectedFields = append(selectedFields, ansible.FieldDescription)
				fieldSeen[ansible.FieldDescription] = struct{}{}
			}
		case "source":
			if _, ok := fieldSeen[ansible.FieldSource]; !ok {
				selectedFields = append(selectedFields, ansible.FieldSource)
				fieldSeen[ansible.FieldSource] = struct{}{}
			}
		case "playbookName":
			if _, ok := fieldSeen[ansible.FieldPlaybookName]; !ok {
				selectedFields = append(selectedFields, ansible.FieldPlaybookName)
				fieldSeen[ansible.FieldPlaybookName] = struct{}{}
			}
		case "method":
			if _, ok := fieldSeen[ansible.FieldMethod]; !ok {
				selectedFields = append(selectedFields, ansible.FieldMethod)
				fieldSeen[ansible.FieldMethod] = struct{}{}
			}
		case "inventory":
			if _, ok := fieldSeen[ansible.FieldInventory]; !ok {
				selectedFields = append(selectedFields, ansible.FieldInventory)
				fieldSeen[ansible.FieldInventory] = struct{}{}
			}
		case "absPath":
			if _, ok := fieldSeen[ansible.FieldAbsPath]; !ok {
				selectedFields = append(selectedFields, ansible.FieldAbsPath)
				fieldSeen[ansible.FieldAbsPath] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[ansible.FieldTags]; !ok {
				selectedFields = append(selectedFields, ansible.FieldTags)
				fieldSeen[ansible.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		a.Select(selectedFields...)
	}
	return nil
}

type ansiblePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []AnsiblePaginateOption
}

func newAnsiblePaginateArgs(rv map[string]any) *ansiblePaginateArgs {
	args := &ansiblePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (au *AuthUserQuery) CollectFields(ctx context.Context, satisfies ...string) (*AuthUserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return au, nil
	}
	if err := au.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return au, nil
}

func (au *AuthUserQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(authuser.Columns))
		selectedFields = []string{authuser.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "tokens":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TokenClient{config: au.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			au.WithNamedTokens(alias, func(wq *TokenQuery) {
				*wq = *query
			})
		case "servertasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ServerTaskClient{config: au.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			au.WithNamedServerTasks(alias, func(wq *ServerTaskQuery) {
				*wq = *query
			})
		case "username":
			if _, ok := fieldSeen[authuser.FieldUsername]; !ok {
				selectedFields = append(selectedFields, authuser.FieldUsername)
				fieldSeen[authuser.FieldUsername] = struct{}{}
			}
		case "firstName":
			if _, ok := fieldSeen[authuser.FieldFirstName]; !ok {
				selectedFields = append(selectedFields, authuser.FieldFirstName)
				fieldSeen[authuser.FieldFirstName] = struct{}{}
			}
		case "lastName":
			if _, ok := fieldSeen[authuser.FieldLastName]; !ok {
				selectedFields = append(selectedFields, authuser.FieldLastName)
				fieldSeen[authuser.FieldLastName] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[authuser.FieldEmail]; !ok {
				selectedFields = append(selectedFields, authuser.FieldEmail)
				fieldSeen[authuser.FieldEmail] = struct{}{}
			}
		case "phone":
			if _, ok := fieldSeen[authuser.FieldPhone]; !ok {
				selectedFields = append(selectedFields, authuser.FieldPhone)
				fieldSeen[authuser.FieldPhone] = struct{}{}
			}
		case "company":
			if _, ok := fieldSeen[authuser.FieldCompany]; !ok {
				selectedFields = append(selectedFields, authuser.FieldCompany)
				fieldSeen[authuser.FieldCompany] = struct{}{}
			}
		case "occupation":
			if _, ok := fieldSeen[authuser.FieldOccupation]; !ok {
				selectedFields = append(selectedFields, authuser.FieldOccupation)
				fieldSeen[authuser.FieldOccupation] = struct{}{}
			}
		case "privateKeyPath":
			if _, ok := fieldSeen[authuser.FieldPrivateKeyPath]; !ok {
				selectedFields = append(selectedFields, authuser.FieldPrivateKeyPath)
				fieldSeen[authuser.FieldPrivateKeyPath] = struct{}{}
			}
		case "role":
			if _, ok := fieldSeen[authuser.FieldRole]; !ok {
				selectedFields = append(selectedFields, authuser.FieldRole)
				fieldSeen[authuser.FieldRole] = struct{}{}
			}
		case "provider":
			if _, ok := fieldSeen[authuser.FieldProvider]; !ok {
				selectedFields = append(selectedFields, authuser.FieldProvider)
				fieldSeen[authuser.FieldProvider] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		au.Select(selectedFields...)
	}
	return nil
}

type authuserPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []AuthUserPaginateOption
}

func newAuthUserPaginateArgs(rv map[string]any) *authuserPaginateArgs {
	args := &authuserPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (b *BuildQuery) CollectFields(ctx context.Context, satisfies ...string) (*BuildQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return b, nil
	}
	if err := b.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return b, nil
}

func (b *BuildQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(build.Columns))
		selectedFields = []string{build.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "status":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&StatusClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.withStatus = query
		case "environment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.withEnvironment = query
		case "competition":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompetitionClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.withCompetition = query
		case "latestbuildcommit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildCommitClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.withLatestBuildCommit = query
		case "repocommit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RepoCommitClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.withRepoCommit = query
		case "provisionednetworks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedNetworkClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.WithNamedProvisionedNetworks(alias, func(wq *ProvisionedNetworkQuery) {
				*wq = *query
			})
		case "teams":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TeamClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.WithNamedTeams(alias, func(wq *TeamQuery) {
				*wq = *query
			})
		case "plans":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.WithNamedPlans(alias, func(wq *PlanQuery) {
				*wq = *query
			})
		case "buildcommits":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildCommitClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.WithNamedBuildCommits(alias, func(wq *BuildCommitQuery) {
				*wq = *query
			})
		case "adhocplans":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AdhocPlanClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.WithNamedAdhocPlans(alias, func(wq *AdhocPlanQuery) {
				*wq = *query
			})
		case "agentstatuses":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AgentStatusClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.WithNamedAgentStatuses(alias, func(wq *AgentStatusQuery) {
				*wq = *query
			})
		case "servertasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ServerTaskClient{config: b.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			b.WithNamedServerTasks(alias, func(wq *ServerTaskQuery) {
				*wq = *query
			})
		case "revision":
			if _, ok := fieldSeen[build.FieldRevision]; !ok {
				selectedFields = append(selectedFields, build.FieldRevision)
				fieldSeen[build.FieldRevision] = struct{}{}
			}
		case "environmentRevision":
			if _, ok := fieldSeen[build.FieldEnvironmentRevision]; !ok {
				selectedFields = append(selectedFields, build.FieldEnvironmentRevision)
				fieldSeen[build.FieldEnvironmentRevision] = struct{}{}
			}
		case "vars":
			if _, ok := fieldSeen[build.FieldVars]; !ok {
				selectedFields = append(selectedFields, build.FieldVars)
				fieldSeen[build.FieldVars] = struct{}{}
			}
		case "completedPlan":
			if _, ok := fieldSeen[build.FieldCompletedPlan]; !ok {
				selectedFields = append(selectedFields, build.FieldCompletedPlan)
				fieldSeen[build.FieldCompletedPlan] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		b.Select(selectedFields...)
	}
	return nil
}

type buildPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []BuildPaginateOption
}

func newBuildPaginateArgs(rv map[string]any) *buildPaginateArgs {
	args := &buildPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (bc *BuildCommitQuery) CollectFields(ctx context.Context, satisfies ...string) (*BuildCommitQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return bc, nil
	}
	if err := bc.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return bc, nil
}

func (bc *BuildCommitQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(buildcommit.Columns))
		selectedFields = []string{buildcommit.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "build":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildClient{config: bc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			bc.withBuild = query
		case "servertasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ServerTaskClient{config: bc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			bc.WithNamedServerTasks(alias, func(wq *ServerTaskQuery) {
				*wq = *query
			})
		case "plandiffs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanDiffClient{config: bc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			bc.WithNamedPlanDiffs(alias, func(wq *PlanDiffQuery) {
				*wq = *query
			})
		case "type":
			if _, ok := fieldSeen[buildcommit.FieldType]; !ok {
				selectedFields = append(selectedFields, buildcommit.FieldType)
				fieldSeen[buildcommit.FieldType] = struct{}{}
			}
		case "revision":
			if _, ok := fieldSeen[buildcommit.FieldRevision]; !ok {
				selectedFields = append(selectedFields, buildcommit.FieldRevision)
				fieldSeen[buildcommit.FieldRevision] = struct{}{}
			}
		case "state":
			if _, ok := fieldSeen[buildcommit.FieldState]; !ok {
				selectedFields = append(selectedFields, buildcommit.FieldState)
				fieldSeen[buildcommit.FieldState] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[buildcommit.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, buildcommit.FieldCreatedAt)
				fieldSeen[buildcommit.FieldCreatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		bc.Select(selectedFields...)
	}
	return nil
}

type buildcommitPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []BuildCommitPaginateOption
}

func newBuildCommitPaginateArgs(rv map[string]any) *buildcommitPaginateArgs {
	args := &buildcommitPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *CommandQuery) CollectFields(ctx context.Context, satisfies ...string) (*CommandQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CommandQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(command.Columns))
		selectedFields = []string{command.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "users":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			c.WithNamedUsers(alias, func(wq *UserQuery) {
				*wq = *query
			})
		case "environment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			c.withEnvironment = query
		case "hclID":
			if _, ok := fieldSeen[command.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, command.FieldHCLID)
				fieldSeen[command.FieldHCLID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[command.FieldName]; !ok {
				selectedFields = append(selectedFields, command.FieldName)
				fieldSeen[command.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[command.FieldDescription]; !ok {
				selectedFields = append(selectedFields, command.FieldDescription)
				fieldSeen[command.FieldDescription] = struct{}{}
			}
		case "program":
			if _, ok := fieldSeen[command.FieldProgram]; !ok {
				selectedFields = append(selectedFields, command.FieldProgram)
				fieldSeen[command.FieldProgram] = struct{}{}
			}
		case "args":
			if _, ok := fieldSeen[command.FieldArgs]; !ok {
				selectedFields = append(selectedFields, command.FieldArgs)
				fieldSeen[command.FieldArgs] = struct{}{}
			}
		case "ignoreErrors":
			if _, ok := fieldSeen[command.FieldIgnoreErrors]; !ok {
				selectedFields = append(selectedFields, command.FieldIgnoreErrors)
				fieldSeen[command.FieldIgnoreErrors] = struct{}{}
			}
		case "disabled":
			if _, ok := fieldSeen[command.FieldDisabled]; !ok {
				selectedFields = append(selectedFields, command.FieldDisabled)
				fieldSeen[command.FieldDisabled] = struct{}{}
			}
		case "cooldown":
			if _, ok := fieldSeen[command.FieldCooldown]; !ok {
				selectedFields = append(selectedFields, command.FieldCooldown)
				fieldSeen[command.FieldCooldown] = struct{}{}
			}
		case "timeout":
			if _, ok := fieldSeen[command.FieldTimeout]; !ok {
				selectedFields = append(selectedFields, command.FieldTimeout)
				fieldSeen[command.FieldTimeout] = struct{}{}
			}
		case "vars":
			if _, ok := fieldSeen[command.FieldVars]; !ok {
				selectedFields = append(selectedFields, command.FieldVars)
				fieldSeen[command.FieldVars] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[command.FieldTags]; !ok {
				selectedFields = append(selectedFields, command.FieldTags)
				fieldSeen[command.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type commandPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CommandPaginateOption
}

func newCommandPaginateArgs(rv map[string]any) *commandPaginateArgs {
	args := &commandPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *CompetitionQuery) CollectFields(ctx context.Context, satisfies ...string) (*CompetitionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CompetitionQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(competition.Columns))
		selectedFields = []string{competition.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "dns":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DNSClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			c.WithNamedDNS(alias, func(wq *DNSQuery) {
				*wq = *query
			})
		case "environment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			c.withEnvironment = query
		case "builds":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			c.WithNamedBuilds(alias, func(wq *BuildQuery) {
				*wq = *query
			})
		case "hclID":
			if _, ok := fieldSeen[competition.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, competition.FieldHCLID)
				fieldSeen[competition.FieldHCLID] = struct{}{}
			}
		case "rootPassword":
			if _, ok := fieldSeen[competition.FieldRootPassword]; !ok {
				selectedFields = append(selectedFields, competition.FieldRootPassword)
				fieldSeen[competition.FieldRootPassword] = struct{}{}
			}
		case "startTime":
			if _, ok := fieldSeen[competition.FieldStartTime]; !ok {
				selectedFields = append(selectedFields, competition.FieldStartTime)
				fieldSeen[competition.FieldStartTime] = struct{}{}
			}
		case "stopTime":
			if _, ok := fieldSeen[competition.FieldStopTime]; !ok {
				selectedFields = append(selectedFields, competition.FieldStopTime)
				fieldSeen[competition.FieldStopTime] = struct{}{}
			}
		case "config":
			if _, ok := fieldSeen[competition.FieldConfig]; !ok {
				selectedFields = append(selectedFields, competition.FieldConfig)
				fieldSeen[competition.FieldConfig] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[competition.FieldTags]; !ok {
				selectedFields = append(selectedFields, competition.FieldTags)
				fieldSeen[competition.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type competitionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CompetitionPaginateOption
}

func newCompetitionPaginateArgs(rv map[string]any) *competitionPaginateArgs {
	args := &competitionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (d *DNSQuery) CollectFields(ctx context.Context, satisfies ...string) (*DNSQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return d, nil
	}
	if err := d.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return d, nil
}

func (d *DNSQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(dns.Columns))
		selectedFields = []string{dns.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "environments":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			d.WithNamedEnvironments(alias, func(wq *EnvironmentQuery) {
				*wq = *query
			})
		case "competitions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompetitionClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			d.WithNamedCompetitions(alias, func(wq *CompetitionQuery) {
				*wq = *query
			})
		case "hclID":
			if _, ok := fieldSeen[dns.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, dns.FieldHCLID)
				fieldSeen[dns.FieldHCLID] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[dns.FieldType]; !ok {
				selectedFields = append(selectedFields, dns.FieldType)
				fieldSeen[dns.FieldType] = struct{}{}
			}
		case "rootDomain":
			if _, ok := fieldSeen[dns.FieldRootDomain]; !ok {
				selectedFields = append(selectedFields, dns.FieldRootDomain)
				fieldSeen[dns.FieldRootDomain] = struct{}{}
			}
		case "dnsServers":
			if _, ok := fieldSeen[dns.FieldDNSServers]; !ok {
				selectedFields = append(selectedFields, dns.FieldDNSServers)
				fieldSeen[dns.FieldDNSServers] = struct{}{}
			}
		case "ntpServers":
			if _, ok := fieldSeen[dns.FieldNtpServers]; !ok {
				selectedFields = append(selectedFields, dns.FieldNtpServers)
				fieldSeen[dns.FieldNtpServers] = struct{}{}
			}
		case "config":
			if _, ok := fieldSeen[dns.FieldConfig]; !ok {
				selectedFields = append(selectedFields, dns.FieldConfig)
				fieldSeen[dns.FieldConfig] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		d.Select(selectedFields...)
	}
	return nil
}

type dnsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DNSPaginateOption
}

func newDNSPaginateArgs(rv map[string]any) *dnsPaginateArgs {
	args := &dnsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (dr *DNSRecordQuery) CollectFields(ctx context.Context, satisfies ...string) (*DNSRecordQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return dr, nil
	}
	if err := dr.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return dr, nil
}

func (dr *DNSRecordQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(dnsrecord.Columns))
		selectedFields = []string{dnsrecord.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "environment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: dr.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			dr.withEnvironment = query
		case "hclID":
			if _, ok := fieldSeen[dnsrecord.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, dnsrecord.FieldHCLID)
				fieldSeen[dnsrecord.FieldHCLID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[dnsrecord.FieldName]; !ok {
				selectedFields = append(selectedFields, dnsrecord.FieldName)
				fieldSeen[dnsrecord.FieldName] = struct{}{}
			}
		case "values":
			if _, ok := fieldSeen[dnsrecord.FieldValues]; !ok {
				selectedFields = append(selectedFields, dnsrecord.FieldValues)
				fieldSeen[dnsrecord.FieldValues] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[dnsrecord.FieldType]; !ok {
				selectedFields = append(selectedFields, dnsrecord.FieldType)
				fieldSeen[dnsrecord.FieldType] = struct{}{}
			}
		case "zone":
			if _, ok := fieldSeen[dnsrecord.FieldZone]; !ok {
				selectedFields = append(selectedFields, dnsrecord.FieldZone)
				fieldSeen[dnsrecord.FieldZone] = struct{}{}
			}
		case "vars":
			if _, ok := fieldSeen[dnsrecord.FieldVars]; !ok {
				selectedFields = append(selectedFields, dnsrecord.FieldVars)
				fieldSeen[dnsrecord.FieldVars] = struct{}{}
			}
		case "disabled":
			if _, ok := fieldSeen[dnsrecord.FieldDisabled]; !ok {
				selectedFields = append(selectedFields, dnsrecord.FieldDisabled)
				fieldSeen[dnsrecord.FieldDisabled] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[dnsrecord.FieldTags]; !ok {
				selectedFields = append(selectedFields, dnsrecord.FieldTags)
				fieldSeen[dnsrecord.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		dr.Select(selectedFields...)
	}
	return nil
}

type dnsrecordPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DNSRecordPaginateOption
}

func newDNSRecordPaginateArgs(rv map[string]any) *dnsrecordPaginateArgs {
	args := &dnsrecordPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (d *DiskQuery) CollectFields(ctx context.Context, satisfies ...string) (*DiskQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return d, nil
	}
	if err := d.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return d, nil
}

func (d *DiskQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(disk.Columns))
		selectedFields = []string{disk.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "host":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HostClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			d.withHost = query
		case "size":
			if _, ok := fieldSeen[disk.FieldSize]; !ok {
				selectedFields = append(selectedFields, disk.FieldSize)
				fieldSeen[disk.FieldSize] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		d.Select(selectedFields...)
	}
	return nil
}

type diskPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DiskPaginateOption
}

func newDiskPaginateArgs(rv map[string]any) *diskPaginateArgs {
	args := &diskPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (e *EnvironmentQuery) CollectFields(ctx context.Context, satisfies ...string) (*EnvironmentQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return e, nil
	}
	if err := e.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return e, nil
}

func (e *EnvironmentQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(environment.Columns))
		selectedFields = []string{environment.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "users":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedUsers(alias, func(wq *UserQuery) {
				*wq = *query
			})
		case "hosts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HostClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedHosts(alias, func(wq *HostQuery) {
				*wq = *query
			})
		case "competitions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompetitionClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedCompetitions(alias, func(wq *CompetitionQuery) {
				*wq = *query
			})
		case "identities":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&IdentityClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedIdentities(alias, func(wq *IdentityQuery) {
				*wq = *query
			})
		case "commands":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CommandClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedCommands(alias, func(wq *CommandQuery) {
				*wq = *query
			})
		case "scripts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ScriptClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedScripts(alias, func(wq *ScriptQuery) {
				*wq = *query
			})
		case "filedownloads":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileDownloadClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedFileDownloads(alias, func(wq *FileDownloadQuery) {
				*wq = *query
			})
		case "filedeletes":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileDeleteClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedFileDeletes(alias, func(wq *FileDeleteQuery) {
				*wq = *query
			})
		case "fileextracts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileExtractClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedFileExtracts(alias, func(wq *FileExtractQuery) {
				*wq = *query
			})
		case "includednetworks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&IncludedNetworkClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedIncludedNetworks(alias, func(wq *IncludedNetworkQuery) {
				*wq = *query
			})
		case "findings":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FindingClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedFindings(alias, func(wq *FindingQuery) {
				*wq = *query
			})
		case "dnsrecords":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DNSRecordClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedDNSRecords(alias, func(wq *DNSRecordQuery) {
				*wq = *query
			})
		case "dns":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DNSClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedDNS(alias, func(wq *DNSQuery) {
				*wq = *query
			})
		case "networks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NetworkClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedNetworks(alias, func(wq *NetworkQuery) {
				*wq = *query
			})
		case "hostdependencies":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HostDependencyClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedHostDependencies(alias, func(wq *HostDependencyQuery) {
				*wq = *query
			})
		case "ansibles":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AnsibleClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedAnsibles(alias, func(wq *AnsibleQuery) {
				*wq = *query
			})
		case "scheduledsteps":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ScheduledStepClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedScheduledSteps(alias, func(wq *ScheduledStepQuery) {
				*wq = *query
			})
		case "builds":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedBuilds(alias, func(wq *BuildQuery) {
				*wq = *query
			})
		case "repositories":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RepositoryClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedRepositories(alias, func(wq *RepositoryQuery) {
				*wq = *query
			})
		case "servertasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ServerTaskClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedServerTasks(alias, func(wq *ServerTaskQuery) {
				*wq = *query
			})
		case "hclID":
			if _, ok := fieldSeen[environment.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, environment.FieldHCLID)
				fieldSeen[environment.FieldHCLID] = struct{}{}
			}
		case "competitionID":
			if _, ok := fieldSeen[environment.FieldCompetitionID]; !ok {
				selectedFields = append(selectedFields, environment.FieldCompetitionID)
				fieldSeen[environment.FieldCompetitionID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[environment.FieldName]; !ok {
				selectedFields = append(selectedFields, environment.FieldName)
				fieldSeen[environment.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[environment.FieldDescription]; !ok {
				selectedFields = append(selectedFields, environment.FieldDescription)
				fieldSeen[environment.FieldDescription] = struct{}{}
			}
		case "builder":
			if _, ok := fieldSeen[environment.FieldBuilder]; !ok {
				selectedFields = append(selectedFields, environment.FieldBuilder)
				fieldSeen[environment.FieldBuilder] = struct{}{}
			}
		case "teamCount":
			if _, ok := fieldSeen[environment.FieldTeamCount]; !ok {
				selectedFields = append(selectedFields, environment.FieldTeamCount)
				fieldSeen[environment.FieldTeamCount] = struct{}{}
			}
		case "revision":
			if _, ok := fieldSeen[environment.FieldRevision]; !ok {
				selectedFields = append(selectedFields, environment.FieldRevision)
				fieldSeen[environment.FieldRevision] = struct{}{}
			}
		case "adminCidrs":
			if _, ok := fieldSeen[environment.FieldAdminCidrs]; !ok {
				selectedFields = append(selectedFields, environment.FieldAdminCidrs)
				fieldSeen[environment.FieldAdminCidrs] = struct{}{}
			}
		case "exposedVdiPorts":
			if _, ok := fieldSeen[environment.FieldExposedVdiPorts]; !ok {
				selectedFields = append(selectedFields, environment.FieldExposedVdiPorts)
				fieldSeen[environment.FieldExposedVdiPorts] = struct{}{}
			}
		case "config":
			if _, ok := fieldSeen[environment.FieldConfig]; !ok {
				selectedFields = append(selectedFields, environment.FieldConfig)
				fieldSeen[environment.FieldConfig] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[environment.FieldTags]; !ok {
				selectedFields = append(selectedFields, environment.FieldTags)
				fieldSeen[environment.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		e.Select(selectedFields...)
	}
	return nil
}

type environmentPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EnvironmentPaginateOption
}

func newEnvironmentPaginateArgs(rv map[string]any) *environmentPaginateArgs {
	args := &environmentPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (fd *FileDeleteQuery) CollectFields(ctx context.Context, satisfies ...string) (*FileDeleteQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return fd, nil
	}
	if err := fd.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return fd, nil
}

func (fd *FileDeleteQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(filedelete.Columns))
		selectedFields = []string{filedelete.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "environment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: fd.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			fd.withEnvironment = query
		case "hclID":
			if _, ok := fieldSeen[filedelete.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, filedelete.FieldHCLID)
				fieldSeen[filedelete.FieldHCLID] = struct{}{}
			}
		case "path":
			if _, ok := fieldSeen[filedelete.FieldPath]; !ok {
				selectedFields = append(selectedFields, filedelete.FieldPath)
				fieldSeen[filedelete.FieldPath] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[filedelete.FieldTags]; !ok {
				selectedFields = append(selectedFields, filedelete.FieldTags)
				fieldSeen[filedelete.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		fd.Select(selectedFields...)
	}
	return nil
}

type filedeletePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []FileDeletePaginateOption
}

func newFileDeletePaginateArgs(rv map[string]any) *filedeletePaginateArgs {
	args := &filedeletePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (fd *FileDownloadQuery) CollectFields(ctx context.Context, satisfies ...string) (*FileDownloadQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return fd, nil
	}
	if err := fd.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return fd, nil
}

func (fd *FileDownloadQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(filedownload.Columns))
		selectedFields = []string{filedownload.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "environment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: fd.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			fd.withEnvironment = query
		case "hclID":
			if _, ok := fieldSeen[filedownload.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, filedownload.FieldHCLID)
				fieldSeen[filedownload.FieldHCLID] = struct{}{}
			}
		case "sourceType":
			if _, ok := fieldSeen[filedownload.FieldSourceType]; !ok {
				selectedFields = append(selectedFields, filedownload.FieldSourceType)
				fieldSeen[filedownload.FieldSourceType] = struct{}{}
			}
		case "source":
			if _, ok := fieldSeen[filedownload.FieldSource]; !ok {
				selectedFields = append(selectedFields, filedownload.FieldSource)
				fieldSeen[filedownload.FieldSource] = struct{}{}
			}
		case "destination":
			if _, ok := fieldSeen[filedownload.FieldDestination]; !ok {
				selectedFields = append(selectedFields, filedownload.FieldDestination)
				fieldSeen[filedownload.FieldDestination] = struct{}{}
			}
		case "template":
			if _, ok := fieldSeen[filedownload.FieldTemplate]; !ok {
				selectedFields = append(selectedFields, filedownload.FieldTemplate)
				fieldSeen[filedownload.FieldTemplate] = struct{}{}
			}
		case "perms":
			if _, ok := fieldSeen[filedownload.FieldPerms]; !ok {
				selectedFields = append(selectedFields, filedownload.FieldPerms)
				fieldSeen[filedownload.FieldPerms] = struct{}{}
			}
		case "disabled":
			if _, ok := fieldSeen[filedownload.FieldDisabled]; !ok {
				selectedFields = append(selectedFields, filedownload.FieldDisabled)
				fieldSeen[filedownload.FieldDisabled] = struct{}{}
			}
		case "md5":
			if _, ok := fieldSeen[filedownload.FieldMd5]; !ok {
				selectedFields = append(selectedFields, filedownload.FieldMd5)
				fieldSeen[filedownload.FieldMd5] = struct{}{}
			}
		case "absPath":
			if _, ok := fieldSeen[filedownload.FieldAbsPath]; !ok {
				selectedFields = append(selectedFields, filedownload.FieldAbsPath)
				fieldSeen[filedownload.FieldAbsPath] = struct{}{}
			}
		case "isTxt":
			if _, ok := fieldSeen[filedownload.FieldIsTxt]; !ok {
				selectedFields = append(selectedFields, filedownload.FieldIsTxt)
				fieldSeen[filedownload.FieldIsTxt] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[filedownload.FieldTags]; !ok {
				selectedFields = append(selectedFields, filedownload.FieldTags)
				fieldSeen[filedownload.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		fd.Select(selectedFields...)
	}
	return nil
}

type filedownloadPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []FileDownloadPaginateOption
}

func newFileDownloadPaginateArgs(rv map[string]any) *filedownloadPaginateArgs {
	args := &filedownloadPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (fe *FileExtractQuery) CollectFields(ctx context.Context, satisfies ...string) (*FileExtractQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return fe, nil
	}
	if err := fe.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return fe, nil
}

func (fe *FileExtractQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(fileextract.Columns))
		selectedFields = []string{fileextract.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "environment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: fe.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			fe.withEnvironment = query
		case "hclID":
			if _, ok := fieldSeen[fileextract.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, fileextract.FieldHCLID)
				fieldSeen[fileextract.FieldHCLID] = struct{}{}
			}
		case "source":
			if _, ok := fieldSeen[fileextract.FieldSource]; !ok {
				selectedFields = append(selectedFields, fileextract.FieldSource)
				fieldSeen[fileextract.FieldSource] = struct{}{}
			}
		case "destination":
			if _, ok := fieldSeen[fileextract.FieldDestination]; !ok {
				selectedFields = append(selectedFields, fileextract.FieldDestination)
				fieldSeen[fileextract.FieldDestination] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[fileextract.FieldType]; !ok {
				selectedFields = append(selectedFields, fileextract.FieldType)
				fieldSeen[fileextract.FieldType] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[fileextract.FieldTags]; !ok {
				selectedFields = append(selectedFields, fileextract.FieldTags)
				fieldSeen[fileextract.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		fe.Select(selectedFields...)
	}
	return nil
}

type fileextractPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []FileExtractPaginateOption
}

func newFileExtractPaginateArgs(rv map[string]any) *fileextractPaginateArgs {
	args := &fileextractPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (f *FindingQuery) CollectFields(ctx context.Context, satisfies ...string) (*FindingQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return f, nil
	}
	if err := f.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return f, nil
}

func (f *FindingQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(finding.Columns))
		selectedFields = []string{finding.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "users":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			f.WithNamedUsers(alias, func(wq *UserQuery) {
				*wq = *query
			})
		case "host":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HostClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			f.withHost = query
		case "script":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ScriptClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			f.withScript = query
		case "environment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: f.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			f.withEnvironment = query
		case "name":
			if _, ok := fieldSeen[finding.FieldName]; !ok {
				selectedFields = append(selectedFields, finding.FieldName)
				fieldSeen[finding.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[finding.FieldDescription]; !ok {
				selectedFields = append(selectedFields, finding.FieldDescription)
				fieldSeen[finding.FieldDescription] = struct{}{}
			}
		case "severity":
			if _, ok := fieldSeen[finding.FieldSeverity]; !ok {
				selectedFields = append(selectedFields, finding.FieldSeverity)
				fieldSeen[finding.FieldSeverity] = struct{}{}
			}
		case "difficulty":
			if _, ok := fieldSeen[finding.FieldDifficulty]; !ok {
				selectedFields = append(selectedFields, finding.FieldDifficulty)
				fieldSeen[finding.FieldDifficulty] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[finding.FieldTags]; !ok {
				selectedFields = append(selectedFields, finding.FieldTags)
				fieldSeen[finding.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		f.Select(selectedFields...)
	}
	return nil
}

type findingPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []FindingPaginateOption
}

func newFindingPaginateArgs(rv map[string]any) *findingPaginateArgs {
	args := &findingPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (gfm *GinFileMiddlewareQuery) CollectFields(ctx context.Context, satisfies ...string) (*GinFileMiddlewareQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return gfm, nil
	}
	if err := gfm.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return gfm, nil
}

func (gfm *GinFileMiddlewareQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(ginfilemiddleware.Columns))
		selectedFields = []string{ginfilemiddleware.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "provisionedhost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedHostClient{config: gfm.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			gfm.withProvisionedHost = query
		case "provisioningstep":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisioningStepClient{config: gfm.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			gfm.withProvisioningStep = query
		case "provisioningscheduledstep":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisioningScheduledStepClient{config: gfm.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			gfm.withProvisioningScheduledStep = query
		case "urlID":
			if _, ok := fieldSeen[ginfilemiddleware.FieldURLID]; !ok {
				selectedFields = append(selectedFields, ginfilemiddleware.FieldURLID)
				fieldSeen[ginfilemiddleware.FieldURLID] = struct{}{}
			}
		case "filePath":
			if _, ok := fieldSeen[ginfilemiddleware.FieldFilePath]; !ok {
				selectedFields = append(selectedFields, ginfilemiddleware.FieldFilePath)
				fieldSeen[ginfilemiddleware.FieldFilePath] = struct{}{}
			}
		case "accessed":
			if _, ok := fieldSeen[ginfilemiddleware.FieldAccessed]; !ok {
				selectedFields = append(selectedFields, ginfilemiddleware.FieldAccessed)
				fieldSeen[ginfilemiddleware.FieldAccessed] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		gfm.Select(selectedFields...)
	}
	return nil
}

type ginfilemiddlewarePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []GinFileMiddlewarePaginateOption
}

func newGinFileMiddlewarePaginateArgs(rv map[string]any) *ginfilemiddlewarePaginateArgs {
	args := &ginfilemiddlewarePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (h *HostQuery) CollectFields(ctx context.Context, satisfies ...string) (*HostQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return h, nil
	}
	if err := h.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return h, nil
}

func (h *HostQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(host.Columns))
		selectedFields = []string{host.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "disk":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DiskClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			h.withDisk = query
		case "users":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			h.WithNamedUsers(alias, func(wq *UserQuery) {
				*wq = *query
			})
		case "environment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			h.withEnvironment = query
		case "includednetworks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&IncludedNetworkClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			h.WithNamedIncludedNetworks(alias, func(wq *IncludedNetworkQuery) {
				*wq = *query
			})
		case "dependonhostdependencies":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HostDependencyClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			h.WithNamedDependOnHostDependencies(alias, func(wq *HostDependencyQuery) {
				*wq = *query
			})
		case "requiredbyhostdependencies":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HostDependencyClient{config: h.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			h.WithNamedRequiredByHostDependencies(alias, func(wq *HostDependencyQuery) {
				*wq = *query
			})
		case "hclID":
			if _, ok := fieldSeen[host.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, host.FieldHCLID)
				fieldSeen[host.FieldHCLID] = struct{}{}
			}
		case "hostname":
			if _, ok := fieldSeen[host.FieldHostname]; !ok {
				selectedFields = append(selectedFields, host.FieldHostname)
				fieldSeen[host.FieldHostname] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[host.FieldDescription]; !ok {
				selectedFields = append(selectedFields, host.FieldDescription)
				fieldSeen[host.FieldDescription] = struct{}{}
			}
		case "os":
			if _, ok := fieldSeen[host.FieldOS]; !ok {
				selectedFields = append(selectedFields, host.FieldOS)
				fieldSeen[host.FieldOS] = struct{}{}
			}
		case "lastOctet":
			if _, ok := fieldSeen[host.FieldLastOctet]; !ok {
				selectedFields = append(selectedFields, host.FieldLastOctet)
				fieldSeen[host.FieldLastOctet] = struct{}{}
			}
		case "instanceSize":
			if _, ok := fieldSeen[host.FieldInstanceSize]; !ok {
				selectedFields = append(selectedFields, host.FieldInstanceSize)
				fieldSeen[host.FieldInstanceSize] = struct{}{}
			}
		case "allowMACChanges":
			if _, ok := fieldSeen[host.FieldAllowMACChanges]; !ok {
				selectedFields = append(selectedFields, host.FieldAllowMACChanges)
				fieldSeen[host.FieldAllowMACChanges] = struct{}{}
			}
		case "exposedTCPPorts":
			if _, ok := fieldSeen[host.FieldExposedTCPPorts]; !ok {
				selectedFields = append(selectedFields, host.FieldExposedTCPPorts)
				fieldSeen[host.FieldExposedTCPPorts] = struct{}{}
			}
		case "exposedUDPPorts":
			if _, ok := fieldSeen[host.FieldExposedUDPPorts]; !ok {
				selectedFields = append(selectedFields, host.FieldExposedUDPPorts)
				fieldSeen[host.FieldExposedUDPPorts] = struct{}{}
			}
		case "overridePassword":
			if _, ok := fieldSeen[host.FieldOverridePassword]; !ok {
				selectedFields = append(selectedFields, host.FieldOverridePassword)
				fieldSeen[host.FieldOverridePassword] = struct{}{}
			}
		case "vars":
			if _, ok := fieldSeen[host.FieldVars]; !ok {
				selectedFields = append(selectedFields, host.FieldVars)
				fieldSeen[host.FieldVars] = struct{}{}
			}
		case "userGroups":
			if _, ok := fieldSeen[host.FieldUserGroups]; !ok {
				selectedFields = append(selectedFields, host.FieldUserGroups)
				fieldSeen[host.FieldUserGroups] = struct{}{}
			}
		case "provisionSteps":
			if _, ok := fieldSeen[host.FieldProvisionSteps]; !ok {
				selectedFields = append(selectedFields, host.FieldProvisionSteps)
				fieldSeen[host.FieldProvisionSteps] = struct{}{}
			}
		case "scheduledSteps":
			if _, ok := fieldSeen[host.FieldScheduledSteps]; !ok {
				selectedFields = append(selectedFields, host.FieldScheduledSteps)
				fieldSeen[host.FieldScheduledSteps] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[host.FieldTags]; !ok {
				selectedFields = append(selectedFields, host.FieldTags)
				fieldSeen[host.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		h.Select(selectedFields...)
	}
	return nil
}

type hostPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HostPaginateOption
}

func newHostPaginateArgs(rv map[string]any) *hostPaginateArgs {
	args := &hostPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (hd *HostDependencyQuery) CollectFields(ctx context.Context, satisfies ...string) (*HostDependencyQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return hd, nil
	}
	if err := hd.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return hd, nil
}

func (hd *HostDependencyQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hostdependency.Columns))
		selectedFields = []string{hostdependency.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "requiredby":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HostClient{config: hd.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hd.withRequiredBy = query
		case "dependonhost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HostClient{config: hd.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hd.withDependOnHost = query
		case "dependonnetwork":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NetworkClient{config: hd.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hd.withDependOnNetwork = query
		case "environment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: hd.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			hd.withEnvironment = query
		case "hostID":
			if _, ok := fieldSeen[hostdependency.FieldHostID]; !ok {
				selectedFields = append(selectedFields, hostdependency.FieldHostID)
				fieldSeen[hostdependency.FieldHostID] = struct{}{}
			}
		case "networkID":
			if _, ok := fieldSeen[hostdependency.FieldNetworkID]; !ok {
				selectedFields = append(selectedFields, hostdependency.FieldNetworkID)
				fieldSeen[hostdependency.FieldNetworkID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		hd.Select(selectedFields...)
	}
	return nil
}

type hostdependencyPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HostDependencyPaginateOption
}

func newHostDependencyPaginateArgs(rv map[string]any) *hostdependencyPaginateArgs {
	args := &hostdependencyPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (i *IdentityQuery) CollectFields(ctx context.Context, satisfies ...string) (*IdentityQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return i, nil
	}
	if err := i.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return i, nil
}

func (i *IdentityQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(identity.Columns))
		selectedFields = []string{identity.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "environment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: i.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			i.withEnvironment = query
		case "hclID":
			if _, ok := fieldSeen[identity.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, identity.FieldHCLID)
				fieldSeen[identity.FieldHCLID] = struct{}{}
			}
		case "firstName":
			if _, ok := fieldSeen[identity.FieldFirstName]; !ok {
				selectedFields = append(selectedFields, identity.FieldFirstName)
				fieldSeen[identity.FieldFirstName] = struct{}{}
			}
		case "lastName":
			if _, ok := fieldSeen[identity.FieldLastName]; !ok {
				selectedFields = append(selectedFields, identity.FieldLastName)
				fieldSeen[identity.FieldLastName] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[identity.FieldEmail]; !ok {
				selectedFields = append(selectedFields, identity.FieldEmail)
				fieldSeen[identity.FieldEmail] = struct{}{}
			}
		case "password":
			if _, ok := fieldSeen[identity.FieldPassword]; !ok {
				selectedFields = append(selectedFields, identity.FieldPassword)
				fieldSeen[identity.FieldPassword] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[identity.FieldDescription]; !ok {
				selectedFields = append(selectedFields, identity.FieldDescription)
				fieldSeen[identity.FieldDescription] = struct{}{}
			}
		case "avatarFile":
			if _, ok := fieldSeen[identity.FieldAvatarFile]; !ok {
				selectedFields = append(selectedFields, identity.FieldAvatarFile)
				fieldSeen[identity.FieldAvatarFile] = struct{}{}
			}
		case "vars":
			if _, ok := fieldSeen[identity.FieldVars]; !ok {
				selectedFields = append(selectedFields, identity.FieldVars)
				fieldSeen[identity.FieldVars] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[identity.FieldTags]; !ok {
				selectedFields = append(selectedFields, identity.FieldTags)
				fieldSeen[identity.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		i.Select(selectedFields...)
	}
	return nil
}

type identityPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []IdentityPaginateOption
}

func newIdentityPaginateArgs(rv map[string]any) *identityPaginateArgs {
	args := &identityPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (in *IncludedNetworkQuery) CollectFields(ctx context.Context, satisfies ...string) (*IncludedNetworkQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return in, nil
	}
	if err := in.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return in, nil
}

func (in *IncludedNetworkQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(includednetwork.Columns))
		selectedFields = []string{includednetwork.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "tags":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TagClient{config: in.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			in.WithNamedTags(alias, func(wq *TagQuery) {
				*wq = *query
			})
		case "hosts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HostClient{config: in.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			in.WithNamedHosts(alias, func(wq *HostQuery) {
				*wq = *query
			})
		case "network":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NetworkClient{config: in.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			in.withNetwork = query
		case "environments":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: in.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			in.WithNamedEnvironments(alias, func(wq *EnvironmentQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[includednetwork.FieldName]; !ok {
				selectedFields = append(selectedFields, includednetwork.FieldName)
				fieldSeen[includednetwork.FieldName] = struct{}{}
			}
		case "includedHosts":
			if _, ok := fieldSeen[includednetwork.FieldIncludedHosts]; !ok {
				selectedFields = append(selectedFields, includednetwork.FieldIncludedHosts)
				fieldSeen[includednetwork.FieldIncludedHosts] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		in.Select(selectedFields...)
	}
	return nil
}

type includednetworkPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []IncludedNetworkPaginateOption
}

func newIncludedNetworkPaginateArgs(rv map[string]any) *includednetworkPaginateArgs {
	args := &includednetworkPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (n *NetworkQuery) CollectFields(ctx context.Context, satisfies ...string) (*NetworkQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return n, nil
	}
	if err := n.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return n, nil
}

func (n *NetworkQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(network.Columns))
		selectedFields = []string{network.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "environment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			n.withEnvironment = query
		case "hostdependencies":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HostDependencyClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			n.WithNamedHostDependencies(alias, func(wq *HostDependencyQuery) {
				*wq = *query
			})
		case "includednetworks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&IncludedNetworkClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			n.WithNamedIncludedNetworks(alias, func(wq *IncludedNetworkQuery) {
				*wq = *query
			})
		case "hclID":
			if _, ok := fieldSeen[network.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, network.FieldHCLID)
				fieldSeen[network.FieldHCLID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[network.FieldName]; !ok {
				selectedFields = append(selectedFields, network.FieldName)
				fieldSeen[network.FieldName] = struct{}{}
			}
		case "cidr":
			if _, ok := fieldSeen[network.FieldCidr]; !ok {
				selectedFields = append(selectedFields, network.FieldCidr)
				fieldSeen[network.FieldCidr] = struct{}{}
			}
		case "vdiVisible":
			if _, ok := fieldSeen[network.FieldVdiVisible]; !ok {
				selectedFields = append(selectedFields, network.FieldVdiVisible)
				fieldSeen[network.FieldVdiVisible] = struct{}{}
			}
		case "vars":
			if _, ok := fieldSeen[network.FieldVars]; !ok {
				selectedFields = append(selectedFields, network.FieldVars)
				fieldSeen[network.FieldVars] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[network.FieldTags]; !ok {
				selectedFields = append(selectedFields, network.FieldTags)
				fieldSeen[network.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		n.Select(selectedFields...)
	}
	return nil
}

type networkPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []NetworkPaginateOption
}

func newNetworkPaginateArgs(rv map[string]any) *networkPaginateArgs {
	args := &networkPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pl *PlanQuery) CollectFields(ctx context.Context, satisfies ...string) (*PlanQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pl, nil
	}
	if err := pl.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pl, nil
}

func (pl *PlanQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(plan.Columns))
		selectedFields = []string{plan.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "prevplans":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pl.WithNamedPrevPlans(alias, func(wq *PlanQuery) {
				*wq = *query
			})
		case "nextplans":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pl.WithNamedNextPlans(alias, func(wq *PlanQuery) {
				*wq = *query
			})
		case "build":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pl.withBuild = query
		case "team":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TeamClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pl.withTeam = query
		case "provisionednetwork":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedNetworkClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pl.withProvisionedNetwork = query
		case "provisionedhost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedHostClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pl.withProvisionedHost = query
		case "provisioningstep":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisioningStepClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pl.withProvisioningStep = query
		case "provisioningscheduledstep":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisioningScheduledStepClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pl.withProvisioningScheduledStep = query
		case "status":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&StatusClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pl.withStatus = query
		case "plandiffs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanDiffClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pl.WithNamedPlanDiffs(alias, func(wq *PlanDiffQuery) {
				*wq = *query
			})
		case "stepNumber":
			if _, ok := fieldSeen[plan.FieldStepNumber]; !ok {
				selectedFields = append(selectedFields, plan.FieldStepNumber)
				fieldSeen[plan.FieldStepNumber] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[plan.FieldType]; !ok {
				selectedFields = append(selectedFields, plan.FieldType)
				fieldSeen[plan.FieldType] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pl.Select(selectedFields...)
	}
	return nil
}

type planPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PlanPaginateOption
}

func newPlanPaginateArgs(rv map[string]any) *planPaginateArgs {
	args := &planPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pd *PlanDiffQuery) CollectFields(ctx context.Context, satisfies ...string) (*PlanDiffQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pd, nil
	}
	if err := pd.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pd, nil
}

func (pd *PlanDiffQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(plandiff.Columns))
		selectedFields = []string{plandiff.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "buildcommit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildCommitClient{config: pd.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pd.withBuildCommit = query
		case "plan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanClient{config: pd.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pd.withPlan = query
		case "revision":
			if _, ok := fieldSeen[plandiff.FieldRevision]; !ok {
				selectedFields = append(selectedFields, plandiff.FieldRevision)
				fieldSeen[plandiff.FieldRevision] = struct{}{}
			}
		case "newState":
			if _, ok := fieldSeen[plandiff.FieldNewState]; !ok {
				selectedFields = append(selectedFields, plandiff.FieldNewState)
				fieldSeen[plandiff.FieldNewState] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pd.Select(selectedFields...)
	}
	return nil
}

type plandiffPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PlanDiffPaginateOption
}

func newPlanDiffPaginateArgs(rv map[string]any) *plandiffPaginateArgs {
	args := &plandiffPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ph *ProvisionedHostQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProvisionedHostQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ph, nil
	}
	if err := ph.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ph, nil
}

func (ph *ProvisionedHostQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(provisionedhost.Columns))
		selectedFields = []string{provisionedhost.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "status":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&StatusClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ph.withStatus = query
		case "provisionednetwork":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedNetworkClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ph.withProvisionedNetwork = query
		case "host":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HostClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ph.withHost = query
		case "endstepplan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ph.withEndStepPlan = query
		case "build":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ph.withBuild = query
		case "provisioningsteps":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisioningStepClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ph.WithNamedProvisioningSteps(alias, func(wq *ProvisioningStepQuery) {
				*wq = *query
			})
		case "provisioningscheduledsteps":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisioningScheduledStepClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ph.WithNamedProvisioningScheduledSteps(alias, func(wq *ProvisioningScheduledStepQuery) {
				*wq = *query
			})
		case "agentstatuses":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AgentStatusClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ph.WithNamedAgentStatuses(alias, func(wq *AgentStatusQuery) {
				*wq = *query
			})
		case "agenttasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AgentTaskClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ph.WithNamedAgentTasks(alias, func(wq *AgentTaskQuery) {
				*wq = *query
			})
		case "plan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ph.withPlan = query
		case "ginfilemiddleware":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GinFileMiddlewareClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ph.withGinFileMiddleware = query
		case "subnetIP":
			if _, ok := fieldSeen[provisionedhost.FieldSubnetIP]; !ok {
				selectedFields = append(selectedFields, provisionedhost.FieldSubnetIP)
				fieldSeen[provisionedhost.FieldSubnetIP] = struct{}{}
			}
		case "addonType":
			if _, ok := fieldSeen[provisionedhost.FieldAddonType]; !ok {
				selectedFields = append(selectedFields, provisionedhost.FieldAddonType)
				fieldSeen[provisionedhost.FieldAddonType] = struct{}{}
			}
		case "vars":
			if _, ok := fieldSeen[provisionedhost.FieldVars]; !ok {
				selectedFields = append(selectedFields, provisionedhost.FieldVars)
				fieldSeen[provisionedhost.FieldVars] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ph.Select(selectedFields...)
	}
	return nil
}

type provisionedhostPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProvisionedHostPaginateOption
}

func newProvisionedHostPaginateArgs(rv map[string]any) *provisionedhostPaginateArgs {
	args := &provisionedhostPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pn *ProvisionedNetworkQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProvisionedNetworkQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pn, nil
	}
	if err := pn.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pn, nil
}

func (pn *ProvisionedNetworkQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(provisionednetwork.Columns))
		selectedFields = []string{provisionednetwork.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "status":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&StatusClient{config: pn.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pn.withStatus = query
		case "network":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NetworkClient{config: pn.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pn.withNetwork = query
		case "build":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildClient{config: pn.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pn.withBuild = query
		case "team":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TeamClient{config: pn.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pn.withTeam = query
		case "provisionedhosts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedHostClient{config: pn.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pn.WithNamedProvisionedHosts(alias, func(wq *ProvisionedHostQuery) {
				*wq = *query
			})
		case "plan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanClient{config: pn.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pn.withPlan = query
		case "name":
			if _, ok := fieldSeen[provisionednetwork.FieldName]; !ok {
				selectedFields = append(selectedFields, provisionednetwork.FieldName)
				fieldSeen[provisionednetwork.FieldName] = struct{}{}
			}
		case "cidr":
			if _, ok := fieldSeen[provisionednetwork.FieldCidr]; !ok {
				selectedFields = append(selectedFields, provisionednetwork.FieldCidr)
				fieldSeen[provisionednetwork.FieldCidr] = struct{}{}
			}
		case "vars":
			if _, ok := fieldSeen[provisionednetwork.FieldVars]; !ok {
				selectedFields = append(selectedFields, provisionednetwork.FieldVars)
				fieldSeen[provisionednetwork.FieldVars] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pn.Select(selectedFields...)
	}
	return nil
}

type provisionednetworkPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProvisionedNetworkPaginateOption
}

func newProvisionedNetworkPaginateArgs(rv map[string]any) *provisionednetworkPaginateArgs {
	args := &provisionednetworkPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pss *ProvisioningScheduledStepQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProvisioningScheduledStepQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pss, nil
	}
	if err := pss.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pss, nil
}

func (pss *ProvisioningScheduledStepQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(provisioningscheduledstep.Columns))
		selectedFields = []string{provisioningscheduledstep.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "status":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&StatusClient{config: pss.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pss.withStatus = query
		case "scheduledstep":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ScheduledStepClient{config: pss.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pss.withScheduledStep = query
		case "provisionedhost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedHostClient{config: pss.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pss.withProvisionedHost = query
		case "script":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ScriptClient{config: pss.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pss.withScript = query
		case "command":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CommandClient{config: pss.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pss.withCommand = query
		case "dnsrecord":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DNSRecordClient{config: pss.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pss.withDNSRecord = query
		case "filedelete":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileDeleteClient{config: pss.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pss.withFileDelete = query
		case "filedownload":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileDownloadClient{config: pss.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pss.withFileDownload = query
		case "fileextract":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileExtractClient{config: pss.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pss.withFileExtract = query
		case "ansible":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AnsibleClient{config: pss.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pss.withAnsible = query
		case "agenttasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AgentTaskClient{config: pss.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pss.WithNamedAgentTasks(alias, func(wq *AgentTaskQuery) {
				*wq = *query
			})
		case "plan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanClient{config: pss.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pss.withPlan = query
		case "ginfilemiddleware":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GinFileMiddlewareClient{config: pss.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pss.withGinFileMiddleware = query
		case "type":
			if _, ok := fieldSeen[provisioningscheduledstep.FieldType]; !ok {
				selectedFields = append(selectedFields, provisioningscheduledstep.FieldType)
				fieldSeen[provisioningscheduledstep.FieldType] = struct{}{}
			}
		case "runTime":
			if _, ok := fieldSeen[provisioningscheduledstep.FieldRunTime]; !ok {
				selectedFields = append(selectedFields, provisioningscheduledstep.FieldRunTime)
				fieldSeen[provisioningscheduledstep.FieldRunTime] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pss.Select(selectedFields...)
	}
	return nil
}

type provisioningscheduledstepPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProvisioningScheduledStepPaginateOption
}

func newProvisioningScheduledStepPaginateArgs(rv map[string]any) *provisioningscheduledstepPaginateArgs {
	args := &provisioningscheduledstepPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ps *ProvisioningStepQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProvisioningStepQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ps, nil
	}
	if err := ps.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ps, nil
}

func (ps *ProvisioningStepQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(provisioningstep.Columns))
		selectedFields = []string{provisioningstep.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "status":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&StatusClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.withStatus = query
		case "provisionedhost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedHostClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.withProvisionedHost = query
		case "script":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ScriptClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.withScript = query
		case "command":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CommandClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.withCommand = query
		case "dnsrecord":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DNSRecordClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.withDNSRecord = query
		case "filedelete":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileDeleteClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.withFileDelete = query
		case "filedownload":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileDownloadClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.withFileDownload = query
		case "fileextract":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FileExtractClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.withFileExtract = query
		case "ansible":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AnsibleClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.withAnsible = query
		case "plan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.withPlan = query
		case "agenttasks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AgentTaskClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.WithNamedAgentTasks(alias, func(wq *AgentTaskQuery) {
				*wq = *query
			})
		case "ginfilemiddleware":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GinFileMiddlewareClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.withGinFileMiddleware = query
		case "type":
			if _, ok := fieldSeen[provisioningstep.FieldType]; !ok {
				selectedFields = append(selectedFields, provisioningstep.FieldType)
				fieldSeen[provisioningstep.FieldType] = struct{}{}
			}
		case "stepNumber":
			if _, ok := fieldSeen[provisioningstep.FieldStepNumber]; !ok {
				selectedFields = append(selectedFields, provisioningstep.FieldStepNumber)
				fieldSeen[provisioningstep.FieldStepNumber] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ps.Select(selectedFields...)
	}
	return nil
}

type provisioningstepPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProvisioningStepPaginateOption
}

func newProvisioningStepPaginateArgs(rv map[string]any) *provisioningstepPaginateArgs {
	args := &provisioningstepPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (rc *RepoCommitQuery) CollectFields(ctx context.Context, satisfies ...string) (*RepoCommitQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return rc, nil
	}
	if err := rc.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return rc, nil
}

func (rc *RepoCommitQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(repocommit.Columns))
		selectedFields = []string{repocommit.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "repository":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RepositoryClient{config: rc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			rc.withRepository = query
		case "revision":
			if _, ok := fieldSeen[repocommit.FieldRevision]; !ok {
				selectedFields = append(selectedFields, repocommit.FieldRevision)
				fieldSeen[repocommit.FieldRevision] = struct{}{}
			}
		case "hash":
			if _, ok := fieldSeen[repocommit.FieldHash]; !ok {
				selectedFields = append(selectedFields, repocommit.FieldHash)
				fieldSeen[repocommit.FieldHash] = struct{}{}
			}
		case "author":
			if _, ok := fieldSeen[repocommit.FieldAuthor]; !ok {
				selectedFields = append(selectedFields, repocommit.FieldAuthor)
				fieldSeen[repocommit.FieldAuthor] = struct{}{}
			}
		case "committer":
			if _, ok := fieldSeen[repocommit.FieldCommitter]; !ok {
				selectedFields = append(selectedFields, repocommit.FieldCommitter)
				fieldSeen[repocommit.FieldCommitter] = struct{}{}
			}
		case "pgpSignature":
			if _, ok := fieldSeen[repocommit.FieldPgpSignature]; !ok {
				selectedFields = append(selectedFields, repocommit.FieldPgpSignature)
				fieldSeen[repocommit.FieldPgpSignature] = struct{}{}
			}
		case "message":
			if _, ok := fieldSeen[repocommit.FieldMessage]; !ok {
				selectedFields = append(selectedFields, repocommit.FieldMessage)
				fieldSeen[repocommit.FieldMessage] = struct{}{}
			}
		case "treeHash":
			if _, ok := fieldSeen[repocommit.FieldTreeHash]; !ok {
				selectedFields = append(selectedFields, repocommit.FieldTreeHash)
				fieldSeen[repocommit.FieldTreeHash] = struct{}{}
			}
		case "parentHashes":
			if _, ok := fieldSeen[repocommit.FieldParentHashes]; !ok {
				selectedFields = append(selectedFields, repocommit.FieldParentHashes)
				fieldSeen[repocommit.FieldParentHashes] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		rc.Select(selectedFields...)
	}
	return nil
}

type repocommitPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []RepoCommitPaginateOption
}

func newRepoCommitPaginateArgs(rv map[string]any) *repocommitPaginateArgs {
	args := &repocommitPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (r *RepositoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*RepositoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return r, nil
	}
	if err := r.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return r, nil
}

func (r *RepositoryQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(repository.Columns))
		selectedFields = []string{repository.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "environments":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: r.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			r.WithNamedEnvironments(alias, func(wq *EnvironmentQuery) {
				*wq = *query
			})
		case "repocommits":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&RepoCommitClient{config: r.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			r.WithNamedRepoCommits(alias, func(wq *RepoCommitQuery) {
				*wq = *query
			})
		case "repoURL":
			if _, ok := fieldSeen[repository.FieldRepoURL]; !ok {
				selectedFields = append(selectedFields, repository.FieldRepoURL)
				fieldSeen[repository.FieldRepoURL] = struct{}{}
			}
		case "branchName":
			if _, ok := fieldSeen[repository.FieldBranchName]; !ok {
				selectedFields = append(selectedFields, repository.FieldBranchName)
				fieldSeen[repository.FieldBranchName] = struct{}{}
			}
		case "enviromentFilepath":
			if _, ok := fieldSeen[repository.FieldEnviromentFilepath]; !ok {
				selectedFields = append(selectedFields, repository.FieldEnviromentFilepath)
				fieldSeen[repository.FieldEnviromentFilepath] = struct{}{}
			}
		case "folderPath":
			if _, ok := fieldSeen[repository.FieldFolderPath]; !ok {
				selectedFields = append(selectedFields, repository.FieldFolderPath)
				fieldSeen[repository.FieldFolderPath] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		r.Select(selectedFields...)
	}
	return nil
}

type repositoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []RepositoryPaginateOption
}

func newRepositoryPaginateArgs(rv map[string]any) *repositoryPaginateArgs {
	args := &repositoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ss *ScheduledStepQuery) CollectFields(ctx context.Context, satisfies ...string) (*ScheduledStepQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ss, nil
	}
	if err := ss.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ss, nil
}

func (ss *ScheduledStepQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(scheduledstep.Columns))
		selectedFields = []string{scheduledstep.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "environment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: ss.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ss.withEnvironment = query
		case "hclID":
			if _, ok := fieldSeen[scheduledstep.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, scheduledstep.FieldHCLID)
				fieldSeen[scheduledstep.FieldHCLID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[scheduledstep.FieldName]; !ok {
				selectedFields = append(selectedFields, scheduledstep.FieldName)
				fieldSeen[scheduledstep.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[scheduledstep.FieldDescription]; !ok {
				selectedFields = append(selectedFields, scheduledstep.FieldDescription)
				fieldSeen[scheduledstep.FieldDescription] = struct{}{}
			}
		case "step":
			if _, ok := fieldSeen[scheduledstep.FieldStep]; !ok {
				selectedFields = append(selectedFields, scheduledstep.FieldStep)
				fieldSeen[scheduledstep.FieldStep] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[scheduledstep.FieldType]; !ok {
				selectedFields = append(selectedFields, scheduledstep.FieldType)
				fieldSeen[scheduledstep.FieldType] = struct{}{}
			}
		case "schedule":
			if _, ok := fieldSeen[scheduledstep.FieldSchedule]; !ok {
				selectedFields = append(selectedFields, scheduledstep.FieldSchedule)
				fieldSeen[scheduledstep.FieldSchedule] = struct{}{}
			}
		case "runAt":
			if _, ok := fieldSeen[scheduledstep.FieldRunAt]; !ok {
				selectedFields = append(selectedFields, scheduledstep.FieldRunAt)
				fieldSeen[scheduledstep.FieldRunAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ss.Select(selectedFields...)
	}
	return nil
}

type scheduledstepPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ScheduledStepPaginateOption
}

func newScheduledStepPaginateArgs(rv map[string]any) *scheduledstepPaginateArgs {
	args := &scheduledstepPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (s *ScriptQuery) CollectFields(ctx context.Context, satisfies ...string) (*ScriptQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return s, nil
	}
	if err := s.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *ScriptQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(script.Columns))
		selectedFields = []string{script.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "users":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.WithNamedUsers(alias, func(wq *UserQuery) {
				*wq = *query
			})
		case "findings":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&FindingClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.WithNamedFindings(alias, func(wq *FindingQuery) {
				*wq = *query
			})
		case "environment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.withEnvironment = query
		case "hclID":
			if _, ok := fieldSeen[script.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, script.FieldHCLID)
				fieldSeen[script.FieldHCLID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[script.FieldName]; !ok {
				selectedFields = append(selectedFields, script.FieldName)
				fieldSeen[script.FieldName] = struct{}{}
			}
		case "language":
			if _, ok := fieldSeen[script.FieldLanguage]; !ok {
				selectedFields = append(selectedFields, script.FieldLanguage)
				fieldSeen[script.FieldLanguage] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[script.FieldDescription]; !ok {
				selectedFields = append(selectedFields, script.FieldDescription)
				fieldSeen[script.FieldDescription] = struct{}{}
			}
		case "source":
			if _, ok := fieldSeen[script.FieldSource]; !ok {
				selectedFields = append(selectedFields, script.FieldSource)
				fieldSeen[script.FieldSource] = struct{}{}
			}
		case "sourceType":
			if _, ok := fieldSeen[script.FieldSourceType]; !ok {
				selectedFields = append(selectedFields, script.FieldSourceType)
				fieldSeen[script.FieldSourceType] = struct{}{}
			}
		case "cooldown":
			if _, ok := fieldSeen[script.FieldCooldown]; !ok {
				selectedFields = append(selectedFields, script.FieldCooldown)
				fieldSeen[script.FieldCooldown] = struct{}{}
			}
		case "timeout":
			if _, ok := fieldSeen[script.FieldTimeout]; !ok {
				selectedFields = append(selectedFields, script.FieldTimeout)
				fieldSeen[script.FieldTimeout] = struct{}{}
			}
		case "ignoreErrors":
			if _, ok := fieldSeen[script.FieldIgnoreErrors]; !ok {
				selectedFields = append(selectedFields, script.FieldIgnoreErrors)
				fieldSeen[script.FieldIgnoreErrors] = struct{}{}
			}
		case "args":
			if _, ok := fieldSeen[script.FieldArgs]; !ok {
				selectedFields = append(selectedFields, script.FieldArgs)
				fieldSeen[script.FieldArgs] = struct{}{}
			}
		case "disabled":
			if _, ok := fieldSeen[script.FieldDisabled]; !ok {
				selectedFields = append(selectedFields, script.FieldDisabled)
				fieldSeen[script.FieldDisabled] = struct{}{}
			}
		case "vars":
			if _, ok := fieldSeen[script.FieldVars]; !ok {
				selectedFields = append(selectedFields, script.FieldVars)
				fieldSeen[script.FieldVars] = struct{}{}
			}
		case "absPath":
			if _, ok := fieldSeen[script.FieldAbsPath]; !ok {
				selectedFields = append(selectedFields, script.FieldAbsPath)
				fieldSeen[script.FieldAbsPath] = struct{}{}
			}
		case "tags":
			if _, ok := fieldSeen[script.FieldTags]; !ok {
				selectedFields = append(selectedFields, script.FieldTags)
				fieldSeen[script.FieldTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		s.Select(selectedFields...)
	}
	return nil
}

type scriptPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ScriptPaginateOption
}

func newScriptPaginateArgs(rv map[string]any) *scriptPaginateArgs {
	args := &scriptPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (st *ServerTaskQuery) CollectFields(ctx context.Context, satisfies ...string) (*ServerTaskQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return st, nil
	}
	if err := st.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return st, nil
}

func (st *ServerTaskQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(servertask.Columns))
		selectedFields = []string{servertask.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "authuser":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AuthUserClient{config: st.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			st.withAuthUser = query
		case "status":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&StatusClient{config: st.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			st.withStatus = query
		case "environment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: st.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			st.withEnvironment = query
		case "build":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildClient{config: st.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			st.withBuild = query
		case "buildcommit":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildCommitClient{config: st.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			st.withBuildCommit = query
		case "ginfilemiddleware":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&GinFileMiddlewareClient{config: st.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			st.WithNamedGinFileMiddleware(alias, func(wq *GinFileMiddlewareQuery) {
				*wq = *query
			})
		case "type":
			if _, ok := fieldSeen[servertask.FieldType]; !ok {
				selectedFields = append(selectedFields, servertask.FieldType)
				fieldSeen[servertask.FieldType] = struct{}{}
			}
		case "startTime":
			if _, ok := fieldSeen[servertask.FieldStartTime]; !ok {
				selectedFields = append(selectedFields, servertask.FieldStartTime)
				fieldSeen[servertask.FieldStartTime] = struct{}{}
			}
		case "endTime":
			if _, ok := fieldSeen[servertask.FieldEndTime]; !ok {
				selectedFields = append(selectedFields, servertask.FieldEndTime)
				fieldSeen[servertask.FieldEndTime] = struct{}{}
			}
		case "errors":
			if _, ok := fieldSeen[servertask.FieldErrors]; !ok {
				selectedFields = append(selectedFields, servertask.FieldErrors)
				fieldSeen[servertask.FieldErrors] = struct{}{}
			}
		case "logFilePath":
			if _, ok := fieldSeen[servertask.FieldLogFilePath]; !ok {
				selectedFields = append(selectedFields, servertask.FieldLogFilePath)
				fieldSeen[servertask.FieldLogFilePath] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		st.Select(selectedFields...)
	}
	return nil
}

type servertaskPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ServerTaskPaginateOption
}

func newServerTaskPaginateArgs(rv map[string]any) *servertaskPaginateArgs {
	args := &servertaskPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (s *StatusQuery) CollectFields(ctx context.Context, satisfies ...string) (*StatusQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return s, nil
	}
	if err := s.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *StatusQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(status.Columns))
		selectedFields = []string{status.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "build":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.withBuild = query
		case "provisionednetwork":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedNetworkClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.withProvisionedNetwork = query
		case "provisionedhost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedHostClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.withProvisionedHost = query
		case "provisioningstep":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisioningStepClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.withProvisioningStep = query
		case "team":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TeamClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.withTeam = query
		case "plan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.withPlan = query
		case "servertask":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ServerTaskClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.withServerTask = query
		case "adhocplan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AdhocPlanClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.withAdhocPlan = query
		case "provisioningscheduledstep":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisioningScheduledStepClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.withProvisioningScheduledStep = query
		case "state":
			if _, ok := fieldSeen[status.FieldState]; !ok {
				selectedFields = append(selectedFields, status.FieldState)
				fieldSeen[status.FieldState] = struct{}{}
			}
		case "statusFor":
			if _, ok := fieldSeen[status.FieldStatusFor]; !ok {
				selectedFields = append(selectedFields, status.FieldStatusFor)
				fieldSeen[status.FieldStatusFor] = struct{}{}
			}
		case "startedAt":
			if _, ok := fieldSeen[status.FieldStartedAt]; !ok {
				selectedFields = append(selectedFields, status.FieldStartedAt)
				fieldSeen[status.FieldStartedAt] = struct{}{}
			}
		case "endedAt":
			if _, ok := fieldSeen[status.FieldEndedAt]; !ok {
				selectedFields = append(selectedFields, status.FieldEndedAt)
				fieldSeen[status.FieldEndedAt] = struct{}{}
			}
		case "failed":
			if _, ok := fieldSeen[status.FieldFailed]; !ok {
				selectedFields = append(selectedFields, status.FieldFailed)
				fieldSeen[status.FieldFailed] = struct{}{}
			}
		case "completed":
			if _, ok := fieldSeen[status.FieldCompleted]; !ok {
				selectedFields = append(selectedFields, status.FieldCompleted)
				fieldSeen[status.FieldCompleted] = struct{}{}
			}
		case "error":
			if _, ok := fieldSeen[status.FieldError]; !ok {
				selectedFields = append(selectedFields, status.FieldError)
				fieldSeen[status.FieldError] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		s.Select(selectedFields...)
	}
	return nil
}

type statusPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []StatusPaginateOption
}

func newStatusPaginateArgs(rv map[string]any) *statusPaginateArgs {
	args := &statusPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (t *TagQuery) CollectFields(ctx context.Context, satisfies ...string) (*TagQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return t, nil
	}
	if err := t.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return t, nil
}

func (t *TagQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(tag.Columns))
		selectedFields = []string{tag.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "uuid":
			if _, ok := fieldSeen[tag.FieldUUID]; !ok {
				selectedFields = append(selectedFields, tag.FieldUUID)
				fieldSeen[tag.FieldUUID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[tag.FieldName]; !ok {
				selectedFields = append(selectedFields, tag.FieldName)
				fieldSeen[tag.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[tag.FieldDescription]; !ok {
				selectedFields = append(selectedFields, tag.FieldDescription)
				fieldSeen[tag.FieldDescription] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		t.Select(selectedFields...)
	}
	return nil
}

type tagPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TagPaginateOption
}

func newTagPaginateArgs(rv map[string]any) *tagPaginateArgs {
	args := &tagPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (t *TeamQuery) CollectFields(ctx context.Context, satisfies ...string) (*TeamQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return t, nil
	}
	if err := t.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return t, nil
}

func (t *TeamQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(team.Columns))
		selectedFields = []string{team.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "build":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BuildClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			t.withBuild = query
		case "status":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&StatusClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			t.withStatus = query
		case "provisionednetworks":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProvisionedNetworkClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			t.WithNamedProvisionedNetworks(alias, func(wq *ProvisionedNetworkQuery) {
				*wq = *query
			})
		case "plan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			t.withPlan = query
		case "teamNumber":
			if _, ok := fieldSeen[team.FieldTeamNumber]; !ok {
				selectedFields = append(selectedFields, team.FieldTeamNumber)
				fieldSeen[team.FieldTeamNumber] = struct{}{}
			}
		case "vars":
			if _, ok := fieldSeen[team.FieldVars]; !ok {
				selectedFields = append(selectedFields, team.FieldVars)
				fieldSeen[team.FieldVars] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		t.Select(selectedFields...)
	}
	return nil
}

type teamPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TeamPaginateOption
}

func newTeamPaginateArgs(rv map[string]any) *teamPaginateArgs {
	args := &teamPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (t *TokenQuery) CollectFields(ctx context.Context, satisfies ...string) (*TokenQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return t, nil
	}
	if err := t.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return t, nil
}

func (t *TokenQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(token.Columns))
		selectedFields = []string{token.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "authuser":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AuthUserClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			t.withAuthUser = query
		case "token":
			if _, ok := fieldSeen[token.FieldToken]; !ok {
				selectedFields = append(selectedFields, token.FieldToken)
				fieldSeen[token.FieldToken] = struct{}{}
			}
		case "expireAt":
			if _, ok := fieldSeen[token.FieldExpireAt]; !ok {
				selectedFields = append(selectedFields, token.FieldExpireAt)
				fieldSeen[token.FieldExpireAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		t.Select(selectedFields...)
	}
	return nil
}

type tokenPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TokenPaginateOption
}

func newTokenPaginateArgs(rv map[string]any) *tokenPaginateArgs {
	args := &tokenPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (u *UserQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return u, nil
	}
	if err := u.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return u, nil
}

func (u *UserQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(user.Columns))
		selectedFields = []string{user.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "tag":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TagClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedTag(alias, func(wq *TagQuery) {
				*wq = *query
			})
		case "environments":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EnvironmentClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedEnvironments(alias, func(wq *EnvironmentQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[user.FieldName]; !ok {
				selectedFields = append(selectedFields, user.FieldName)
				fieldSeen[user.FieldName] = struct{}{}
			}
		case "uuid":
			if _, ok := fieldSeen[user.FieldUUID]; !ok {
				selectedFields = append(selectedFields, user.FieldUUID)
				fieldSeen[user.FieldUUID] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[user.FieldEmail]; !ok {
				selectedFields = append(selectedFields, user.FieldEmail)
				fieldSeen[user.FieldEmail] = struct{}{}
			}
		case "hclID":
			if _, ok := fieldSeen[user.FieldHCLID]; !ok {
				selectedFields = append(selectedFields, user.FieldHCLID)
				fieldSeen[user.FieldHCLID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		u.Select(selectedFields...)
	}
	return nil
}

type userPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserPaginateOption
}

func newUserPaginateArgs(rv map[string]any) *userPaginateArgs {
	args := &userPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput any, path ...string) map[string]any {
	field := collectedField(ctx, path...)
	if field == nil || field.Arguments == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	args := field.ArgumentMap(oc.Variables)
	return unmarshalArgs(ctx, whereInput, args)
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput any, args map[string]any) map[string]any {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

func limitRows(partitionBy string, limit int, orderBy ...sql.Querier) func(s *sql.Selector) {
	return func(s *sql.Selector) {
		d := sql.Dialect(s.Dialect())
		s.SetDistinct(false)
		with := d.With("src_query").
			As(s.Clone()).
			With("limited_query").
			As(
				d.Select("*").
					AppendSelectExprAs(
						sql.RowNumber().PartitionBy(partitionBy).OrderExpr(orderBy...),
						"row_number",
					).
					From(d.Table("src_query")),
			)
		t := d.Table("limited_query").As(s.TableName())
		*s = *d.Select(s.UnqualifiedColumns()...).
			From(t).
			Where(sql.LTE(t.C("row_number"), limit)).
			Prefix(with)
	}
}

// mayAddCondition appends another type condition to the satisfies list
// if condition is enabled (Node/Nodes) and it does not exist in the list.
func mayAddCondition(satisfies []string, typeCond string) []string {
	if len(satisfies) == 0 {
		return satisfies
	}
	for _, s := range satisfies {
		if typeCond == s {
			return satisfies
		}
	}
	return append(satisfies, typeCond)
}
