// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/gen0cide/laforge/ent/adhocplan"
	"github.com/gen0cide/laforge/ent/agentstatus"
	"github.com/gen0cide/laforge/ent/agenttask"
	"github.com/gen0cide/laforge/ent/ansible"
	"github.com/gen0cide/laforge/ent/authuser"
	"github.com/gen0cide/laforge/ent/build"
	"github.com/gen0cide/laforge/ent/buildcommit"
	"github.com/gen0cide/laforge/ent/command"
	"github.com/gen0cide/laforge/ent/competition"
	"github.com/gen0cide/laforge/ent/disk"
	"github.com/gen0cide/laforge/ent/dns"
	"github.com/gen0cide/laforge/ent/dnsrecord"
	"github.com/gen0cide/laforge/ent/environment"
	"github.com/gen0cide/laforge/ent/filedelete"
	"github.com/gen0cide/laforge/ent/filedownload"
	"github.com/gen0cide/laforge/ent/fileextract"
	"github.com/gen0cide/laforge/ent/finding"
	"github.com/gen0cide/laforge/ent/ginfilemiddleware"
	"github.com/gen0cide/laforge/ent/host"
	"github.com/gen0cide/laforge/ent/hostdependency"
	"github.com/gen0cide/laforge/ent/identity"
	"github.com/gen0cide/laforge/ent/includednetwork"
	"github.com/gen0cide/laforge/ent/network"
	"github.com/gen0cide/laforge/ent/plan"
	"github.com/gen0cide/laforge/ent/plandiff"
	"github.com/gen0cide/laforge/ent/provisionedhost"
	"github.com/gen0cide/laforge/ent/provisionednetwork"
	"github.com/gen0cide/laforge/ent/provisioningstep"
	"github.com/gen0cide/laforge/ent/repocommit"
	"github.com/gen0cide/laforge/ent/repository"
	"github.com/gen0cide/laforge/ent/script"
	"github.com/gen0cide/laforge/ent/servertask"
	"github.com/gen0cide/laforge/ent/status"
	"github.com/gen0cide/laforge/ent/tag"
	"github.com/gen0cide/laforge/ent/team"
	"github.com/gen0cide/laforge/ent/token"
	"github.com/gen0cide/laforge/ent/user"
	"github.com/google/uuid"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[uuid.UUID]
	PageInfo       = entgql.PageInfo[uuid.UUID]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// AdhocPlanEdge is the edge representation of AdhocPlan.
type AdhocPlanEdge struct {
	Node   *AdhocPlan `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// AdhocPlanConnection is the connection containing edges to AdhocPlan.
type AdhocPlanConnection struct {
	Edges      []*AdhocPlanEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *AdhocPlanConnection) build(nodes []*AdhocPlan, pager *adhocplanPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *AdhocPlan
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AdhocPlan {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AdhocPlan {
			return nodes[i]
		}
	}
	c.Edges = make([]*AdhocPlanEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AdhocPlanEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AdhocPlanPaginateOption enables pagination customization.
type AdhocPlanPaginateOption func(*adhocplanPager) error

// WithAdhocPlanOrder configures pagination ordering.
func WithAdhocPlanOrder(order *AdhocPlanOrder) AdhocPlanPaginateOption {
	if order == nil {
		order = DefaultAdhocPlanOrder
	}
	o := *order
	return func(pager *adhocplanPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAdhocPlanOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAdhocPlanFilter configures pagination filter.
func WithAdhocPlanFilter(filter func(*AdhocPlanQuery) (*AdhocPlanQuery, error)) AdhocPlanPaginateOption {
	return func(pager *adhocplanPager) error {
		if filter == nil {
			return errors.New("AdhocPlanQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type adhocplanPager struct {
	reverse bool
	order   *AdhocPlanOrder
	filter  func(*AdhocPlanQuery) (*AdhocPlanQuery, error)
}

func newAdhocPlanPager(opts []AdhocPlanPaginateOption, reverse bool) (*adhocplanPager, error) {
	pager := &adhocplanPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAdhocPlanOrder
	}
	return pager, nil
}

func (p *adhocplanPager) applyFilter(query *AdhocPlanQuery) (*AdhocPlanQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *adhocplanPager) toCursor(ap *AdhocPlan) Cursor {
	return p.order.Field.toCursor(ap)
}

func (p *adhocplanPager) applyCursors(query *AdhocPlanQuery, after, before *Cursor) (*AdhocPlanQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAdhocPlanOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *adhocplanPager) applyOrder(query *AdhocPlanQuery) *AdhocPlanQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAdhocPlanOrder.Field {
		query = query.Order(DefaultAdhocPlanOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *adhocplanPager) orderExpr(query *AdhocPlanQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAdhocPlanOrder.Field {
			b.Comma().Ident(DefaultAdhocPlanOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AdhocPlan.
func (ap *AdhocPlanQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AdhocPlanPaginateOption,
) (*AdhocPlanConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAdhocPlanPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ap, err = pager.applyFilter(ap); err != nil {
		return nil, err
	}
	conn := &AdhocPlanConnection{Edges: []*AdhocPlanEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ap.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ap, err = pager.applyCursors(ap, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ap.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ap.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ap = pager.applyOrder(ap)
	nodes, err := ap.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// AdhocPlanOrderField defines the ordering field of AdhocPlan.
type AdhocPlanOrderField struct {
	// Value extracts the ordering value from the given AdhocPlan.
	Value    func(*AdhocPlan) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) adhocplan.OrderOption
	toCursor func(*AdhocPlan) Cursor
}

// AdhocPlanOrder defines the ordering of AdhocPlan.
type AdhocPlanOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *AdhocPlanOrderField `json:"field"`
}

// DefaultAdhocPlanOrder is the default ordering of AdhocPlan.
var DefaultAdhocPlanOrder = &AdhocPlanOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AdhocPlanOrderField{
		Value: func(ap *AdhocPlan) (ent.Value, error) {
			return ap.ID, nil
		},
		column: adhocplan.FieldID,
		toTerm: adhocplan.ByID,
		toCursor: func(ap *AdhocPlan) Cursor {
			return Cursor{ID: ap.ID}
		},
	},
}

// ToEdge converts AdhocPlan into AdhocPlanEdge.
func (ap *AdhocPlan) ToEdge(order *AdhocPlanOrder) *AdhocPlanEdge {
	if order == nil {
		order = DefaultAdhocPlanOrder
	}
	return &AdhocPlanEdge{
		Node:   ap,
		Cursor: order.Field.toCursor(ap),
	}
}

// AgentStatusEdge is the edge representation of AgentStatus.
type AgentStatusEdge struct {
	Node   *AgentStatus `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// AgentStatusConnection is the connection containing edges to AgentStatus.
type AgentStatusConnection struct {
	Edges      []*AgentStatusEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *AgentStatusConnection) build(nodes []*AgentStatus, pager *agentstatusPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *AgentStatus
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AgentStatus {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AgentStatus {
			return nodes[i]
		}
	}
	c.Edges = make([]*AgentStatusEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AgentStatusEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AgentStatusPaginateOption enables pagination customization.
type AgentStatusPaginateOption func(*agentstatusPager) error

// WithAgentStatusOrder configures pagination ordering.
func WithAgentStatusOrder(order *AgentStatusOrder) AgentStatusPaginateOption {
	if order == nil {
		order = DefaultAgentStatusOrder
	}
	o := *order
	return func(pager *agentstatusPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAgentStatusOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAgentStatusFilter configures pagination filter.
func WithAgentStatusFilter(filter func(*AgentStatusQuery) (*AgentStatusQuery, error)) AgentStatusPaginateOption {
	return func(pager *agentstatusPager) error {
		if filter == nil {
			return errors.New("AgentStatusQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type agentstatusPager struct {
	reverse bool
	order   *AgentStatusOrder
	filter  func(*AgentStatusQuery) (*AgentStatusQuery, error)
}

func newAgentStatusPager(opts []AgentStatusPaginateOption, reverse bool) (*agentstatusPager, error) {
	pager := &agentstatusPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAgentStatusOrder
	}
	return pager, nil
}

func (p *agentstatusPager) applyFilter(query *AgentStatusQuery) (*AgentStatusQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *agentstatusPager) toCursor(as *AgentStatus) Cursor {
	return p.order.Field.toCursor(as)
}

func (p *agentstatusPager) applyCursors(query *AgentStatusQuery, after, before *Cursor) (*AgentStatusQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAgentStatusOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *agentstatusPager) applyOrder(query *AgentStatusQuery) *AgentStatusQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAgentStatusOrder.Field {
		query = query.Order(DefaultAgentStatusOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *agentstatusPager) orderExpr(query *AgentStatusQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAgentStatusOrder.Field {
			b.Comma().Ident(DefaultAgentStatusOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AgentStatus.
func (as *AgentStatusQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AgentStatusPaginateOption,
) (*AgentStatusConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAgentStatusPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if as, err = pager.applyFilter(as); err != nil {
		return nil, err
	}
	conn := &AgentStatusConnection{Edges: []*AgentStatusEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = as.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if as, err = pager.applyCursors(as, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		as.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := as.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	as = pager.applyOrder(as)
	nodes, err := as.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// AgentStatusOrderField defines the ordering field of AgentStatus.
type AgentStatusOrderField struct {
	// Value extracts the ordering value from the given AgentStatus.
	Value    func(*AgentStatus) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) agentstatus.OrderOption
	toCursor func(*AgentStatus) Cursor
}

// AgentStatusOrder defines the ordering of AgentStatus.
type AgentStatusOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *AgentStatusOrderField `json:"field"`
}

// DefaultAgentStatusOrder is the default ordering of AgentStatus.
var DefaultAgentStatusOrder = &AgentStatusOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AgentStatusOrderField{
		Value: func(as *AgentStatus) (ent.Value, error) {
			return as.ID, nil
		},
		column: agentstatus.FieldID,
		toTerm: agentstatus.ByID,
		toCursor: func(as *AgentStatus) Cursor {
			return Cursor{ID: as.ID}
		},
	},
}

// ToEdge converts AgentStatus into AgentStatusEdge.
func (as *AgentStatus) ToEdge(order *AgentStatusOrder) *AgentStatusEdge {
	if order == nil {
		order = DefaultAgentStatusOrder
	}
	return &AgentStatusEdge{
		Node:   as,
		Cursor: order.Field.toCursor(as),
	}
}

// AgentTaskEdge is the edge representation of AgentTask.
type AgentTaskEdge struct {
	Node   *AgentTask `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// AgentTaskConnection is the connection containing edges to AgentTask.
type AgentTaskConnection struct {
	Edges      []*AgentTaskEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *AgentTaskConnection) build(nodes []*AgentTask, pager *agenttaskPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *AgentTask
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AgentTask {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AgentTask {
			return nodes[i]
		}
	}
	c.Edges = make([]*AgentTaskEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AgentTaskEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AgentTaskPaginateOption enables pagination customization.
type AgentTaskPaginateOption func(*agenttaskPager) error

// WithAgentTaskOrder configures pagination ordering.
func WithAgentTaskOrder(order *AgentTaskOrder) AgentTaskPaginateOption {
	if order == nil {
		order = DefaultAgentTaskOrder
	}
	o := *order
	return func(pager *agenttaskPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAgentTaskOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAgentTaskFilter configures pagination filter.
func WithAgentTaskFilter(filter func(*AgentTaskQuery) (*AgentTaskQuery, error)) AgentTaskPaginateOption {
	return func(pager *agenttaskPager) error {
		if filter == nil {
			return errors.New("AgentTaskQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type agenttaskPager struct {
	reverse bool
	order   *AgentTaskOrder
	filter  func(*AgentTaskQuery) (*AgentTaskQuery, error)
}

func newAgentTaskPager(opts []AgentTaskPaginateOption, reverse bool) (*agenttaskPager, error) {
	pager := &agenttaskPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAgentTaskOrder
	}
	return pager, nil
}

func (p *agenttaskPager) applyFilter(query *AgentTaskQuery) (*AgentTaskQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *agenttaskPager) toCursor(at *AgentTask) Cursor {
	return p.order.Field.toCursor(at)
}

func (p *agenttaskPager) applyCursors(query *AgentTaskQuery, after, before *Cursor) (*AgentTaskQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAgentTaskOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *agenttaskPager) applyOrder(query *AgentTaskQuery) *AgentTaskQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAgentTaskOrder.Field {
		query = query.Order(DefaultAgentTaskOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *agenttaskPager) orderExpr(query *AgentTaskQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAgentTaskOrder.Field {
			b.Comma().Ident(DefaultAgentTaskOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AgentTask.
func (at *AgentTaskQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AgentTaskPaginateOption,
) (*AgentTaskConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAgentTaskPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if at, err = pager.applyFilter(at); err != nil {
		return nil, err
	}
	conn := &AgentTaskConnection{Edges: []*AgentTaskEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = at.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if at, err = pager.applyCursors(at, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		at.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := at.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	at = pager.applyOrder(at)
	nodes, err := at.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// AgentTaskOrderField defines the ordering field of AgentTask.
type AgentTaskOrderField struct {
	// Value extracts the ordering value from the given AgentTask.
	Value    func(*AgentTask) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) agenttask.OrderOption
	toCursor func(*AgentTask) Cursor
}

// AgentTaskOrder defines the ordering of AgentTask.
type AgentTaskOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *AgentTaskOrderField `json:"field"`
}

// DefaultAgentTaskOrder is the default ordering of AgentTask.
var DefaultAgentTaskOrder = &AgentTaskOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AgentTaskOrderField{
		Value: func(at *AgentTask) (ent.Value, error) {
			return at.ID, nil
		},
		column: agenttask.FieldID,
		toTerm: agenttask.ByID,
		toCursor: func(at *AgentTask) Cursor {
			return Cursor{ID: at.ID}
		},
	},
}

// ToEdge converts AgentTask into AgentTaskEdge.
func (at *AgentTask) ToEdge(order *AgentTaskOrder) *AgentTaskEdge {
	if order == nil {
		order = DefaultAgentTaskOrder
	}
	return &AgentTaskEdge{
		Node:   at,
		Cursor: order.Field.toCursor(at),
	}
}

// AnsibleEdge is the edge representation of Ansible.
type AnsibleEdge struct {
	Node   *Ansible `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// AnsibleConnection is the connection containing edges to Ansible.
type AnsibleConnection struct {
	Edges      []*AnsibleEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *AnsibleConnection) build(nodes []*Ansible, pager *ansiblePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Ansible
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Ansible {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Ansible {
			return nodes[i]
		}
	}
	c.Edges = make([]*AnsibleEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AnsibleEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AnsiblePaginateOption enables pagination customization.
type AnsiblePaginateOption func(*ansiblePager) error

// WithAnsibleOrder configures pagination ordering.
func WithAnsibleOrder(order *AnsibleOrder) AnsiblePaginateOption {
	if order == nil {
		order = DefaultAnsibleOrder
	}
	o := *order
	return func(pager *ansiblePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAnsibleOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAnsibleFilter configures pagination filter.
func WithAnsibleFilter(filter func(*AnsibleQuery) (*AnsibleQuery, error)) AnsiblePaginateOption {
	return func(pager *ansiblePager) error {
		if filter == nil {
			return errors.New("AnsibleQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type ansiblePager struct {
	reverse bool
	order   *AnsibleOrder
	filter  func(*AnsibleQuery) (*AnsibleQuery, error)
}

func newAnsiblePager(opts []AnsiblePaginateOption, reverse bool) (*ansiblePager, error) {
	pager := &ansiblePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAnsibleOrder
	}
	return pager, nil
}

func (p *ansiblePager) applyFilter(query *AnsibleQuery) (*AnsibleQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *ansiblePager) toCursor(a *Ansible) Cursor {
	return p.order.Field.toCursor(a)
}

func (p *ansiblePager) applyCursors(query *AnsibleQuery, after, before *Cursor) (*AnsibleQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAnsibleOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *ansiblePager) applyOrder(query *AnsibleQuery) *AnsibleQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAnsibleOrder.Field {
		query = query.Order(DefaultAnsibleOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *ansiblePager) orderExpr(query *AnsibleQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAnsibleOrder.Field {
			b.Comma().Ident(DefaultAnsibleOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Ansible.
func (a *AnsibleQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AnsiblePaginateOption,
) (*AnsibleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAnsiblePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &AnsibleConnection{Edges: []*AnsibleEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = a.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if a, err = pager.applyCursors(a, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		a.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	a = pager.applyOrder(a)
	nodes, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// AnsibleOrderField defines the ordering field of Ansible.
type AnsibleOrderField struct {
	// Value extracts the ordering value from the given Ansible.
	Value    func(*Ansible) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) ansible.OrderOption
	toCursor func(*Ansible) Cursor
}

// AnsibleOrder defines the ordering of Ansible.
type AnsibleOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *AnsibleOrderField `json:"field"`
}

// DefaultAnsibleOrder is the default ordering of Ansible.
var DefaultAnsibleOrder = &AnsibleOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AnsibleOrderField{
		Value: func(a *Ansible) (ent.Value, error) {
			return a.ID, nil
		},
		column: ansible.FieldID,
		toTerm: ansible.ByID,
		toCursor: func(a *Ansible) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Ansible into AnsibleEdge.
func (a *Ansible) ToEdge(order *AnsibleOrder) *AnsibleEdge {
	if order == nil {
		order = DefaultAnsibleOrder
	}
	return &AnsibleEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// AuthUserEdge is the edge representation of AuthUser.
type AuthUserEdge struct {
	Node   *AuthUser `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// AuthUserConnection is the connection containing edges to AuthUser.
type AuthUserConnection struct {
	Edges      []*AuthUserEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *AuthUserConnection) build(nodes []*AuthUser, pager *authuserPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *AuthUser
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AuthUser {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AuthUser {
			return nodes[i]
		}
	}
	c.Edges = make([]*AuthUserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AuthUserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AuthUserPaginateOption enables pagination customization.
type AuthUserPaginateOption func(*authuserPager) error

// WithAuthUserOrder configures pagination ordering.
func WithAuthUserOrder(order *AuthUserOrder) AuthUserPaginateOption {
	if order == nil {
		order = DefaultAuthUserOrder
	}
	o := *order
	return func(pager *authuserPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAuthUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAuthUserFilter configures pagination filter.
func WithAuthUserFilter(filter func(*AuthUserQuery) (*AuthUserQuery, error)) AuthUserPaginateOption {
	return func(pager *authuserPager) error {
		if filter == nil {
			return errors.New("AuthUserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type authuserPager struct {
	reverse bool
	order   *AuthUserOrder
	filter  func(*AuthUserQuery) (*AuthUserQuery, error)
}

func newAuthUserPager(opts []AuthUserPaginateOption, reverse bool) (*authuserPager, error) {
	pager := &authuserPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAuthUserOrder
	}
	return pager, nil
}

func (p *authuserPager) applyFilter(query *AuthUserQuery) (*AuthUserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *authuserPager) toCursor(au *AuthUser) Cursor {
	return p.order.Field.toCursor(au)
}

func (p *authuserPager) applyCursors(query *AuthUserQuery, after, before *Cursor) (*AuthUserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAuthUserOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *authuserPager) applyOrder(query *AuthUserQuery) *AuthUserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAuthUserOrder.Field {
		query = query.Order(DefaultAuthUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *authuserPager) orderExpr(query *AuthUserQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAuthUserOrder.Field {
			b.Comma().Ident(DefaultAuthUserOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AuthUser.
func (au *AuthUserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AuthUserPaginateOption,
) (*AuthUserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAuthUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if au, err = pager.applyFilter(au); err != nil {
		return nil, err
	}
	conn := &AuthUserConnection{Edges: []*AuthUserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = au.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if au, err = pager.applyCursors(au, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		au.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := au.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	au = pager.applyOrder(au)
	nodes, err := au.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// AuthUserOrderField defines the ordering field of AuthUser.
type AuthUserOrderField struct {
	// Value extracts the ordering value from the given AuthUser.
	Value    func(*AuthUser) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) authuser.OrderOption
	toCursor func(*AuthUser) Cursor
}

// AuthUserOrder defines the ordering of AuthUser.
type AuthUserOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *AuthUserOrderField `json:"field"`
}

// DefaultAuthUserOrder is the default ordering of AuthUser.
var DefaultAuthUserOrder = &AuthUserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AuthUserOrderField{
		Value: func(au *AuthUser) (ent.Value, error) {
			return au.ID, nil
		},
		column: authuser.FieldID,
		toTerm: authuser.ByID,
		toCursor: func(au *AuthUser) Cursor {
			return Cursor{ID: au.ID}
		},
	},
}

// ToEdge converts AuthUser into AuthUserEdge.
func (au *AuthUser) ToEdge(order *AuthUserOrder) *AuthUserEdge {
	if order == nil {
		order = DefaultAuthUserOrder
	}
	return &AuthUserEdge{
		Node:   au,
		Cursor: order.Field.toCursor(au),
	}
}

// BuildEdge is the edge representation of Build.
type BuildEdge struct {
	Node   *Build `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// BuildConnection is the connection containing edges to Build.
type BuildConnection struct {
	Edges      []*BuildEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *BuildConnection) build(nodes []*Build, pager *buildPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Build
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Build {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Build {
			return nodes[i]
		}
	}
	c.Edges = make([]*BuildEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &BuildEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// BuildPaginateOption enables pagination customization.
type BuildPaginateOption func(*buildPager) error

// WithBuildOrder configures pagination ordering.
func WithBuildOrder(order *BuildOrder) BuildPaginateOption {
	if order == nil {
		order = DefaultBuildOrder
	}
	o := *order
	return func(pager *buildPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultBuildOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithBuildFilter configures pagination filter.
func WithBuildFilter(filter func(*BuildQuery) (*BuildQuery, error)) BuildPaginateOption {
	return func(pager *buildPager) error {
		if filter == nil {
			return errors.New("BuildQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type buildPager struct {
	reverse bool
	order   *BuildOrder
	filter  func(*BuildQuery) (*BuildQuery, error)
}

func newBuildPager(opts []BuildPaginateOption, reverse bool) (*buildPager, error) {
	pager := &buildPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultBuildOrder
	}
	return pager, nil
}

func (p *buildPager) applyFilter(query *BuildQuery) (*BuildQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *buildPager) toCursor(b *Build) Cursor {
	return p.order.Field.toCursor(b)
}

func (p *buildPager) applyCursors(query *BuildQuery, after, before *Cursor) (*BuildQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultBuildOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *buildPager) applyOrder(query *BuildQuery) *BuildQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultBuildOrder.Field {
		query = query.Order(DefaultBuildOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *buildPager) orderExpr(query *BuildQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultBuildOrder.Field {
			b.Comma().Ident(DefaultBuildOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Build.
func (b *BuildQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BuildPaginateOption,
) (*BuildConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBuildPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if b, err = pager.applyFilter(b); err != nil {
		return nil, err
	}
	conn := &BuildConnection{Edges: []*BuildEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = b.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if b, err = pager.applyCursors(b, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		b.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := b.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	b = pager.applyOrder(b)
	nodes, err := b.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// BuildOrderField defines the ordering field of Build.
type BuildOrderField struct {
	// Value extracts the ordering value from the given Build.
	Value    func(*Build) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) build.OrderOption
	toCursor func(*Build) Cursor
}

// BuildOrder defines the ordering of Build.
type BuildOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *BuildOrderField `json:"field"`
}

// DefaultBuildOrder is the default ordering of Build.
var DefaultBuildOrder = &BuildOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &BuildOrderField{
		Value: func(b *Build) (ent.Value, error) {
			return b.ID, nil
		},
		column: build.FieldID,
		toTerm: build.ByID,
		toCursor: func(b *Build) Cursor {
			return Cursor{ID: b.ID}
		},
	},
}

// ToEdge converts Build into BuildEdge.
func (b *Build) ToEdge(order *BuildOrder) *BuildEdge {
	if order == nil {
		order = DefaultBuildOrder
	}
	return &BuildEdge{
		Node:   b,
		Cursor: order.Field.toCursor(b),
	}
}

// BuildCommitEdge is the edge representation of BuildCommit.
type BuildCommitEdge struct {
	Node   *BuildCommit `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// BuildCommitConnection is the connection containing edges to BuildCommit.
type BuildCommitConnection struct {
	Edges      []*BuildCommitEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *BuildCommitConnection) build(nodes []*BuildCommit, pager *buildcommitPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *BuildCommit
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *BuildCommit {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *BuildCommit {
			return nodes[i]
		}
	}
	c.Edges = make([]*BuildCommitEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &BuildCommitEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// BuildCommitPaginateOption enables pagination customization.
type BuildCommitPaginateOption func(*buildcommitPager) error

// WithBuildCommitOrder configures pagination ordering.
func WithBuildCommitOrder(order *BuildCommitOrder) BuildCommitPaginateOption {
	if order == nil {
		order = DefaultBuildCommitOrder
	}
	o := *order
	return func(pager *buildcommitPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultBuildCommitOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithBuildCommitFilter configures pagination filter.
func WithBuildCommitFilter(filter func(*BuildCommitQuery) (*BuildCommitQuery, error)) BuildCommitPaginateOption {
	return func(pager *buildcommitPager) error {
		if filter == nil {
			return errors.New("BuildCommitQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type buildcommitPager struct {
	reverse bool
	order   *BuildCommitOrder
	filter  func(*BuildCommitQuery) (*BuildCommitQuery, error)
}

func newBuildCommitPager(opts []BuildCommitPaginateOption, reverse bool) (*buildcommitPager, error) {
	pager := &buildcommitPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultBuildCommitOrder
	}
	return pager, nil
}

func (p *buildcommitPager) applyFilter(query *BuildCommitQuery) (*BuildCommitQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *buildcommitPager) toCursor(bc *BuildCommit) Cursor {
	return p.order.Field.toCursor(bc)
}

func (p *buildcommitPager) applyCursors(query *BuildCommitQuery, after, before *Cursor) (*BuildCommitQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultBuildCommitOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *buildcommitPager) applyOrder(query *BuildCommitQuery) *BuildCommitQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultBuildCommitOrder.Field {
		query = query.Order(DefaultBuildCommitOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *buildcommitPager) orderExpr(query *BuildCommitQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultBuildCommitOrder.Field {
			b.Comma().Ident(DefaultBuildCommitOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to BuildCommit.
func (bc *BuildCommitQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BuildCommitPaginateOption,
) (*BuildCommitConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBuildCommitPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if bc, err = pager.applyFilter(bc); err != nil {
		return nil, err
	}
	conn := &BuildCommitConnection{Edges: []*BuildCommitEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = bc.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if bc, err = pager.applyCursors(bc, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		bc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := bc.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	bc = pager.applyOrder(bc)
	nodes, err := bc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// BuildCommitOrderField defines the ordering field of BuildCommit.
type BuildCommitOrderField struct {
	// Value extracts the ordering value from the given BuildCommit.
	Value    func(*BuildCommit) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) buildcommit.OrderOption
	toCursor func(*BuildCommit) Cursor
}

// BuildCommitOrder defines the ordering of BuildCommit.
type BuildCommitOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *BuildCommitOrderField `json:"field"`
}

// DefaultBuildCommitOrder is the default ordering of BuildCommit.
var DefaultBuildCommitOrder = &BuildCommitOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &BuildCommitOrderField{
		Value: func(bc *BuildCommit) (ent.Value, error) {
			return bc.ID, nil
		},
		column: buildcommit.FieldID,
		toTerm: buildcommit.ByID,
		toCursor: func(bc *BuildCommit) Cursor {
			return Cursor{ID: bc.ID}
		},
	},
}

// ToEdge converts BuildCommit into BuildCommitEdge.
func (bc *BuildCommit) ToEdge(order *BuildCommitOrder) *BuildCommitEdge {
	if order == nil {
		order = DefaultBuildCommitOrder
	}
	return &BuildCommitEdge{
		Node:   bc,
		Cursor: order.Field.toCursor(bc),
	}
}

// CommandEdge is the edge representation of Command.
type CommandEdge struct {
	Node   *Command `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// CommandConnection is the connection containing edges to Command.
type CommandConnection struct {
	Edges      []*CommandEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *CommandConnection) build(nodes []*Command, pager *commandPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Command
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Command {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Command {
			return nodes[i]
		}
	}
	c.Edges = make([]*CommandEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CommandEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CommandPaginateOption enables pagination customization.
type CommandPaginateOption func(*commandPager) error

// WithCommandOrder configures pagination ordering.
func WithCommandOrder(order *CommandOrder) CommandPaginateOption {
	if order == nil {
		order = DefaultCommandOrder
	}
	o := *order
	return func(pager *commandPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCommandOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCommandFilter configures pagination filter.
func WithCommandFilter(filter func(*CommandQuery) (*CommandQuery, error)) CommandPaginateOption {
	return func(pager *commandPager) error {
		if filter == nil {
			return errors.New("CommandQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type commandPager struct {
	reverse bool
	order   *CommandOrder
	filter  func(*CommandQuery) (*CommandQuery, error)
}

func newCommandPager(opts []CommandPaginateOption, reverse bool) (*commandPager, error) {
	pager := &commandPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCommandOrder
	}
	return pager, nil
}

func (p *commandPager) applyFilter(query *CommandQuery) (*CommandQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *commandPager) toCursor(c *Command) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *commandPager) applyCursors(query *CommandQuery, after, before *Cursor) (*CommandQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCommandOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *commandPager) applyOrder(query *CommandQuery) *CommandQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCommandOrder.Field {
		query = query.Order(DefaultCommandOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *commandPager) orderExpr(query *CommandQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCommandOrder.Field {
			b.Comma().Ident(DefaultCommandOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Command.
func (c *CommandQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CommandPaginateOption,
) (*CommandConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCommandPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CommandConnection{Edges: []*CommandEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = c.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CommandOrderField defines the ordering field of Command.
type CommandOrderField struct {
	// Value extracts the ordering value from the given Command.
	Value    func(*Command) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) command.OrderOption
	toCursor func(*Command) Cursor
}

// CommandOrder defines the ordering of Command.
type CommandOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *CommandOrderField `json:"field"`
}

// DefaultCommandOrder is the default ordering of Command.
var DefaultCommandOrder = &CommandOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CommandOrderField{
		Value: func(c *Command) (ent.Value, error) {
			return c.ID, nil
		},
		column: command.FieldID,
		toTerm: command.ByID,
		toCursor: func(c *Command) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Command into CommandEdge.
func (c *Command) ToEdge(order *CommandOrder) *CommandEdge {
	if order == nil {
		order = DefaultCommandOrder
	}
	return &CommandEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CompetitionEdge is the edge representation of Competition.
type CompetitionEdge struct {
	Node   *Competition `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// CompetitionConnection is the connection containing edges to Competition.
type CompetitionConnection struct {
	Edges      []*CompetitionEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *CompetitionConnection) build(nodes []*Competition, pager *competitionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Competition
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Competition {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Competition {
			return nodes[i]
		}
	}
	c.Edges = make([]*CompetitionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CompetitionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CompetitionPaginateOption enables pagination customization.
type CompetitionPaginateOption func(*competitionPager) error

// WithCompetitionOrder configures pagination ordering.
func WithCompetitionOrder(order *CompetitionOrder) CompetitionPaginateOption {
	if order == nil {
		order = DefaultCompetitionOrder
	}
	o := *order
	return func(pager *competitionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCompetitionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCompetitionFilter configures pagination filter.
func WithCompetitionFilter(filter func(*CompetitionQuery) (*CompetitionQuery, error)) CompetitionPaginateOption {
	return func(pager *competitionPager) error {
		if filter == nil {
			return errors.New("CompetitionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type competitionPager struct {
	reverse bool
	order   *CompetitionOrder
	filter  func(*CompetitionQuery) (*CompetitionQuery, error)
}

func newCompetitionPager(opts []CompetitionPaginateOption, reverse bool) (*competitionPager, error) {
	pager := &competitionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCompetitionOrder
	}
	return pager, nil
}

func (p *competitionPager) applyFilter(query *CompetitionQuery) (*CompetitionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *competitionPager) toCursor(c *Competition) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *competitionPager) applyCursors(query *CompetitionQuery, after, before *Cursor) (*CompetitionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCompetitionOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *competitionPager) applyOrder(query *CompetitionQuery) *CompetitionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCompetitionOrder.Field {
		query = query.Order(DefaultCompetitionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *competitionPager) orderExpr(query *CompetitionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCompetitionOrder.Field {
			b.Comma().Ident(DefaultCompetitionOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Competition.
func (c *CompetitionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CompetitionPaginateOption,
) (*CompetitionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCompetitionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CompetitionConnection{Edges: []*CompetitionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = c.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CompetitionOrderField defines the ordering field of Competition.
type CompetitionOrderField struct {
	// Value extracts the ordering value from the given Competition.
	Value    func(*Competition) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) competition.OrderOption
	toCursor func(*Competition) Cursor
}

// CompetitionOrder defines the ordering of Competition.
type CompetitionOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *CompetitionOrderField `json:"field"`
}

// DefaultCompetitionOrder is the default ordering of Competition.
var DefaultCompetitionOrder = &CompetitionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CompetitionOrderField{
		Value: func(c *Competition) (ent.Value, error) {
			return c.ID, nil
		},
		column: competition.FieldID,
		toTerm: competition.ByID,
		toCursor: func(c *Competition) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Competition into CompetitionEdge.
func (c *Competition) ToEdge(order *CompetitionOrder) *CompetitionEdge {
	if order == nil {
		order = DefaultCompetitionOrder
	}
	return &CompetitionEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// DNSEdge is the edge representation of DNS.
type DNSEdge struct {
	Node   *DNS   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// DNSConnection is the connection containing edges to DNS.
type DNSConnection struct {
	Edges      []*DNSEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

func (c *DNSConnection) build(nodes []*DNS, pager *dnsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DNS
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DNS {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DNS {
			return nodes[i]
		}
	}
	c.Edges = make([]*DNSEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DNSEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DNSPaginateOption enables pagination customization.
type DNSPaginateOption func(*dnsPager) error

// WithDNSOrder configures pagination ordering.
func WithDNSOrder(order *DNSOrder) DNSPaginateOption {
	if order == nil {
		order = DefaultDNSOrder
	}
	o := *order
	return func(pager *dnsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDNSOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDNSFilter configures pagination filter.
func WithDNSFilter(filter func(*DNSQuery) (*DNSQuery, error)) DNSPaginateOption {
	return func(pager *dnsPager) error {
		if filter == nil {
			return errors.New("DNSQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type dnsPager struct {
	reverse bool
	order   *DNSOrder
	filter  func(*DNSQuery) (*DNSQuery, error)
}

func newDNSPager(opts []DNSPaginateOption, reverse bool) (*dnsPager, error) {
	pager := &dnsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDNSOrder
	}
	return pager, nil
}

func (p *dnsPager) applyFilter(query *DNSQuery) (*DNSQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *dnsPager) toCursor(d *DNS) Cursor {
	return p.order.Field.toCursor(d)
}

func (p *dnsPager) applyCursors(query *DNSQuery, after, before *Cursor) (*DNSQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDNSOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *dnsPager) applyOrder(query *DNSQuery) *DNSQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDNSOrder.Field {
		query = query.Order(DefaultDNSOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *dnsPager) orderExpr(query *DNSQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDNSOrder.Field {
			b.Comma().Ident(DefaultDNSOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DNS.
func (d *DNSQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DNSPaginateOption,
) (*DNSConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDNSPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if d, err = pager.applyFilter(d); err != nil {
		return nil, err
	}
	conn := &DNSConnection{Edges: []*DNSEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = d.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if d, err = pager.applyCursors(d, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		d.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := d.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	d = pager.applyOrder(d)
	nodes, err := d.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DNSOrderField defines the ordering field of DNS.
type DNSOrderField struct {
	// Value extracts the ordering value from the given DNS.
	Value    func(*DNS) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) dns.OrderOption
	toCursor func(*DNS) Cursor
}

// DNSOrder defines the ordering of DNS.
type DNSOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *DNSOrderField `json:"field"`
}

// DefaultDNSOrder is the default ordering of DNS.
var DefaultDNSOrder = &DNSOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DNSOrderField{
		Value: func(d *DNS) (ent.Value, error) {
			return d.ID, nil
		},
		column: dns.FieldID,
		toTerm: dns.ByID,
		toCursor: func(d *DNS) Cursor {
			return Cursor{ID: d.ID}
		},
	},
}

// ToEdge converts DNS into DNSEdge.
func (d *DNS) ToEdge(order *DNSOrder) *DNSEdge {
	if order == nil {
		order = DefaultDNSOrder
	}
	return &DNSEdge{
		Node:   d,
		Cursor: order.Field.toCursor(d),
	}
}

// DNSRecordEdge is the edge representation of DNSRecord.
type DNSRecordEdge struct {
	Node   *DNSRecord `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// DNSRecordConnection is the connection containing edges to DNSRecord.
type DNSRecordConnection struct {
	Edges      []*DNSRecordEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *DNSRecordConnection) build(nodes []*DNSRecord, pager *dnsrecordPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DNSRecord
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DNSRecord {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DNSRecord {
			return nodes[i]
		}
	}
	c.Edges = make([]*DNSRecordEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DNSRecordEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DNSRecordPaginateOption enables pagination customization.
type DNSRecordPaginateOption func(*dnsrecordPager) error

// WithDNSRecordOrder configures pagination ordering.
func WithDNSRecordOrder(order *DNSRecordOrder) DNSRecordPaginateOption {
	if order == nil {
		order = DefaultDNSRecordOrder
	}
	o := *order
	return func(pager *dnsrecordPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDNSRecordOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDNSRecordFilter configures pagination filter.
func WithDNSRecordFilter(filter func(*DNSRecordQuery) (*DNSRecordQuery, error)) DNSRecordPaginateOption {
	return func(pager *dnsrecordPager) error {
		if filter == nil {
			return errors.New("DNSRecordQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type dnsrecordPager struct {
	reverse bool
	order   *DNSRecordOrder
	filter  func(*DNSRecordQuery) (*DNSRecordQuery, error)
}

func newDNSRecordPager(opts []DNSRecordPaginateOption, reverse bool) (*dnsrecordPager, error) {
	pager := &dnsrecordPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDNSRecordOrder
	}
	return pager, nil
}

func (p *dnsrecordPager) applyFilter(query *DNSRecordQuery) (*DNSRecordQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *dnsrecordPager) toCursor(dr *DNSRecord) Cursor {
	return p.order.Field.toCursor(dr)
}

func (p *dnsrecordPager) applyCursors(query *DNSRecordQuery, after, before *Cursor) (*DNSRecordQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDNSRecordOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *dnsrecordPager) applyOrder(query *DNSRecordQuery) *DNSRecordQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDNSRecordOrder.Field {
		query = query.Order(DefaultDNSRecordOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *dnsrecordPager) orderExpr(query *DNSRecordQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDNSRecordOrder.Field {
			b.Comma().Ident(DefaultDNSRecordOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DNSRecord.
func (dr *DNSRecordQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DNSRecordPaginateOption,
) (*DNSRecordConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDNSRecordPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if dr, err = pager.applyFilter(dr); err != nil {
		return nil, err
	}
	conn := &DNSRecordConnection{Edges: []*DNSRecordEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = dr.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if dr, err = pager.applyCursors(dr, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		dr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := dr.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	dr = pager.applyOrder(dr)
	nodes, err := dr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DNSRecordOrderField defines the ordering field of DNSRecord.
type DNSRecordOrderField struct {
	// Value extracts the ordering value from the given DNSRecord.
	Value    func(*DNSRecord) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) dnsrecord.OrderOption
	toCursor func(*DNSRecord) Cursor
}

// DNSRecordOrder defines the ordering of DNSRecord.
type DNSRecordOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *DNSRecordOrderField `json:"field"`
}

// DefaultDNSRecordOrder is the default ordering of DNSRecord.
var DefaultDNSRecordOrder = &DNSRecordOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DNSRecordOrderField{
		Value: func(dr *DNSRecord) (ent.Value, error) {
			return dr.ID, nil
		},
		column: dnsrecord.FieldID,
		toTerm: dnsrecord.ByID,
		toCursor: func(dr *DNSRecord) Cursor {
			return Cursor{ID: dr.ID}
		},
	},
}

// ToEdge converts DNSRecord into DNSRecordEdge.
func (dr *DNSRecord) ToEdge(order *DNSRecordOrder) *DNSRecordEdge {
	if order == nil {
		order = DefaultDNSRecordOrder
	}
	return &DNSRecordEdge{
		Node:   dr,
		Cursor: order.Field.toCursor(dr),
	}
}

// DiskEdge is the edge representation of Disk.
type DiskEdge struct {
	Node   *Disk  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// DiskConnection is the connection containing edges to Disk.
type DiskConnection struct {
	Edges      []*DiskEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *DiskConnection) build(nodes []*Disk, pager *diskPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Disk
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Disk {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Disk {
			return nodes[i]
		}
	}
	c.Edges = make([]*DiskEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DiskEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DiskPaginateOption enables pagination customization.
type DiskPaginateOption func(*diskPager) error

// WithDiskOrder configures pagination ordering.
func WithDiskOrder(order *DiskOrder) DiskPaginateOption {
	if order == nil {
		order = DefaultDiskOrder
	}
	o := *order
	return func(pager *diskPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDiskOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDiskFilter configures pagination filter.
func WithDiskFilter(filter func(*DiskQuery) (*DiskQuery, error)) DiskPaginateOption {
	return func(pager *diskPager) error {
		if filter == nil {
			return errors.New("DiskQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type diskPager struct {
	reverse bool
	order   *DiskOrder
	filter  func(*DiskQuery) (*DiskQuery, error)
}

func newDiskPager(opts []DiskPaginateOption, reverse bool) (*diskPager, error) {
	pager := &diskPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDiskOrder
	}
	return pager, nil
}

func (p *diskPager) applyFilter(query *DiskQuery) (*DiskQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *diskPager) toCursor(d *Disk) Cursor {
	return p.order.Field.toCursor(d)
}

func (p *diskPager) applyCursors(query *DiskQuery, after, before *Cursor) (*DiskQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDiskOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *diskPager) applyOrder(query *DiskQuery) *DiskQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDiskOrder.Field {
		query = query.Order(DefaultDiskOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *diskPager) orderExpr(query *DiskQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDiskOrder.Field {
			b.Comma().Ident(DefaultDiskOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Disk.
func (d *DiskQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DiskPaginateOption,
) (*DiskConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDiskPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if d, err = pager.applyFilter(d); err != nil {
		return nil, err
	}
	conn := &DiskConnection{Edges: []*DiskEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = d.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if d, err = pager.applyCursors(d, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		d.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := d.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	d = pager.applyOrder(d)
	nodes, err := d.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DiskOrderField defines the ordering field of Disk.
type DiskOrderField struct {
	// Value extracts the ordering value from the given Disk.
	Value    func(*Disk) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) disk.OrderOption
	toCursor func(*Disk) Cursor
}

// DiskOrder defines the ordering of Disk.
type DiskOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *DiskOrderField `json:"field"`
}

// DefaultDiskOrder is the default ordering of Disk.
var DefaultDiskOrder = &DiskOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DiskOrderField{
		Value: func(d *Disk) (ent.Value, error) {
			return d.ID, nil
		},
		column: disk.FieldID,
		toTerm: disk.ByID,
		toCursor: func(d *Disk) Cursor {
			return Cursor{ID: d.ID}
		},
	},
}

// ToEdge converts Disk into DiskEdge.
func (d *Disk) ToEdge(order *DiskOrder) *DiskEdge {
	if order == nil {
		order = DefaultDiskOrder
	}
	return &DiskEdge{
		Node:   d,
		Cursor: order.Field.toCursor(d),
	}
}

// EnvironmentEdge is the edge representation of Environment.
type EnvironmentEdge struct {
	Node   *Environment `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// EnvironmentConnection is the connection containing edges to Environment.
type EnvironmentConnection struct {
	Edges      []*EnvironmentEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *EnvironmentConnection) build(nodes []*Environment, pager *environmentPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Environment
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Environment {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Environment {
			return nodes[i]
		}
	}
	c.Edges = make([]*EnvironmentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EnvironmentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EnvironmentPaginateOption enables pagination customization.
type EnvironmentPaginateOption func(*environmentPager) error

// WithEnvironmentOrder configures pagination ordering.
func WithEnvironmentOrder(order *EnvironmentOrder) EnvironmentPaginateOption {
	if order == nil {
		order = DefaultEnvironmentOrder
	}
	o := *order
	return func(pager *environmentPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEnvironmentOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEnvironmentFilter configures pagination filter.
func WithEnvironmentFilter(filter func(*EnvironmentQuery) (*EnvironmentQuery, error)) EnvironmentPaginateOption {
	return func(pager *environmentPager) error {
		if filter == nil {
			return errors.New("EnvironmentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type environmentPager struct {
	reverse bool
	order   *EnvironmentOrder
	filter  func(*EnvironmentQuery) (*EnvironmentQuery, error)
}

func newEnvironmentPager(opts []EnvironmentPaginateOption, reverse bool) (*environmentPager, error) {
	pager := &environmentPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEnvironmentOrder
	}
	return pager, nil
}

func (p *environmentPager) applyFilter(query *EnvironmentQuery) (*EnvironmentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *environmentPager) toCursor(e *Environment) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *environmentPager) applyCursors(query *EnvironmentQuery, after, before *Cursor) (*EnvironmentQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEnvironmentOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *environmentPager) applyOrder(query *EnvironmentQuery) *EnvironmentQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEnvironmentOrder.Field {
		query = query.Order(DefaultEnvironmentOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *environmentPager) orderExpr(query *EnvironmentQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEnvironmentOrder.Field {
			b.Comma().Ident(DefaultEnvironmentOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Environment.
func (e *EnvironmentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EnvironmentPaginateOption,
) (*EnvironmentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEnvironmentPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}
	conn := &EnvironmentConnection{Edges: []*EnvironmentEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = e.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if e, err = pager.applyCursors(e, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		e.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := e.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	e = pager.applyOrder(e)
	nodes, err := e.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// EnvironmentOrderField defines the ordering field of Environment.
type EnvironmentOrderField struct {
	// Value extracts the ordering value from the given Environment.
	Value    func(*Environment) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) environment.OrderOption
	toCursor func(*Environment) Cursor
}

// EnvironmentOrder defines the ordering of Environment.
type EnvironmentOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *EnvironmentOrderField `json:"field"`
}

// DefaultEnvironmentOrder is the default ordering of Environment.
var DefaultEnvironmentOrder = &EnvironmentOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EnvironmentOrderField{
		Value: func(e *Environment) (ent.Value, error) {
			return e.ID, nil
		},
		column: environment.FieldID,
		toTerm: environment.ByID,
		toCursor: func(e *Environment) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Environment into EnvironmentEdge.
func (e *Environment) ToEdge(order *EnvironmentOrder) *EnvironmentEdge {
	if order == nil {
		order = DefaultEnvironmentOrder
	}
	return &EnvironmentEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// FileDeleteEdge is the edge representation of FileDelete.
type FileDeleteEdge struct {
	Node   *FileDelete `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// FileDeleteConnection is the connection containing edges to FileDelete.
type FileDeleteConnection struct {
	Edges      []*FileDeleteEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *FileDeleteConnection) build(nodes []*FileDelete, pager *filedeletePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *FileDelete
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FileDelete {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FileDelete {
			return nodes[i]
		}
	}
	c.Edges = make([]*FileDeleteEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FileDeleteEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FileDeletePaginateOption enables pagination customization.
type FileDeletePaginateOption func(*filedeletePager) error

// WithFileDeleteOrder configures pagination ordering.
func WithFileDeleteOrder(order *FileDeleteOrder) FileDeletePaginateOption {
	if order == nil {
		order = DefaultFileDeleteOrder
	}
	o := *order
	return func(pager *filedeletePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFileDeleteOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFileDeleteFilter configures pagination filter.
func WithFileDeleteFilter(filter func(*FileDeleteQuery) (*FileDeleteQuery, error)) FileDeletePaginateOption {
	return func(pager *filedeletePager) error {
		if filter == nil {
			return errors.New("FileDeleteQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type filedeletePager struct {
	reverse bool
	order   *FileDeleteOrder
	filter  func(*FileDeleteQuery) (*FileDeleteQuery, error)
}

func newFileDeletePager(opts []FileDeletePaginateOption, reverse bool) (*filedeletePager, error) {
	pager := &filedeletePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFileDeleteOrder
	}
	return pager, nil
}

func (p *filedeletePager) applyFilter(query *FileDeleteQuery) (*FileDeleteQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *filedeletePager) toCursor(fd *FileDelete) Cursor {
	return p.order.Field.toCursor(fd)
}

func (p *filedeletePager) applyCursors(query *FileDeleteQuery, after, before *Cursor) (*FileDeleteQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFileDeleteOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *filedeletePager) applyOrder(query *FileDeleteQuery) *FileDeleteQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFileDeleteOrder.Field {
		query = query.Order(DefaultFileDeleteOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *filedeletePager) orderExpr(query *FileDeleteQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFileDeleteOrder.Field {
			b.Comma().Ident(DefaultFileDeleteOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to FileDelete.
func (fd *FileDeleteQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FileDeletePaginateOption,
) (*FileDeleteConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFileDeletePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if fd, err = pager.applyFilter(fd); err != nil {
		return nil, err
	}
	conn := &FileDeleteConnection{Edges: []*FileDeleteEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = fd.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if fd, err = pager.applyCursors(fd, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		fd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := fd.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	fd = pager.applyOrder(fd)
	nodes, err := fd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// FileDeleteOrderField defines the ordering field of FileDelete.
type FileDeleteOrderField struct {
	// Value extracts the ordering value from the given FileDelete.
	Value    func(*FileDelete) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) filedelete.OrderOption
	toCursor func(*FileDelete) Cursor
}

// FileDeleteOrder defines the ordering of FileDelete.
type FileDeleteOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *FileDeleteOrderField `json:"field"`
}

// DefaultFileDeleteOrder is the default ordering of FileDelete.
var DefaultFileDeleteOrder = &FileDeleteOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FileDeleteOrderField{
		Value: func(fd *FileDelete) (ent.Value, error) {
			return fd.ID, nil
		},
		column: filedelete.FieldID,
		toTerm: filedelete.ByID,
		toCursor: func(fd *FileDelete) Cursor {
			return Cursor{ID: fd.ID}
		},
	},
}

// ToEdge converts FileDelete into FileDeleteEdge.
func (fd *FileDelete) ToEdge(order *FileDeleteOrder) *FileDeleteEdge {
	if order == nil {
		order = DefaultFileDeleteOrder
	}
	return &FileDeleteEdge{
		Node:   fd,
		Cursor: order.Field.toCursor(fd),
	}
}

// FileDownloadEdge is the edge representation of FileDownload.
type FileDownloadEdge struct {
	Node   *FileDownload `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// FileDownloadConnection is the connection containing edges to FileDownload.
type FileDownloadConnection struct {
	Edges      []*FileDownloadEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *FileDownloadConnection) build(nodes []*FileDownload, pager *filedownloadPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *FileDownload
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FileDownload {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FileDownload {
			return nodes[i]
		}
	}
	c.Edges = make([]*FileDownloadEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FileDownloadEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FileDownloadPaginateOption enables pagination customization.
type FileDownloadPaginateOption func(*filedownloadPager) error

// WithFileDownloadOrder configures pagination ordering.
func WithFileDownloadOrder(order *FileDownloadOrder) FileDownloadPaginateOption {
	if order == nil {
		order = DefaultFileDownloadOrder
	}
	o := *order
	return func(pager *filedownloadPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFileDownloadOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFileDownloadFilter configures pagination filter.
func WithFileDownloadFilter(filter func(*FileDownloadQuery) (*FileDownloadQuery, error)) FileDownloadPaginateOption {
	return func(pager *filedownloadPager) error {
		if filter == nil {
			return errors.New("FileDownloadQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type filedownloadPager struct {
	reverse bool
	order   *FileDownloadOrder
	filter  func(*FileDownloadQuery) (*FileDownloadQuery, error)
}

func newFileDownloadPager(opts []FileDownloadPaginateOption, reverse bool) (*filedownloadPager, error) {
	pager := &filedownloadPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFileDownloadOrder
	}
	return pager, nil
}

func (p *filedownloadPager) applyFilter(query *FileDownloadQuery) (*FileDownloadQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *filedownloadPager) toCursor(fd *FileDownload) Cursor {
	return p.order.Field.toCursor(fd)
}

func (p *filedownloadPager) applyCursors(query *FileDownloadQuery, after, before *Cursor) (*FileDownloadQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFileDownloadOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *filedownloadPager) applyOrder(query *FileDownloadQuery) *FileDownloadQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFileDownloadOrder.Field {
		query = query.Order(DefaultFileDownloadOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *filedownloadPager) orderExpr(query *FileDownloadQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFileDownloadOrder.Field {
			b.Comma().Ident(DefaultFileDownloadOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to FileDownload.
func (fd *FileDownloadQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FileDownloadPaginateOption,
) (*FileDownloadConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFileDownloadPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if fd, err = pager.applyFilter(fd); err != nil {
		return nil, err
	}
	conn := &FileDownloadConnection{Edges: []*FileDownloadEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = fd.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if fd, err = pager.applyCursors(fd, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		fd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := fd.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	fd = pager.applyOrder(fd)
	nodes, err := fd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// FileDownloadOrderField defines the ordering field of FileDownload.
type FileDownloadOrderField struct {
	// Value extracts the ordering value from the given FileDownload.
	Value    func(*FileDownload) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) filedownload.OrderOption
	toCursor func(*FileDownload) Cursor
}

// FileDownloadOrder defines the ordering of FileDownload.
type FileDownloadOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *FileDownloadOrderField `json:"field"`
}

// DefaultFileDownloadOrder is the default ordering of FileDownload.
var DefaultFileDownloadOrder = &FileDownloadOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FileDownloadOrderField{
		Value: func(fd *FileDownload) (ent.Value, error) {
			return fd.ID, nil
		},
		column: filedownload.FieldID,
		toTerm: filedownload.ByID,
		toCursor: func(fd *FileDownload) Cursor {
			return Cursor{ID: fd.ID}
		},
	},
}

// ToEdge converts FileDownload into FileDownloadEdge.
func (fd *FileDownload) ToEdge(order *FileDownloadOrder) *FileDownloadEdge {
	if order == nil {
		order = DefaultFileDownloadOrder
	}
	return &FileDownloadEdge{
		Node:   fd,
		Cursor: order.Field.toCursor(fd),
	}
}

// FileExtractEdge is the edge representation of FileExtract.
type FileExtractEdge struct {
	Node   *FileExtract `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// FileExtractConnection is the connection containing edges to FileExtract.
type FileExtractConnection struct {
	Edges      []*FileExtractEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *FileExtractConnection) build(nodes []*FileExtract, pager *fileextractPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *FileExtract
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *FileExtract {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *FileExtract {
			return nodes[i]
		}
	}
	c.Edges = make([]*FileExtractEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FileExtractEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FileExtractPaginateOption enables pagination customization.
type FileExtractPaginateOption func(*fileextractPager) error

// WithFileExtractOrder configures pagination ordering.
func WithFileExtractOrder(order *FileExtractOrder) FileExtractPaginateOption {
	if order == nil {
		order = DefaultFileExtractOrder
	}
	o := *order
	return func(pager *fileextractPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFileExtractOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFileExtractFilter configures pagination filter.
func WithFileExtractFilter(filter func(*FileExtractQuery) (*FileExtractQuery, error)) FileExtractPaginateOption {
	return func(pager *fileextractPager) error {
		if filter == nil {
			return errors.New("FileExtractQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type fileextractPager struct {
	reverse bool
	order   *FileExtractOrder
	filter  func(*FileExtractQuery) (*FileExtractQuery, error)
}

func newFileExtractPager(opts []FileExtractPaginateOption, reverse bool) (*fileextractPager, error) {
	pager := &fileextractPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFileExtractOrder
	}
	return pager, nil
}

func (p *fileextractPager) applyFilter(query *FileExtractQuery) (*FileExtractQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *fileextractPager) toCursor(fe *FileExtract) Cursor {
	return p.order.Field.toCursor(fe)
}

func (p *fileextractPager) applyCursors(query *FileExtractQuery, after, before *Cursor) (*FileExtractQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFileExtractOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *fileextractPager) applyOrder(query *FileExtractQuery) *FileExtractQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFileExtractOrder.Field {
		query = query.Order(DefaultFileExtractOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *fileextractPager) orderExpr(query *FileExtractQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFileExtractOrder.Field {
			b.Comma().Ident(DefaultFileExtractOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to FileExtract.
func (fe *FileExtractQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FileExtractPaginateOption,
) (*FileExtractConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFileExtractPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if fe, err = pager.applyFilter(fe); err != nil {
		return nil, err
	}
	conn := &FileExtractConnection{Edges: []*FileExtractEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = fe.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if fe, err = pager.applyCursors(fe, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		fe.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := fe.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	fe = pager.applyOrder(fe)
	nodes, err := fe.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// FileExtractOrderField defines the ordering field of FileExtract.
type FileExtractOrderField struct {
	// Value extracts the ordering value from the given FileExtract.
	Value    func(*FileExtract) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) fileextract.OrderOption
	toCursor func(*FileExtract) Cursor
}

// FileExtractOrder defines the ordering of FileExtract.
type FileExtractOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *FileExtractOrderField `json:"field"`
}

// DefaultFileExtractOrder is the default ordering of FileExtract.
var DefaultFileExtractOrder = &FileExtractOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FileExtractOrderField{
		Value: func(fe *FileExtract) (ent.Value, error) {
			return fe.ID, nil
		},
		column: fileextract.FieldID,
		toTerm: fileextract.ByID,
		toCursor: func(fe *FileExtract) Cursor {
			return Cursor{ID: fe.ID}
		},
	},
}

// ToEdge converts FileExtract into FileExtractEdge.
func (fe *FileExtract) ToEdge(order *FileExtractOrder) *FileExtractEdge {
	if order == nil {
		order = DefaultFileExtractOrder
	}
	return &FileExtractEdge{
		Node:   fe,
		Cursor: order.Field.toCursor(fe),
	}
}

// FindingEdge is the edge representation of Finding.
type FindingEdge struct {
	Node   *Finding `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// FindingConnection is the connection containing edges to Finding.
type FindingConnection struct {
	Edges      []*FindingEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *FindingConnection) build(nodes []*Finding, pager *findingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Finding
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Finding {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Finding {
			return nodes[i]
		}
	}
	c.Edges = make([]*FindingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FindingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FindingPaginateOption enables pagination customization.
type FindingPaginateOption func(*findingPager) error

// WithFindingOrder configures pagination ordering.
func WithFindingOrder(order *FindingOrder) FindingPaginateOption {
	if order == nil {
		order = DefaultFindingOrder
	}
	o := *order
	return func(pager *findingPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFindingOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFindingFilter configures pagination filter.
func WithFindingFilter(filter func(*FindingQuery) (*FindingQuery, error)) FindingPaginateOption {
	return func(pager *findingPager) error {
		if filter == nil {
			return errors.New("FindingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type findingPager struct {
	reverse bool
	order   *FindingOrder
	filter  func(*FindingQuery) (*FindingQuery, error)
}

func newFindingPager(opts []FindingPaginateOption, reverse bool) (*findingPager, error) {
	pager := &findingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFindingOrder
	}
	return pager, nil
}

func (p *findingPager) applyFilter(query *FindingQuery) (*FindingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *findingPager) toCursor(f *Finding) Cursor {
	return p.order.Field.toCursor(f)
}

func (p *findingPager) applyCursors(query *FindingQuery, after, before *Cursor) (*FindingQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFindingOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *findingPager) applyOrder(query *FindingQuery) *FindingQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFindingOrder.Field {
		query = query.Order(DefaultFindingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *findingPager) orderExpr(query *FindingQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFindingOrder.Field {
			b.Comma().Ident(DefaultFindingOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Finding.
func (f *FindingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FindingPaginateOption,
) (*FindingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFindingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if f, err = pager.applyFilter(f); err != nil {
		return nil, err
	}
	conn := &FindingConnection{Edges: []*FindingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = f.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if f, err = pager.applyCursors(f, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		f.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := f.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	f = pager.applyOrder(f)
	nodes, err := f.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// FindingOrderField defines the ordering field of Finding.
type FindingOrderField struct {
	// Value extracts the ordering value from the given Finding.
	Value    func(*Finding) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) finding.OrderOption
	toCursor func(*Finding) Cursor
}

// FindingOrder defines the ordering of Finding.
type FindingOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *FindingOrderField `json:"field"`
}

// DefaultFindingOrder is the default ordering of Finding.
var DefaultFindingOrder = &FindingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FindingOrderField{
		Value: func(f *Finding) (ent.Value, error) {
			return f.ID, nil
		},
		column: finding.FieldID,
		toTerm: finding.ByID,
		toCursor: func(f *Finding) Cursor {
			return Cursor{ID: f.ID}
		},
	},
}

// ToEdge converts Finding into FindingEdge.
func (f *Finding) ToEdge(order *FindingOrder) *FindingEdge {
	if order == nil {
		order = DefaultFindingOrder
	}
	return &FindingEdge{
		Node:   f,
		Cursor: order.Field.toCursor(f),
	}
}

// GinFileMiddlewareEdge is the edge representation of GinFileMiddleware.
type GinFileMiddlewareEdge struct {
	Node   *GinFileMiddleware `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// GinFileMiddlewareConnection is the connection containing edges to GinFileMiddleware.
type GinFileMiddlewareConnection struct {
	Edges      []*GinFileMiddlewareEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *GinFileMiddlewareConnection) build(nodes []*GinFileMiddleware, pager *ginfilemiddlewarePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *GinFileMiddleware
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GinFileMiddleware {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GinFileMiddleware {
			return nodes[i]
		}
	}
	c.Edges = make([]*GinFileMiddlewareEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GinFileMiddlewareEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GinFileMiddlewarePaginateOption enables pagination customization.
type GinFileMiddlewarePaginateOption func(*ginfilemiddlewarePager) error

// WithGinFileMiddlewareOrder configures pagination ordering.
func WithGinFileMiddlewareOrder(order *GinFileMiddlewareOrder) GinFileMiddlewarePaginateOption {
	if order == nil {
		order = DefaultGinFileMiddlewareOrder
	}
	o := *order
	return func(pager *ginfilemiddlewarePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGinFileMiddlewareOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGinFileMiddlewareFilter configures pagination filter.
func WithGinFileMiddlewareFilter(filter func(*GinFileMiddlewareQuery) (*GinFileMiddlewareQuery, error)) GinFileMiddlewarePaginateOption {
	return func(pager *ginfilemiddlewarePager) error {
		if filter == nil {
			return errors.New("GinFileMiddlewareQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type ginfilemiddlewarePager struct {
	reverse bool
	order   *GinFileMiddlewareOrder
	filter  func(*GinFileMiddlewareQuery) (*GinFileMiddlewareQuery, error)
}

func newGinFileMiddlewarePager(opts []GinFileMiddlewarePaginateOption, reverse bool) (*ginfilemiddlewarePager, error) {
	pager := &ginfilemiddlewarePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGinFileMiddlewareOrder
	}
	return pager, nil
}

func (p *ginfilemiddlewarePager) applyFilter(query *GinFileMiddlewareQuery) (*GinFileMiddlewareQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *ginfilemiddlewarePager) toCursor(gfm *GinFileMiddleware) Cursor {
	return p.order.Field.toCursor(gfm)
}

func (p *ginfilemiddlewarePager) applyCursors(query *GinFileMiddlewareQuery, after, before *Cursor) (*GinFileMiddlewareQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGinFileMiddlewareOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *ginfilemiddlewarePager) applyOrder(query *GinFileMiddlewareQuery) *GinFileMiddlewareQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGinFileMiddlewareOrder.Field {
		query = query.Order(DefaultGinFileMiddlewareOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *ginfilemiddlewarePager) orderExpr(query *GinFileMiddlewareQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGinFileMiddlewareOrder.Field {
			b.Comma().Ident(DefaultGinFileMiddlewareOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GinFileMiddleware.
func (gfm *GinFileMiddlewareQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GinFileMiddlewarePaginateOption,
) (*GinFileMiddlewareConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGinFileMiddlewarePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if gfm, err = pager.applyFilter(gfm); err != nil {
		return nil, err
	}
	conn := &GinFileMiddlewareConnection{Edges: []*GinFileMiddlewareEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = gfm.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if gfm, err = pager.applyCursors(gfm, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		gfm.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := gfm.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	gfm = pager.applyOrder(gfm)
	nodes, err := gfm.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// GinFileMiddlewareOrderField defines the ordering field of GinFileMiddleware.
type GinFileMiddlewareOrderField struct {
	// Value extracts the ordering value from the given GinFileMiddleware.
	Value    func(*GinFileMiddleware) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) ginfilemiddleware.OrderOption
	toCursor func(*GinFileMiddleware) Cursor
}

// GinFileMiddlewareOrder defines the ordering of GinFileMiddleware.
type GinFileMiddlewareOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *GinFileMiddlewareOrderField `json:"field"`
}

// DefaultGinFileMiddlewareOrder is the default ordering of GinFileMiddleware.
var DefaultGinFileMiddlewareOrder = &GinFileMiddlewareOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GinFileMiddlewareOrderField{
		Value: func(gfm *GinFileMiddleware) (ent.Value, error) {
			return gfm.ID, nil
		},
		column: ginfilemiddleware.FieldID,
		toTerm: ginfilemiddleware.ByID,
		toCursor: func(gfm *GinFileMiddleware) Cursor {
			return Cursor{ID: gfm.ID}
		},
	},
}

// ToEdge converts GinFileMiddleware into GinFileMiddlewareEdge.
func (gfm *GinFileMiddleware) ToEdge(order *GinFileMiddlewareOrder) *GinFileMiddlewareEdge {
	if order == nil {
		order = DefaultGinFileMiddlewareOrder
	}
	return &GinFileMiddlewareEdge{
		Node:   gfm,
		Cursor: order.Field.toCursor(gfm),
	}
}

// HostEdge is the edge representation of Host.
type HostEdge struct {
	Node   *Host  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// HostConnection is the connection containing edges to Host.
type HostConnection struct {
	Edges      []*HostEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *HostConnection) build(nodes []*Host, pager *hostPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Host
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Host {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Host {
			return nodes[i]
		}
	}
	c.Edges = make([]*HostEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HostEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HostPaginateOption enables pagination customization.
type HostPaginateOption func(*hostPager) error

// WithHostOrder configures pagination ordering.
func WithHostOrder(order *HostOrder) HostPaginateOption {
	if order == nil {
		order = DefaultHostOrder
	}
	o := *order
	return func(pager *hostPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHostOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHostFilter configures pagination filter.
func WithHostFilter(filter func(*HostQuery) (*HostQuery, error)) HostPaginateOption {
	return func(pager *hostPager) error {
		if filter == nil {
			return errors.New("HostQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hostPager struct {
	reverse bool
	order   *HostOrder
	filter  func(*HostQuery) (*HostQuery, error)
}

func newHostPager(opts []HostPaginateOption, reverse bool) (*hostPager, error) {
	pager := &hostPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHostOrder
	}
	return pager, nil
}

func (p *hostPager) applyFilter(query *HostQuery) (*HostQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hostPager) toCursor(h *Host) Cursor {
	return p.order.Field.toCursor(h)
}

func (p *hostPager) applyCursors(query *HostQuery, after, before *Cursor) (*HostQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHostOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hostPager) applyOrder(query *HostQuery) *HostQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultHostOrder.Field {
		query = query.Order(DefaultHostOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *hostPager) orderExpr(query *HostQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHostOrder.Field {
			b.Comma().Ident(DefaultHostOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Host.
func (h *HostQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HostPaginateOption,
) (*HostConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHostPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if h, err = pager.applyFilter(h); err != nil {
		return nil, err
	}
	conn := &HostConnection{Edges: []*HostEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = h.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if h, err = pager.applyCursors(h, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		h.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := h.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	h = pager.applyOrder(h)
	nodes, err := h.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// HostOrderField defines the ordering field of Host.
type HostOrderField struct {
	// Value extracts the ordering value from the given Host.
	Value    func(*Host) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) host.OrderOption
	toCursor func(*Host) Cursor
}

// HostOrder defines the ordering of Host.
type HostOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *HostOrderField `json:"field"`
}

// DefaultHostOrder is the default ordering of Host.
var DefaultHostOrder = &HostOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HostOrderField{
		Value: func(h *Host) (ent.Value, error) {
			return h.ID, nil
		},
		column: host.FieldID,
		toTerm: host.ByID,
		toCursor: func(h *Host) Cursor {
			return Cursor{ID: h.ID}
		},
	},
}

// ToEdge converts Host into HostEdge.
func (h *Host) ToEdge(order *HostOrder) *HostEdge {
	if order == nil {
		order = DefaultHostOrder
	}
	return &HostEdge{
		Node:   h,
		Cursor: order.Field.toCursor(h),
	}
}

// HostDependencyEdge is the edge representation of HostDependency.
type HostDependencyEdge struct {
	Node   *HostDependency `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// HostDependencyConnection is the connection containing edges to HostDependency.
type HostDependencyConnection struct {
	Edges      []*HostDependencyEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *HostDependencyConnection) build(nodes []*HostDependency, pager *hostdependencyPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HostDependency
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HostDependency {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HostDependency {
			return nodes[i]
		}
	}
	c.Edges = make([]*HostDependencyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HostDependencyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HostDependencyPaginateOption enables pagination customization.
type HostDependencyPaginateOption func(*hostdependencyPager) error

// WithHostDependencyOrder configures pagination ordering.
func WithHostDependencyOrder(order *HostDependencyOrder) HostDependencyPaginateOption {
	if order == nil {
		order = DefaultHostDependencyOrder
	}
	o := *order
	return func(pager *hostdependencyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHostDependencyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHostDependencyFilter configures pagination filter.
func WithHostDependencyFilter(filter func(*HostDependencyQuery) (*HostDependencyQuery, error)) HostDependencyPaginateOption {
	return func(pager *hostdependencyPager) error {
		if filter == nil {
			return errors.New("HostDependencyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hostdependencyPager struct {
	reverse bool
	order   *HostDependencyOrder
	filter  func(*HostDependencyQuery) (*HostDependencyQuery, error)
}

func newHostDependencyPager(opts []HostDependencyPaginateOption, reverse bool) (*hostdependencyPager, error) {
	pager := &hostdependencyPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHostDependencyOrder
	}
	return pager, nil
}

func (p *hostdependencyPager) applyFilter(query *HostDependencyQuery) (*HostDependencyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hostdependencyPager) toCursor(hd *HostDependency) Cursor {
	return p.order.Field.toCursor(hd)
}

func (p *hostdependencyPager) applyCursors(query *HostDependencyQuery, after, before *Cursor) (*HostDependencyQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHostDependencyOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hostdependencyPager) applyOrder(query *HostDependencyQuery) *HostDependencyQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultHostDependencyOrder.Field {
		query = query.Order(DefaultHostDependencyOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *hostdependencyPager) orderExpr(query *HostDependencyQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHostDependencyOrder.Field {
			b.Comma().Ident(DefaultHostDependencyOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HostDependency.
func (hd *HostDependencyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HostDependencyPaginateOption,
) (*HostDependencyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHostDependencyPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if hd, err = pager.applyFilter(hd); err != nil {
		return nil, err
	}
	conn := &HostDependencyConnection{Edges: []*HostDependencyEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = hd.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if hd, err = pager.applyCursors(hd, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		hd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := hd.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	hd = pager.applyOrder(hd)
	nodes, err := hd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// HostDependencyOrderField defines the ordering field of HostDependency.
type HostDependencyOrderField struct {
	// Value extracts the ordering value from the given HostDependency.
	Value    func(*HostDependency) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) hostdependency.OrderOption
	toCursor func(*HostDependency) Cursor
}

// HostDependencyOrder defines the ordering of HostDependency.
type HostDependencyOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *HostDependencyOrderField `json:"field"`
}

// DefaultHostDependencyOrder is the default ordering of HostDependency.
var DefaultHostDependencyOrder = &HostDependencyOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HostDependencyOrderField{
		Value: func(hd *HostDependency) (ent.Value, error) {
			return hd.ID, nil
		},
		column: hostdependency.FieldID,
		toTerm: hostdependency.ByID,
		toCursor: func(hd *HostDependency) Cursor {
			return Cursor{ID: hd.ID}
		},
	},
}

// ToEdge converts HostDependency into HostDependencyEdge.
func (hd *HostDependency) ToEdge(order *HostDependencyOrder) *HostDependencyEdge {
	if order == nil {
		order = DefaultHostDependencyOrder
	}
	return &HostDependencyEdge{
		Node:   hd,
		Cursor: order.Field.toCursor(hd),
	}
}

// IdentityEdge is the edge representation of Identity.
type IdentityEdge struct {
	Node   *Identity `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// IdentityConnection is the connection containing edges to Identity.
type IdentityConnection struct {
	Edges      []*IdentityEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *IdentityConnection) build(nodes []*Identity, pager *identityPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Identity
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Identity {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Identity {
			return nodes[i]
		}
	}
	c.Edges = make([]*IdentityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &IdentityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// IdentityPaginateOption enables pagination customization.
type IdentityPaginateOption func(*identityPager) error

// WithIdentityOrder configures pagination ordering.
func WithIdentityOrder(order *IdentityOrder) IdentityPaginateOption {
	if order == nil {
		order = DefaultIdentityOrder
	}
	o := *order
	return func(pager *identityPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultIdentityOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithIdentityFilter configures pagination filter.
func WithIdentityFilter(filter func(*IdentityQuery) (*IdentityQuery, error)) IdentityPaginateOption {
	return func(pager *identityPager) error {
		if filter == nil {
			return errors.New("IdentityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type identityPager struct {
	reverse bool
	order   *IdentityOrder
	filter  func(*IdentityQuery) (*IdentityQuery, error)
}

func newIdentityPager(opts []IdentityPaginateOption, reverse bool) (*identityPager, error) {
	pager := &identityPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultIdentityOrder
	}
	return pager, nil
}

func (p *identityPager) applyFilter(query *IdentityQuery) (*IdentityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *identityPager) toCursor(i *Identity) Cursor {
	return p.order.Field.toCursor(i)
}

func (p *identityPager) applyCursors(query *IdentityQuery, after, before *Cursor) (*IdentityQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultIdentityOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *identityPager) applyOrder(query *IdentityQuery) *IdentityQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultIdentityOrder.Field {
		query = query.Order(DefaultIdentityOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *identityPager) orderExpr(query *IdentityQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultIdentityOrder.Field {
			b.Comma().Ident(DefaultIdentityOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Identity.
func (i *IdentityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...IdentityPaginateOption,
) (*IdentityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newIdentityPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if i, err = pager.applyFilter(i); err != nil {
		return nil, err
	}
	conn := &IdentityConnection{Edges: []*IdentityEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = i.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if i, err = pager.applyCursors(i, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		i.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := i.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	i = pager.applyOrder(i)
	nodes, err := i.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// IdentityOrderField defines the ordering field of Identity.
type IdentityOrderField struct {
	// Value extracts the ordering value from the given Identity.
	Value    func(*Identity) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) identity.OrderOption
	toCursor func(*Identity) Cursor
}

// IdentityOrder defines the ordering of Identity.
type IdentityOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *IdentityOrderField `json:"field"`
}

// DefaultIdentityOrder is the default ordering of Identity.
var DefaultIdentityOrder = &IdentityOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &IdentityOrderField{
		Value: func(i *Identity) (ent.Value, error) {
			return i.ID, nil
		},
		column: identity.FieldID,
		toTerm: identity.ByID,
		toCursor: func(i *Identity) Cursor {
			return Cursor{ID: i.ID}
		},
	},
}

// ToEdge converts Identity into IdentityEdge.
func (i *Identity) ToEdge(order *IdentityOrder) *IdentityEdge {
	if order == nil {
		order = DefaultIdentityOrder
	}
	return &IdentityEdge{
		Node:   i,
		Cursor: order.Field.toCursor(i),
	}
}

// IncludedNetworkEdge is the edge representation of IncludedNetwork.
type IncludedNetworkEdge struct {
	Node   *IncludedNetwork `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// IncludedNetworkConnection is the connection containing edges to IncludedNetwork.
type IncludedNetworkConnection struct {
	Edges      []*IncludedNetworkEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *IncludedNetworkConnection) build(nodes []*IncludedNetwork, pager *includednetworkPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *IncludedNetwork
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *IncludedNetwork {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *IncludedNetwork {
			return nodes[i]
		}
	}
	c.Edges = make([]*IncludedNetworkEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &IncludedNetworkEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// IncludedNetworkPaginateOption enables pagination customization.
type IncludedNetworkPaginateOption func(*includednetworkPager) error

// WithIncludedNetworkOrder configures pagination ordering.
func WithIncludedNetworkOrder(order *IncludedNetworkOrder) IncludedNetworkPaginateOption {
	if order == nil {
		order = DefaultIncludedNetworkOrder
	}
	o := *order
	return func(pager *includednetworkPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultIncludedNetworkOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithIncludedNetworkFilter configures pagination filter.
func WithIncludedNetworkFilter(filter func(*IncludedNetworkQuery) (*IncludedNetworkQuery, error)) IncludedNetworkPaginateOption {
	return func(pager *includednetworkPager) error {
		if filter == nil {
			return errors.New("IncludedNetworkQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type includednetworkPager struct {
	reverse bool
	order   *IncludedNetworkOrder
	filter  func(*IncludedNetworkQuery) (*IncludedNetworkQuery, error)
}

func newIncludedNetworkPager(opts []IncludedNetworkPaginateOption, reverse bool) (*includednetworkPager, error) {
	pager := &includednetworkPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultIncludedNetworkOrder
	}
	return pager, nil
}

func (p *includednetworkPager) applyFilter(query *IncludedNetworkQuery) (*IncludedNetworkQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *includednetworkPager) toCursor(in *IncludedNetwork) Cursor {
	return p.order.Field.toCursor(in)
}

func (p *includednetworkPager) applyCursors(query *IncludedNetworkQuery, after, before *Cursor) (*IncludedNetworkQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultIncludedNetworkOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *includednetworkPager) applyOrder(query *IncludedNetworkQuery) *IncludedNetworkQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultIncludedNetworkOrder.Field {
		query = query.Order(DefaultIncludedNetworkOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *includednetworkPager) orderExpr(query *IncludedNetworkQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultIncludedNetworkOrder.Field {
			b.Comma().Ident(DefaultIncludedNetworkOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to IncludedNetwork.
func (in *IncludedNetworkQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...IncludedNetworkPaginateOption,
) (*IncludedNetworkConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newIncludedNetworkPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if in, err = pager.applyFilter(in); err != nil {
		return nil, err
	}
	conn := &IncludedNetworkConnection{Edges: []*IncludedNetworkEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = in.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if in, err = pager.applyCursors(in, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		in.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := in.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	in = pager.applyOrder(in)
	nodes, err := in.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// IncludedNetworkOrderField defines the ordering field of IncludedNetwork.
type IncludedNetworkOrderField struct {
	// Value extracts the ordering value from the given IncludedNetwork.
	Value    func(*IncludedNetwork) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) includednetwork.OrderOption
	toCursor func(*IncludedNetwork) Cursor
}

// IncludedNetworkOrder defines the ordering of IncludedNetwork.
type IncludedNetworkOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *IncludedNetworkOrderField `json:"field"`
}

// DefaultIncludedNetworkOrder is the default ordering of IncludedNetwork.
var DefaultIncludedNetworkOrder = &IncludedNetworkOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &IncludedNetworkOrderField{
		Value: func(in *IncludedNetwork) (ent.Value, error) {
			return in.ID, nil
		},
		column: includednetwork.FieldID,
		toTerm: includednetwork.ByID,
		toCursor: func(in *IncludedNetwork) Cursor {
			return Cursor{ID: in.ID}
		},
	},
}

// ToEdge converts IncludedNetwork into IncludedNetworkEdge.
func (in *IncludedNetwork) ToEdge(order *IncludedNetworkOrder) *IncludedNetworkEdge {
	if order == nil {
		order = DefaultIncludedNetworkOrder
	}
	return &IncludedNetworkEdge{
		Node:   in,
		Cursor: order.Field.toCursor(in),
	}
}

// NetworkEdge is the edge representation of Network.
type NetworkEdge struct {
	Node   *Network `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// NetworkConnection is the connection containing edges to Network.
type NetworkConnection struct {
	Edges      []*NetworkEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *NetworkConnection) build(nodes []*Network, pager *networkPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Network
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Network {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Network {
			return nodes[i]
		}
	}
	c.Edges = make([]*NetworkEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NetworkEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NetworkPaginateOption enables pagination customization.
type NetworkPaginateOption func(*networkPager) error

// WithNetworkOrder configures pagination ordering.
func WithNetworkOrder(order *NetworkOrder) NetworkPaginateOption {
	if order == nil {
		order = DefaultNetworkOrder
	}
	o := *order
	return func(pager *networkPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNetworkOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNetworkFilter configures pagination filter.
func WithNetworkFilter(filter func(*NetworkQuery) (*NetworkQuery, error)) NetworkPaginateOption {
	return func(pager *networkPager) error {
		if filter == nil {
			return errors.New("NetworkQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type networkPager struct {
	reverse bool
	order   *NetworkOrder
	filter  func(*NetworkQuery) (*NetworkQuery, error)
}

func newNetworkPager(opts []NetworkPaginateOption, reverse bool) (*networkPager, error) {
	pager := &networkPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNetworkOrder
	}
	return pager, nil
}

func (p *networkPager) applyFilter(query *NetworkQuery) (*NetworkQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *networkPager) toCursor(n *Network) Cursor {
	return p.order.Field.toCursor(n)
}

func (p *networkPager) applyCursors(query *NetworkQuery, after, before *Cursor) (*NetworkQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultNetworkOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *networkPager) applyOrder(query *NetworkQuery) *NetworkQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultNetworkOrder.Field {
		query = query.Order(DefaultNetworkOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *networkPager) orderExpr(query *NetworkQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultNetworkOrder.Field {
			b.Comma().Ident(DefaultNetworkOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Network.
func (n *NetworkQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NetworkPaginateOption,
) (*NetworkConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNetworkPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if n, err = pager.applyFilter(n); err != nil {
		return nil, err
	}
	conn := &NetworkConnection{Edges: []*NetworkEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = n.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if n, err = pager.applyCursors(n, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		n.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := n.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	n = pager.applyOrder(n)
	nodes, err := n.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// NetworkOrderField defines the ordering field of Network.
type NetworkOrderField struct {
	// Value extracts the ordering value from the given Network.
	Value    func(*Network) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) network.OrderOption
	toCursor func(*Network) Cursor
}

// NetworkOrder defines the ordering of Network.
type NetworkOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *NetworkOrderField `json:"field"`
}

// DefaultNetworkOrder is the default ordering of Network.
var DefaultNetworkOrder = &NetworkOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NetworkOrderField{
		Value: func(n *Network) (ent.Value, error) {
			return n.ID, nil
		},
		column: network.FieldID,
		toTerm: network.ByID,
		toCursor: func(n *Network) Cursor {
			return Cursor{ID: n.ID}
		},
	},
}

// ToEdge converts Network into NetworkEdge.
func (n *Network) ToEdge(order *NetworkOrder) *NetworkEdge {
	if order == nil {
		order = DefaultNetworkOrder
	}
	return &NetworkEdge{
		Node:   n,
		Cursor: order.Field.toCursor(n),
	}
}

// PlanEdge is the edge representation of Plan.
type PlanEdge struct {
	Node   *Plan  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// PlanConnection is the connection containing edges to Plan.
type PlanConnection struct {
	Edges      []*PlanEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *PlanConnection) build(nodes []*Plan, pager *planPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Plan
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Plan {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Plan {
			return nodes[i]
		}
	}
	c.Edges = make([]*PlanEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PlanEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PlanPaginateOption enables pagination customization.
type PlanPaginateOption func(*planPager) error

// WithPlanOrder configures pagination ordering.
func WithPlanOrder(order *PlanOrder) PlanPaginateOption {
	if order == nil {
		order = DefaultPlanOrder
	}
	o := *order
	return func(pager *planPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPlanOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPlanFilter configures pagination filter.
func WithPlanFilter(filter func(*PlanQuery) (*PlanQuery, error)) PlanPaginateOption {
	return func(pager *planPager) error {
		if filter == nil {
			return errors.New("PlanQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type planPager struct {
	reverse bool
	order   *PlanOrder
	filter  func(*PlanQuery) (*PlanQuery, error)
}

func newPlanPager(opts []PlanPaginateOption, reverse bool) (*planPager, error) {
	pager := &planPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPlanOrder
	}
	return pager, nil
}

func (p *planPager) applyFilter(query *PlanQuery) (*PlanQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *planPager) toCursor(pl *Plan) Cursor {
	return p.order.Field.toCursor(pl)
}

func (p *planPager) applyCursors(query *PlanQuery, after, before *Cursor) (*PlanQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPlanOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *planPager) applyOrder(query *PlanQuery) *PlanQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPlanOrder.Field {
		query = query.Order(DefaultPlanOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *planPager) orderExpr(query *PlanQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPlanOrder.Field {
			b.Comma().Ident(DefaultPlanOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Plan.
func (pl *PlanQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PlanPaginateOption,
) (*PlanConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPlanPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pl, err = pager.applyFilter(pl); err != nil {
		return nil, err
	}
	conn := &PlanConnection{Edges: []*PlanEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pl.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pl, err = pager.applyCursors(pl, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pl.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pl.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pl = pager.applyOrder(pl)
	nodes, err := pl.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PlanOrderField defines the ordering field of Plan.
type PlanOrderField struct {
	// Value extracts the ordering value from the given Plan.
	Value    func(*Plan) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) plan.OrderOption
	toCursor func(*Plan) Cursor
}

// PlanOrder defines the ordering of Plan.
type PlanOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *PlanOrderField `json:"field"`
}

// DefaultPlanOrder is the default ordering of Plan.
var DefaultPlanOrder = &PlanOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PlanOrderField{
		Value: func(pl *Plan) (ent.Value, error) {
			return pl.ID, nil
		},
		column: plan.FieldID,
		toTerm: plan.ByID,
		toCursor: func(pl *Plan) Cursor {
			return Cursor{ID: pl.ID}
		},
	},
}

// ToEdge converts Plan into PlanEdge.
func (pl *Plan) ToEdge(order *PlanOrder) *PlanEdge {
	if order == nil {
		order = DefaultPlanOrder
	}
	return &PlanEdge{
		Node:   pl,
		Cursor: order.Field.toCursor(pl),
	}
}

// PlanDiffEdge is the edge representation of PlanDiff.
type PlanDiffEdge struct {
	Node   *PlanDiff `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// PlanDiffConnection is the connection containing edges to PlanDiff.
type PlanDiffConnection struct {
	Edges      []*PlanDiffEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *PlanDiffConnection) build(nodes []*PlanDiff, pager *plandiffPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PlanDiff
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PlanDiff {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PlanDiff {
			return nodes[i]
		}
	}
	c.Edges = make([]*PlanDiffEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PlanDiffEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PlanDiffPaginateOption enables pagination customization.
type PlanDiffPaginateOption func(*plandiffPager) error

// WithPlanDiffOrder configures pagination ordering.
func WithPlanDiffOrder(order *PlanDiffOrder) PlanDiffPaginateOption {
	if order == nil {
		order = DefaultPlanDiffOrder
	}
	o := *order
	return func(pager *plandiffPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPlanDiffOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPlanDiffFilter configures pagination filter.
func WithPlanDiffFilter(filter func(*PlanDiffQuery) (*PlanDiffQuery, error)) PlanDiffPaginateOption {
	return func(pager *plandiffPager) error {
		if filter == nil {
			return errors.New("PlanDiffQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type plandiffPager struct {
	reverse bool
	order   *PlanDiffOrder
	filter  func(*PlanDiffQuery) (*PlanDiffQuery, error)
}

func newPlanDiffPager(opts []PlanDiffPaginateOption, reverse bool) (*plandiffPager, error) {
	pager := &plandiffPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPlanDiffOrder
	}
	return pager, nil
}

func (p *plandiffPager) applyFilter(query *PlanDiffQuery) (*PlanDiffQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *plandiffPager) toCursor(pd *PlanDiff) Cursor {
	return p.order.Field.toCursor(pd)
}

func (p *plandiffPager) applyCursors(query *PlanDiffQuery, after, before *Cursor) (*PlanDiffQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPlanDiffOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *plandiffPager) applyOrder(query *PlanDiffQuery) *PlanDiffQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPlanDiffOrder.Field {
		query = query.Order(DefaultPlanDiffOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *plandiffPager) orderExpr(query *PlanDiffQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPlanDiffOrder.Field {
			b.Comma().Ident(DefaultPlanDiffOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to PlanDiff.
func (pd *PlanDiffQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PlanDiffPaginateOption,
) (*PlanDiffConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPlanDiffPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pd, err = pager.applyFilter(pd); err != nil {
		return nil, err
	}
	conn := &PlanDiffConnection{Edges: []*PlanDiffEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pd.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pd, err = pager.applyCursors(pd, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pd.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pd = pager.applyOrder(pd)
	nodes, err := pd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PlanDiffOrderField defines the ordering field of PlanDiff.
type PlanDiffOrderField struct {
	// Value extracts the ordering value from the given PlanDiff.
	Value    func(*PlanDiff) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) plandiff.OrderOption
	toCursor func(*PlanDiff) Cursor
}

// PlanDiffOrder defines the ordering of PlanDiff.
type PlanDiffOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *PlanDiffOrderField `json:"field"`
}

// DefaultPlanDiffOrder is the default ordering of PlanDiff.
var DefaultPlanDiffOrder = &PlanDiffOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PlanDiffOrderField{
		Value: func(pd *PlanDiff) (ent.Value, error) {
			return pd.ID, nil
		},
		column: plandiff.FieldID,
		toTerm: plandiff.ByID,
		toCursor: func(pd *PlanDiff) Cursor {
			return Cursor{ID: pd.ID}
		},
	},
}

// ToEdge converts PlanDiff into PlanDiffEdge.
func (pd *PlanDiff) ToEdge(order *PlanDiffOrder) *PlanDiffEdge {
	if order == nil {
		order = DefaultPlanDiffOrder
	}
	return &PlanDiffEdge{
		Node:   pd,
		Cursor: order.Field.toCursor(pd),
	}
}

// ProvisionedHostEdge is the edge representation of ProvisionedHost.
type ProvisionedHostEdge struct {
	Node   *ProvisionedHost `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// ProvisionedHostConnection is the connection containing edges to ProvisionedHost.
type ProvisionedHostConnection struct {
	Edges      []*ProvisionedHostEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *ProvisionedHostConnection) build(nodes []*ProvisionedHost, pager *provisionedhostPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProvisionedHost
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProvisionedHost {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProvisionedHost {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProvisionedHostEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProvisionedHostEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProvisionedHostPaginateOption enables pagination customization.
type ProvisionedHostPaginateOption func(*provisionedhostPager) error

// WithProvisionedHostOrder configures pagination ordering.
func WithProvisionedHostOrder(order *ProvisionedHostOrder) ProvisionedHostPaginateOption {
	if order == nil {
		order = DefaultProvisionedHostOrder
	}
	o := *order
	return func(pager *provisionedhostPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProvisionedHostOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProvisionedHostFilter configures pagination filter.
func WithProvisionedHostFilter(filter func(*ProvisionedHostQuery) (*ProvisionedHostQuery, error)) ProvisionedHostPaginateOption {
	return func(pager *provisionedhostPager) error {
		if filter == nil {
			return errors.New("ProvisionedHostQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type provisionedhostPager struct {
	reverse bool
	order   *ProvisionedHostOrder
	filter  func(*ProvisionedHostQuery) (*ProvisionedHostQuery, error)
}

func newProvisionedHostPager(opts []ProvisionedHostPaginateOption, reverse bool) (*provisionedhostPager, error) {
	pager := &provisionedhostPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProvisionedHostOrder
	}
	return pager, nil
}

func (p *provisionedhostPager) applyFilter(query *ProvisionedHostQuery) (*ProvisionedHostQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *provisionedhostPager) toCursor(ph *ProvisionedHost) Cursor {
	return p.order.Field.toCursor(ph)
}

func (p *provisionedhostPager) applyCursors(query *ProvisionedHostQuery, after, before *Cursor) (*ProvisionedHostQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProvisionedHostOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *provisionedhostPager) applyOrder(query *ProvisionedHostQuery) *ProvisionedHostQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProvisionedHostOrder.Field {
		query = query.Order(DefaultProvisionedHostOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *provisionedhostPager) orderExpr(query *ProvisionedHostQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProvisionedHostOrder.Field {
			b.Comma().Ident(DefaultProvisionedHostOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProvisionedHost.
func (ph *ProvisionedHostQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProvisionedHostPaginateOption,
) (*ProvisionedHostConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProvisionedHostPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ph, err = pager.applyFilter(ph); err != nil {
		return nil, err
	}
	conn := &ProvisionedHostConnection{Edges: []*ProvisionedHostEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ph.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ph, err = pager.applyCursors(ph, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ph.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ph.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ph = pager.applyOrder(ph)
	nodes, err := ph.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ProvisionedHostOrderField defines the ordering field of ProvisionedHost.
type ProvisionedHostOrderField struct {
	// Value extracts the ordering value from the given ProvisionedHost.
	Value    func(*ProvisionedHost) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) provisionedhost.OrderOption
	toCursor func(*ProvisionedHost) Cursor
}

// ProvisionedHostOrder defines the ordering of ProvisionedHost.
type ProvisionedHostOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *ProvisionedHostOrderField `json:"field"`
}

// DefaultProvisionedHostOrder is the default ordering of ProvisionedHost.
var DefaultProvisionedHostOrder = &ProvisionedHostOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProvisionedHostOrderField{
		Value: func(ph *ProvisionedHost) (ent.Value, error) {
			return ph.ID, nil
		},
		column: provisionedhost.FieldID,
		toTerm: provisionedhost.ByID,
		toCursor: func(ph *ProvisionedHost) Cursor {
			return Cursor{ID: ph.ID}
		},
	},
}

// ToEdge converts ProvisionedHost into ProvisionedHostEdge.
func (ph *ProvisionedHost) ToEdge(order *ProvisionedHostOrder) *ProvisionedHostEdge {
	if order == nil {
		order = DefaultProvisionedHostOrder
	}
	return &ProvisionedHostEdge{
		Node:   ph,
		Cursor: order.Field.toCursor(ph),
	}
}

// ProvisionedNetworkEdge is the edge representation of ProvisionedNetwork.
type ProvisionedNetworkEdge struct {
	Node   *ProvisionedNetwork `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// ProvisionedNetworkConnection is the connection containing edges to ProvisionedNetwork.
type ProvisionedNetworkConnection struct {
	Edges      []*ProvisionedNetworkEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *ProvisionedNetworkConnection) build(nodes []*ProvisionedNetwork, pager *provisionednetworkPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProvisionedNetwork
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProvisionedNetwork {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProvisionedNetwork {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProvisionedNetworkEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProvisionedNetworkEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProvisionedNetworkPaginateOption enables pagination customization.
type ProvisionedNetworkPaginateOption func(*provisionednetworkPager) error

// WithProvisionedNetworkOrder configures pagination ordering.
func WithProvisionedNetworkOrder(order *ProvisionedNetworkOrder) ProvisionedNetworkPaginateOption {
	if order == nil {
		order = DefaultProvisionedNetworkOrder
	}
	o := *order
	return func(pager *provisionednetworkPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProvisionedNetworkOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProvisionedNetworkFilter configures pagination filter.
func WithProvisionedNetworkFilter(filter func(*ProvisionedNetworkQuery) (*ProvisionedNetworkQuery, error)) ProvisionedNetworkPaginateOption {
	return func(pager *provisionednetworkPager) error {
		if filter == nil {
			return errors.New("ProvisionedNetworkQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type provisionednetworkPager struct {
	reverse bool
	order   *ProvisionedNetworkOrder
	filter  func(*ProvisionedNetworkQuery) (*ProvisionedNetworkQuery, error)
}

func newProvisionedNetworkPager(opts []ProvisionedNetworkPaginateOption, reverse bool) (*provisionednetworkPager, error) {
	pager := &provisionednetworkPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProvisionedNetworkOrder
	}
	return pager, nil
}

func (p *provisionednetworkPager) applyFilter(query *ProvisionedNetworkQuery) (*ProvisionedNetworkQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *provisionednetworkPager) toCursor(pn *ProvisionedNetwork) Cursor {
	return p.order.Field.toCursor(pn)
}

func (p *provisionednetworkPager) applyCursors(query *ProvisionedNetworkQuery, after, before *Cursor) (*ProvisionedNetworkQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProvisionedNetworkOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *provisionednetworkPager) applyOrder(query *ProvisionedNetworkQuery) *ProvisionedNetworkQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProvisionedNetworkOrder.Field {
		query = query.Order(DefaultProvisionedNetworkOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *provisionednetworkPager) orderExpr(query *ProvisionedNetworkQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProvisionedNetworkOrder.Field {
			b.Comma().Ident(DefaultProvisionedNetworkOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProvisionedNetwork.
func (pn *ProvisionedNetworkQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProvisionedNetworkPaginateOption,
) (*ProvisionedNetworkConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProvisionedNetworkPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pn, err = pager.applyFilter(pn); err != nil {
		return nil, err
	}
	conn := &ProvisionedNetworkConnection{Edges: []*ProvisionedNetworkEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pn.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pn, err = pager.applyCursors(pn, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pn.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pn.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pn = pager.applyOrder(pn)
	nodes, err := pn.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ProvisionedNetworkOrderField defines the ordering field of ProvisionedNetwork.
type ProvisionedNetworkOrderField struct {
	// Value extracts the ordering value from the given ProvisionedNetwork.
	Value    func(*ProvisionedNetwork) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) provisionednetwork.OrderOption
	toCursor func(*ProvisionedNetwork) Cursor
}

// ProvisionedNetworkOrder defines the ordering of ProvisionedNetwork.
type ProvisionedNetworkOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *ProvisionedNetworkOrderField `json:"field"`
}

// DefaultProvisionedNetworkOrder is the default ordering of ProvisionedNetwork.
var DefaultProvisionedNetworkOrder = &ProvisionedNetworkOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProvisionedNetworkOrderField{
		Value: func(pn *ProvisionedNetwork) (ent.Value, error) {
			return pn.ID, nil
		},
		column: provisionednetwork.FieldID,
		toTerm: provisionednetwork.ByID,
		toCursor: func(pn *ProvisionedNetwork) Cursor {
			return Cursor{ID: pn.ID}
		},
	},
}

// ToEdge converts ProvisionedNetwork into ProvisionedNetworkEdge.
func (pn *ProvisionedNetwork) ToEdge(order *ProvisionedNetworkOrder) *ProvisionedNetworkEdge {
	if order == nil {
		order = DefaultProvisionedNetworkOrder
	}
	return &ProvisionedNetworkEdge{
		Node:   pn,
		Cursor: order.Field.toCursor(pn),
	}
}

// ProvisioningStepEdge is the edge representation of ProvisioningStep.
type ProvisioningStepEdge struct {
	Node   *ProvisioningStep `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// ProvisioningStepConnection is the connection containing edges to ProvisioningStep.
type ProvisioningStepConnection struct {
	Edges      []*ProvisioningStepEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *ProvisioningStepConnection) build(nodes []*ProvisioningStep, pager *provisioningstepPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProvisioningStep
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProvisioningStep {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProvisioningStep {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProvisioningStepEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProvisioningStepEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProvisioningStepPaginateOption enables pagination customization.
type ProvisioningStepPaginateOption func(*provisioningstepPager) error

// WithProvisioningStepOrder configures pagination ordering.
func WithProvisioningStepOrder(order *ProvisioningStepOrder) ProvisioningStepPaginateOption {
	if order == nil {
		order = DefaultProvisioningStepOrder
	}
	o := *order
	return func(pager *provisioningstepPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProvisioningStepOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProvisioningStepFilter configures pagination filter.
func WithProvisioningStepFilter(filter func(*ProvisioningStepQuery) (*ProvisioningStepQuery, error)) ProvisioningStepPaginateOption {
	return func(pager *provisioningstepPager) error {
		if filter == nil {
			return errors.New("ProvisioningStepQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type provisioningstepPager struct {
	reverse bool
	order   *ProvisioningStepOrder
	filter  func(*ProvisioningStepQuery) (*ProvisioningStepQuery, error)
}

func newProvisioningStepPager(opts []ProvisioningStepPaginateOption, reverse bool) (*provisioningstepPager, error) {
	pager := &provisioningstepPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProvisioningStepOrder
	}
	return pager, nil
}

func (p *provisioningstepPager) applyFilter(query *ProvisioningStepQuery) (*ProvisioningStepQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *provisioningstepPager) toCursor(ps *ProvisioningStep) Cursor {
	return p.order.Field.toCursor(ps)
}

func (p *provisioningstepPager) applyCursors(query *ProvisioningStepQuery, after, before *Cursor) (*ProvisioningStepQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProvisioningStepOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *provisioningstepPager) applyOrder(query *ProvisioningStepQuery) *ProvisioningStepQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProvisioningStepOrder.Field {
		query = query.Order(DefaultProvisioningStepOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *provisioningstepPager) orderExpr(query *ProvisioningStepQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProvisioningStepOrder.Field {
			b.Comma().Ident(DefaultProvisioningStepOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProvisioningStep.
func (ps *ProvisioningStepQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProvisioningStepPaginateOption,
) (*ProvisioningStepConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProvisioningStepPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ps, err = pager.applyFilter(ps); err != nil {
		return nil, err
	}
	conn := &ProvisioningStepConnection{Edges: []*ProvisioningStepEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ps.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ps, err = pager.applyCursors(ps, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ps.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ps.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ps = pager.applyOrder(ps)
	nodes, err := ps.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ProvisioningStepOrderField defines the ordering field of ProvisioningStep.
type ProvisioningStepOrderField struct {
	// Value extracts the ordering value from the given ProvisioningStep.
	Value    func(*ProvisioningStep) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) provisioningstep.OrderOption
	toCursor func(*ProvisioningStep) Cursor
}

// ProvisioningStepOrder defines the ordering of ProvisioningStep.
type ProvisioningStepOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *ProvisioningStepOrderField `json:"field"`
}

// DefaultProvisioningStepOrder is the default ordering of ProvisioningStep.
var DefaultProvisioningStepOrder = &ProvisioningStepOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProvisioningStepOrderField{
		Value: func(ps *ProvisioningStep) (ent.Value, error) {
			return ps.ID, nil
		},
		column: provisioningstep.FieldID,
		toTerm: provisioningstep.ByID,
		toCursor: func(ps *ProvisioningStep) Cursor {
			return Cursor{ID: ps.ID}
		},
	},
}

// ToEdge converts ProvisioningStep into ProvisioningStepEdge.
func (ps *ProvisioningStep) ToEdge(order *ProvisioningStepOrder) *ProvisioningStepEdge {
	if order == nil {
		order = DefaultProvisioningStepOrder
	}
	return &ProvisioningStepEdge{
		Node:   ps,
		Cursor: order.Field.toCursor(ps),
	}
}

// RepoCommitEdge is the edge representation of RepoCommit.
type RepoCommitEdge struct {
	Node   *RepoCommit `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// RepoCommitConnection is the connection containing edges to RepoCommit.
type RepoCommitConnection struct {
	Edges      []*RepoCommitEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *RepoCommitConnection) build(nodes []*RepoCommit, pager *repocommitPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *RepoCommit
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *RepoCommit {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *RepoCommit {
			return nodes[i]
		}
	}
	c.Edges = make([]*RepoCommitEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RepoCommitEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RepoCommitPaginateOption enables pagination customization.
type RepoCommitPaginateOption func(*repocommitPager) error

// WithRepoCommitOrder configures pagination ordering.
func WithRepoCommitOrder(order *RepoCommitOrder) RepoCommitPaginateOption {
	if order == nil {
		order = DefaultRepoCommitOrder
	}
	o := *order
	return func(pager *repocommitPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRepoCommitOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRepoCommitFilter configures pagination filter.
func WithRepoCommitFilter(filter func(*RepoCommitQuery) (*RepoCommitQuery, error)) RepoCommitPaginateOption {
	return func(pager *repocommitPager) error {
		if filter == nil {
			return errors.New("RepoCommitQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type repocommitPager struct {
	reverse bool
	order   *RepoCommitOrder
	filter  func(*RepoCommitQuery) (*RepoCommitQuery, error)
}

func newRepoCommitPager(opts []RepoCommitPaginateOption, reverse bool) (*repocommitPager, error) {
	pager := &repocommitPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRepoCommitOrder
	}
	return pager, nil
}

func (p *repocommitPager) applyFilter(query *RepoCommitQuery) (*RepoCommitQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *repocommitPager) toCursor(rc *RepoCommit) Cursor {
	return p.order.Field.toCursor(rc)
}

func (p *repocommitPager) applyCursors(query *RepoCommitQuery, after, before *Cursor) (*RepoCommitQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultRepoCommitOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *repocommitPager) applyOrder(query *RepoCommitQuery) *RepoCommitQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultRepoCommitOrder.Field {
		query = query.Order(DefaultRepoCommitOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *repocommitPager) orderExpr(query *RepoCommitQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultRepoCommitOrder.Field {
			b.Comma().Ident(DefaultRepoCommitOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to RepoCommit.
func (rc *RepoCommitQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RepoCommitPaginateOption,
) (*RepoCommitConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRepoCommitPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if rc, err = pager.applyFilter(rc); err != nil {
		return nil, err
	}
	conn := &RepoCommitConnection{Edges: []*RepoCommitEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = rc.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if rc, err = pager.applyCursors(rc, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		rc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := rc.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	rc = pager.applyOrder(rc)
	nodes, err := rc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// RepoCommitOrderField defines the ordering field of RepoCommit.
type RepoCommitOrderField struct {
	// Value extracts the ordering value from the given RepoCommit.
	Value    func(*RepoCommit) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) repocommit.OrderOption
	toCursor func(*RepoCommit) Cursor
}

// RepoCommitOrder defines the ordering of RepoCommit.
type RepoCommitOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *RepoCommitOrderField `json:"field"`
}

// DefaultRepoCommitOrder is the default ordering of RepoCommit.
var DefaultRepoCommitOrder = &RepoCommitOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RepoCommitOrderField{
		Value: func(rc *RepoCommit) (ent.Value, error) {
			return rc.ID, nil
		},
		column: repocommit.FieldID,
		toTerm: repocommit.ByID,
		toCursor: func(rc *RepoCommit) Cursor {
			return Cursor{ID: rc.ID}
		},
	},
}

// ToEdge converts RepoCommit into RepoCommitEdge.
func (rc *RepoCommit) ToEdge(order *RepoCommitOrder) *RepoCommitEdge {
	if order == nil {
		order = DefaultRepoCommitOrder
	}
	return &RepoCommitEdge{
		Node:   rc,
		Cursor: order.Field.toCursor(rc),
	}
}

// RepositoryEdge is the edge representation of Repository.
type RepositoryEdge struct {
	Node   *Repository `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// RepositoryConnection is the connection containing edges to Repository.
type RepositoryConnection struct {
	Edges      []*RepositoryEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *RepositoryConnection) build(nodes []*Repository, pager *repositoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Repository
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Repository {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Repository {
			return nodes[i]
		}
	}
	c.Edges = make([]*RepositoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &RepositoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// RepositoryPaginateOption enables pagination customization.
type RepositoryPaginateOption func(*repositoryPager) error

// WithRepositoryOrder configures pagination ordering.
func WithRepositoryOrder(order *RepositoryOrder) RepositoryPaginateOption {
	if order == nil {
		order = DefaultRepositoryOrder
	}
	o := *order
	return func(pager *repositoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRepositoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRepositoryFilter configures pagination filter.
func WithRepositoryFilter(filter func(*RepositoryQuery) (*RepositoryQuery, error)) RepositoryPaginateOption {
	return func(pager *repositoryPager) error {
		if filter == nil {
			return errors.New("RepositoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type repositoryPager struct {
	reverse bool
	order   *RepositoryOrder
	filter  func(*RepositoryQuery) (*RepositoryQuery, error)
}

func newRepositoryPager(opts []RepositoryPaginateOption, reverse bool) (*repositoryPager, error) {
	pager := &repositoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRepositoryOrder
	}
	return pager, nil
}

func (p *repositoryPager) applyFilter(query *RepositoryQuery) (*RepositoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *repositoryPager) toCursor(r *Repository) Cursor {
	return p.order.Field.toCursor(r)
}

func (p *repositoryPager) applyCursors(query *RepositoryQuery, after, before *Cursor) (*RepositoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultRepositoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *repositoryPager) applyOrder(query *RepositoryQuery) *RepositoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultRepositoryOrder.Field {
		query = query.Order(DefaultRepositoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *repositoryPager) orderExpr(query *RepositoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultRepositoryOrder.Field {
			b.Comma().Ident(DefaultRepositoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Repository.
func (r *RepositoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RepositoryPaginateOption,
) (*RepositoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRepositoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}
	conn := &RepositoryConnection{Edges: []*RepositoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = r.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if r, err = pager.applyCursors(r, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		r.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := r.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	r = pager.applyOrder(r)
	nodes, err := r.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// RepositoryOrderField defines the ordering field of Repository.
type RepositoryOrderField struct {
	// Value extracts the ordering value from the given Repository.
	Value    func(*Repository) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) repository.OrderOption
	toCursor func(*Repository) Cursor
}

// RepositoryOrder defines the ordering of Repository.
type RepositoryOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *RepositoryOrderField `json:"field"`
}

// DefaultRepositoryOrder is the default ordering of Repository.
var DefaultRepositoryOrder = &RepositoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &RepositoryOrderField{
		Value: func(r *Repository) (ent.Value, error) {
			return r.ID, nil
		},
		column: repository.FieldID,
		toTerm: repository.ByID,
		toCursor: func(r *Repository) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// ToEdge converts Repository into RepositoryEdge.
func (r *Repository) ToEdge(order *RepositoryOrder) *RepositoryEdge {
	if order == nil {
		order = DefaultRepositoryOrder
	}
	return &RepositoryEdge{
		Node:   r,
		Cursor: order.Field.toCursor(r),
	}
}

// ScriptEdge is the edge representation of Script.
type ScriptEdge struct {
	Node   *Script `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// ScriptConnection is the connection containing edges to Script.
type ScriptConnection struct {
	Edges      []*ScriptEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *ScriptConnection) build(nodes []*Script, pager *scriptPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Script
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Script {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Script {
			return nodes[i]
		}
	}
	c.Edges = make([]*ScriptEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ScriptEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ScriptPaginateOption enables pagination customization.
type ScriptPaginateOption func(*scriptPager) error

// WithScriptOrder configures pagination ordering.
func WithScriptOrder(order *ScriptOrder) ScriptPaginateOption {
	if order == nil {
		order = DefaultScriptOrder
	}
	o := *order
	return func(pager *scriptPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultScriptOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithScriptFilter configures pagination filter.
func WithScriptFilter(filter func(*ScriptQuery) (*ScriptQuery, error)) ScriptPaginateOption {
	return func(pager *scriptPager) error {
		if filter == nil {
			return errors.New("ScriptQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type scriptPager struct {
	reverse bool
	order   *ScriptOrder
	filter  func(*ScriptQuery) (*ScriptQuery, error)
}

func newScriptPager(opts []ScriptPaginateOption, reverse bool) (*scriptPager, error) {
	pager := &scriptPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultScriptOrder
	}
	return pager, nil
}

func (p *scriptPager) applyFilter(query *ScriptQuery) (*ScriptQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *scriptPager) toCursor(s *Script) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *scriptPager) applyCursors(query *ScriptQuery, after, before *Cursor) (*ScriptQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultScriptOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *scriptPager) applyOrder(query *ScriptQuery) *ScriptQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultScriptOrder.Field {
		query = query.Order(DefaultScriptOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *scriptPager) orderExpr(query *ScriptQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultScriptOrder.Field {
			b.Comma().Ident(DefaultScriptOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Script.
func (s *ScriptQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ScriptPaginateOption,
) (*ScriptConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newScriptPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &ScriptConnection{Edges: []*ScriptEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = s.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ScriptOrderField defines the ordering field of Script.
type ScriptOrderField struct {
	// Value extracts the ordering value from the given Script.
	Value    func(*Script) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) script.OrderOption
	toCursor func(*Script) Cursor
}

// ScriptOrder defines the ordering of Script.
type ScriptOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *ScriptOrderField `json:"field"`
}

// DefaultScriptOrder is the default ordering of Script.
var DefaultScriptOrder = &ScriptOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ScriptOrderField{
		Value: func(s *Script) (ent.Value, error) {
			return s.ID, nil
		},
		column: script.FieldID,
		toTerm: script.ByID,
		toCursor: func(s *Script) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Script into ScriptEdge.
func (s *Script) ToEdge(order *ScriptOrder) *ScriptEdge {
	if order == nil {
		order = DefaultScriptOrder
	}
	return &ScriptEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// ServerTaskEdge is the edge representation of ServerTask.
type ServerTaskEdge struct {
	Node   *ServerTask `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// ServerTaskConnection is the connection containing edges to ServerTask.
type ServerTaskConnection struct {
	Edges      []*ServerTaskEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *ServerTaskConnection) build(nodes []*ServerTask, pager *servertaskPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ServerTask
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ServerTask {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ServerTask {
			return nodes[i]
		}
	}
	c.Edges = make([]*ServerTaskEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ServerTaskEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ServerTaskPaginateOption enables pagination customization.
type ServerTaskPaginateOption func(*servertaskPager) error

// WithServerTaskOrder configures pagination ordering.
func WithServerTaskOrder(order *ServerTaskOrder) ServerTaskPaginateOption {
	if order == nil {
		order = DefaultServerTaskOrder
	}
	o := *order
	return func(pager *servertaskPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultServerTaskOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithServerTaskFilter configures pagination filter.
func WithServerTaskFilter(filter func(*ServerTaskQuery) (*ServerTaskQuery, error)) ServerTaskPaginateOption {
	return func(pager *servertaskPager) error {
		if filter == nil {
			return errors.New("ServerTaskQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type servertaskPager struct {
	reverse bool
	order   *ServerTaskOrder
	filter  func(*ServerTaskQuery) (*ServerTaskQuery, error)
}

func newServerTaskPager(opts []ServerTaskPaginateOption, reverse bool) (*servertaskPager, error) {
	pager := &servertaskPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultServerTaskOrder
	}
	return pager, nil
}

func (p *servertaskPager) applyFilter(query *ServerTaskQuery) (*ServerTaskQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *servertaskPager) toCursor(st *ServerTask) Cursor {
	return p.order.Field.toCursor(st)
}

func (p *servertaskPager) applyCursors(query *ServerTaskQuery, after, before *Cursor) (*ServerTaskQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultServerTaskOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *servertaskPager) applyOrder(query *ServerTaskQuery) *ServerTaskQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultServerTaskOrder.Field {
		query = query.Order(DefaultServerTaskOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *servertaskPager) orderExpr(query *ServerTaskQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultServerTaskOrder.Field {
			b.Comma().Ident(DefaultServerTaskOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ServerTask.
func (st *ServerTaskQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ServerTaskPaginateOption,
) (*ServerTaskConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newServerTaskPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if st, err = pager.applyFilter(st); err != nil {
		return nil, err
	}
	conn := &ServerTaskConnection{Edges: []*ServerTaskEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = st.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if st, err = pager.applyCursors(st, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		st.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := st.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	st = pager.applyOrder(st)
	nodes, err := st.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ServerTaskOrderField defines the ordering field of ServerTask.
type ServerTaskOrderField struct {
	// Value extracts the ordering value from the given ServerTask.
	Value    func(*ServerTask) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) servertask.OrderOption
	toCursor func(*ServerTask) Cursor
}

// ServerTaskOrder defines the ordering of ServerTask.
type ServerTaskOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *ServerTaskOrderField `json:"field"`
}

// DefaultServerTaskOrder is the default ordering of ServerTask.
var DefaultServerTaskOrder = &ServerTaskOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ServerTaskOrderField{
		Value: func(st *ServerTask) (ent.Value, error) {
			return st.ID, nil
		},
		column: servertask.FieldID,
		toTerm: servertask.ByID,
		toCursor: func(st *ServerTask) Cursor {
			return Cursor{ID: st.ID}
		},
	},
}

// ToEdge converts ServerTask into ServerTaskEdge.
func (st *ServerTask) ToEdge(order *ServerTaskOrder) *ServerTaskEdge {
	if order == nil {
		order = DefaultServerTaskOrder
	}
	return &ServerTaskEdge{
		Node:   st,
		Cursor: order.Field.toCursor(st),
	}
}

// StatusEdge is the edge representation of Status.
type StatusEdge struct {
	Node   *Status `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// StatusConnection is the connection containing edges to Status.
type StatusConnection struct {
	Edges      []*StatusEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *StatusConnection) build(nodes []*Status, pager *statusPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Status
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Status {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Status {
			return nodes[i]
		}
	}
	c.Edges = make([]*StatusEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &StatusEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// StatusPaginateOption enables pagination customization.
type StatusPaginateOption func(*statusPager) error

// WithStatusOrder configures pagination ordering.
func WithStatusOrder(order *StatusOrder) StatusPaginateOption {
	if order == nil {
		order = DefaultStatusOrder
	}
	o := *order
	return func(pager *statusPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultStatusOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithStatusFilter configures pagination filter.
func WithStatusFilter(filter func(*StatusQuery) (*StatusQuery, error)) StatusPaginateOption {
	return func(pager *statusPager) error {
		if filter == nil {
			return errors.New("StatusQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type statusPager struct {
	reverse bool
	order   *StatusOrder
	filter  func(*StatusQuery) (*StatusQuery, error)
}

func newStatusPager(opts []StatusPaginateOption, reverse bool) (*statusPager, error) {
	pager := &statusPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultStatusOrder
	}
	return pager, nil
}

func (p *statusPager) applyFilter(query *StatusQuery) (*StatusQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *statusPager) toCursor(s *Status) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *statusPager) applyCursors(query *StatusQuery, after, before *Cursor) (*StatusQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultStatusOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *statusPager) applyOrder(query *StatusQuery) *StatusQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultStatusOrder.Field {
		query = query.Order(DefaultStatusOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *statusPager) orderExpr(query *StatusQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultStatusOrder.Field {
			b.Comma().Ident(DefaultStatusOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Status.
func (s *StatusQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...StatusPaginateOption,
) (*StatusConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newStatusPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &StatusConnection{Edges: []*StatusEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = s.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// StatusOrderField defines the ordering field of Status.
type StatusOrderField struct {
	// Value extracts the ordering value from the given Status.
	Value    func(*Status) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) status.OrderOption
	toCursor func(*Status) Cursor
}

// StatusOrder defines the ordering of Status.
type StatusOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *StatusOrderField `json:"field"`
}

// DefaultStatusOrder is the default ordering of Status.
var DefaultStatusOrder = &StatusOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &StatusOrderField{
		Value: func(s *Status) (ent.Value, error) {
			return s.ID, nil
		},
		column: status.FieldID,
		toTerm: status.ByID,
		toCursor: func(s *Status) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Status into StatusEdge.
func (s *Status) ToEdge(order *StatusOrder) *StatusEdge {
	if order == nil {
		order = DefaultStatusOrder
	}
	return &StatusEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// TagEdge is the edge representation of Tag.
type TagEdge struct {
	Node   *Tag   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TagConnection is the connection containing edges to Tag.
type TagConnection struct {
	Edges      []*TagEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

func (c *TagConnection) build(nodes []*Tag, pager *tagPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Tag
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Tag {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Tag {
			return nodes[i]
		}
	}
	c.Edges = make([]*TagEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TagEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TagPaginateOption enables pagination customization.
type TagPaginateOption func(*tagPager) error

// WithTagOrder configures pagination ordering.
func WithTagOrder(order *TagOrder) TagPaginateOption {
	if order == nil {
		order = DefaultTagOrder
	}
	o := *order
	return func(pager *tagPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTagOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTagFilter configures pagination filter.
func WithTagFilter(filter func(*TagQuery) (*TagQuery, error)) TagPaginateOption {
	return func(pager *tagPager) error {
		if filter == nil {
			return errors.New("TagQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type tagPager struct {
	reverse bool
	order   *TagOrder
	filter  func(*TagQuery) (*TagQuery, error)
}

func newTagPager(opts []TagPaginateOption, reverse bool) (*tagPager, error) {
	pager := &tagPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTagOrder
	}
	return pager, nil
}

func (p *tagPager) applyFilter(query *TagQuery) (*TagQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *tagPager) toCursor(t *Tag) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *tagPager) applyCursors(query *TagQuery, after, before *Cursor) (*TagQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTagOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *tagPager) applyOrder(query *TagQuery) *TagQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTagOrder.Field {
		query = query.Order(DefaultTagOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *tagPager) orderExpr(query *TagQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTagOrder.Field {
			b.Comma().Ident(DefaultTagOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Tag.
func (t *TagQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TagPaginateOption,
) (*TagConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTagPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TagConnection{Edges: []*TagEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = t.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if t, err = pager.applyCursors(t, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	t = pager.applyOrder(t)
	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// TagOrderField defines the ordering field of Tag.
type TagOrderField struct {
	// Value extracts the ordering value from the given Tag.
	Value    func(*Tag) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) tag.OrderOption
	toCursor func(*Tag) Cursor
}

// TagOrder defines the ordering of Tag.
type TagOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *TagOrderField `json:"field"`
}

// DefaultTagOrder is the default ordering of Tag.
var DefaultTagOrder = &TagOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TagOrderField{
		Value: func(t *Tag) (ent.Value, error) {
			return t.ID, nil
		},
		column: tag.FieldID,
		toTerm: tag.ByID,
		toCursor: func(t *Tag) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Tag into TagEdge.
func (t *Tag) ToEdge(order *TagOrder) *TagEdge {
	if order == nil {
		order = DefaultTagOrder
	}
	return &TagEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// TeamEdge is the edge representation of Team.
type TeamEdge struct {
	Node   *Team  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TeamConnection is the connection containing edges to Team.
type TeamConnection struct {
	Edges      []*TeamEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *TeamConnection) build(nodes []*Team, pager *teamPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Team
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Team {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Team {
			return nodes[i]
		}
	}
	c.Edges = make([]*TeamEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TeamEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TeamPaginateOption enables pagination customization.
type TeamPaginateOption func(*teamPager) error

// WithTeamOrder configures pagination ordering.
func WithTeamOrder(order *TeamOrder) TeamPaginateOption {
	if order == nil {
		order = DefaultTeamOrder
	}
	o := *order
	return func(pager *teamPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTeamOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTeamFilter configures pagination filter.
func WithTeamFilter(filter func(*TeamQuery) (*TeamQuery, error)) TeamPaginateOption {
	return func(pager *teamPager) error {
		if filter == nil {
			return errors.New("TeamQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type teamPager struct {
	reverse bool
	order   *TeamOrder
	filter  func(*TeamQuery) (*TeamQuery, error)
}

func newTeamPager(opts []TeamPaginateOption, reverse bool) (*teamPager, error) {
	pager := &teamPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTeamOrder
	}
	return pager, nil
}

func (p *teamPager) applyFilter(query *TeamQuery) (*TeamQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *teamPager) toCursor(t *Team) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *teamPager) applyCursors(query *TeamQuery, after, before *Cursor) (*TeamQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTeamOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *teamPager) applyOrder(query *TeamQuery) *TeamQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTeamOrder.Field {
		query = query.Order(DefaultTeamOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *teamPager) orderExpr(query *TeamQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTeamOrder.Field {
			b.Comma().Ident(DefaultTeamOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Team.
func (t *TeamQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TeamPaginateOption,
) (*TeamConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTeamPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TeamConnection{Edges: []*TeamEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = t.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if t, err = pager.applyCursors(t, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	t = pager.applyOrder(t)
	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// TeamOrderField defines the ordering field of Team.
type TeamOrderField struct {
	// Value extracts the ordering value from the given Team.
	Value    func(*Team) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) team.OrderOption
	toCursor func(*Team) Cursor
}

// TeamOrder defines the ordering of Team.
type TeamOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *TeamOrderField `json:"field"`
}

// DefaultTeamOrder is the default ordering of Team.
var DefaultTeamOrder = &TeamOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TeamOrderField{
		Value: func(t *Team) (ent.Value, error) {
			return t.ID, nil
		},
		column: team.FieldID,
		toTerm: team.ByID,
		toCursor: func(t *Team) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Team into TeamEdge.
func (t *Team) ToEdge(order *TeamOrder) *TeamEdge {
	if order == nil {
		order = DefaultTeamOrder
	}
	return &TeamEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// TokenEdge is the edge representation of Token.
type TokenEdge struct {
	Node   *Token `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TokenConnection is the connection containing edges to Token.
type TokenConnection struct {
	Edges      []*TokenEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *TokenConnection) build(nodes []*Token, pager *tokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Token
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Token {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Token {
			return nodes[i]
		}
	}
	c.Edges = make([]*TokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TokenPaginateOption enables pagination customization.
type TokenPaginateOption func(*tokenPager) error

// WithTokenOrder configures pagination ordering.
func WithTokenOrder(order *TokenOrder) TokenPaginateOption {
	if order == nil {
		order = DefaultTokenOrder
	}
	o := *order
	return func(pager *tokenPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTokenOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTokenFilter configures pagination filter.
func WithTokenFilter(filter func(*TokenQuery) (*TokenQuery, error)) TokenPaginateOption {
	return func(pager *tokenPager) error {
		if filter == nil {
			return errors.New("TokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type tokenPager struct {
	reverse bool
	order   *TokenOrder
	filter  func(*TokenQuery) (*TokenQuery, error)
}

func newTokenPager(opts []TokenPaginateOption, reverse bool) (*tokenPager, error) {
	pager := &tokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTokenOrder
	}
	return pager, nil
}

func (p *tokenPager) applyFilter(query *TokenQuery) (*TokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *tokenPager) toCursor(t *Token) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *tokenPager) applyCursors(query *TokenQuery, after, before *Cursor) (*TokenQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTokenOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *tokenPager) applyOrder(query *TokenQuery) *TokenQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTokenOrder.Field {
		query = query.Order(DefaultTokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *tokenPager) orderExpr(query *TokenQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTokenOrder.Field {
			b.Comma().Ident(DefaultTokenOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Token.
func (t *TokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TokenPaginateOption,
) (*TokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TokenConnection{Edges: []*TokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = t.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if t, err = pager.applyCursors(t, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	t = pager.applyOrder(t)
	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// TokenOrderField defines the ordering field of Token.
type TokenOrderField struct {
	// Value extracts the ordering value from the given Token.
	Value    func(*Token) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) token.OrderOption
	toCursor func(*Token) Cursor
}

// TokenOrder defines the ordering of Token.
type TokenOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *TokenOrderField `json:"field"`
}

// DefaultTokenOrder is the default ordering of Token.
var DefaultTokenOrder = &TokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TokenOrderField{
		Value: func(t *Token) (ent.Value, error) {
			return t.ID, nil
		},
		column: token.FieldID,
		toTerm: token.ByID,
		toCursor: func(t *Token) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Token into TokenEdge.
func (t *Token) ToEdge(order *TokenOrder) *TokenEdge {
	if order == nil {
		order = DefaultTokenOrder
	}
	return &TokenEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	reverse bool
	order   *UserOrder
	filter  func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption, reverse bool) (*userPager, error) {
	pager := &userPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) (*UserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userPager) applyOrder(query *UserQuery) *UserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(DefaultUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userPager) orderExpr(query *UserQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserOrder.Field {
			b.Comma().Ident(DefaultUserOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = u.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if u, err = pager.applyCursors(u, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	u = pager.applyOrder(u)
	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	// Value extracts the ordering value from the given User.
	Value    func(*User) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) user.OrderOption
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.ID, nil
		},
		column: user.FieldID,
		toTerm: user.ByID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}
