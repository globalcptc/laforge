// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/gen0cide/laforge/ent/adhocplan"
	"github.com/gen0cide/laforge/ent/agentstatus"
	"github.com/gen0cide/laforge/ent/agenttask"
	"github.com/gen0cide/laforge/ent/ansible"
	"github.com/gen0cide/laforge/ent/authuser"
	"github.com/gen0cide/laforge/ent/build"
	"github.com/gen0cide/laforge/ent/buildcommit"
	"github.com/gen0cide/laforge/ent/command"
	"github.com/gen0cide/laforge/ent/competition"
	"github.com/gen0cide/laforge/ent/disk"
	"github.com/gen0cide/laforge/ent/dns"
	"github.com/gen0cide/laforge/ent/dnsrecord"
	"github.com/gen0cide/laforge/ent/environment"
	"github.com/gen0cide/laforge/ent/filedelete"
	"github.com/gen0cide/laforge/ent/filedownload"
	"github.com/gen0cide/laforge/ent/fileextract"
	"github.com/gen0cide/laforge/ent/finding"
	"github.com/gen0cide/laforge/ent/ginfilemiddleware"
	"github.com/gen0cide/laforge/ent/host"
	"github.com/gen0cide/laforge/ent/hostdependency"
	"github.com/gen0cide/laforge/ent/identity"
	"github.com/gen0cide/laforge/ent/includednetwork"
	"github.com/gen0cide/laforge/ent/network"
	"github.com/gen0cide/laforge/ent/plan"
	"github.com/gen0cide/laforge/ent/plandiff"
	"github.com/gen0cide/laforge/ent/provisionedhost"
	"github.com/gen0cide/laforge/ent/provisionednetwork"
	"github.com/gen0cide/laforge/ent/provisioningscheduledstep"
	"github.com/gen0cide/laforge/ent/provisioningstep"
	"github.com/gen0cide/laforge/ent/repocommit"
	"github.com/gen0cide/laforge/ent/repository"
	"github.com/gen0cide/laforge/ent/scheduledstep"
	"github.com/gen0cide/laforge/ent/script"
	"github.com/gen0cide/laforge/ent/servertask"
	"github.com/gen0cide/laforge/ent/status"
	"github.com/gen0cide/laforge/ent/tag"
	"github.com/gen0cide/laforge/ent/team"
	"github.com/gen0cide/laforge/ent/token"
	"github.com/gen0cide/laforge/ent/user"
	"github.com/google/uuid"
	"github.com/hashicorp/go-multierror"
)

// Noder wraps the basic Node method.
type Noder interface {
	IsNode()
}

// IsNode implements the Node interface check for GQLGen.
func (n *AdhocPlan) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *AgentStatus) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *AgentTask) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *Ansible) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *AuthUser) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *Build) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *BuildCommit) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *Command) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *Competition) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *DNS) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *DNSRecord) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *Disk) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *Environment) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *FileDelete) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *FileDownload) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *FileExtract) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *Finding) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *GinFileMiddleware) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *Host) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *HostDependency) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *Identity) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *IncludedNetwork) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *Network) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *Plan) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *PlanDiff) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *ProvisionedHost) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *ProvisionedNetwork) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *ProvisioningScheduledStep) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *ProvisioningStep) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *RepoCommit) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *Repository) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *ScheduledStep) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *Script) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *ServerTask) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *Status) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *Tag) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *Team) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *Token) IsNode() {}

// IsNode implements the Node interface check for GQLGen.
func (n *User) IsNode() {}

var errNodeInvalidID = &NotFoundError{"node"}

// NodeOption allows configuring the Noder execution using functional options.
type NodeOption func(*nodeOptions)

// WithNodeType sets the node Type resolver function (i.e. the table to query).
// If was not provided, the table will be derived from the universal-id
// configuration as described in: https://entgo.io/docs/migrate/#universal-ids.
func WithNodeType(f func(context.Context, uuid.UUID) (string, error)) NodeOption {
	return func(o *nodeOptions) {
		o.nodeType = f
	}
}

// WithFixedNodeType sets the Type of the node to a fixed value.
func WithFixedNodeType(t string) NodeOption {
	return WithNodeType(func(context.Context, uuid.UUID) (string, error) {
		return t, nil
	})
}

type nodeOptions struct {
	nodeType func(context.Context, uuid.UUID) (string, error)
}

func (c *Client) newNodeOpts(opts []NodeOption) *nodeOptions {
	nopts := &nodeOptions{}
	for _, opt := range opts {
		opt(nopts)
	}
	if nopts.nodeType == nil {
		nopts.nodeType = func(ctx context.Context, id uuid.UUID) (string, error) {
			return "", fmt.Errorf("cannot resolve noder (%v) without its type", id)
		}
	}
	return nopts
}

// Noder returns a Node by its id. If the NodeType was not provided, it will
// be derived from the id value according to the universal-id configuration.
//
//	c.Noder(ctx, id)
//	c.Noder(ctx, id, ent.WithNodeType(typeResolver))
func (c *Client) Noder(ctx context.Context, id uuid.UUID, opts ...NodeOption) (_ Noder, err error) {
	defer func() {
		if IsNotFound(err) {
			err = multierror.Append(err, entgql.ErrNodeNotFound(id))
		}
	}()
	table, err := c.newNodeOpts(opts).nodeType(ctx, id)
	if err != nil {
		return nil, err
	}
	return c.noder(ctx, table, id)
}

func (c *Client) noder(ctx context.Context, table string, id uuid.UUID) (Noder, error) {
	switch table {
	case adhocplan.Table:
		query := c.AdhocPlan.Query().
			Where(adhocplan.ID(id))
		query, err := query.CollectFields(ctx, "AdhocPlan")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case agentstatus.Table:
		query := c.AgentStatus.Query().
			Where(agentstatus.ID(id))
		query, err := query.CollectFields(ctx, "AgentStatus")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case agenttask.Table:
		query := c.AgentTask.Query().
			Where(agenttask.ID(id))
		query, err := query.CollectFields(ctx, "AgentTask")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case ansible.Table:
		query := c.Ansible.Query().
			Where(ansible.ID(id))
		query, err := query.CollectFields(ctx, "Ansible")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case authuser.Table:
		query := c.AuthUser.Query().
			Where(authuser.ID(id))
		query, err := query.CollectFields(ctx, "AuthUser")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case build.Table:
		query := c.Build.Query().
			Where(build.ID(id))
		query, err := query.CollectFields(ctx, "Build")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case buildcommit.Table:
		query := c.BuildCommit.Query().
			Where(buildcommit.ID(id))
		query, err := query.CollectFields(ctx, "BuildCommit")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case command.Table:
		query := c.Command.Query().
			Where(command.ID(id))
		query, err := query.CollectFields(ctx, "Command")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case competition.Table:
		query := c.Competition.Query().
			Where(competition.ID(id))
		query, err := query.CollectFields(ctx, "Competition")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case dns.Table:
		query := c.DNS.Query().
			Where(dns.ID(id))
		query, err := query.CollectFields(ctx, "DNS")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case dnsrecord.Table:
		query := c.DNSRecord.Query().
			Where(dnsrecord.ID(id))
		query, err := query.CollectFields(ctx, "DNSRecord")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case disk.Table:
		query := c.Disk.Query().
			Where(disk.ID(id))
		query, err := query.CollectFields(ctx, "Disk")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case environment.Table:
		query := c.Environment.Query().
			Where(environment.ID(id))
		query, err := query.CollectFields(ctx, "Environment")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case filedelete.Table:
		query := c.FileDelete.Query().
			Where(filedelete.ID(id))
		query, err := query.CollectFields(ctx, "FileDelete")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case filedownload.Table:
		query := c.FileDownload.Query().
			Where(filedownload.ID(id))
		query, err := query.CollectFields(ctx, "FileDownload")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case fileextract.Table:
		query := c.FileExtract.Query().
			Where(fileextract.ID(id))
		query, err := query.CollectFields(ctx, "FileExtract")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case finding.Table:
		query := c.Finding.Query().
			Where(finding.ID(id))
		query, err := query.CollectFields(ctx, "Finding")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case ginfilemiddleware.Table:
		query := c.GinFileMiddleware.Query().
			Where(ginfilemiddleware.ID(id))
		query, err := query.CollectFields(ctx, "GinFileMiddleware")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case host.Table:
		query := c.Host.Query().
			Where(host.ID(id))
		query, err := query.CollectFields(ctx, "Host")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case hostdependency.Table:
		query := c.HostDependency.Query().
			Where(hostdependency.ID(id))
		query, err := query.CollectFields(ctx, "HostDependency")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case identity.Table:
		query := c.Identity.Query().
			Where(identity.ID(id))
		query, err := query.CollectFields(ctx, "Identity")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case includednetwork.Table:
		query := c.IncludedNetwork.Query().
			Where(includednetwork.ID(id))
		query, err := query.CollectFields(ctx, "IncludedNetwork")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case network.Table:
		query := c.Network.Query().
			Where(network.ID(id))
		query, err := query.CollectFields(ctx, "Network")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case plan.Table:
		query := c.Plan.Query().
			Where(plan.ID(id))
		query, err := query.CollectFields(ctx, "Plan")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case plandiff.Table:
		query := c.PlanDiff.Query().
			Where(plandiff.ID(id))
		query, err := query.CollectFields(ctx, "PlanDiff")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case provisionedhost.Table:
		query := c.ProvisionedHost.Query().
			Where(provisionedhost.ID(id))
		query, err := query.CollectFields(ctx, "ProvisionedHost")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case provisionednetwork.Table:
		query := c.ProvisionedNetwork.Query().
			Where(provisionednetwork.ID(id))
		query, err := query.CollectFields(ctx, "ProvisionedNetwork")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case provisioningscheduledstep.Table:
		query := c.ProvisioningScheduledStep.Query().
			Where(provisioningscheduledstep.ID(id))
		query, err := query.CollectFields(ctx, "ProvisioningScheduledStep")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case provisioningstep.Table:
		query := c.ProvisioningStep.Query().
			Where(provisioningstep.ID(id))
		query, err := query.CollectFields(ctx, "ProvisioningStep")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case repocommit.Table:
		query := c.RepoCommit.Query().
			Where(repocommit.ID(id))
		query, err := query.CollectFields(ctx, "RepoCommit")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case repository.Table:
		query := c.Repository.Query().
			Where(repository.ID(id))
		query, err := query.CollectFields(ctx, "Repository")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case scheduledstep.Table:
		query := c.ScheduledStep.Query().
			Where(scheduledstep.ID(id))
		query, err := query.CollectFields(ctx, "ScheduledStep")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case script.Table:
		query := c.Script.Query().
			Where(script.ID(id))
		query, err := query.CollectFields(ctx, "Script")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case servertask.Table:
		query := c.ServerTask.Query().
			Where(servertask.ID(id))
		query, err := query.CollectFields(ctx, "ServerTask")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case status.Table:
		query := c.Status.Query().
			Where(status.ID(id))
		query, err := query.CollectFields(ctx, "Status")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case tag.Table:
		query := c.Tag.Query().
			Where(tag.ID(id))
		query, err := query.CollectFields(ctx, "Tag")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case team.Table:
		query := c.Team.Query().
			Where(team.ID(id))
		query, err := query.CollectFields(ctx, "Team")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case token.Table:
		query := c.Token.Query().
			Where(token.ID(id))
		query, err := query.CollectFields(ctx, "Token")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	case user.Table:
		query := c.User.Query().
			Where(user.ID(id))
		query, err := query.CollectFields(ctx, "User")
		if err != nil {
			return nil, err
		}
		n, err := query.Only(ctx)
		if err != nil {
			return nil, err
		}
		return n, nil
	default:
		return nil, fmt.Errorf("cannot resolve noder from table %q: %w", table, errNodeInvalidID)
	}
}

func (c *Client) Noders(ctx context.Context, ids []uuid.UUID, opts ...NodeOption) ([]Noder, error) {
	switch len(ids) {
	case 1:
		noder, err := c.Noder(ctx, ids[0], opts...)
		if err != nil {
			return nil, err
		}
		return []Noder{noder}, nil
	case 0:
		return []Noder{}, nil
	}

	noders := make([]Noder, len(ids))
	errors := make([]error, len(ids))
	tables := make(map[string][]uuid.UUID)
	id2idx := make(map[uuid.UUID][]int, len(ids))
	nopts := c.newNodeOpts(opts)
	for i, id := range ids {
		table, err := nopts.nodeType(ctx, id)
		if err != nil {
			errors[i] = err
			continue
		}
		tables[table] = append(tables[table], id)
		id2idx[id] = append(id2idx[id], i)
	}

	for table, ids := range tables {
		nodes, err := c.noders(ctx, table, ids)
		if err != nil {
			for _, id := range ids {
				for _, idx := range id2idx[id] {
					errors[idx] = err
				}
			}
		} else {
			for i, id := range ids {
				for _, idx := range id2idx[id] {
					noders[idx] = nodes[i]
				}
			}
		}
	}

	for i, id := range ids {
		if errors[i] == nil {
			if noders[i] != nil {
				continue
			}
			errors[i] = entgql.ErrNodeNotFound(id)
		} else if IsNotFound(errors[i]) {
			errors[i] = multierror.Append(errors[i], entgql.ErrNodeNotFound(id))
		}
		ctx := graphql.WithPathContext(ctx,
			graphql.NewPathWithIndex(i),
		)
		graphql.AddError(ctx, errors[i])
	}
	return noders, nil
}

func (c *Client) noders(ctx context.Context, table string, ids []uuid.UUID) ([]Noder, error) {
	noders := make([]Noder, len(ids))
	idmap := make(map[uuid.UUID][]*Noder, len(ids))
	for i, id := range ids {
		idmap[id] = append(idmap[id], &noders[i])
	}
	switch table {
	case adhocplan.Table:
		query := c.AdhocPlan.Query().
			Where(adhocplan.IDIn(ids...))
		query, err := query.CollectFields(ctx, "AdhocPlan")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case agentstatus.Table:
		query := c.AgentStatus.Query().
			Where(agentstatus.IDIn(ids...))
		query, err := query.CollectFields(ctx, "AgentStatus")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case agenttask.Table:
		query := c.AgentTask.Query().
			Where(agenttask.IDIn(ids...))
		query, err := query.CollectFields(ctx, "AgentTask")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case ansible.Table:
		query := c.Ansible.Query().
			Where(ansible.IDIn(ids...))
		query, err := query.CollectFields(ctx, "Ansible")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case authuser.Table:
		query := c.AuthUser.Query().
			Where(authuser.IDIn(ids...))
		query, err := query.CollectFields(ctx, "AuthUser")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case build.Table:
		query := c.Build.Query().
			Where(build.IDIn(ids...))
		query, err := query.CollectFields(ctx, "Build")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case buildcommit.Table:
		query := c.BuildCommit.Query().
			Where(buildcommit.IDIn(ids...))
		query, err := query.CollectFields(ctx, "BuildCommit")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case command.Table:
		query := c.Command.Query().
			Where(command.IDIn(ids...))
		query, err := query.CollectFields(ctx, "Command")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case competition.Table:
		query := c.Competition.Query().
			Where(competition.IDIn(ids...))
		query, err := query.CollectFields(ctx, "Competition")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case dns.Table:
		query := c.DNS.Query().
			Where(dns.IDIn(ids...))
		query, err := query.CollectFields(ctx, "DNS")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case dnsrecord.Table:
		query := c.DNSRecord.Query().
			Where(dnsrecord.IDIn(ids...))
		query, err := query.CollectFields(ctx, "DNSRecord")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case disk.Table:
		query := c.Disk.Query().
			Where(disk.IDIn(ids...))
		query, err := query.CollectFields(ctx, "Disk")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case environment.Table:
		query := c.Environment.Query().
			Where(environment.IDIn(ids...))
		query, err := query.CollectFields(ctx, "Environment")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case filedelete.Table:
		query := c.FileDelete.Query().
			Where(filedelete.IDIn(ids...))
		query, err := query.CollectFields(ctx, "FileDelete")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case filedownload.Table:
		query := c.FileDownload.Query().
			Where(filedownload.IDIn(ids...))
		query, err := query.CollectFields(ctx, "FileDownload")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case fileextract.Table:
		query := c.FileExtract.Query().
			Where(fileextract.IDIn(ids...))
		query, err := query.CollectFields(ctx, "FileExtract")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case finding.Table:
		query := c.Finding.Query().
			Where(finding.IDIn(ids...))
		query, err := query.CollectFields(ctx, "Finding")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case ginfilemiddleware.Table:
		query := c.GinFileMiddleware.Query().
			Where(ginfilemiddleware.IDIn(ids...))
		query, err := query.CollectFields(ctx, "GinFileMiddleware")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case host.Table:
		query := c.Host.Query().
			Where(host.IDIn(ids...))
		query, err := query.CollectFields(ctx, "Host")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case hostdependency.Table:
		query := c.HostDependency.Query().
			Where(hostdependency.IDIn(ids...))
		query, err := query.CollectFields(ctx, "HostDependency")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case identity.Table:
		query := c.Identity.Query().
			Where(identity.IDIn(ids...))
		query, err := query.CollectFields(ctx, "Identity")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case includednetwork.Table:
		query := c.IncludedNetwork.Query().
			Where(includednetwork.IDIn(ids...))
		query, err := query.CollectFields(ctx, "IncludedNetwork")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case network.Table:
		query := c.Network.Query().
			Where(network.IDIn(ids...))
		query, err := query.CollectFields(ctx, "Network")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case plan.Table:
		query := c.Plan.Query().
			Where(plan.IDIn(ids...))
		query, err := query.CollectFields(ctx, "Plan")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case plandiff.Table:
		query := c.PlanDiff.Query().
			Where(plandiff.IDIn(ids...))
		query, err := query.CollectFields(ctx, "PlanDiff")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case provisionedhost.Table:
		query := c.ProvisionedHost.Query().
			Where(provisionedhost.IDIn(ids...))
		query, err := query.CollectFields(ctx, "ProvisionedHost")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case provisionednetwork.Table:
		query := c.ProvisionedNetwork.Query().
			Where(provisionednetwork.IDIn(ids...))
		query, err := query.CollectFields(ctx, "ProvisionedNetwork")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case provisioningscheduledstep.Table:
		query := c.ProvisioningScheduledStep.Query().
			Where(provisioningscheduledstep.IDIn(ids...))
		query, err := query.CollectFields(ctx, "ProvisioningScheduledStep")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case provisioningstep.Table:
		query := c.ProvisioningStep.Query().
			Where(provisioningstep.IDIn(ids...))
		query, err := query.CollectFields(ctx, "ProvisioningStep")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case repocommit.Table:
		query := c.RepoCommit.Query().
			Where(repocommit.IDIn(ids...))
		query, err := query.CollectFields(ctx, "RepoCommit")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case repository.Table:
		query := c.Repository.Query().
			Where(repository.IDIn(ids...))
		query, err := query.CollectFields(ctx, "Repository")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case scheduledstep.Table:
		query := c.ScheduledStep.Query().
			Where(scheduledstep.IDIn(ids...))
		query, err := query.CollectFields(ctx, "ScheduledStep")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case script.Table:
		query := c.Script.Query().
			Where(script.IDIn(ids...))
		query, err := query.CollectFields(ctx, "Script")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case servertask.Table:
		query := c.ServerTask.Query().
			Where(servertask.IDIn(ids...))
		query, err := query.CollectFields(ctx, "ServerTask")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case status.Table:
		query := c.Status.Query().
			Where(status.IDIn(ids...))
		query, err := query.CollectFields(ctx, "Status")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case tag.Table:
		query := c.Tag.Query().
			Where(tag.IDIn(ids...))
		query, err := query.CollectFields(ctx, "Tag")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case team.Table:
		query := c.Team.Query().
			Where(team.IDIn(ids...))
		query, err := query.CollectFields(ctx, "Team")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case token.Table:
		query := c.Token.Query().
			Where(token.IDIn(ids...))
		query, err := query.CollectFields(ctx, "Token")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	case user.Table:
		query := c.User.Query().
			Where(user.IDIn(ids...))
		query, err := query.CollectFields(ctx, "User")
		if err != nil {
			return nil, err
		}
		nodes, err := query.All(ctx)
		if err != nil {
			return nil, err
		}
		for _, node := range nodes {
			for _, noder := range idmap[node.ID] {
				*noder = node
			}
		}
	default:
		return nil, fmt.Errorf("cannot resolve noders from table %q: %w", table, errNodeInvalidID)
	}
	return noders, nil
}
