// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/gen0cide/laforge/ent/migrate"
	"github.com/google/uuid"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/gen0cide/laforge/ent/adhocplan"
	"github.com/gen0cide/laforge/ent/agentstatus"
	"github.com/gen0cide/laforge/ent/agenttask"
	"github.com/gen0cide/laforge/ent/ansible"
	"github.com/gen0cide/laforge/ent/authuser"
	"github.com/gen0cide/laforge/ent/build"
	"github.com/gen0cide/laforge/ent/buildcommit"
	"github.com/gen0cide/laforge/ent/command"
	"github.com/gen0cide/laforge/ent/competition"
	"github.com/gen0cide/laforge/ent/disk"
	"github.com/gen0cide/laforge/ent/dns"
	"github.com/gen0cide/laforge/ent/dnsrecord"
	"github.com/gen0cide/laforge/ent/environment"
	"github.com/gen0cide/laforge/ent/filedelete"
	"github.com/gen0cide/laforge/ent/filedownload"
	"github.com/gen0cide/laforge/ent/fileextract"
	"github.com/gen0cide/laforge/ent/finding"
	"github.com/gen0cide/laforge/ent/ginfilemiddleware"
	"github.com/gen0cide/laforge/ent/host"
	"github.com/gen0cide/laforge/ent/hostdependency"
	"github.com/gen0cide/laforge/ent/identity"
	"github.com/gen0cide/laforge/ent/includednetwork"
	"github.com/gen0cide/laforge/ent/network"
	"github.com/gen0cide/laforge/ent/plan"
	"github.com/gen0cide/laforge/ent/plandiff"
	"github.com/gen0cide/laforge/ent/provisionedhost"
	"github.com/gen0cide/laforge/ent/provisionednetwork"
	"github.com/gen0cide/laforge/ent/provisioningstep"
	"github.com/gen0cide/laforge/ent/repocommit"
	"github.com/gen0cide/laforge/ent/repository"
	"github.com/gen0cide/laforge/ent/script"
	"github.com/gen0cide/laforge/ent/servertask"
	"github.com/gen0cide/laforge/ent/status"
	"github.com/gen0cide/laforge/ent/tag"
	"github.com/gen0cide/laforge/ent/team"
	"github.com/gen0cide/laforge/ent/token"
	"github.com/gen0cide/laforge/ent/user"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AdhocPlan is the client for interacting with the AdhocPlan builders.
	AdhocPlan *AdhocPlanClient
	// AgentStatus is the client for interacting with the AgentStatus builders.
	AgentStatus *AgentStatusClient
	// AgentTask is the client for interacting with the AgentTask builders.
	AgentTask *AgentTaskClient
	// Ansible is the client for interacting with the Ansible builders.
	Ansible *AnsibleClient
	// AuthUser is the client for interacting with the AuthUser builders.
	AuthUser *AuthUserClient
	// Build is the client for interacting with the Build builders.
	Build *BuildClient
	// BuildCommit is the client for interacting with the BuildCommit builders.
	BuildCommit *BuildCommitClient
	// Command is the client for interacting with the Command builders.
	Command *CommandClient
	// Competition is the client for interacting with the Competition builders.
	Competition *CompetitionClient
	// DNS is the client for interacting with the DNS builders.
	DNS *DNSClient
	// DNSRecord is the client for interacting with the DNSRecord builders.
	DNSRecord *DNSRecordClient
	// Disk is the client for interacting with the Disk builders.
	Disk *DiskClient
	// Environment is the client for interacting with the Environment builders.
	Environment *EnvironmentClient
	// FileDelete is the client for interacting with the FileDelete builders.
	FileDelete *FileDeleteClient
	// FileDownload is the client for interacting with the FileDownload builders.
	FileDownload *FileDownloadClient
	// FileExtract is the client for interacting with the FileExtract builders.
	FileExtract *FileExtractClient
	// Finding is the client for interacting with the Finding builders.
	Finding *FindingClient
	// GinFileMiddleware is the client for interacting with the GinFileMiddleware builders.
	GinFileMiddleware *GinFileMiddlewareClient
	// Host is the client for interacting with the Host builders.
	Host *HostClient
	// HostDependency is the client for interacting with the HostDependency builders.
	HostDependency *HostDependencyClient
	// Identity is the client for interacting with the Identity builders.
	Identity *IdentityClient
	// IncludedNetwork is the client for interacting with the IncludedNetwork builders.
	IncludedNetwork *IncludedNetworkClient
	// Network is the client for interacting with the Network builders.
	Network *NetworkClient
	// Plan is the client for interacting with the Plan builders.
	Plan *PlanClient
	// PlanDiff is the client for interacting with the PlanDiff builders.
	PlanDiff *PlanDiffClient
	// ProvisionedHost is the client for interacting with the ProvisionedHost builders.
	ProvisionedHost *ProvisionedHostClient
	// ProvisionedNetwork is the client for interacting with the ProvisionedNetwork builders.
	ProvisionedNetwork *ProvisionedNetworkClient
	// ProvisioningStep is the client for interacting with the ProvisioningStep builders.
	ProvisioningStep *ProvisioningStepClient
	// RepoCommit is the client for interacting with the RepoCommit builders.
	RepoCommit *RepoCommitClient
	// Repository is the client for interacting with the Repository builders.
	Repository *RepositoryClient
	// Script is the client for interacting with the Script builders.
	Script *ScriptClient
	// ServerTask is the client for interacting with the ServerTask builders.
	ServerTask *ServerTaskClient
	// Status is the client for interacting with the Status builders.
	Status *StatusClient
	// Tag is the client for interacting with the Tag builders.
	Tag *TagClient
	// Team is the client for interacting with the Team builders.
	Team *TeamClient
	// Token is the client for interacting with the Token builders.
	Token *TokenClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AdhocPlan = NewAdhocPlanClient(c.config)
	c.AgentStatus = NewAgentStatusClient(c.config)
	c.AgentTask = NewAgentTaskClient(c.config)
	c.Ansible = NewAnsibleClient(c.config)
	c.AuthUser = NewAuthUserClient(c.config)
	c.Build = NewBuildClient(c.config)
	c.BuildCommit = NewBuildCommitClient(c.config)
	c.Command = NewCommandClient(c.config)
	c.Competition = NewCompetitionClient(c.config)
	c.DNS = NewDNSClient(c.config)
	c.DNSRecord = NewDNSRecordClient(c.config)
	c.Disk = NewDiskClient(c.config)
	c.Environment = NewEnvironmentClient(c.config)
	c.FileDelete = NewFileDeleteClient(c.config)
	c.FileDownload = NewFileDownloadClient(c.config)
	c.FileExtract = NewFileExtractClient(c.config)
	c.Finding = NewFindingClient(c.config)
	c.GinFileMiddleware = NewGinFileMiddlewareClient(c.config)
	c.Host = NewHostClient(c.config)
	c.HostDependency = NewHostDependencyClient(c.config)
	c.Identity = NewIdentityClient(c.config)
	c.IncludedNetwork = NewIncludedNetworkClient(c.config)
	c.Network = NewNetworkClient(c.config)
	c.Plan = NewPlanClient(c.config)
	c.PlanDiff = NewPlanDiffClient(c.config)
	c.ProvisionedHost = NewProvisionedHostClient(c.config)
	c.ProvisionedNetwork = NewProvisionedNetworkClient(c.config)
	c.ProvisioningStep = NewProvisioningStepClient(c.config)
	c.RepoCommit = NewRepoCommitClient(c.config)
	c.Repository = NewRepositoryClient(c.config)
	c.Script = NewScriptClient(c.config)
	c.ServerTask = NewServerTaskClient(c.config)
	c.Status = NewStatusClient(c.config)
	c.Tag = NewTagClient(c.config)
	c.Team = NewTeamClient(c.config)
	c.Token = NewTokenClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		AdhocPlan:          NewAdhocPlanClient(cfg),
		AgentStatus:        NewAgentStatusClient(cfg),
		AgentTask:          NewAgentTaskClient(cfg),
		Ansible:            NewAnsibleClient(cfg),
		AuthUser:           NewAuthUserClient(cfg),
		Build:              NewBuildClient(cfg),
		BuildCommit:        NewBuildCommitClient(cfg),
		Command:            NewCommandClient(cfg),
		Competition:        NewCompetitionClient(cfg),
		DNS:                NewDNSClient(cfg),
		DNSRecord:          NewDNSRecordClient(cfg),
		Disk:               NewDiskClient(cfg),
		Environment:        NewEnvironmentClient(cfg),
		FileDelete:         NewFileDeleteClient(cfg),
		FileDownload:       NewFileDownloadClient(cfg),
		FileExtract:        NewFileExtractClient(cfg),
		Finding:            NewFindingClient(cfg),
		GinFileMiddleware:  NewGinFileMiddlewareClient(cfg),
		Host:               NewHostClient(cfg),
		HostDependency:     NewHostDependencyClient(cfg),
		Identity:           NewIdentityClient(cfg),
		IncludedNetwork:    NewIncludedNetworkClient(cfg),
		Network:            NewNetworkClient(cfg),
		Plan:               NewPlanClient(cfg),
		PlanDiff:           NewPlanDiffClient(cfg),
		ProvisionedHost:    NewProvisionedHostClient(cfg),
		ProvisionedNetwork: NewProvisionedNetworkClient(cfg),
		ProvisioningStep:   NewProvisioningStepClient(cfg),
		RepoCommit:         NewRepoCommitClient(cfg),
		Repository:         NewRepositoryClient(cfg),
		Script:             NewScriptClient(cfg),
		ServerTask:         NewServerTaskClient(cfg),
		Status:             NewStatusClient(cfg),
		Tag:                NewTagClient(cfg),
		Team:               NewTeamClient(cfg),
		Token:              NewTokenClient(cfg),
		User:               NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		AdhocPlan:          NewAdhocPlanClient(cfg),
		AgentStatus:        NewAgentStatusClient(cfg),
		AgentTask:          NewAgentTaskClient(cfg),
		Ansible:            NewAnsibleClient(cfg),
		AuthUser:           NewAuthUserClient(cfg),
		Build:              NewBuildClient(cfg),
		BuildCommit:        NewBuildCommitClient(cfg),
		Command:            NewCommandClient(cfg),
		Competition:        NewCompetitionClient(cfg),
		DNS:                NewDNSClient(cfg),
		DNSRecord:          NewDNSRecordClient(cfg),
		Disk:               NewDiskClient(cfg),
		Environment:        NewEnvironmentClient(cfg),
		FileDelete:         NewFileDeleteClient(cfg),
		FileDownload:       NewFileDownloadClient(cfg),
		FileExtract:        NewFileExtractClient(cfg),
		Finding:            NewFindingClient(cfg),
		GinFileMiddleware:  NewGinFileMiddlewareClient(cfg),
		Host:               NewHostClient(cfg),
		HostDependency:     NewHostDependencyClient(cfg),
		Identity:           NewIdentityClient(cfg),
		IncludedNetwork:    NewIncludedNetworkClient(cfg),
		Network:            NewNetworkClient(cfg),
		Plan:               NewPlanClient(cfg),
		PlanDiff:           NewPlanDiffClient(cfg),
		ProvisionedHost:    NewProvisionedHostClient(cfg),
		ProvisionedNetwork: NewProvisionedNetworkClient(cfg),
		ProvisioningStep:   NewProvisioningStepClient(cfg),
		RepoCommit:         NewRepoCommitClient(cfg),
		Repository:         NewRepositoryClient(cfg),
		Script:             NewScriptClient(cfg),
		ServerTask:         NewServerTaskClient(cfg),
		Status:             NewStatusClient(cfg),
		Tag:                NewTagClient(cfg),
		Team:               NewTeamClient(cfg),
		Token:              NewTokenClient(cfg),
		User:               NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AdhocPlan.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AdhocPlan, c.AgentStatus, c.AgentTask, c.Ansible, c.AuthUser, c.Build,
		c.BuildCommit, c.Command, c.Competition, c.DNS, c.DNSRecord, c.Disk,
		c.Environment, c.FileDelete, c.FileDownload, c.FileExtract, c.Finding,
		c.GinFileMiddleware, c.Host, c.HostDependency, c.Identity, c.IncludedNetwork,
		c.Network, c.Plan, c.PlanDiff, c.ProvisionedHost, c.ProvisionedNetwork,
		c.ProvisioningStep, c.RepoCommit, c.Repository, c.Script, c.ServerTask,
		c.Status, c.Tag, c.Team, c.Token, c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AdhocPlan, c.AgentStatus, c.AgentTask, c.Ansible, c.AuthUser, c.Build,
		c.BuildCommit, c.Command, c.Competition, c.DNS, c.DNSRecord, c.Disk,
		c.Environment, c.FileDelete, c.FileDownload, c.FileExtract, c.Finding,
		c.GinFileMiddleware, c.Host, c.HostDependency, c.Identity, c.IncludedNetwork,
		c.Network, c.Plan, c.PlanDiff, c.ProvisionedHost, c.ProvisionedNetwork,
		c.ProvisioningStep, c.RepoCommit, c.Repository, c.Script, c.ServerTask,
		c.Status, c.Tag, c.Team, c.Token, c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AdhocPlanMutation:
		return c.AdhocPlan.mutate(ctx, m)
	case *AgentStatusMutation:
		return c.AgentStatus.mutate(ctx, m)
	case *AgentTaskMutation:
		return c.AgentTask.mutate(ctx, m)
	case *AnsibleMutation:
		return c.Ansible.mutate(ctx, m)
	case *AuthUserMutation:
		return c.AuthUser.mutate(ctx, m)
	case *BuildMutation:
		return c.Build.mutate(ctx, m)
	case *BuildCommitMutation:
		return c.BuildCommit.mutate(ctx, m)
	case *CommandMutation:
		return c.Command.mutate(ctx, m)
	case *CompetitionMutation:
		return c.Competition.mutate(ctx, m)
	case *DNSMutation:
		return c.DNS.mutate(ctx, m)
	case *DNSRecordMutation:
		return c.DNSRecord.mutate(ctx, m)
	case *DiskMutation:
		return c.Disk.mutate(ctx, m)
	case *EnvironmentMutation:
		return c.Environment.mutate(ctx, m)
	case *FileDeleteMutation:
		return c.FileDelete.mutate(ctx, m)
	case *FileDownloadMutation:
		return c.FileDownload.mutate(ctx, m)
	case *FileExtractMutation:
		return c.FileExtract.mutate(ctx, m)
	case *FindingMutation:
		return c.Finding.mutate(ctx, m)
	case *GinFileMiddlewareMutation:
		return c.GinFileMiddleware.mutate(ctx, m)
	case *HostMutation:
		return c.Host.mutate(ctx, m)
	case *HostDependencyMutation:
		return c.HostDependency.mutate(ctx, m)
	case *IdentityMutation:
		return c.Identity.mutate(ctx, m)
	case *IncludedNetworkMutation:
		return c.IncludedNetwork.mutate(ctx, m)
	case *NetworkMutation:
		return c.Network.mutate(ctx, m)
	case *PlanMutation:
		return c.Plan.mutate(ctx, m)
	case *PlanDiffMutation:
		return c.PlanDiff.mutate(ctx, m)
	case *ProvisionedHostMutation:
		return c.ProvisionedHost.mutate(ctx, m)
	case *ProvisionedNetworkMutation:
		return c.ProvisionedNetwork.mutate(ctx, m)
	case *ProvisioningStepMutation:
		return c.ProvisioningStep.mutate(ctx, m)
	case *RepoCommitMutation:
		return c.RepoCommit.mutate(ctx, m)
	case *RepositoryMutation:
		return c.Repository.mutate(ctx, m)
	case *ScriptMutation:
		return c.Script.mutate(ctx, m)
	case *ServerTaskMutation:
		return c.ServerTask.mutate(ctx, m)
	case *StatusMutation:
		return c.Status.mutate(ctx, m)
	case *TagMutation:
		return c.Tag.mutate(ctx, m)
	case *TeamMutation:
		return c.Team.mutate(ctx, m)
	case *TokenMutation:
		return c.Token.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AdhocPlanClient is a client for the AdhocPlan schema.
type AdhocPlanClient struct {
	config
}

// NewAdhocPlanClient returns a client for the AdhocPlan from the given config.
func NewAdhocPlanClient(c config) *AdhocPlanClient {
	return &AdhocPlanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `adhocplan.Hooks(f(g(h())))`.
func (c *AdhocPlanClient) Use(hooks ...Hook) {
	c.hooks.AdhocPlan = append(c.hooks.AdhocPlan, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `adhocplan.Intercept(f(g(h())))`.
func (c *AdhocPlanClient) Intercept(interceptors ...Interceptor) {
	c.inters.AdhocPlan = append(c.inters.AdhocPlan, interceptors...)
}

// Create returns a builder for creating a AdhocPlan entity.
func (c *AdhocPlanClient) Create() *AdhocPlanCreate {
	mutation := newAdhocPlanMutation(c.config, OpCreate)
	return &AdhocPlanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AdhocPlan entities.
func (c *AdhocPlanClient) CreateBulk(builders ...*AdhocPlanCreate) *AdhocPlanCreateBulk {
	return &AdhocPlanCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AdhocPlanClient) MapCreateBulk(slice any, setFunc func(*AdhocPlanCreate, int)) *AdhocPlanCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AdhocPlanCreateBulk{err: fmt.Errorf("calling to AdhocPlanClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AdhocPlanCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AdhocPlanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AdhocPlan.
func (c *AdhocPlanClient) Update() *AdhocPlanUpdate {
	mutation := newAdhocPlanMutation(c.config, OpUpdate)
	return &AdhocPlanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AdhocPlanClient) UpdateOne(ap *AdhocPlan) *AdhocPlanUpdateOne {
	mutation := newAdhocPlanMutation(c.config, OpUpdateOne, withAdhocPlan(ap))
	return &AdhocPlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AdhocPlanClient) UpdateOneID(id uuid.UUID) *AdhocPlanUpdateOne {
	mutation := newAdhocPlanMutation(c.config, OpUpdateOne, withAdhocPlanID(id))
	return &AdhocPlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AdhocPlan.
func (c *AdhocPlanClient) Delete() *AdhocPlanDelete {
	mutation := newAdhocPlanMutation(c.config, OpDelete)
	return &AdhocPlanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AdhocPlanClient) DeleteOne(ap *AdhocPlan) *AdhocPlanDeleteOne {
	return c.DeleteOneID(ap.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AdhocPlanClient) DeleteOneID(id uuid.UUID) *AdhocPlanDeleteOne {
	builder := c.Delete().Where(adhocplan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AdhocPlanDeleteOne{builder}
}

// Query returns a query builder for AdhocPlan.
func (c *AdhocPlanClient) Query() *AdhocPlanQuery {
	return &AdhocPlanQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAdhocPlan},
		inters: c.Interceptors(),
	}
}

// Get returns a AdhocPlan entity by its id.
func (c *AdhocPlanClient) Get(ctx context.Context, id uuid.UUID) (*AdhocPlan, error) {
	return c.Query().Where(adhocplan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AdhocPlanClient) GetX(ctx context.Context, id uuid.UUID) *AdhocPlan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPrevAdhocPlan queries the PrevAdhocPlan edge of a AdhocPlan.
func (c *AdhocPlanClient) QueryPrevAdhocPlan(ap *AdhocPlan) *AdhocPlanQuery {
	query := (&AdhocPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(adhocplan.Table, adhocplan.FieldID, id),
			sqlgraph.To(adhocplan.Table, adhocplan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, adhocplan.PrevAdhocPlanTable, adhocplan.PrevAdhocPlanPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNextAdhocPlan queries the NextAdhocPlan edge of a AdhocPlan.
func (c *AdhocPlanClient) QueryNextAdhocPlan(ap *AdhocPlan) *AdhocPlanQuery {
	query := (&AdhocPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(adhocplan.Table, adhocplan.FieldID, id),
			sqlgraph.To(adhocplan.Table, adhocplan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, adhocplan.NextAdhocPlanTable, adhocplan.NextAdhocPlanPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAdhocPlanToBuild queries the AdhocPlanToBuild edge of a AdhocPlan.
func (c *AdhocPlanClient) QueryAdhocPlanToBuild(ap *AdhocPlan) *BuildQuery {
	query := (&BuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(adhocplan.Table, adhocplan.FieldID, id),
			sqlgraph.To(build.Table, build.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, adhocplan.AdhocPlanToBuildTable, adhocplan.AdhocPlanToBuildColumn),
		)
		fromV = sqlgraph.Neighbors(ap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAdhocPlanToStatus queries the AdhocPlanToStatus edge of a AdhocPlan.
func (c *AdhocPlanClient) QueryAdhocPlanToStatus(ap *AdhocPlan) *StatusQuery {
	query := (&StatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(adhocplan.Table, adhocplan.FieldID, id),
			sqlgraph.To(status.Table, status.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, adhocplan.AdhocPlanToStatusTable, adhocplan.AdhocPlanToStatusColumn),
		)
		fromV = sqlgraph.Neighbors(ap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAdhocPlanToAgentTask queries the AdhocPlanToAgentTask edge of a AdhocPlan.
func (c *AdhocPlanClient) QueryAdhocPlanToAgentTask(ap *AdhocPlan) *AgentTaskQuery {
	query := (&AgentTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(adhocplan.Table, adhocplan.FieldID, id),
			sqlgraph.To(agenttask.Table, agenttask.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, adhocplan.AdhocPlanToAgentTaskTable, adhocplan.AdhocPlanToAgentTaskColumn),
		)
		fromV = sqlgraph.Neighbors(ap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AdhocPlanClient) Hooks() []Hook {
	return c.hooks.AdhocPlan
}

// Interceptors returns the client interceptors.
func (c *AdhocPlanClient) Interceptors() []Interceptor {
	return c.inters.AdhocPlan
}

func (c *AdhocPlanClient) mutate(ctx context.Context, m *AdhocPlanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AdhocPlanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AdhocPlanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AdhocPlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AdhocPlanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AdhocPlan mutation op: %q", m.Op())
	}
}

// AgentStatusClient is a client for the AgentStatus schema.
type AgentStatusClient struct {
	config
}

// NewAgentStatusClient returns a client for the AgentStatus from the given config.
func NewAgentStatusClient(c config) *AgentStatusClient {
	return &AgentStatusClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `agentstatus.Hooks(f(g(h())))`.
func (c *AgentStatusClient) Use(hooks ...Hook) {
	c.hooks.AgentStatus = append(c.hooks.AgentStatus, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `agentstatus.Intercept(f(g(h())))`.
func (c *AgentStatusClient) Intercept(interceptors ...Interceptor) {
	c.inters.AgentStatus = append(c.inters.AgentStatus, interceptors...)
}

// Create returns a builder for creating a AgentStatus entity.
func (c *AgentStatusClient) Create() *AgentStatusCreate {
	mutation := newAgentStatusMutation(c.config, OpCreate)
	return &AgentStatusCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AgentStatus entities.
func (c *AgentStatusClient) CreateBulk(builders ...*AgentStatusCreate) *AgentStatusCreateBulk {
	return &AgentStatusCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AgentStatusClient) MapCreateBulk(slice any, setFunc func(*AgentStatusCreate, int)) *AgentStatusCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AgentStatusCreateBulk{err: fmt.Errorf("calling to AgentStatusClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AgentStatusCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AgentStatusCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AgentStatus.
func (c *AgentStatusClient) Update() *AgentStatusUpdate {
	mutation := newAgentStatusMutation(c.config, OpUpdate)
	return &AgentStatusUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AgentStatusClient) UpdateOne(as *AgentStatus) *AgentStatusUpdateOne {
	mutation := newAgentStatusMutation(c.config, OpUpdateOne, withAgentStatus(as))
	return &AgentStatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AgentStatusClient) UpdateOneID(id uuid.UUID) *AgentStatusUpdateOne {
	mutation := newAgentStatusMutation(c.config, OpUpdateOne, withAgentStatusID(id))
	return &AgentStatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AgentStatus.
func (c *AgentStatusClient) Delete() *AgentStatusDelete {
	mutation := newAgentStatusMutation(c.config, OpDelete)
	return &AgentStatusDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AgentStatusClient) DeleteOne(as *AgentStatus) *AgentStatusDeleteOne {
	return c.DeleteOneID(as.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AgentStatusClient) DeleteOneID(id uuid.UUID) *AgentStatusDeleteOne {
	builder := c.Delete().Where(agentstatus.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AgentStatusDeleteOne{builder}
}

// Query returns a query builder for AgentStatus.
func (c *AgentStatusClient) Query() *AgentStatusQuery {
	return &AgentStatusQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAgentStatus},
		inters: c.Interceptors(),
	}
}

// Get returns a AgentStatus entity by its id.
func (c *AgentStatusClient) Get(ctx context.Context, id uuid.UUID) (*AgentStatus, error) {
	return c.Query().Where(agentstatus.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AgentStatusClient) GetX(ctx context.Context, id uuid.UUID) *AgentStatus {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAgentStatusToProvisionedHost queries the AgentStatusToProvisionedHost edge of a AgentStatus.
func (c *AgentStatusClient) QueryAgentStatusToProvisionedHost(as *AgentStatus) *ProvisionedHostQuery {
	query := (&ProvisionedHostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := as.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agentstatus.Table, agentstatus.FieldID, id),
			sqlgraph.To(provisionedhost.Table, provisionedhost.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, agentstatus.AgentStatusToProvisionedHostTable, agentstatus.AgentStatusToProvisionedHostColumn),
		)
		fromV = sqlgraph.Neighbors(as.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAgentStatusToProvisionedNetwork queries the AgentStatusToProvisionedNetwork edge of a AgentStatus.
func (c *AgentStatusClient) QueryAgentStatusToProvisionedNetwork(as *AgentStatus) *ProvisionedNetworkQuery {
	query := (&ProvisionedNetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := as.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agentstatus.Table, agentstatus.FieldID, id),
			sqlgraph.To(provisionednetwork.Table, provisionednetwork.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, agentstatus.AgentStatusToProvisionedNetworkTable, agentstatus.AgentStatusToProvisionedNetworkColumn),
		)
		fromV = sqlgraph.Neighbors(as.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAgentStatusToBuild queries the AgentStatusToBuild edge of a AgentStatus.
func (c *AgentStatusClient) QueryAgentStatusToBuild(as *AgentStatus) *BuildQuery {
	query := (&BuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := as.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agentstatus.Table, agentstatus.FieldID, id),
			sqlgraph.To(build.Table, build.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, agentstatus.AgentStatusToBuildTable, agentstatus.AgentStatusToBuildColumn),
		)
		fromV = sqlgraph.Neighbors(as.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AgentStatusClient) Hooks() []Hook {
	return c.hooks.AgentStatus
}

// Interceptors returns the client interceptors.
func (c *AgentStatusClient) Interceptors() []Interceptor {
	return c.inters.AgentStatus
}

func (c *AgentStatusClient) mutate(ctx context.Context, m *AgentStatusMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AgentStatusCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AgentStatusUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AgentStatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AgentStatusDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AgentStatus mutation op: %q", m.Op())
	}
}

// AgentTaskClient is a client for the AgentTask schema.
type AgentTaskClient struct {
	config
}

// NewAgentTaskClient returns a client for the AgentTask from the given config.
func NewAgentTaskClient(c config) *AgentTaskClient {
	return &AgentTaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `agenttask.Hooks(f(g(h())))`.
func (c *AgentTaskClient) Use(hooks ...Hook) {
	c.hooks.AgentTask = append(c.hooks.AgentTask, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `agenttask.Intercept(f(g(h())))`.
func (c *AgentTaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.AgentTask = append(c.inters.AgentTask, interceptors...)
}

// Create returns a builder for creating a AgentTask entity.
func (c *AgentTaskClient) Create() *AgentTaskCreate {
	mutation := newAgentTaskMutation(c.config, OpCreate)
	return &AgentTaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AgentTask entities.
func (c *AgentTaskClient) CreateBulk(builders ...*AgentTaskCreate) *AgentTaskCreateBulk {
	return &AgentTaskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AgentTaskClient) MapCreateBulk(slice any, setFunc func(*AgentTaskCreate, int)) *AgentTaskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AgentTaskCreateBulk{err: fmt.Errorf("calling to AgentTaskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AgentTaskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AgentTaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AgentTask.
func (c *AgentTaskClient) Update() *AgentTaskUpdate {
	mutation := newAgentTaskMutation(c.config, OpUpdate)
	return &AgentTaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AgentTaskClient) UpdateOne(at *AgentTask) *AgentTaskUpdateOne {
	mutation := newAgentTaskMutation(c.config, OpUpdateOne, withAgentTask(at))
	return &AgentTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AgentTaskClient) UpdateOneID(id uuid.UUID) *AgentTaskUpdateOne {
	mutation := newAgentTaskMutation(c.config, OpUpdateOne, withAgentTaskID(id))
	return &AgentTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AgentTask.
func (c *AgentTaskClient) Delete() *AgentTaskDelete {
	mutation := newAgentTaskMutation(c.config, OpDelete)
	return &AgentTaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AgentTaskClient) DeleteOne(at *AgentTask) *AgentTaskDeleteOne {
	return c.DeleteOneID(at.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AgentTaskClient) DeleteOneID(id uuid.UUID) *AgentTaskDeleteOne {
	builder := c.Delete().Where(agenttask.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AgentTaskDeleteOne{builder}
}

// Query returns a query builder for AgentTask.
func (c *AgentTaskClient) Query() *AgentTaskQuery {
	return &AgentTaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAgentTask},
		inters: c.Interceptors(),
	}
}

// Get returns a AgentTask entity by its id.
func (c *AgentTaskClient) Get(ctx context.Context, id uuid.UUID) (*AgentTask, error) {
	return c.Query().Where(agenttask.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AgentTaskClient) GetX(ctx context.Context, id uuid.UUID) *AgentTask {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAgentTaskToProvisioningStep queries the AgentTaskToProvisioningStep edge of a AgentTask.
func (c *AgentTaskClient) QueryAgentTaskToProvisioningStep(at *AgentTask) *ProvisioningStepQuery {
	query := (&ProvisioningStepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := at.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agenttask.Table, agenttask.FieldID, id),
			sqlgraph.To(provisioningstep.Table, provisioningstep.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, agenttask.AgentTaskToProvisioningStepTable, agenttask.AgentTaskToProvisioningStepColumn),
		)
		fromV = sqlgraph.Neighbors(at.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAgentTaskToProvisionedHost queries the AgentTaskToProvisionedHost edge of a AgentTask.
func (c *AgentTaskClient) QueryAgentTaskToProvisionedHost(at *AgentTask) *ProvisionedHostQuery {
	query := (&ProvisionedHostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := at.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agenttask.Table, agenttask.FieldID, id),
			sqlgraph.To(provisionedhost.Table, provisionedhost.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, agenttask.AgentTaskToProvisionedHostTable, agenttask.AgentTaskToProvisionedHostColumn),
		)
		fromV = sqlgraph.Neighbors(at.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAgentTaskToAdhocPlan queries the AgentTaskToAdhocPlan edge of a AgentTask.
func (c *AgentTaskClient) QueryAgentTaskToAdhocPlan(at *AgentTask) *AdhocPlanQuery {
	query := (&AdhocPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := at.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agenttask.Table, agenttask.FieldID, id),
			sqlgraph.To(adhocplan.Table, adhocplan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, agenttask.AgentTaskToAdhocPlanTable, agenttask.AgentTaskToAdhocPlanColumn),
		)
		fromV = sqlgraph.Neighbors(at.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AgentTaskClient) Hooks() []Hook {
	return c.hooks.AgentTask
}

// Interceptors returns the client interceptors.
func (c *AgentTaskClient) Interceptors() []Interceptor {
	return c.inters.AgentTask
}

func (c *AgentTaskClient) mutate(ctx context.Context, m *AgentTaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AgentTaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AgentTaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AgentTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AgentTaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AgentTask mutation op: %q", m.Op())
	}
}

// AnsibleClient is a client for the Ansible schema.
type AnsibleClient struct {
	config
}

// NewAnsibleClient returns a client for the Ansible from the given config.
func NewAnsibleClient(c config) *AnsibleClient {
	return &AnsibleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ansible.Hooks(f(g(h())))`.
func (c *AnsibleClient) Use(hooks ...Hook) {
	c.hooks.Ansible = append(c.hooks.Ansible, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ansible.Intercept(f(g(h())))`.
func (c *AnsibleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Ansible = append(c.inters.Ansible, interceptors...)
}

// Create returns a builder for creating a Ansible entity.
func (c *AnsibleClient) Create() *AnsibleCreate {
	mutation := newAnsibleMutation(c.config, OpCreate)
	return &AnsibleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Ansible entities.
func (c *AnsibleClient) CreateBulk(builders ...*AnsibleCreate) *AnsibleCreateBulk {
	return &AnsibleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AnsibleClient) MapCreateBulk(slice any, setFunc func(*AnsibleCreate, int)) *AnsibleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AnsibleCreateBulk{err: fmt.Errorf("calling to AnsibleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AnsibleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AnsibleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Ansible.
func (c *AnsibleClient) Update() *AnsibleUpdate {
	mutation := newAnsibleMutation(c.config, OpUpdate)
	return &AnsibleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AnsibleClient) UpdateOne(a *Ansible) *AnsibleUpdateOne {
	mutation := newAnsibleMutation(c.config, OpUpdateOne, withAnsible(a))
	return &AnsibleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AnsibleClient) UpdateOneID(id uuid.UUID) *AnsibleUpdateOne {
	mutation := newAnsibleMutation(c.config, OpUpdateOne, withAnsibleID(id))
	return &AnsibleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Ansible.
func (c *AnsibleClient) Delete() *AnsibleDelete {
	mutation := newAnsibleMutation(c.config, OpDelete)
	return &AnsibleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AnsibleClient) DeleteOne(a *Ansible) *AnsibleDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AnsibleClient) DeleteOneID(id uuid.UUID) *AnsibleDeleteOne {
	builder := c.Delete().Where(ansible.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AnsibleDeleteOne{builder}
}

// Query returns a query builder for Ansible.
func (c *AnsibleClient) Query() *AnsibleQuery {
	return &AnsibleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAnsible},
		inters: c.Interceptors(),
	}
}

// Get returns a Ansible entity by its id.
func (c *AnsibleClient) Get(ctx context.Context, id uuid.UUID) (*Ansible, error) {
	return c.Query().Where(ansible.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AnsibleClient) GetX(ctx context.Context, id uuid.UUID) *Ansible {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAnsibleToUser queries the AnsibleToUser edge of a Ansible.
func (c *AnsibleClient) QueryAnsibleToUser(a *Ansible) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ansible.Table, ansible.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ansible.AnsibleToUserTable, ansible.AnsibleToUserColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAnsibleFromEnvironment queries the AnsibleFromEnvironment edge of a Ansible.
func (c *AnsibleClient) QueryAnsibleFromEnvironment(a *Ansible) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ansible.Table, ansible.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ansible.AnsibleFromEnvironmentTable, ansible.AnsibleFromEnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AnsibleClient) Hooks() []Hook {
	return c.hooks.Ansible
}

// Interceptors returns the client interceptors.
func (c *AnsibleClient) Interceptors() []Interceptor {
	return c.inters.Ansible
}

func (c *AnsibleClient) mutate(ctx context.Context, m *AnsibleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AnsibleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AnsibleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AnsibleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AnsibleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Ansible mutation op: %q", m.Op())
	}
}

// AuthUserClient is a client for the AuthUser schema.
type AuthUserClient struct {
	config
}

// NewAuthUserClient returns a client for the AuthUser from the given config.
func NewAuthUserClient(c config) *AuthUserClient {
	return &AuthUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authuser.Hooks(f(g(h())))`.
func (c *AuthUserClient) Use(hooks ...Hook) {
	c.hooks.AuthUser = append(c.hooks.AuthUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authuser.Intercept(f(g(h())))`.
func (c *AuthUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthUser = append(c.inters.AuthUser, interceptors...)
}

// Create returns a builder for creating a AuthUser entity.
func (c *AuthUserClient) Create() *AuthUserCreate {
	mutation := newAuthUserMutation(c.config, OpCreate)
	return &AuthUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthUser entities.
func (c *AuthUserClient) CreateBulk(builders ...*AuthUserCreate) *AuthUserCreateBulk {
	return &AuthUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthUserClient) MapCreateBulk(slice any, setFunc func(*AuthUserCreate, int)) *AuthUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthUserCreateBulk{err: fmt.Errorf("calling to AuthUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthUser.
func (c *AuthUserClient) Update() *AuthUserUpdate {
	mutation := newAuthUserMutation(c.config, OpUpdate)
	return &AuthUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthUserClient) UpdateOne(au *AuthUser) *AuthUserUpdateOne {
	mutation := newAuthUserMutation(c.config, OpUpdateOne, withAuthUser(au))
	return &AuthUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthUserClient) UpdateOneID(id uuid.UUID) *AuthUserUpdateOne {
	mutation := newAuthUserMutation(c.config, OpUpdateOne, withAuthUserID(id))
	return &AuthUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthUser.
func (c *AuthUserClient) Delete() *AuthUserDelete {
	mutation := newAuthUserMutation(c.config, OpDelete)
	return &AuthUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthUserClient) DeleteOne(au *AuthUser) *AuthUserDeleteOne {
	return c.DeleteOneID(au.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthUserClient) DeleteOneID(id uuid.UUID) *AuthUserDeleteOne {
	builder := c.Delete().Where(authuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthUserDeleteOne{builder}
}

// Query returns a query builder for AuthUser.
func (c *AuthUserClient) Query() *AuthUserQuery {
	return &AuthUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthUser},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthUser entity by its id.
func (c *AuthUserClient) Get(ctx context.Context, id uuid.UUID) (*AuthUser, error) {
	return c.Query().Where(authuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthUserClient) GetX(ctx context.Context, id uuid.UUID) *AuthUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAuthUserToToken queries the AuthUserToToken edge of a AuthUser.
func (c *AuthUserClient) QueryAuthUserToToken(au *AuthUser) *TokenQuery {
	query := (&TokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := au.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(authuser.Table, authuser.FieldID, id),
			sqlgraph.To(token.Table, token.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, authuser.AuthUserToTokenTable, authuser.AuthUserToTokenColumn),
		)
		fromV = sqlgraph.Neighbors(au.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthUserToServerTasks queries the AuthUserToServerTasks edge of a AuthUser.
func (c *AuthUserClient) QueryAuthUserToServerTasks(au *AuthUser) *ServerTaskQuery {
	query := (&ServerTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := au.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(authuser.Table, authuser.FieldID, id),
			sqlgraph.To(servertask.Table, servertask.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, authuser.AuthUserToServerTasksTable, authuser.AuthUserToServerTasksColumn),
		)
		fromV = sqlgraph.Neighbors(au.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AuthUserClient) Hooks() []Hook {
	return c.hooks.AuthUser
}

// Interceptors returns the client interceptors.
func (c *AuthUserClient) Interceptors() []Interceptor {
	return c.inters.AuthUser
}

func (c *AuthUserClient) mutate(ctx context.Context, m *AuthUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuthUser mutation op: %q", m.Op())
	}
}

// BuildClient is a client for the Build schema.
type BuildClient struct {
	config
}

// NewBuildClient returns a client for the Build from the given config.
func NewBuildClient(c config) *BuildClient {
	return &BuildClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `build.Hooks(f(g(h())))`.
func (c *BuildClient) Use(hooks ...Hook) {
	c.hooks.Build = append(c.hooks.Build, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `build.Intercept(f(g(h())))`.
func (c *BuildClient) Intercept(interceptors ...Interceptor) {
	c.inters.Build = append(c.inters.Build, interceptors...)
}

// Create returns a builder for creating a Build entity.
func (c *BuildClient) Create() *BuildCreate {
	mutation := newBuildMutation(c.config, OpCreate)
	return &BuildCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Build entities.
func (c *BuildClient) CreateBulk(builders ...*BuildCreate) *BuildCreateBulk {
	return &BuildCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BuildClient) MapCreateBulk(slice any, setFunc func(*BuildCreate, int)) *BuildCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BuildCreateBulk{err: fmt.Errorf("calling to BuildClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BuildCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BuildCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Build.
func (c *BuildClient) Update() *BuildUpdate {
	mutation := newBuildMutation(c.config, OpUpdate)
	return &BuildUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BuildClient) UpdateOne(b *Build) *BuildUpdateOne {
	mutation := newBuildMutation(c.config, OpUpdateOne, withBuild(b))
	return &BuildUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BuildClient) UpdateOneID(id uuid.UUID) *BuildUpdateOne {
	mutation := newBuildMutation(c.config, OpUpdateOne, withBuildID(id))
	return &BuildUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Build.
func (c *BuildClient) Delete() *BuildDelete {
	mutation := newBuildMutation(c.config, OpDelete)
	return &BuildDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BuildClient) DeleteOne(b *Build) *BuildDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BuildClient) DeleteOneID(id uuid.UUID) *BuildDeleteOne {
	builder := c.Delete().Where(build.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BuildDeleteOne{builder}
}

// Query returns a query builder for Build.
func (c *BuildClient) Query() *BuildQuery {
	return &BuildQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBuild},
		inters: c.Interceptors(),
	}
}

// Get returns a Build entity by its id.
func (c *BuildClient) Get(ctx context.Context, id uuid.UUID) (*Build, error) {
	return c.Query().Where(build.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BuildClient) GetX(ctx context.Context, id uuid.UUID) *Build {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBuildToStatus queries the BuildToStatus edge of a Build.
func (c *BuildClient) QueryBuildToStatus(b *Build) *StatusQuery {
	query := (&StatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(status.Table, status.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, build.BuildToStatusTable, build.BuildToStatusColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuildToEnvironment queries the BuildToEnvironment edge of a Build.
func (c *BuildClient) QueryBuildToEnvironment(b *Build) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, build.BuildToEnvironmentTable, build.BuildToEnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuildToCompetition queries the BuildToCompetition edge of a Build.
func (c *BuildClient) QueryBuildToCompetition(b *Build) *CompetitionQuery {
	query := (&CompetitionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(competition.Table, competition.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, build.BuildToCompetitionTable, build.BuildToCompetitionColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuildToLatestBuildCommit queries the BuildToLatestBuildCommit edge of a Build.
func (c *BuildClient) QueryBuildToLatestBuildCommit(b *Build) *BuildCommitQuery {
	query := (&BuildCommitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(buildcommit.Table, buildcommit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, build.BuildToLatestBuildCommitTable, build.BuildToLatestBuildCommitColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuildToRepoCommit queries the BuildToRepoCommit edge of a Build.
func (c *BuildClient) QueryBuildToRepoCommit(b *Build) *RepoCommitQuery {
	query := (&RepoCommitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(repocommit.Table, repocommit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, build.BuildToRepoCommitTable, build.BuildToRepoCommitColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuildToProvisionedNetwork queries the BuildToProvisionedNetwork edge of a Build.
func (c *BuildClient) QueryBuildToProvisionedNetwork(b *Build) *ProvisionedNetworkQuery {
	query := (&ProvisionedNetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(provisionednetwork.Table, provisionednetwork.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, build.BuildToProvisionedNetworkTable, build.BuildToProvisionedNetworkColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuildToTeam queries the BuildToTeam edge of a Build.
func (c *BuildClient) QueryBuildToTeam(b *Build) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, build.BuildToTeamTable, build.BuildToTeamColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuildToPlan queries the BuildToPlan edge of a Build.
func (c *BuildClient) QueryBuildToPlan(b *Build) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, build.BuildToPlanTable, build.BuildToPlanColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuildToBuildCommits queries the BuildToBuildCommits edge of a Build.
func (c *BuildClient) QueryBuildToBuildCommits(b *Build) *BuildCommitQuery {
	query := (&BuildCommitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(buildcommit.Table, buildcommit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, build.BuildToBuildCommitsTable, build.BuildToBuildCommitsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuildToAdhocPlans queries the BuildToAdhocPlans edge of a Build.
func (c *BuildClient) QueryBuildToAdhocPlans(b *Build) *AdhocPlanQuery {
	query := (&AdhocPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(adhocplan.Table, adhocplan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, build.BuildToAdhocPlansTable, build.BuildToAdhocPlansColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuildToAgentStatuses queries the BuildToAgentStatuses edge of a Build.
func (c *BuildClient) QueryBuildToAgentStatuses(b *Build) *AgentStatusQuery {
	query := (&AgentStatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(agentstatus.Table, agentstatus.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, build.BuildToAgentStatusesTable, build.BuildToAgentStatusesColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuildToServerTasks queries the BuildToServerTasks edge of a Build.
func (c *BuildClient) QueryBuildToServerTasks(b *Build) *ServerTaskQuery {
	query := (&ServerTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(servertask.Table, servertask.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, build.BuildToServerTasksTable, build.BuildToServerTasksColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BuildClient) Hooks() []Hook {
	return c.hooks.Build
}

// Interceptors returns the client interceptors.
func (c *BuildClient) Interceptors() []Interceptor {
	return c.inters.Build
}

func (c *BuildClient) mutate(ctx context.Context, m *BuildMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BuildCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BuildUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BuildUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BuildDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Build mutation op: %q", m.Op())
	}
}

// BuildCommitClient is a client for the BuildCommit schema.
type BuildCommitClient struct {
	config
}

// NewBuildCommitClient returns a client for the BuildCommit from the given config.
func NewBuildCommitClient(c config) *BuildCommitClient {
	return &BuildCommitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `buildcommit.Hooks(f(g(h())))`.
func (c *BuildCommitClient) Use(hooks ...Hook) {
	c.hooks.BuildCommit = append(c.hooks.BuildCommit, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `buildcommit.Intercept(f(g(h())))`.
func (c *BuildCommitClient) Intercept(interceptors ...Interceptor) {
	c.inters.BuildCommit = append(c.inters.BuildCommit, interceptors...)
}

// Create returns a builder for creating a BuildCommit entity.
func (c *BuildCommitClient) Create() *BuildCommitCreate {
	mutation := newBuildCommitMutation(c.config, OpCreate)
	return &BuildCommitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BuildCommit entities.
func (c *BuildCommitClient) CreateBulk(builders ...*BuildCommitCreate) *BuildCommitCreateBulk {
	return &BuildCommitCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BuildCommitClient) MapCreateBulk(slice any, setFunc func(*BuildCommitCreate, int)) *BuildCommitCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BuildCommitCreateBulk{err: fmt.Errorf("calling to BuildCommitClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BuildCommitCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BuildCommitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BuildCommit.
func (c *BuildCommitClient) Update() *BuildCommitUpdate {
	mutation := newBuildCommitMutation(c.config, OpUpdate)
	return &BuildCommitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BuildCommitClient) UpdateOne(bc *BuildCommit) *BuildCommitUpdateOne {
	mutation := newBuildCommitMutation(c.config, OpUpdateOne, withBuildCommit(bc))
	return &BuildCommitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BuildCommitClient) UpdateOneID(id uuid.UUID) *BuildCommitUpdateOne {
	mutation := newBuildCommitMutation(c.config, OpUpdateOne, withBuildCommitID(id))
	return &BuildCommitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BuildCommit.
func (c *BuildCommitClient) Delete() *BuildCommitDelete {
	mutation := newBuildCommitMutation(c.config, OpDelete)
	return &BuildCommitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BuildCommitClient) DeleteOne(bc *BuildCommit) *BuildCommitDeleteOne {
	return c.DeleteOneID(bc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BuildCommitClient) DeleteOneID(id uuid.UUID) *BuildCommitDeleteOne {
	builder := c.Delete().Where(buildcommit.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BuildCommitDeleteOne{builder}
}

// Query returns a query builder for BuildCommit.
func (c *BuildCommitClient) Query() *BuildCommitQuery {
	return &BuildCommitQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBuildCommit},
		inters: c.Interceptors(),
	}
}

// Get returns a BuildCommit entity by its id.
func (c *BuildCommitClient) Get(ctx context.Context, id uuid.UUID) (*BuildCommit, error) {
	return c.Query().Where(buildcommit.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BuildCommitClient) GetX(ctx context.Context, id uuid.UUID) *BuildCommit {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBuildCommitToBuild queries the BuildCommitToBuild edge of a BuildCommit.
func (c *BuildCommitClient) QueryBuildCommitToBuild(bc *BuildCommit) *BuildQuery {
	query := (&BuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(buildcommit.Table, buildcommit.FieldID, id),
			sqlgraph.To(build.Table, build.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, buildcommit.BuildCommitToBuildTable, buildcommit.BuildCommitToBuildColumn),
		)
		fromV = sqlgraph.Neighbors(bc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuildCommitToServerTask queries the BuildCommitToServerTask edge of a BuildCommit.
func (c *BuildCommitClient) QueryBuildCommitToServerTask(bc *BuildCommit) *ServerTaskQuery {
	query := (&ServerTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(buildcommit.Table, buildcommit.FieldID, id),
			sqlgraph.To(servertask.Table, servertask.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, buildcommit.BuildCommitToServerTaskTable, buildcommit.BuildCommitToServerTaskColumn),
		)
		fromV = sqlgraph.Neighbors(bc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuildCommitToPlanDiffs queries the BuildCommitToPlanDiffs edge of a BuildCommit.
func (c *BuildCommitClient) QueryBuildCommitToPlanDiffs(bc *BuildCommit) *PlanDiffQuery {
	query := (&PlanDiffClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(buildcommit.Table, buildcommit.FieldID, id),
			sqlgraph.To(plandiff.Table, plandiff.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, buildcommit.BuildCommitToPlanDiffsTable, buildcommit.BuildCommitToPlanDiffsColumn),
		)
		fromV = sqlgraph.Neighbors(bc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BuildCommitClient) Hooks() []Hook {
	return c.hooks.BuildCommit
}

// Interceptors returns the client interceptors.
func (c *BuildCommitClient) Interceptors() []Interceptor {
	return c.inters.BuildCommit
}

func (c *BuildCommitClient) mutate(ctx context.Context, m *BuildCommitMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BuildCommitCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BuildCommitUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BuildCommitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BuildCommitDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BuildCommit mutation op: %q", m.Op())
	}
}

// CommandClient is a client for the Command schema.
type CommandClient struct {
	config
}

// NewCommandClient returns a client for the Command from the given config.
func NewCommandClient(c config) *CommandClient {
	return &CommandClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `command.Hooks(f(g(h())))`.
func (c *CommandClient) Use(hooks ...Hook) {
	c.hooks.Command = append(c.hooks.Command, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `command.Intercept(f(g(h())))`.
func (c *CommandClient) Intercept(interceptors ...Interceptor) {
	c.inters.Command = append(c.inters.Command, interceptors...)
}

// Create returns a builder for creating a Command entity.
func (c *CommandClient) Create() *CommandCreate {
	mutation := newCommandMutation(c.config, OpCreate)
	return &CommandCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Command entities.
func (c *CommandClient) CreateBulk(builders ...*CommandCreate) *CommandCreateBulk {
	return &CommandCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CommandClient) MapCreateBulk(slice any, setFunc func(*CommandCreate, int)) *CommandCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CommandCreateBulk{err: fmt.Errorf("calling to CommandClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CommandCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CommandCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Command.
func (c *CommandClient) Update() *CommandUpdate {
	mutation := newCommandMutation(c.config, OpUpdate)
	return &CommandUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CommandClient) UpdateOne(co *Command) *CommandUpdateOne {
	mutation := newCommandMutation(c.config, OpUpdateOne, withCommand(co))
	return &CommandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CommandClient) UpdateOneID(id uuid.UUID) *CommandUpdateOne {
	mutation := newCommandMutation(c.config, OpUpdateOne, withCommandID(id))
	return &CommandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Command.
func (c *CommandClient) Delete() *CommandDelete {
	mutation := newCommandMutation(c.config, OpDelete)
	return &CommandDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CommandClient) DeleteOne(co *Command) *CommandDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CommandClient) DeleteOneID(id uuid.UUID) *CommandDeleteOne {
	builder := c.Delete().Where(command.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CommandDeleteOne{builder}
}

// Query returns a query builder for Command.
func (c *CommandClient) Query() *CommandQuery {
	return &CommandQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCommand},
		inters: c.Interceptors(),
	}
}

// Get returns a Command entity by its id.
func (c *CommandClient) Get(ctx context.Context, id uuid.UUID) (*Command, error) {
	return c.Query().Where(command.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CommandClient) GetX(ctx context.Context, id uuid.UUID) *Command {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCommandToUser queries the CommandToUser edge of a Command.
func (c *CommandClient) QueryCommandToUser(co *Command) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(command.Table, command.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, command.CommandToUserTable, command.CommandToUserColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCommandToEnvironment queries the CommandToEnvironment edge of a Command.
func (c *CommandClient) QueryCommandToEnvironment(co *Command) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(command.Table, command.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, command.CommandToEnvironmentTable, command.CommandToEnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CommandClient) Hooks() []Hook {
	return c.hooks.Command
}

// Interceptors returns the client interceptors.
func (c *CommandClient) Interceptors() []Interceptor {
	return c.inters.Command
}

func (c *CommandClient) mutate(ctx context.Context, m *CommandMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CommandCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CommandUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CommandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CommandDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Command mutation op: %q", m.Op())
	}
}

// CompetitionClient is a client for the Competition schema.
type CompetitionClient struct {
	config
}

// NewCompetitionClient returns a client for the Competition from the given config.
func NewCompetitionClient(c config) *CompetitionClient {
	return &CompetitionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `competition.Hooks(f(g(h())))`.
func (c *CompetitionClient) Use(hooks ...Hook) {
	c.hooks.Competition = append(c.hooks.Competition, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `competition.Intercept(f(g(h())))`.
func (c *CompetitionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Competition = append(c.inters.Competition, interceptors...)
}

// Create returns a builder for creating a Competition entity.
func (c *CompetitionClient) Create() *CompetitionCreate {
	mutation := newCompetitionMutation(c.config, OpCreate)
	return &CompetitionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Competition entities.
func (c *CompetitionClient) CreateBulk(builders ...*CompetitionCreate) *CompetitionCreateBulk {
	return &CompetitionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CompetitionClient) MapCreateBulk(slice any, setFunc func(*CompetitionCreate, int)) *CompetitionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CompetitionCreateBulk{err: fmt.Errorf("calling to CompetitionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CompetitionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CompetitionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Competition.
func (c *CompetitionClient) Update() *CompetitionUpdate {
	mutation := newCompetitionMutation(c.config, OpUpdate)
	return &CompetitionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CompetitionClient) UpdateOne(co *Competition) *CompetitionUpdateOne {
	mutation := newCompetitionMutation(c.config, OpUpdateOne, withCompetition(co))
	return &CompetitionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CompetitionClient) UpdateOneID(id uuid.UUID) *CompetitionUpdateOne {
	mutation := newCompetitionMutation(c.config, OpUpdateOne, withCompetitionID(id))
	return &CompetitionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Competition.
func (c *CompetitionClient) Delete() *CompetitionDelete {
	mutation := newCompetitionMutation(c.config, OpDelete)
	return &CompetitionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CompetitionClient) DeleteOne(co *Competition) *CompetitionDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CompetitionClient) DeleteOneID(id uuid.UUID) *CompetitionDeleteOne {
	builder := c.Delete().Where(competition.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CompetitionDeleteOne{builder}
}

// Query returns a query builder for Competition.
func (c *CompetitionClient) Query() *CompetitionQuery {
	return &CompetitionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCompetition},
		inters: c.Interceptors(),
	}
}

// Get returns a Competition entity by its id.
func (c *CompetitionClient) Get(ctx context.Context, id uuid.UUID) (*Competition, error) {
	return c.Query().Where(competition.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CompetitionClient) GetX(ctx context.Context, id uuid.UUID) *Competition {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompetitionToDNS queries the CompetitionToDNS edge of a Competition.
func (c *CompetitionClient) QueryCompetitionToDNS(co *Competition) *DNSQuery {
	query := (&DNSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(competition.Table, competition.FieldID, id),
			sqlgraph.To(dns.Table, dns.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, competition.CompetitionToDNSTable, competition.CompetitionToDNSPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCompetitionToEnvironment queries the CompetitionToEnvironment edge of a Competition.
func (c *CompetitionClient) QueryCompetitionToEnvironment(co *Competition) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(competition.Table, competition.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, competition.CompetitionToEnvironmentTable, competition.CompetitionToEnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCompetitionToBuild queries the CompetitionToBuild edge of a Competition.
func (c *CompetitionClient) QueryCompetitionToBuild(co *Competition) *BuildQuery {
	query := (&BuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(competition.Table, competition.FieldID, id),
			sqlgraph.To(build.Table, build.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, competition.CompetitionToBuildTable, competition.CompetitionToBuildColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CompetitionClient) Hooks() []Hook {
	return c.hooks.Competition
}

// Interceptors returns the client interceptors.
func (c *CompetitionClient) Interceptors() []Interceptor {
	return c.inters.Competition
}

func (c *CompetitionClient) mutate(ctx context.Context, m *CompetitionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CompetitionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CompetitionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CompetitionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CompetitionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Competition mutation op: %q", m.Op())
	}
}

// DNSClient is a client for the DNS schema.
type DNSClient struct {
	config
}

// NewDNSClient returns a client for the DNS from the given config.
func NewDNSClient(c config) *DNSClient {
	return &DNSClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dns.Hooks(f(g(h())))`.
func (c *DNSClient) Use(hooks ...Hook) {
	c.hooks.DNS = append(c.hooks.DNS, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dns.Intercept(f(g(h())))`.
func (c *DNSClient) Intercept(interceptors ...Interceptor) {
	c.inters.DNS = append(c.inters.DNS, interceptors...)
}

// Create returns a builder for creating a DNS entity.
func (c *DNSClient) Create() *DNSCreate {
	mutation := newDNSMutation(c.config, OpCreate)
	return &DNSCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DNS entities.
func (c *DNSClient) CreateBulk(builders ...*DNSCreate) *DNSCreateBulk {
	return &DNSCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DNSClient) MapCreateBulk(slice any, setFunc func(*DNSCreate, int)) *DNSCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DNSCreateBulk{err: fmt.Errorf("calling to DNSClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DNSCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DNSCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DNS.
func (c *DNSClient) Update() *DNSUpdate {
	mutation := newDNSMutation(c.config, OpUpdate)
	return &DNSUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DNSClient) UpdateOne(d *DNS) *DNSUpdateOne {
	mutation := newDNSMutation(c.config, OpUpdateOne, withDNS(d))
	return &DNSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DNSClient) UpdateOneID(id uuid.UUID) *DNSUpdateOne {
	mutation := newDNSMutation(c.config, OpUpdateOne, withDNSID(id))
	return &DNSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DNS.
func (c *DNSClient) Delete() *DNSDelete {
	mutation := newDNSMutation(c.config, OpDelete)
	return &DNSDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DNSClient) DeleteOne(d *DNS) *DNSDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DNSClient) DeleteOneID(id uuid.UUID) *DNSDeleteOne {
	builder := c.Delete().Where(dns.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DNSDeleteOne{builder}
}

// Query returns a query builder for DNS.
func (c *DNSClient) Query() *DNSQuery {
	return &DNSQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDNS},
		inters: c.Interceptors(),
	}
}

// Get returns a DNS entity by its id.
func (c *DNSClient) Get(ctx context.Context, id uuid.UUID) (*DNS, error) {
	return c.Query().Where(dns.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DNSClient) GetX(ctx context.Context, id uuid.UUID) *DNS {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDNSToEnvironment queries the DNSToEnvironment edge of a DNS.
func (c *DNSClient) QueryDNSToEnvironment(d *DNS) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dns.Table, dns.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, dns.DNSToEnvironmentTable, dns.DNSToEnvironmentPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDNSToCompetition queries the DNSToCompetition edge of a DNS.
func (c *DNSClient) QueryDNSToCompetition(d *DNS) *CompetitionQuery {
	query := (&CompetitionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dns.Table, dns.FieldID, id),
			sqlgraph.To(competition.Table, competition.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, dns.DNSToCompetitionTable, dns.DNSToCompetitionPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DNSClient) Hooks() []Hook {
	return c.hooks.DNS
}

// Interceptors returns the client interceptors.
func (c *DNSClient) Interceptors() []Interceptor {
	return c.inters.DNS
}

func (c *DNSClient) mutate(ctx context.Context, m *DNSMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DNSCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DNSUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DNSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DNSDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DNS mutation op: %q", m.Op())
	}
}

// DNSRecordClient is a client for the DNSRecord schema.
type DNSRecordClient struct {
	config
}

// NewDNSRecordClient returns a client for the DNSRecord from the given config.
func NewDNSRecordClient(c config) *DNSRecordClient {
	return &DNSRecordClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dnsrecord.Hooks(f(g(h())))`.
func (c *DNSRecordClient) Use(hooks ...Hook) {
	c.hooks.DNSRecord = append(c.hooks.DNSRecord, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dnsrecord.Intercept(f(g(h())))`.
func (c *DNSRecordClient) Intercept(interceptors ...Interceptor) {
	c.inters.DNSRecord = append(c.inters.DNSRecord, interceptors...)
}

// Create returns a builder for creating a DNSRecord entity.
func (c *DNSRecordClient) Create() *DNSRecordCreate {
	mutation := newDNSRecordMutation(c.config, OpCreate)
	return &DNSRecordCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DNSRecord entities.
func (c *DNSRecordClient) CreateBulk(builders ...*DNSRecordCreate) *DNSRecordCreateBulk {
	return &DNSRecordCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DNSRecordClient) MapCreateBulk(slice any, setFunc func(*DNSRecordCreate, int)) *DNSRecordCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DNSRecordCreateBulk{err: fmt.Errorf("calling to DNSRecordClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DNSRecordCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DNSRecordCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DNSRecord.
func (c *DNSRecordClient) Update() *DNSRecordUpdate {
	mutation := newDNSRecordMutation(c.config, OpUpdate)
	return &DNSRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DNSRecordClient) UpdateOne(dr *DNSRecord) *DNSRecordUpdateOne {
	mutation := newDNSRecordMutation(c.config, OpUpdateOne, withDNSRecord(dr))
	return &DNSRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DNSRecordClient) UpdateOneID(id uuid.UUID) *DNSRecordUpdateOne {
	mutation := newDNSRecordMutation(c.config, OpUpdateOne, withDNSRecordID(id))
	return &DNSRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DNSRecord.
func (c *DNSRecordClient) Delete() *DNSRecordDelete {
	mutation := newDNSRecordMutation(c.config, OpDelete)
	return &DNSRecordDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DNSRecordClient) DeleteOne(dr *DNSRecord) *DNSRecordDeleteOne {
	return c.DeleteOneID(dr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DNSRecordClient) DeleteOneID(id uuid.UUID) *DNSRecordDeleteOne {
	builder := c.Delete().Where(dnsrecord.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DNSRecordDeleteOne{builder}
}

// Query returns a query builder for DNSRecord.
func (c *DNSRecordClient) Query() *DNSRecordQuery {
	return &DNSRecordQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDNSRecord},
		inters: c.Interceptors(),
	}
}

// Get returns a DNSRecord entity by its id.
func (c *DNSRecordClient) Get(ctx context.Context, id uuid.UUID) (*DNSRecord, error) {
	return c.Query().Where(dnsrecord.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DNSRecordClient) GetX(ctx context.Context, id uuid.UUID) *DNSRecord {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDNSRecordToEnvironment queries the DNSRecordToEnvironment edge of a DNSRecord.
func (c *DNSRecordClient) QueryDNSRecordToEnvironment(dr *DNSRecord) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dnsrecord.Table, dnsrecord.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, dnsrecord.DNSRecordToEnvironmentTable, dnsrecord.DNSRecordToEnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(dr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DNSRecordClient) Hooks() []Hook {
	return c.hooks.DNSRecord
}

// Interceptors returns the client interceptors.
func (c *DNSRecordClient) Interceptors() []Interceptor {
	return c.inters.DNSRecord
}

func (c *DNSRecordClient) mutate(ctx context.Context, m *DNSRecordMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DNSRecordCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DNSRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DNSRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DNSRecordDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DNSRecord mutation op: %q", m.Op())
	}
}

// DiskClient is a client for the Disk schema.
type DiskClient struct {
	config
}

// NewDiskClient returns a client for the Disk from the given config.
func NewDiskClient(c config) *DiskClient {
	return &DiskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `disk.Hooks(f(g(h())))`.
func (c *DiskClient) Use(hooks ...Hook) {
	c.hooks.Disk = append(c.hooks.Disk, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `disk.Intercept(f(g(h())))`.
func (c *DiskClient) Intercept(interceptors ...Interceptor) {
	c.inters.Disk = append(c.inters.Disk, interceptors...)
}

// Create returns a builder for creating a Disk entity.
func (c *DiskClient) Create() *DiskCreate {
	mutation := newDiskMutation(c.config, OpCreate)
	return &DiskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Disk entities.
func (c *DiskClient) CreateBulk(builders ...*DiskCreate) *DiskCreateBulk {
	return &DiskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DiskClient) MapCreateBulk(slice any, setFunc func(*DiskCreate, int)) *DiskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DiskCreateBulk{err: fmt.Errorf("calling to DiskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DiskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DiskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Disk.
func (c *DiskClient) Update() *DiskUpdate {
	mutation := newDiskMutation(c.config, OpUpdate)
	return &DiskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DiskClient) UpdateOne(d *Disk) *DiskUpdateOne {
	mutation := newDiskMutation(c.config, OpUpdateOne, withDisk(d))
	return &DiskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DiskClient) UpdateOneID(id uuid.UUID) *DiskUpdateOne {
	mutation := newDiskMutation(c.config, OpUpdateOne, withDiskID(id))
	return &DiskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Disk.
func (c *DiskClient) Delete() *DiskDelete {
	mutation := newDiskMutation(c.config, OpDelete)
	return &DiskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DiskClient) DeleteOne(d *Disk) *DiskDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DiskClient) DeleteOneID(id uuid.UUID) *DiskDeleteOne {
	builder := c.Delete().Where(disk.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DiskDeleteOne{builder}
}

// Query returns a query builder for Disk.
func (c *DiskClient) Query() *DiskQuery {
	return &DiskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDisk},
		inters: c.Interceptors(),
	}
}

// Get returns a Disk entity by its id.
func (c *DiskClient) Get(ctx context.Context, id uuid.UUID) (*Disk, error) {
	return c.Query().Where(disk.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DiskClient) GetX(ctx context.Context, id uuid.UUID) *Disk {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDiskToHost queries the DiskToHost edge of a Disk.
func (c *DiskClient) QueryDiskToHost(d *Disk) *HostQuery {
	query := (&HostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(disk.Table, disk.FieldID, id),
			sqlgraph.To(host.Table, host.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, disk.DiskToHostTable, disk.DiskToHostColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DiskClient) Hooks() []Hook {
	return c.hooks.Disk
}

// Interceptors returns the client interceptors.
func (c *DiskClient) Interceptors() []Interceptor {
	return c.inters.Disk
}

func (c *DiskClient) mutate(ctx context.Context, m *DiskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DiskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DiskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DiskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DiskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Disk mutation op: %q", m.Op())
	}
}

// EnvironmentClient is a client for the Environment schema.
type EnvironmentClient struct {
	config
}

// NewEnvironmentClient returns a client for the Environment from the given config.
func NewEnvironmentClient(c config) *EnvironmentClient {
	return &EnvironmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `environment.Hooks(f(g(h())))`.
func (c *EnvironmentClient) Use(hooks ...Hook) {
	c.hooks.Environment = append(c.hooks.Environment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `environment.Intercept(f(g(h())))`.
func (c *EnvironmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Environment = append(c.inters.Environment, interceptors...)
}

// Create returns a builder for creating a Environment entity.
func (c *EnvironmentClient) Create() *EnvironmentCreate {
	mutation := newEnvironmentMutation(c.config, OpCreate)
	return &EnvironmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Environment entities.
func (c *EnvironmentClient) CreateBulk(builders ...*EnvironmentCreate) *EnvironmentCreateBulk {
	return &EnvironmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EnvironmentClient) MapCreateBulk(slice any, setFunc func(*EnvironmentCreate, int)) *EnvironmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EnvironmentCreateBulk{err: fmt.Errorf("calling to EnvironmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EnvironmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EnvironmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Environment.
func (c *EnvironmentClient) Update() *EnvironmentUpdate {
	mutation := newEnvironmentMutation(c.config, OpUpdate)
	return &EnvironmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EnvironmentClient) UpdateOne(e *Environment) *EnvironmentUpdateOne {
	mutation := newEnvironmentMutation(c.config, OpUpdateOne, withEnvironment(e))
	return &EnvironmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EnvironmentClient) UpdateOneID(id uuid.UUID) *EnvironmentUpdateOne {
	mutation := newEnvironmentMutation(c.config, OpUpdateOne, withEnvironmentID(id))
	return &EnvironmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Environment.
func (c *EnvironmentClient) Delete() *EnvironmentDelete {
	mutation := newEnvironmentMutation(c.config, OpDelete)
	return &EnvironmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EnvironmentClient) DeleteOne(e *Environment) *EnvironmentDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EnvironmentClient) DeleteOneID(id uuid.UUID) *EnvironmentDeleteOne {
	builder := c.Delete().Where(environment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EnvironmentDeleteOne{builder}
}

// Query returns a query builder for Environment.
func (c *EnvironmentClient) Query() *EnvironmentQuery {
	return &EnvironmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEnvironment},
		inters: c.Interceptors(),
	}
}

// Get returns a Environment entity by its id.
func (c *EnvironmentClient) Get(ctx context.Context, id uuid.UUID) (*Environment, error) {
	return c.Query().Where(environment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EnvironmentClient) GetX(ctx context.Context, id uuid.UUID) *Environment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEnvironmentToUser queries the EnvironmentToUser edge of a Environment.
func (c *EnvironmentClient) QueryEnvironmentToUser(e *Environment) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, environment.EnvironmentToUserTable, environment.EnvironmentToUserPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironmentToHost queries the EnvironmentToHost edge of a Environment.
func (c *EnvironmentClient) QueryEnvironmentToHost(e *Environment) *HostQuery {
	query := (&HostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(host.Table, host.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.EnvironmentToHostTable, environment.EnvironmentToHostColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironmentToCompetition queries the EnvironmentToCompetition edge of a Environment.
func (c *EnvironmentClient) QueryEnvironmentToCompetition(e *Environment) *CompetitionQuery {
	query := (&CompetitionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(competition.Table, competition.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.EnvironmentToCompetitionTable, environment.EnvironmentToCompetitionColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironmentToIdentity queries the EnvironmentToIdentity edge of a Environment.
func (c *EnvironmentClient) QueryEnvironmentToIdentity(e *Environment) *IdentityQuery {
	query := (&IdentityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(identity.Table, identity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.EnvironmentToIdentityTable, environment.EnvironmentToIdentityColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironmentToCommand queries the EnvironmentToCommand edge of a Environment.
func (c *EnvironmentClient) QueryEnvironmentToCommand(e *Environment) *CommandQuery {
	query := (&CommandClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(command.Table, command.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.EnvironmentToCommandTable, environment.EnvironmentToCommandColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironmentToScript queries the EnvironmentToScript edge of a Environment.
func (c *EnvironmentClient) QueryEnvironmentToScript(e *Environment) *ScriptQuery {
	query := (&ScriptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(script.Table, script.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.EnvironmentToScriptTable, environment.EnvironmentToScriptColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironmentToFileDownload queries the EnvironmentToFileDownload edge of a Environment.
func (c *EnvironmentClient) QueryEnvironmentToFileDownload(e *Environment) *FileDownloadQuery {
	query := (&FileDownloadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(filedownload.Table, filedownload.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.EnvironmentToFileDownloadTable, environment.EnvironmentToFileDownloadColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironmentToFileDelete queries the EnvironmentToFileDelete edge of a Environment.
func (c *EnvironmentClient) QueryEnvironmentToFileDelete(e *Environment) *FileDeleteQuery {
	query := (&FileDeleteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(filedelete.Table, filedelete.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.EnvironmentToFileDeleteTable, environment.EnvironmentToFileDeleteColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironmentToFileExtract queries the EnvironmentToFileExtract edge of a Environment.
func (c *EnvironmentClient) QueryEnvironmentToFileExtract(e *Environment) *FileExtractQuery {
	query := (&FileExtractClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(fileextract.Table, fileextract.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.EnvironmentToFileExtractTable, environment.EnvironmentToFileExtractColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironmentToIncludedNetwork queries the EnvironmentToIncludedNetwork edge of a Environment.
func (c *EnvironmentClient) QueryEnvironmentToIncludedNetwork(e *Environment) *IncludedNetworkQuery {
	query := (&IncludedNetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(includednetwork.Table, includednetwork.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, environment.EnvironmentToIncludedNetworkTable, environment.EnvironmentToIncludedNetworkPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironmentToFinding queries the EnvironmentToFinding edge of a Environment.
func (c *EnvironmentClient) QueryEnvironmentToFinding(e *Environment) *FindingQuery {
	query := (&FindingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(finding.Table, finding.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.EnvironmentToFindingTable, environment.EnvironmentToFindingColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironmentToDNSRecord queries the EnvironmentToDNSRecord edge of a Environment.
func (c *EnvironmentClient) QueryEnvironmentToDNSRecord(e *Environment) *DNSRecordQuery {
	query := (&DNSRecordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(dnsrecord.Table, dnsrecord.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.EnvironmentToDNSRecordTable, environment.EnvironmentToDNSRecordColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironmentToDNS queries the EnvironmentToDNS edge of a Environment.
func (c *EnvironmentClient) QueryEnvironmentToDNS(e *Environment) *DNSQuery {
	query := (&DNSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(dns.Table, dns.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, environment.EnvironmentToDNSTable, environment.EnvironmentToDNSPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironmentToNetwork queries the EnvironmentToNetwork edge of a Environment.
func (c *EnvironmentClient) QueryEnvironmentToNetwork(e *Environment) *NetworkQuery {
	query := (&NetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(network.Table, network.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.EnvironmentToNetworkTable, environment.EnvironmentToNetworkColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironmentToHostDependency queries the EnvironmentToHostDependency edge of a Environment.
func (c *EnvironmentClient) QueryEnvironmentToHostDependency(e *Environment) *HostDependencyQuery {
	query := (&HostDependencyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(hostdependency.Table, hostdependency.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.EnvironmentToHostDependencyTable, environment.EnvironmentToHostDependencyColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironmentToAnsible queries the EnvironmentToAnsible edge of a Environment.
func (c *EnvironmentClient) QueryEnvironmentToAnsible(e *Environment) *AnsibleQuery {
	query := (&AnsibleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(ansible.Table, ansible.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.EnvironmentToAnsibleTable, environment.EnvironmentToAnsibleColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironmentToBuild queries the EnvironmentToBuild edge of a Environment.
func (c *EnvironmentClient) QueryEnvironmentToBuild(e *Environment) *BuildQuery {
	query := (&BuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(build.Table, build.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, environment.EnvironmentToBuildTable, environment.EnvironmentToBuildColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironmentToRepository queries the EnvironmentToRepository edge of a Environment.
func (c *EnvironmentClient) QueryEnvironmentToRepository(e *Environment) *RepositoryQuery {
	query := (&RepositoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(repository.Table, repository.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, environment.EnvironmentToRepositoryTable, environment.EnvironmentToRepositoryPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironmentToServerTask queries the EnvironmentToServerTask edge of a Environment.
func (c *EnvironmentClient) QueryEnvironmentToServerTask(e *Environment) *ServerTaskQuery {
	query := (&ServerTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(servertask.Table, servertask.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, environment.EnvironmentToServerTaskTable, environment.EnvironmentToServerTaskColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EnvironmentClient) Hooks() []Hook {
	return c.hooks.Environment
}

// Interceptors returns the client interceptors.
func (c *EnvironmentClient) Interceptors() []Interceptor {
	return c.inters.Environment
}

func (c *EnvironmentClient) mutate(ctx context.Context, m *EnvironmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EnvironmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EnvironmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EnvironmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EnvironmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Environment mutation op: %q", m.Op())
	}
}

// FileDeleteClient is a client for the FileDelete schema.
type FileDeleteClient struct {
	config
}

// NewFileDeleteClient returns a client for the FileDelete from the given config.
func NewFileDeleteClient(c config) *FileDeleteClient {
	return &FileDeleteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `filedelete.Hooks(f(g(h())))`.
func (c *FileDeleteClient) Use(hooks ...Hook) {
	c.hooks.FileDelete = append(c.hooks.FileDelete, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `filedelete.Intercept(f(g(h())))`.
func (c *FileDeleteClient) Intercept(interceptors ...Interceptor) {
	c.inters.FileDelete = append(c.inters.FileDelete, interceptors...)
}

// Create returns a builder for creating a FileDelete entity.
func (c *FileDeleteClient) Create() *FileDeleteCreate {
	mutation := newFileDeleteMutation(c.config, OpCreate)
	return &FileDeleteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FileDelete entities.
func (c *FileDeleteClient) CreateBulk(builders ...*FileDeleteCreate) *FileDeleteCreateBulk {
	return &FileDeleteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FileDeleteClient) MapCreateBulk(slice any, setFunc func(*FileDeleteCreate, int)) *FileDeleteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FileDeleteCreateBulk{err: fmt.Errorf("calling to FileDeleteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FileDeleteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FileDeleteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FileDelete.
func (c *FileDeleteClient) Update() *FileDeleteUpdate {
	mutation := newFileDeleteMutation(c.config, OpUpdate)
	return &FileDeleteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FileDeleteClient) UpdateOne(fd *FileDelete) *FileDeleteUpdateOne {
	mutation := newFileDeleteMutation(c.config, OpUpdateOne, withFileDelete(fd))
	return &FileDeleteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FileDeleteClient) UpdateOneID(id uuid.UUID) *FileDeleteUpdateOne {
	mutation := newFileDeleteMutation(c.config, OpUpdateOne, withFileDeleteID(id))
	return &FileDeleteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FileDelete.
func (c *FileDeleteClient) Delete() *FileDeleteDelete {
	mutation := newFileDeleteMutation(c.config, OpDelete)
	return &FileDeleteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FileDeleteClient) DeleteOne(fd *FileDelete) *FileDeleteDeleteOne {
	return c.DeleteOneID(fd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FileDeleteClient) DeleteOneID(id uuid.UUID) *FileDeleteDeleteOne {
	builder := c.Delete().Where(filedelete.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FileDeleteDeleteOne{builder}
}

// Query returns a query builder for FileDelete.
func (c *FileDeleteClient) Query() *FileDeleteQuery {
	return &FileDeleteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFileDelete},
		inters: c.Interceptors(),
	}
}

// Get returns a FileDelete entity by its id.
func (c *FileDeleteClient) Get(ctx context.Context, id uuid.UUID) (*FileDelete, error) {
	return c.Query().Where(filedelete.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FileDeleteClient) GetX(ctx context.Context, id uuid.UUID) *FileDelete {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFileDeleteToEnvironment queries the FileDeleteToEnvironment edge of a FileDelete.
func (c *FileDeleteClient) QueryFileDeleteToEnvironment(fd *FileDelete) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(filedelete.Table, filedelete.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, filedelete.FileDeleteToEnvironmentTable, filedelete.FileDeleteToEnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(fd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FileDeleteClient) Hooks() []Hook {
	return c.hooks.FileDelete
}

// Interceptors returns the client interceptors.
func (c *FileDeleteClient) Interceptors() []Interceptor {
	return c.inters.FileDelete
}

func (c *FileDeleteClient) mutate(ctx context.Context, m *FileDeleteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FileDeleteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FileDeleteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FileDeleteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FileDeleteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FileDelete mutation op: %q", m.Op())
	}
}

// FileDownloadClient is a client for the FileDownload schema.
type FileDownloadClient struct {
	config
}

// NewFileDownloadClient returns a client for the FileDownload from the given config.
func NewFileDownloadClient(c config) *FileDownloadClient {
	return &FileDownloadClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `filedownload.Hooks(f(g(h())))`.
func (c *FileDownloadClient) Use(hooks ...Hook) {
	c.hooks.FileDownload = append(c.hooks.FileDownload, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `filedownload.Intercept(f(g(h())))`.
func (c *FileDownloadClient) Intercept(interceptors ...Interceptor) {
	c.inters.FileDownload = append(c.inters.FileDownload, interceptors...)
}

// Create returns a builder for creating a FileDownload entity.
func (c *FileDownloadClient) Create() *FileDownloadCreate {
	mutation := newFileDownloadMutation(c.config, OpCreate)
	return &FileDownloadCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FileDownload entities.
func (c *FileDownloadClient) CreateBulk(builders ...*FileDownloadCreate) *FileDownloadCreateBulk {
	return &FileDownloadCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FileDownloadClient) MapCreateBulk(slice any, setFunc func(*FileDownloadCreate, int)) *FileDownloadCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FileDownloadCreateBulk{err: fmt.Errorf("calling to FileDownloadClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FileDownloadCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FileDownloadCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FileDownload.
func (c *FileDownloadClient) Update() *FileDownloadUpdate {
	mutation := newFileDownloadMutation(c.config, OpUpdate)
	return &FileDownloadUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FileDownloadClient) UpdateOne(fd *FileDownload) *FileDownloadUpdateOne {
	mutation := newFileDownloadMutation(c.config, OpUpdateOne, withFileDownload(fd))
	return &FileDownloadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FileDownloadClient) UpdateOneID(id uuid.UUID) *FileDownloadUpdateOne {
	mutation := newFileDownloadMutation(c.config, OpUpdateOne, withFileDownloadID(id))
	return &FileDownloadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FileDownload.
func (c *FileDownloadClient) Delete() *FileDownloadDelete {
	mutation := newFileDownloadMutation(c.config, OpDelete)
	return &FileDownloadDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FileDownloadClient) DeleteOne(fd *FileDownload) *FileDownloadDeleteOne {
	return c.DeleteOneID(fd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FileDownloadClient) DeleteOneID(id uuid.UUID) *FileDownloadDeleteOne {
	builder := c.Delete().Where(filedownload.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FileDownloadDeleteOne{builder}
}

// Query returns a query builder for FileDownload.
func (c *FileDownloadClient) Query() *FileDownloadQuery {
	return &FileDownloadQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFileDownload},
		inters: c.Interceptors(),
	}
}

// Get returns a FileDownload entity by its id.
func (c *FileDownloadClient) Get(ctx context.Context, id uuid.UUID) (*FileDownload, error) {
	return c.Query().Where(filedownload.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FileDownloadClient) GetX(ctx context.Context, id uuid.UUID) *FileDownload {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFileDownloadToEnvironment queries the FileDownloadToEnvironment edge of a FileDownload.
func (c *FileDownloadClient) QueryFileDownloadToEnvironment(fd *FileDownload) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(filedownload.Table, filedownload.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, filedownload.FileDownloadToEnvironmentTable, filedownload.FileDownloadToEnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(fd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FileDownloadClient) Hooks() []Hook {
	return c.hooks.FileDownload
}

// Interceptors returns the client interceptors.
func (c *FileDownloadClient) Interceptors() []Interceptor {
	return c.inters.FileDownload
}

func (c *FileDownloadClient) mutate(ctx context.Context, m *FileDownloadMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FileDownloadCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FileDownloadUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FileDownloadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FileDownloadDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FileDownload mutation op: %q", m.Op())
	}
}

// FileExtractClient is a client for the FileExtract schema.
type FileExtractClient struct {
	config
}

// NewFileExtractClient returns a client for the FileExtract from the given config.
func NewFileExtractClient(c config) *FileExtractClient {
	return &FileExtractClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fileextract.Hooks(f(g(h())))`.
func (c *FileExtractClient) Use(hooks ...Hook) {
	c.hooks.FileExtract = append(c.hooks.FileExtract, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `fileextract.Intercept(f(g(h())))`.
func (c *FileExtractClient) Intercept(interceptors ...Interceptor) {
	c.inters.FileExtract = append(c.inters.FileExtract, interceptors...)
}

// Create returns a builder for creating a FileExtract entity.
func (c *FileExtractClient) Create() *FileExtractCreate {
	mutation := newFileExtractMutation(c.config, OpCreate)
	return &FileExtractCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FileExtract entities.
func (c *FileExtractClient) CreateBulk(builders ...*FileExtractCreate) *FileExtractCreateBulk {
	return &FileExtractCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FileExtractClient) MapCreateBulk(slice any, setFunc func(*FileExtractCreate, int)) *FileExtractCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FileExtractCreateBulk{err: fmt.Errorf("calling to FileExtractClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FileExtractCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FileExtractCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FileExtract.
func (c *FileExtractClient) Update() *FileExtractUpdate {
	mutation := newFileExtractMutation(c.config, OpUpdate)
	return &FileExtractUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FileExtractClient) UpdateOne(fe *FileExtract) *FileExtractUpdateOne {
	mutation := newFileExtractMutation(c.config, OpUpdateOne, withFileExtract(fe))
	return &FileExtractUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FileExtractClient) UpdateOneID(id uuid.UUID) *FileExtractUpdateOne {
	mutation := newFileExtractMutation(c.config, OpUpdateOne, withFileExtractID(id))
	return &FileExtractUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FileExtract.
func (c *FileExtractClient) Delete() *FileExtractDelete {
	mutation := newFileExtractMutation(c.config, OpDelete)
	return &FileExtractDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FileExtractClient) DeleteOne(fe *FileExtract) *FileExtractDeleteOne {
	return c.DeleteOneID(fe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FileExtractClient) DeleteOneID(id uuid.UUID) *FileExtractDeleteOne {
	builder := c.Delete().Where(fileextract.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FileExtractDeleteOne{builder}
}

// Query returns a query builder for FileExtract.
func (c *FileExtractClient) Query() *FileExtractQuery {
	return &FileExtractQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFileExtract},
		inters: c.Interceptors(),
	}
}

// Get returns a FileExtract entity by its id.
func (c *FileExtractClient) Get(ctx context.Context, id uuid.UUID) (*FileExtract, error) {
	return c.Query().Where(fileextract.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FileExtractClient) GetX(ctx context.Context, id uuid.UUID) *FileExtract {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFileExtractToEnvironment queries the FileExtractToEnvironment edge of a FileExtract.
func (c *FileExtractClient) QueryFileExtractToEnvironment(fe *FileExtract) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fileextract.Table, fileextract.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fileextract.FileExtractToEnvironmentTable, fileextract.FileExtractToEnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(fe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FileExtractClient) Hooks() []Hook {
	return c.hooks.FileExtract
}

// Interceptors returns the client interceptors.
func (c *FileExtractClient) Interceptors() []Interceptor {
	return c.inters.FileExtract
}

func (c *FileExtractClient) mutate(ctx context.Context, m *FileExtractMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FileExtractCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FileExtractUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FileExtractUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FileExtractDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FileExtract mutation op: %q", m.Op())
	}
}

// FindingClient is a client for the Finding schema.
type FindingClient struct {
	config
}

// NewFindingClient returns a client for the Finding from the given config.
func NewFindingClient(c config) *FindingClient {
	return &FindingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `finding.Hooks(f(g(h())))`.
func (c *FindingClient) Use(hooks ...Hook) {
	c.hooks.Finding = append(c.hooks.Finding, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `finding.Intercept(f(g(h())))`.
func (c *FindingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Finding = append(c.inters.Finding, interceptors...)
}

// Create returns a builder for creating a Finding entity.
func (c *FindingClient) Create() *FindingCreate {
	mutation := newFindingMutation(c.config, OpCreate)
	return &FindingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Finding entities.
func (c *FindingClient) CreateBulk(builders ...*FindingCreate) *FindingCreateBulk {
	return &FindingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FindingClient) MapCreateBulk(slice any, setFunc func(*FindingCreate, int)) *FindingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FindingCreateBulk{err: fmt.Errorf("calling to FindingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FindingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FindingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Finding.
func (c *FindingClient) Update() *FindingUpdate {
	mutation := newFindingMutation(c.config, OpUpdate)
	return &FindingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FindingClient) UpdateOne(f *Finding) *FindingUpdateOne {
	mutation := newFindingMutation(c.config, OpUpdateOne, withFinding(f))
	return &FindingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FindingClient) UpdateOneID(id uuid.UUID) *FindingUpdateOne {
	mutation := newFindingMutation(c.config, OpUpdateOne, withFindingID(id))
	return &FindingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Finding.
func (c *FindingClient) Delete() *FindingDelete {
	mutation := newFindingMutation(c.config, OpDelete)
	return &FindingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FindingClient) DeleteOne(f *Finding) *FindingDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FindingClient) DeleteOneID(id uuid.UUID) *FindingDeleteOne {
	builder := c.Delete().Where(finding.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FindingDeleteOne{builder}
}

// Query returns a query builder for Finding.
func (c *FindingClient) Query() *FindingQuery {
	return &FindingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFinding},
		inters: c.Interceptors(),
	}
}

// Get returns a Finding entity by its id.
func (c *FindingClient) Get(ctx context.Context, id uuid.UUID) (*Finding, error) {
	return c.Query().Where(finding.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FindingClient) GetX(ctx context.Context, id uuid.UUID) *Finding {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryFindingToUser queries the FindingToUser edge of a Finding.
func (c *FindingClient) QueryFindingToUser(f *Finding) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, finding.FindingToUserTable, finding.FindingToUserColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFindingToHost queries the FindingToHost edge of a Finding.
func (c *FindingClient) QueryFindingToHost(f *Finding) *HostQuery {
	query := (&HostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(host.Table, host.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, finding.FindingToHostTable, finding.FindingToHostColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFindingToScript queries the FindingToScript edge of a Finding.
func (c *FindingClient) QueryFindingToScript(f *Finding) *ScriptQuery {
	query := (&ScriptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(script.Table, script.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, finding.FindingToScriptTable, finding.FindingToScriptColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFindingToEnvironment queries the FindingToEnvironment edge of a Finding.
func (c *FindingClient) QueryFindingToEnvironment(f *Finding) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, finding.FindingToEnvironmentTable, finding.FindingToEnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FindingClient) Hooks() []Hook {
	return c.hooks.Finding
}

// Interceptors returns the client interceptors.
func (c *FindingClient) Interceptors() []Interceptor {
	return c.inters.Finding
}

func (c *FindingClient) mutate(ctx context.Context, m *FindingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FindingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FindingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FindingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FindingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Finding mutation op: %q", m.Op())
	}
}

// GinFileMiddlewareClient is a client for the GinFileMiddleware schema.
type GinFileMiddlewareClient struct {
	config
}

// NewGinFileMiddlewareClient returns a client for the GinFileMiddleware from the given config.
func NewGinFileMiddlewareClient(c config) *GinFileMiddlewareClient {
	return &GinFileMiddlewareClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ginfilemiddleware.Hooks(f(g(h())))`.
func (c *GinFileMiddlewareClient) Use(hooks ...Hook) {
	c.hooks.GinFileMiddleware = append(c.hooks.GinFileMiddleware, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ginfilemiddleware.Intercept(f(g(h())))`.
func (c *GinFileMiddlewareClient) Intercept(interceptors ...Interceptor) {
	c.inters.GinFileMiddleware = append(c.inters.GinFileMiddleware, interceptors...)
}

// Create returns a builder for creating a GinFileMiddleware entity.
func (c *GinFileMiddlewareClient) Create() *GinFileMiddlewareCreate {
	mutation := newGinFileMiddlewareMutation(c.config, OpCreate)
	return &GinFileMiddlewareCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GinFileMiddleware entities.
func (c *GinFileMiddlewareClient) CreateBulk(builders ...*GinFileMiddlewareCreate) *GinFileMiddlewareCreateBulk {
	return &GinFileMiddlewareCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GinFileMiddlewareClient) MapCreateBulk(slice any, setFunc func(*GinFileMiddlewareCreate, int)) *GinFileMiddlewareCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GinFileMiddlewareCreateBulk{err: fmt.Errorf("calling to GinFileMiddlewareClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GinFileMiddlewareCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GinFileMiddlewareCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GinFileMiddleware.
func (c *GinFileMiddlewareClient) Update() *GinFileMiddlewareUpdate {
	mutation := newGinFileMiddlewareMutation(c.config, OpUpdate)
	return &GinFileMiddlewareUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GinFileMiddlewareClient) UpdateOne(gfm *GinFileMiddleware) *GinFileMiddlewareUpdateOne {
	mutation := newGinFileMiddlewareMutation(c.config, OpUpdateOne, withGinFileMiddleware(gfm))
	return &GinFileMiddlewareUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GinFileMiddlewareClient) UpdateOneID(id uuid.UUID) *GinFileMiddlewareUpdateOne {
	mutation := newGinFileMiddlewareMutation(c.config, OpUpdateOne, withGinFileMiddlewareID(id))
	return &GinFileMiddlewareUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GinFileMiddleware.
func (c *GinFileMiddlewareClient) Delete() *GinFileMiddlewareDelete {
	mutation := newGinFileMiddlewareMutation(c.config, OpDelete)
	return &GinFileMiddlewareDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GinFileMiddlewareClient) DeleteOne(gfm *GinFileMiddleware) *GinFileMiddlewareDeleteOne {
	return c.DeleteOneID(gfm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GinFileMiddlewareClient) DeleteOneID(id uuid.UUID) *GinFileMiddlewareDeleteOne {
	builder := c.Delete().Where(ginfilemiddleware.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GinFileMiddlewareDeleteOne{builder}
}

// Query returns a query builder for GinFileMiddleware.
func (c *GinFileMiddlewareClient) Query() *GinFileMiddlewareQuery {
	return &GinFileMiddlewareQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGinFileMiddleware},
		inters: c.Interceptors(),
	}
}

// Get returns a GinFileMiddleware entity by its id.
func (c *GinFileMiddlewareClient) Get(ctx context.Context, id uuid.UUID) (*GinFileMiddleware, error) {
	return c.Query().Where(ginfilemiddleware.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GinFileMiddlewareClient) GetX(ctx context.Context, id uuid.UUID) *GinFileMiddleware {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGinFileMiddlewareToProvisionedHost queries the GinFileMiddlewareToProvisionedHost edge of a GinFileMiddleware.
func (c *GinFileMiddlewareClient) QueryGinFileMiddlewareToProvisionedHost(gfm *GinFileMiddleware) *ProvisionedHostQuery {
	query := (&ProvisionedHostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gfm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ginfilemiddleware.Table, ginfilemiddleware.FieldID, id),
			sqlgraph.To(provisionedhost.Table, provisionedhost.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, ginfilemiddleware.GinFileMiddlewareToProvisionedHostTable, ginfilemiddleware.GinFileMiddlewareToProvisionedHostColumn),
		)
		fromV = sqlgraph.Neighbors(gfm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGinFileMiddlewareToProvisioningStep queries the GinFileMiddlewareToProvisioningStep edge of a GinFileMiddleware.
func (c *GinFileMiddlewareClient) QueryGinFileMiddlewareToProvisioningStep(gfm *GinFileMiddleware) *ProvisioningStepQuery {
	query := (&ProvisioningStepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gfm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ginfilemiddleware.Table, ginfilemiddleware.FieldID, id),
			sqlgraph.To(provisioningstep.Table, provisioningstep.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, ginfilemiddleware.GinFileMiddlewareToProvisioningStepTable, ginfilemiddleware.GinFileMiddlewareToProvisioningStepColumn),
		)
		fromV = sqlgraph.Neighbors(gfm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GinFileMiddlewareClient) Hooks() []Hook {
	return c.hooks.GinFileMiddleware
}

// Interceptors returns the client interceptors.
func (c *GinFileMiddlewareClient) Interceptors() []Interceptor {
	return c.inters.GinFileMiddleware
}

func (c *GinFileMiddlewareClient) mutate(ctx context.Context, m *GinFileMiddlewareMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GinFileMiddlewareCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GinFileMiddlewareUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GinFileMiddlewareUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GinFileMiddlewareDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GinFileMiddleware mutation op: %q", m.Op())
	}
}

// HostClient is a client for the Host schema.
type HostClient struct {
	config
}

// NewHostClient returns a client for the Host from the given config.
func NewHostClient(c config) *HostClient {
	return &HostClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `host.Hooks(f(g(h())))`.
func (c *HostClient) Use(hooks ...Hook) {
	c.hooks.Host = append(c.hooks.Host, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `host.Intercept(f(g(h())))`.
func (c *HostClient) Intercept(interceptors ...Interceptor) {
	c.inters.Host = append(c.inters.Host, interceptors...)
}

// Create returns a builder for creating a Host entity.
func (c *HostClient) Create() *HostCreate {
	mutation := newHostMutation(c.config, OpCreate)
	return &HostCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Host entities.
func (c *HostClient) CreateBulk(builders ...*HostCreate) *HostCreateBulk {
	return &HostCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HostClient) MapCreateBulk(slice any, setFunc func(*HostCreate, int)) *HostCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HostCreateBulk{err: fmt.Errorf("calling to HostClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HostCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HostCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Host.
func (c *HostClient) Update() *HostUpdate {
	mutation := newHostMutation(c.config, OpUpdate)
	return &HostUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HostClient) UpdateOne(h *Host) *HostUpdateOne {
	mutation := newHostMutation(c.config, OpUpdateOne, withHost(h))
	return &HostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HostClient) UpdateOneID(id uuid.UUID) *HostUpdateOne {
	mutation := newHostMutation(c.config, OpUpdateOne, withHostID(id))
	return &HostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Host.
func (c *HostClient) Delete() *HostDelete {
	mutation := newHostMutation(c.config, OpDelete)
	return &HostDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HostClient) DeleteOne(h *Host) *HostDeleteOne {
	return c.DeleteOneID(h.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HostClient) DeleteOneID(id uuid.UUID) *HostDeleteOne {
	builder := c.Delete().Where(host.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HostDeleteOne{builder}
}

// Query returns a query builder for Host.
func (c *HostClient) Query() *HostQuery {
	return &HostQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHost},
		inters: c.Interceptors(),
	}
}

// Get returns a Host entity by its id.
func (c *HostClient) Get(ctx context.Context, id uuid.UUID) (*Host, error) {
	return c.Query().Where(host.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HostClient) GetX(ctx context.Context, id uuid.UUID) *Host {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryHostToDisk queries the HostToDisk edge of a Host.
func (c *HostClient) QueryHostToDisk(h *Host) *DiskQuery {
	query := (&DiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(host.Table, host.FieldID, id),
			sqlgraph.To(disk.Table, disk.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, host.HostToDiskTable, host.HostToDiskColumn),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHostToUser queries the HostToUser edge of a Host.
func (c *HostClient) QueryHostToUser(h *Host) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(host.Table, host.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, host.HostToUserTable, host.HostToUserColumn),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHostToEnvironment queries the HostToEnvironment edge of a Host.
func (c *HostClient) QueryHostToEnvironment(h *Host) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(host.Table, host.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, host.HostToEnvironmentTable, host.HostToEnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHostToIncludedNetwork queries the HostToIncludedNetwork edge of a Host.
func (c *HostClient) QueryHostToIncludedNetwork(h *Host) *IncludedNetworkQuery {
	query := (&IncludedNetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(host.Table, host.FieldID, id),
			sqlgraph.To(includednetwork.Table, includednetwork.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, host.HostToIncludedNetworkTable, host.HostToIncludedNetworkPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependOnHostToHostDependency queries the DependOnHostToHostDependency edge of a Host.
func (c *HostClient) QueryDependOnHostToHostDependency(h *Host) *HostDependencyQuery {
	query := (&HostDependencyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(host.Table, host.FieldID, id),
			sqlgraph.To(hostdependency.Table, hostdependency.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, host.DependOnHostToHostDependencyTable, host.DependOnHostToHostDependencyColumn),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependByHostToHostDependency queries the DependByHostToHostDependency edge of a Host.
func (c *HostClient) QueryDependByHostToHostDependency(h *Host) *HostDependencyQuery {
	query := (&HostDependencyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(host.Table, host.FieldID, id),
			sqlgraph.To(hostdependency.Table, hostdependency.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, host.DependByHostToHostDependencyTable, host.DependByHostToHostDependencyColumn),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HostClient) Hooks() []Hook {
	return c.hooks.Host
}

// Interceptors returns the client interceptors.
func (c *HostClient) Interceptors() []Interceptor {
	return c.inters.Host
}

func (c *HostClient) mutate(ctx context.Context, m *HostMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HostCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HostUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HostDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Host mutation op: %q", m.Op())
	}
}

// HostDependencyClient is a client for the HostDependency schema.
type HostDependencyClient struct {
	config
}

// NewHostDependencyClient returns a client for the HostDependency from the given config.
func NewHostDependencyClient(c config) *HostDependencyClient {
	return &HostDependencyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hostdependency.Hooks(f(g(h())))`.
func (c *HostDependencyClient) Use(hooks ...Hook) {
	c.hooks.HostDependency = append(c.hooks.HostDependency, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `hostdependency.Intercept(f(g(h())))`.
func (c *HostDependencyClient) Intercept(interceptors ...Interceptor) {
	c.inters.HostDependency = append(c.inters.HostDependency, interceptors...)
}

// Create returns a builder for creating a HostDependency entity.
func (c *HostDependencyClient) Create() *HostDependencyCreate {
	mutation := newHostDependencyMutation(c.config, OpCreate)
	return &HostDependencyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of HostDependency entities.
func (c *HostDependencyClient) CreateBulk(builders ...*HostDependencyCreate) *HostDependencyCreateBulk {
	return &HostDependencyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HostDependencyClient) MapCreateBulk(slice any, setFunc func(*HostDependencyCreate, int)) *HostDependencyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HostDependencyCreateBulk{err: fmt.Errorf("calling to HostDependencyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HostDependencyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HostDependencyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for HostDependency.
func (c *HostDependencyClient) Update() *HostDependencyUpdate {
	mutation := newHostDependencyMutation(c.config, OpUpdate)
	return &HostDependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HostDependencyClient) UpdateOne(hd *HostDependency) *HostDependencyUpdateOne {
	mutation := newHostDependencyMutation(c.config, OpUpdateOne, withHostDependency(hd))
	return &HostDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HostDependencyClient) UpdateOneID(id uuid.UUID) *HostDependencyUpdateOne {
	mutation := newHostDependencyMutation(c.config, OpUpdateOne, withHostDependencyID(id))
	return &HostDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for HostDependency.
func (c *HostDependencyClient) Delete() *HostDependencyDelete {
	mutation := newHostDependencyMutation(c.config, OpDelete)
	return &HostDependencyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HostDependencyClient) DeleteOne(hd *HostDependency) *HostDependencyDeleteOne {
	return c.DeleteOneID(hd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HostDependencyClient) DeleteOneID(id uuid.UUID) *HostDependencyDeleteOne {
	builder := c.Delete().Where(hostdependency.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HostDependencyDeleteOne{builder}
}

// Query returns a query builder for HostDependency.
func (c *HostDependencyClient) Query() *HostDependencyQuery {
	return &HostDependencyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHostDependency},
		inters: c.Interceptors(),
	}
}

// Get returns a HostDependency entity by its id.
func (c *HostDependencyClient) Get(ctx context.Context, id uuid.UUID) (*HostDependency, error) {
	return c.Query().Where(hostdependency.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HostDependencyClient) GetX(ctx context.Context, id uuid.UUID) *HostDependency {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryHostDependencyToDependOnHost queries the HostDependencyToDependOnHost edge of a HostDependency.
func (c *HostDependencyClient) QueryHostDependencyToDependOnHost(hd *HostDependency) *HostQuery {
	query := (&HostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := hd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hostdependency.Table, hostdependency.FieldID, id),
			sqlgraph.To(host.Table, host.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, hostdependency.HostDependencyToDependOnHostTable, hostdependency.HostDependencyToDependOnHostColumn),
		)
		fromV = sqlgraph.Neighbors(hd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHostDependencyToDependByHost queries the HostDependencyToDependByHost edge of a HostDependency.
func (c *HostDependencyClient) QueryHostDependencyToDependByHost(hd *HostDependency) *HostQuery {
	query := (&HostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := hd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hostdependency.Table, hostdependency.FieldID, id),
			sqlgraph.To(host.Table, host.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, hostdependency.HostDependencyToDependByHostTable, hostdependency.HostDependencyToDependByHostColumn),
		)
		fromV = sqlgraph.Neighbors(hd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHostDependencyToNetwork queries the HostDependencyToNetwork edge of a HostDependency.
func (c *HostDependencyClient) QueryHostDependencyToNetwork(hd *HostDependency) *NetworkQuery {
	query := (&NetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := hd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hostdependency.Table, hostdependency.FieldID, id),
			sqlgraph.To(network.Table, network.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, hostdependency.HostDependencyToNetworkTable, hostdependency.HostDependencyToNetworkColumn),
		)
		fromV = sqlgraph.Neighbors(hd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHostDependencyToEnvironment queries the HostDependencyToEnvironment edge of a HostDependency.
func (c *HostDependencyClient) QueryHostDependencyToEnvironment(hd *HostDependency) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := hd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hostdependency.Table, hostdependency.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, hostdependency.HostDependencyToEnvironmentTable, hostdependency.HostDependencyToEnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(hd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HostDependencyClient) Hooks() []Hook {
	return c.hooks.HostDependency
}

// Interceptors returns the client interceptors.
func (c *HostDependencyClient) Interceptors() []Interceptor {
	return c.inters.HostDependency
}

func (c *HostDependencyClient) mutate(ctx context.Context, m *HostDependencyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HostDependencyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HostDependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HostDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HostDependencyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown HostDependency mutation op: %q", m.Op())
	}
}

// IdentityClient is a client for the Identity schema.
type IdentityClient struct {
	config
}

// NewIdentityClient returns a client for the Identity from the given config.
func NewIdentityClient(c config) *IdentityClient {
	return &IdentityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `identity.Hooks(f(g(h())))`.
func (c *IdentityClient) Use(hooks ...Hook) {
	c.hooks.Identity = append(c.hooks.Identity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `identity.Intercept(f(g(h())))`.
func (c *IdentityClient) Intercept(interceptors ...Interceptor) {
	c.inters.Identity = append(c.inters.Identity, interceptors...)
}

// Create returns a builder for creating a Identity entity.
func (c *IdentityClient) Create() *IdentityCreate {
	mutation := newIdentityMutation(c.config, OpCreate)
	return &IdentityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Identity entities.
func (c *IdentityClient) CreateBulk(builders ...*IdentityCreate) *IdentityCreateBulk {
	return &IdentityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IdentityClient) MapCreateBulk(slice any, setFunc func(*IdentityCreate, int)) *IdentityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IdentityCreateBulk{err: fmt.Errorf("calling to IdentityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IdentityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IdentityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Identity.
func (c *IdentityClient) Update() *IdentityUpdate {
	mutation := newIdentityMutation(c.config, OpUpdate)
	return &IdentityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IdentityClient) UpdateOne(i *Identity) *IdentityUpdateOne {
	mutation := newIdentityMutation(c.config, OpUpdateOne, withIdentity(i))
	return &IdentityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IdentityClient) UpdateOneID(id uuid.UUID) *IdentityUpdateOne {
	mutation := newIdentityMutation(c.config, OpUpdateOne, withIdentityID(id))
	return &IdentityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Identity.
func (c *IdentityClient) Delete() *IdentityDelete {
	mutation := newIdentityMutation(c.config, OpDelete)
	return &IdentityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IdentityClient) DeleteOne(i *Identity) *IdentityDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IdentityClient) DeleteOneID(id uuid.UUID) *IdentityDeleteOne {
	builder := c.Delete().Where(identity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IdentityDeleteOne{builder}
}

// Query returns a query builder for Identity.
func (c *IdentityClient) Query() *IdentityQuery {
	return &IdentityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIdentity},
		inters: c.Interceptors(),
	}
}

// Get returns a Identity entity by its id.
func (c *IdentityClient) Get(ctx context.Context, id uuid.UUID) (*Identity, error) {
	return c.Query().Where(identity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IdentityClient) GetX(ctx context.Context, id uuid.UUID) *Identity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIdentityToEnvironment queries the IdentityToEnvironment edge of a Identity.
func (c *IdentityClient) QueryIdentityToEnvironment(i *Identity) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(identity.Table, identity.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, identity.IdentityToEnvironmentTable, identity.IdentityToEnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IdentityClient) Hooks() []Hook {
	return c.hooks.Identity
}

// Interceptors returns the client interceptors.
func (c *IdentityClient) Interceptors() []Interceptor {
	return c.inters.Identity
}

func (c *IdentityClient) mutate(ctx context.Context, m *IdentityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IdentityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IdentityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IdentityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IdentityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Identity mutation op: %q", m.Op())
	}
}

// IncludedNetworkClient is a client for the IncludedNetwork schema.
type IncludedNetworkClient struct {
	config
}

// NewIncludedNetworkClient returns a client for the IncludedNetwork from the given config.
func NewIncludedNetworkClient(c config) *IncludedNetworkClient {
	return &IncludedNetworkClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `includednetwork.Hooks(f(g(h())))`.
func (c *IncludedNetworkClient) Use(hooks ...Hook) {
	c.hooks.IncludedNetwork = append(c.hooks.IncludedNetwork, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `includednetwork.Intercept(f(g(h())))`.
func (c *IncludedNetworkClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncludedNetwork = append(c.inters.IncludedNetwork, interceptors...)
}

// Create returns a builder for creating a IncludedNetwork entity.
func (c *IncludedNetworkClient) Create() *IncludedNetworkCreate {
	mutation := newIncludedNetworkMutation(c.config, OpCreate)
	return &IncludedNetworkCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncludedNetwork entities.
func (c *IncludedNetworkClient) CreateBulk(builders ...*IncludedNetworkCreate) *IncludedNetworkCreateBulk {
	return &IncludedNetworkCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncludedNetworkClient) MapCreateBulk(slice any, setFunc func(*IncludedNetworkCreate, int)) *IncludedNetworkCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncludedNetworkCreateBulk{err: fmt.Errorf("calling to IncludedNetworkClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncludedNetworkCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncludedNetworkCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncludedNetwork.
func (c *IncludedNetworkClient) Update() *IncludedNetworkUpdate {
	mutation := newIncludedNetworkMutation(c.config, OpUpdate)
	return &IncludedNetworkUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncludedNetworkClient) UpdateOne(in *IncludedNetwork) *IncludedNetworkUpdateOne {
	mutation := newIncludedNetworkMutation(c.config, OpUpdateOne, withIncludedNetwork(in))
	return &IncludedNetworkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncludedNetworkClient) UpdateOneID(id uuid.UUID) *IncludedNetworkUpdateOne {
	mutation := newIncludedNetworkMutation(c.config, OpUpdateOne, withIncludedNetworkID(id))
	return &IncludedNetworkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncludedNetwork.
func (c *IncludedNetworkClient) Delete() *IncludedNetworkDelete {
	mutation := newIncludedNetworkMutation(c.config, OpDelete)
	return &IncludedNetworkDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncludedNetworkClient) DeleteOne(in *IncludedNetwork) *IncludedNetworkDeleteOne {
	return c.DeleteOneID(in.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncludedNetworkClient) DeleteOneID(id uuid.UUID) *IncludedNetworkDeleteOne {
	builder := c.Delete().Where(includednetwork.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncludedNetworkDeleteOne{builder}
}

// Query returns a query builder for IncludedNetwork.
func (c *IncludedNetworkClient) Query() *IncludedNetworkQuery {
	return &IncludedNetworkQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncludedNetwork},
		inters: c.Interceptors(),
	}
}

// Get returns a IncludedNetwork entity by its id.
func (c *IncludedNetworkClient) Get(ctx context.Context, id uuid.UUID) (*IncludedNetwork, error) {
	return c.Query().Where(includednetwork.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncludedNetworkClient) GetX(ctx context.Context, id uuid.UUID) *IncludedNetwork {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryIncludedNetworkToTag queries the IncludedNetworkToTag edge of a IncludedNetwork.
func (c *IncludedNetworkClient) QueryIncludedNetworkToTag(in *IncludedNetwork) *TagQuery {
	query := (&TagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := in.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(includednetwork.Table, includednetwork.FieldID, id),
			sqlgraph.To(tag.Table, tag.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, includednetwork.IncludedNetworkToTagTable, includednetwork.IncludedNetworkToTagColumn),
		)
		fromV = sqlgraph.Neighbors(in.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncludedNetworkToHost queries the IncludedNetworkToHost edge of a IncludedNetwork.
func (c *IncludedNetworkClient) QueryIncludedNetworkToHost(in *IncludedNetwork) *HostQuery {
	query := (&HostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := in.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(includednetwork.Table, includednetwork.FieldID, id),
			sqlgraph.To(host.Table, host.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, includednetwork.IncludedNetworkToHostTable, includednetwork.IncludedNetworkToHostPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(in.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncludedNetworkToNetwork queries the IncludedNetworkToNetwork edge of a IncludedNetwork.
func (c *IncludedNetworkClient) QueryIncludedNetworkToNetwork(in *IncludedNetwork) *NetworkQuery {
	query := (&NetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := in.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(includednetwork.Table, includednetwork.FieldID, id),
			sqlgraph.To(network.Table, network.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, includednetwork.IncludedNetworkToNetworkTable, includednetwork.IncludedNetworkToNetworkColumn),
		)
		fromV = sqlgraph.Neighbors(in.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncludedNetworkToEnvironment queries the IncludedNetworkToEnvironment edge of a IncludedNetwork.
func (c *IncludedNetworkClient) QueryIncludedNetworkToEnvironment(in *IncludedNetwork) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := in.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(includednetwork.Table, includednetwork.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, includednetwork.IncludedNetworkToEnvironmentTable, includednetwork.IncludedNetworkToEnvironmentPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(in.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncludedNetworkClient) Hooks() []Hook {
	return c.hooks.IncludedNetwork
}

// Interceptors returns the client interceptors.
func (c *IncludedNetworkClient) Interceptors() []Interceptor {
	return c.inters.IncludedNetwork
}

func (c *IncludedNetworkClient) mutate(ctx context.Context, m *IncludedNetworkMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncludedNetworkCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncludedNetworkUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncludedNetworkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncludedNetworkDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncludedNetwork mutation op: %q", m.Op())
	}
}

// NetworkClient is a client for the Network schema.
type NetworkClient struct {
	config
}

// NewNetworkClient returns a client for the Network from the given config.
func NewNetworkClient(c config) *NetworkClient {
	return &NetworkClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `network.Hooks(f(g(h())))`.
func (c *NetworkClient) Use(hooks ...Hook) {
	c.hooks.Network = append(c.hooks.Network, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `network.Intercept(f(g(h())))`.
func (c *NetworkClient) Intercept(interceptors ...Interceptor) {
	c.inters.Network = append(c.inters.Network, interceptors...)
}

// Create returns a builder for creating a Network entity.
func (c *NetworkClient) Create() *NetworkCreate {
	mutation := newNetworkMutation(c.config, OpCreate)
	return &NetworkCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Network entities.
func (c *NetworkClient) CreateBulk(builders ...*NetworkCreate) *NetworkCreateBulk {
	return &NetworkCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NetworkClient) MapCreateBulk(slice any, setFunc func(*NetworkCreate, int)) *NetworkCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NetworkCreateBulk{err: fmt.Errorf("calling to NetworkClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NetworkCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NetworkCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Network.
func (c *NetworkClient) Update() *NetworkUpdate {
	mutation := newNetworkMutation(c.config, OpUpdate)
	return &NetworkUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NetworkClient) UpdateOne(n *Network) *NetworkUpdateOne {
	mutation := newNetworkMutation(c.config, OpUpdateOne, withNetwork(n))
	return &NetworkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NetworkClient) UpdateOneID(id uuid.UUID) *NetworkUpdateOne {
	mutation := newNetworkMutation(c.config, OpUpdateOne, withNetworkID(id))
	return &NetworkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Network.
func (c *NetworkClient) Delete() *NetworkDelete {
	mutation := newNetworkMutation(c.config, OpDelete)
	return &NetworkDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NetworkClient) DeleteOne(n *Network) *NetworkDeleteOne {
	return c.DeleteOneID(n.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NetworkClient) DeleteOneID(id uuid.UUID) *NetworkDeleteOne {
	builder := c.Delete().Where(network.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NetworkDeleteOne{builder}
}

// Query returns a query builder for Network.
func (c *NetworkClient) Query() *NetworkQuery {
	return &NetworkQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNetwork},
		inters: c.Interceptors(),
	}
}

// Get returns a Network entity by its id.
func (c *NetworkClient) Get(ctx context.Context, id uuid.UUID) (*Network, error) {
	return c.Query().Where(network.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NetworkClient) GetX(ctx context.Context, id uuid.UUID) *Network {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNetworkToEnvironment queries the NetworkToEnvironment edge of a Network.
func (c *NetworkClient) QueryNetworkToEnvironment(n *Network) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(network.Table, network.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, network.NetworkToEnvironmentTable, network.NetworkToEnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNetworkToHostDependency queries the NetworkToHostDependency edge of a Network.
func (c *NetworkClient) QueryNetworkToHostDependency(n *Network) *HostDependencyQuery {
	query := (&HostDependencyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(network.Table, network.FieldID, id),
			sqlgraph.To(hostdependency.Table, hostdependency.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, network.NetworkToHostDependencyTable, network.NetworkToHostDependencyColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNetworkToIncludedNetwork queries the NetworkToIncludedNetwork edge of a Network.
func (c *NetworkClient) QueryNetworkToIncludedNetwork(n *Network) *IncludedNetworkQuery {
	query := (&IncludedNetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(network.Table, network.FieldID, id),
			sqlgraph.To(includednetwork.Table, includednetwork.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, network.NetworkToIncludedNetworkTable, network.NetworkToIncludedNetworkColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NetworkClient) Hooks() []Hook {
	return c.hooks.Network
}

// Interceptors returns the client interceptors.
func (c *NetworkClient) Interceptors() []Interceptor {
	return c.inters.Network
}

func (c *NetworkClient) mutate(ctx context.Context, m *NetworkMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NetworkCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NetworkUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NetworkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NetworkDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Network mutation op: %q", m.Op())
	}
}

// PlanClient is a client for the Plan schema.
type PlanClient struct {
	config
}

// NewPlanClient returns a client for the Plan from the given config.
func NewPlanClient(c config) *PlanClient {
	return &PlanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `plan.Hooks(f(g(h())))`.
func (c *PlanClient) Use(hooks ...Hook) {
	c.hooks.Plan = append(c.hooks.Plan, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `plan.Intercept(f(g(h())))`.
func (c *PlanClient) Intercept(interceptors ...Interceptor) {
	c.inters.Plan = append(c.inters.Plan, interceptors...)
}

// Create returns a builder for creating a Plan entity.
func (c *PlanClient) Create() *PlanCreate {
	mutation := newPlanMutation(c.config, OpCreate)
	return &PlanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Plan entities.
func (c *PlanClient) CreateBulk(builders ...*PlanCreate) *PlanCreateBulk {
	return &PlanCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PlanClient) MapCreateBulk(slice any, setFunc func(*PlanCreate, int)) *PlanCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PlanCreateBulk{err: fmt.Errorf("calling to PlanClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PlanCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PlanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Plan.
func (c *PlanClient) Update() *PlanUpdate {
	mutation := newPlanMutation(c.config, OpUpdate)
	return &PlanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlanClient) UpdateOne(pl *Plan) *PlanUpdateOne {
	mutation := newPlanMutation(c.config, OpUpdateOne, withPlan(pl))
	return &PlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlanClient) UpdateOneID(id uuid.UUID) *PlanUpdateOne {
	mutation := newPlanMutation(c.config, OpUpdateOne, withPlanID(id))
	return &PlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Plan.
func (c *PlanClient) Delete() *PlanDelete {
	mutation := newPlanMutation(c.config, OpDelete)
	return &PlanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlanClient) DeleteOne(pl *Plan) *PlanDeleteOne {
	return c.DeleteOneID(pl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlanClient) DeleteOneID(id uuid.UUID) *PlanDeleteOne {
	builder := c.Delete().Where(plan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlanDeleteOne{builder}
}

// Query returns a query builder for Plan.
func (c *PlanClient) Query() *PlanQuery {
	return &PlanQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlan},
		inters: c.Interceptors(),
	}
}

// Get returns a Plan entity by its id.
func (c *PlanClient) Get(ctx context.Context, id uuid.UUID) (*Plan, error) {
	return c.Query().Where(plan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlanClient) GetX(ctx context.Context, id uuid.UUID) *Plan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPrevPlan queries the PrevPlan edge of a Plan.
func (c *PlanClient) QueryPrevPlan(pl *Plan) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, plan.PrevPlanTable, plan.PrevPlanPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNextPlan queries the NextPlan edge of a Plan.
func (c *PlanClient) QueryNextPlan(pl *Plan) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, plan.NextPlanTable, plan.NextPlanPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlanToBuild queries the PlanToBuild edge of a Plan.
func (c *PlanClient) QueryPlanToBuild(pl *Plan) *BuildQuery {
	query := (&BuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(build.Table, build.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, plan.PlanToBuildTable, plan.PlanToBuildColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlanToTeam queries the PlanToTeam edge of a Plan.
func (c *PlanClient) QueryPlanToTeam(pl *Plan) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, plan.PlanToTeamTable, plan.PlanToTeamColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlanToProvisionedNetwork queries the PlanToProvisionedNetwork edge of a Plan.
func (c *PlanClient) QueryPlanToProvisionedNetwork(pl *Plan) *ProvisionedNetworkQuery {
	query := (&ProvisionedNetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(provisionednetwork.Table, provisionednetwork.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, plan.PlanToProvisionedNetworkTable, plan.PlanToProvisionedNetworkColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlanToProvisionedHost queries the PlanToProvisionedHost edge of a Plan.
func (c *PlanClient) QueryPlanToProvisionedHost(pl *Plan) *ProvisionedHostQuery {
	query := (&ProvisionedHostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(provisionedhost.Table, provisionedhost.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, plan.PlanToProvisionedHostTable, plan.PlanToProvisionedHostColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlanToProvisioningStep queries the PlanToProvisioningStep edge of a Plan.
func (c *PlanClient) QueryPlanToProvisioningStep(pl *Plan) *ProvisioningStepQuery {
	query := (&ProvisioningStepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(provisioningstep.Table, provisioningstep.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, plan.PlanToProvisioningStepTable, plan.PlanToProvisioningStepColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlanToStatus queries the PlanToStatus edge of a Plan.
func (c *PlanClient) QueryPlanToStatus(pl *Plan) *StatusQuery {
	query := (&StatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(status.Table, status.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, plan.PlanToStatusTable, plan.PlanToStatusColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlanToPlanDiffs queries the PlanToPlanDiffs edge of a Plan.
func (c *PlanClient) QueryPlanToPlanDiffs(pl *Plan) *PlanDiffQuery {
	query := (&PlanDiffClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(plandiff.Table, plandiff.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, plan.PlanToPlanDiffsTable, plan.PlanToPlanDiffsColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlanClient) Hooks() []Hook {
	return c.hooks.Plan
}

// Interceptors returns the client interceptors.
func (c *PlanClient) Interceptors() []Interceptor {
	return c.inters.Plan
}

func (c *PlanClient) mutate(ctx context.Context, m *PlanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Plan mutation op: %q", m.Op())
	}
}

// PlanDiffClient is a client for the PlanDiff schema.
type PlanDiffClient struct {
	config
}

// NewPlanDiffClient returns a client for the PlanDiff from the given config.
func NewPlanDiffClient(c config) *PlanDiffClient {
	return &PlanDiffClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `plandiff.Hooks(f(g(h())))`.
func (c *PlanDiffClient) Use(hooks ...Hook) {
	c.hooks.PlanDiff = append(c.hooks.PlanDiff, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `plandiff.Intercept(f(g(h())))`.
func (c *PlanDiffClient) Intercept(interceptors ...Interceptor) {
	c.inters.PlanDiff = append(c.inters.PlanDiff, interceptors...)
}

// Create returns a builder for creating a PlanDiff entity.
func (c *PlanDiffClient) Create() *PlanDiffCreate {
	mutation := newPlanDiffMutation(c.config, OpCreate)
	return &PlanDiffCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PlanDiff entities.
func (c *PlanDiffClient) CreateBulk(builders ...*PlanDiffCreate) *PlanDiffCreateBulk {
	return &PlanDiffCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PlanDiffClient) MapCreateBulk(slice any, setFunc func(*PlanDiffCreate, int)) *PlanDiffCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PlanDiffCreateBulk{err: fmt.Errorf("calling to PlanDiffClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PlanDiffCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PlanDiffCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PlanDiff.
func (c *PlanDiffClient) Update() *PlanDiffUpdate {
	mutation := newPlanDiffMutation(c.config, OpUpdate)
	return &PlanDiffUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlanDiffClient) UpdateOne(pd *PlanDiff) *PlanDiffUpdateOne {
	mutation := newPlanDiffMutation(c.config, OpUpdateOne, withPlanDiff(pd))
	return &PlanDiffUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlanDiffClient) UpdateOneID(id uuid.UUID) *PlanDiffUpdateOne {
	mutation := newPlanDiffMutation(c.config, OpUpdateOne, withPlanDiffID(id))
	return &PlanDiffUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PlanDiff.
func (c *PlanDiffClient) Delete() *PlanDiffDelete {
	mutation := newPlanDiffMutation(c.config, OpDelete)
	return &PlanDiffDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlanDiffClient) DeleteOne(pd *PlanDiff) *PlanDiffDeleteOne {
	return c.DeleteOneID(pd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlanDiffClient) DeleteOneID(id uuid.UUID) *PlanDiffDeleteOne {
	builder := c.Delete().Where(plandiff.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlanDiffDeleteOne{builder}
}

// Query returns a query builder for PlanDiff.
func (c *PlanDiffClient) Query() *PlanDiffQuery {
	return &PlanDiffQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlanDiff},
		inters: c.Interceptors(),
	}
}

// Get returns a PlanDiff entity by its id.
func (c *PlanDiffClient) Get(ctx context.Context, id uuid.UUID) (*PlanDiff, error) {
	return c.Query().Where(plandiff.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlanDiffClient) GetX(ctx context.Context, id uuid.UUID) *PlanDiff {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlanDiffToBuildCommit queries the PlanDiffToBuildCommit edge of a PlanDiff.
func (c *PlanDiffClient) QueryPlanDiffToBuildCommit(pd *PlanDiff) *BuildCommitQuery {
	query := (&BuildCommitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plandiff.Table, plandiff.FieldID, id),
			sqlgraph.To(buildcommit.Table, buildcommit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, plandiff.PlanDiffToBuildCommitTable, plandiff.PlanDiffToBuildCommitColumn),
		)
		fromV = sqlgraph.Neighbors(pd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlanDiffToPlan queries the PlanDiffToPlan edge of a PlanDiff.
func (c *PlanDiffClient) QueryPlanDiffToPlan(pd *PlanDiff) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plandiff.Table, plandiff.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, plandiff.PlanDiffToPlanTable, plandiff.PlanDiffToPlanColumn),
		)
		fromV = sqlgraph.Neighbors(pd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlanDiffClient) Hooks() []Hook {
	return c.hooks.PlanDiff
}

// Interceptors returns the client interceptors.
func (c *PlanDiffClient) Interceptors() []Interceptor {
	return c.inters.PlanDiff
}

func (c *PlanDiffClient) mutate(ctx context.Context, m *PlanDiffMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlanDiffCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlanDiffUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlanDiffUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlanDiffDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PlanDiff mutation op: %q", m.Op())
	}
}

// ProvisionedHostClient is a client for the ProvisionedHost schema.
type ProvisionedHostClient struct {
	config
}

// NewProvisionedHostClient returns a client for the ProvisionedHost from the given config.
func NewProvisionedHostClient(c config) *ProvisionedHostClient {
	return &ProvisionedHostClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `provisionedhost.Hooks(f(g(h())))`.
func (c *ProvisionedHostClient) Use(hooks ...Hook) {
	c.hooks.ProvisionedHost = append(c.hooks.ProvisionedHost, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `provisionedhost.Intercept(f(g(h())))`.
func (c *ProvisionedHostClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProvisionedHost = append(c.inters.ProvisionedHost, interceptors...)
}

// Create returns a builder for creating a ProvisionedHost entity.
func (c *ProvisionedHostClient) Create() *ProvisionedHostCreate {
	mutation := newProvisionedHostMutation(c.config, OpCreate)
	return &ProvisionedHostCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProvisionedHost entities.
func (c *ProvisionedHostClient) CreateBulk(builders ...*ProvisionedHostCreate) *ProvisionedHostCreateBulk {
	return &ProvisionedHostCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProvisionedHostClient) MapCreateBulk(slice any, setFunc func(*ProvisionedHostCreate, int)) *ProvisionedHostCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProvisionedHostCreateBulk{err: fmt.Errorf("calling to ProvisionedHostClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProvisionedHostCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProvisionedHostCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProvisionedHost.
func (c *ProvisionedHostClient) Update() *ProvisionedHostUpdate {
	mutation := newProvisionedHostMutation(c.config, OpUpdate)
	return &ProvisionedHostUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProvisionedHostClient) UpdateOne(ph *ProvisionedHost) *ProvisionedHostUpdateOne {
	mutation := newProvisionedHostMutation(c.config, OpUpdateOne, withProvisionedHost(ph))
	return &ProvisionedHostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProvisionedHostClient) UpdateOneID(id uuid.UUID) *ProvisionedHostUpdateOne {
	mutation := newProvisionedHostMutation(c.config, OpUpdateOne, withProvisionedHostID(id))
	return &ProvisionedHostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProvisionedHost.
func (c *ProvisionedHostClient) Delete() *ProvisionedHostDelete {
	mutation := newProvisionedHostMutation(c.config, OpDelete)
	return &ProvisionedHostDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProvisionedHostClient) DeleteOne(ph *ProvisionedHost) *ProvisionedHostDeleteOne {
	return c.DeleteOneID(ph.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProvisionedHostClient) DeleteOneID(id uuid.UUID) *ProvisionedHostDeleteOne {
	builder := c.Delete().Where(provisionedhost.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProvisionedHostDeleteOne{builder}
}

// Query returns a query builder for ProvisionedHost.
func (c *ProvisionedHostClient) Query() *ProvisionedHostQuery {
	return &ProvisionedHostQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProvisionedHost},
		inters: c.Interceptors(),
	}
}

// Get returns a ProvisionedHost entity by its id.
func (c *ProvisionedHostClient) Get(ctx context.Context, id uuid.UUID) (*ProvisionedHost, error) {
	return c.Query().Where(provisionedhost.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProvisionedHostClient) GetX(ctx context.Context, id uuid.UUID) *ProvisionedHost {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProvisionedHostToStatus queries the ProvisionedHostToStatus edge of a ProvisionedHost.
func (c *ProvisionedHostClient) QueryProvisionedHostToStatus(ph *ProvisionedHost) *StatusQuery {
	query := (&StatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ph.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionedhost.Table, provisionedhost.FieldID, id),
			sqlgraph.To(status.Table, status.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, provisionedhost.ProvisionedHostToStatusTable, provisionedhost.ProvisionedHostToStatusColumn),
		)
		fromV = sqlgraph.Neighbors(ph.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedHostToProvisionedNetwork queries the ProvisionedHostToProvisionedNetwork edge of a ProvisionedHost.
func (c *ProvisionedHostClient) QueryProvisionedHostToProvisionedNetwork(ph *ProvisionedHost) *ProvisionedNetworkQuery {
	query := (&ProvisionedNetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ph.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionedhost.Table, provisionedhost.FieldID, id),
			sqlgraph.To(provisionednetwork.Table, provisionednetwork.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisionedhost.ProvisionedHostToProvisionedNetworkTable, provisionedhost.ProvisionedHostToProvisionedNetworkColumn),
		)
		fromV = sqlgraph.Neighbors(ph.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedHostToHost queries the ProvisionedHostToHost edge of a ProvisionedHost.
func (c *ProvisionedHostClient) QueryProvisionedHostToHost(ph *ProvisionedHost) *HostQuery {
	query := (&HostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ph.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionedhost.Table, provisionedhost.FieldID, id),
			sqlgraph.To(host.Table, host.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisionedhost.ProvisionedHostToHostTable, provisionedhost.ProvisionedHostToHostColumn),
		)
		fromV = sqlgraph.Neighbors(ph.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedHostToEndStepPlan queries the ProvisionedHostToEndStepPlan edge of a ProvisionedHost.
func (c *ProvisionedHostClient) QueryProvisionedHostToEndStepPlan(ph *ProvisionedHost) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ph.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionedhost.Table, provisionedhost.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisionedhost.ProvisionedHostToEndStepPlanTable, provisionedhost.ProvisionedHostToEndStepPlanColumn),
		)
		fromV = sqlgraph.Neighbors(ph.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedHostToBuild queries the ProvisionedHostToBuild edge of a ProvisionedHost.
func (c *ProvisionedHostClient) QueryProvisionedHostToBuild(ph *ProvisionedHost) *BuildQuery {
	query := (&BuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ph.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionedhost.Table, provisionedhost.FieldID, id),
			sqlgraph.To(build.Table, build.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisionedhost.ProvisionedHostToBuildTable, provisionedhost.ProvisionedHostToBuildColumn),
		)
		fromV = sqlgraph.Neighbors(ph.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedHostToProvisioningStep queries the ProvisionedHostToProvisioningStep edge of a ProvisionedHost.
func (c *ProvisionedHostClient) QueryProvisionedHostToProvisioningStep(ph *ProvisionedHost) *ProvisioningStepQuery {
	query := (&ProvisioningStepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ph.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionedhost.Table, provisionedhost.FieldID, id),
			sqlgraph.To(provisioningstep.Table, provisioningstep.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, provisionedhost.ProvisionedHostToProvisioningStepTable, provisionedhost.ProvisionedHostToProvisioningStepColumn),
		)
		fromV = sqlgraph.Neighbors(ph.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedHostToAgentStatus queries the ProvisionedHostToAgentStatus edge of a ProvisionedHost.
func (c *ProvisionedHostClient) QueryProvisionedHostToAgentStatus(ph *ProvisionedHost) *AgentStatusQuery {
	query := (&AgentStatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ph.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionedhost.Table, provisionedhost.FieldID, id),
			sqlgraph.To(agentstatus.Table, agentstatus.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, provisionedhost.ProvisionedHostToAgentStatusTable, provisionedhost.ProvisionedHostToAgentStatusColumn),
		)
		fromV = sqlgraph.Neighbors(ph.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedHostToAgentTask queries the ProvisionedHostToAgentTask edge of a ProvisionedHost.
func (c *ProvisionedHostClient) QueryProvisionedHostToAgentTask(ph *ProvisionedHost) *AgentTaskQuery {
	query := (&AgentTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ph.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionedhost.Table, provisionedhost.FieldID, id),
			sqlgraph.To(agenttask.Table, agenttask.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, provisionedhost.ProvisionedHostToAgentTaskTable, provisionedhost.ProvisionedHostToAgentTaskColumn),
		)
		fromV = sqlgraph.Neighbors(ph.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedHostToPlan queries the ProvisionedHostToPlan edge of a ProvisionedHost.
func (c *ProvisionedHostClient) QueryProvisionedHostToPlan(ph *ProvisionedHost) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ph.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionedhost.Table, provisionedhost.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, provisionedhost.ProvisionedHostToPlanTable, provisionedhost.ProvisionedHostToPlanColumn),
		)
		fromV = sqlgraph.Neighbors(ph.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedHostToGinFileMiddleware queries the ProvisionedHostToGinFileMiddleware edge of a ProvisionedHost.
func (c *ProvisionedHostClient) QueryProvisionedHostToGinFileMiddleware(ph *ProvisionedHost) *GinFileMiddlewareQuery {
	query := (&GinFileMiddlewareClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ph.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionedhost.Table, provisionedhost.FieldID, id),
			sqlgraph.To(ginfilemiddleware.Table, ginfilemiddleware.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, provisionedhost.ProvisionedHostToGinFileMiddlewareTable, provisionedhost.ProvisionedHostToGinFileMiddlewareColumn),
		)
		fromV = sqlgraph.Neighbors(ph.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProvisionedHostClient) Hooks() []Hook {
	return c.hooks.ProvisionedHost
}

// Interceptors returns the client interceptors.
func (c *ProvisionedHostClient) Interceptors() []Interceptor {
	return c.inters.ProvisionedHost
}

func (c *ProvisionedHostClient) mutate(ctx context.Context, m *ProvisionedHostMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProvisionedHostCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProvisionedHostUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProvisionedHostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProvisionedHostDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProvisionedHost mutation op: %q", m.Op())
	}
}

// ProvisionedNetworkClient is a client for the ProvisionedNetwork schema.
type ProvisionedNetworkClient struct {
	config
}

// NewProvisionedNetworkClient returns a client for the ProvisionedNetwork from the given config.
func NewProvisionedNetworkClient(c config) *ProvisionedNetworkClient {
	return &ProvisionedNetworkClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `provisionednetwork.Hooks(f(g(h())))`.
func (c *ProvisionedNetworkClient) Use(hooks ...Hook) {
	c.hooks.ProvisionedNetwork = append(c.hooks.ProvisionedNetwork, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `provisionednetwork.Intercept(f(g(h())))`.
func (c *ProvisionedNetworkClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProvisionedNetwork = append(c.inters.ProvisionedNetwork, interceptors...)
}

// Create returns a builder for creating a ProvisionedNetwork entity.
func (c *ProvisionedNetworkClient) Create() *ProvisionedNetworkCreate {
	mutation := newProvisionedNetworkMutation(c.config, OpCreate)
	return &ProvisionedNetworkCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProvisionedNetwork entities.
func (c *ProvisionedNetworkClient) CreateBulk(builders ...*ProvisionedNetworkCreate) *ProvisionedNetworkCreateBulk {
	return &ProvisionedNetworkCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProvisionedNetworkClient) MapCreateBulk(slice any, setFunc func(*ProvisionedNetworkCreate, int)) *ProvisionedNetworkCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProvisionedNetworkCreateBulk{err: fmt.Errorf("calling to ProvisionedNetworkClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProvisionedNetworkCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProvisionedNetworkCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProvisionedNetwork.
func (c *ProvisionedNetworkClient) Update() *ProvisionedNetworkUpdate {
	mutation := newProvisionedNetworkMutation(c.config, OpUpdate)
	return &ProvisionedNetworkUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProvisionedNetworkClient) UpdateOne(pn *ProvisionedNetwork) *ProvisionedNetworkUpdateOne {
	mutation := newProvisionedNetworkMutation(c.config, OpUpdateOne, withProvisionedNetwork(pn))
	return &ProvisionedNetworkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProvisionedNetworkClient) UpdateOneID(id uuid.UUID) *ProvisionedNetworkUpdateOne {
	mutation := newProvisionedNetworkMutation(c.config, OpUpdateOne, withProvisionedNetworkID(id))
	return &ProvisionedNetworkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProvisionedNetwork.
func (c *ProvisionedNetworkClient) Delete() *ProvisionedNetworkDelete {
	mutation := newProvisionedNetworkMutation(c.config, OpDelete)
	return &ProvisionedNetworkDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProvisionedNetworkClient) DeleteOne(pn *ProvisionedNetwork) *ProvisionedNetworkDeleteOne {
	return c.DeleteOneID(pn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProvisionedNetworkClient) DeleteOneID(id uuid.UUID) *ProvisionedNetworkDeleteOne {
	builder := c.Delete().Where(provisionednetwork.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProvisionedNetworkDeleteOne{builder}
}

// Query returns a query builder for ProvisionedNetwork.
func (c *ProvisionedNetworkClient) Query() *ProvisionedNetworkQuery {
	return &ProvisionedNetworkQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProvisionedNetwork},
		inters: c.Interceptors(),
	}
}

// Get returns a ProvisionedNetwork entity by its id.
func (c *ProvisionedNetworkClient) Get(ctx context.Context, id uuid.UUID) (*ProvisionedNetwork, error) {
	return c.Query().Where(provisionednetwork.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProvisionedNetworkClient) GetX(ctx context.Context, id uuid.UUID) *ProvisionedNetwork {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProvisionedNetworkToStatus queries the ProvisionedNetworkToStatus edge of a ProvisionedNetwork.
func (c *ProvisionedNetworkClient) QueryProvisionedNetworkToStatus(pn *ProvisionedNetwork) *StatusQuery {
	query := (&StatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionednetwork.Table, provisionednetwork.FieldID, id),
			sqlgraph.To(status.Table, status.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, provisionednetwork.ProvisionedNetworkToStatusTable, provisionednetwork.ProvisionedNetworkToStatusColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedNetworkToNetwork queries the ProvisionedNetworkToNetwork edge of a ProvisionedNetwork.
func (c *ProvisionedNetworkClient) QueryProvisionedNetworkToNetwork(pn *ProvisionedNetwork) *NetworkQuery {
	query := (&NetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionednetwork.Table, provisionednetwork.FieldID, id),
			sqlgraph.To(network.Table, network.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisionednetwork.ProvisionedNetworkToNetworkTable, provisionednetwork.ProvisionedNetworkToNetworkColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedNetworkToBuild queries the ProvisionedNetworkToBuild edge of a ProvisionedNetwork.
func (c *ProvisionedNetworkClient) QueryProvisionedNetworkToBuild(pn *ProvisionedNetwork) *BuildQuery {
	query := (&BuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionednetwork.Table, provisionednetwork.FieldID, id),
			sqlgraph.To(build.Table, build.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisionednetwork.ProvisionedNetworkToBuildTable, provisionednetwork.ProvisionedNetworkToBuildColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedNetworkToTeam queries the ProvisionedNetworkToTeam edge of a ProvisionedNetwork.
func (c *ProvisionedNetworkClient) QueryProvisionedNetworkToTeam(pn *ProvisionedNetwork) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionednetwork.Table, provisionednetwork.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisionednetwork.ProvisionedNetworkToTeamTable, provisionednetwork.ProvisionedNetworkToTeamColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedNetworkToProvisionedHost queries the ProvisionedNetworkToProvisionedHost edge of a ProvisionedNetwork.
func (c *ProvisionedNetworkClient) QueryProvisionedNetworkToProvisionedHost(pn *ProvisionedNetwork) *ProvisionedHostQuery {
	query := (&ProvisionedHostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionednetwork.Table, provisionednetwork.FieldID, id),
			sqlgraph.To(provisionedhost.Table, provisionedhost.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, provisionednetwork.ProvisionedNetworkToProvisionedHostTable, provisionednetwork.ProvisionedNetworkToProvisionedHostColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedNetworkToPlan queries the ProvisionedNetworkToPlan edge of a ProvisionedNetwork.
func (c *ProvisionedNetworkClient) QueryProvisionedNetworkToPlan(pn *ProvisionedNetwork) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionednetwork.Table, provisionednetwork.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, provisionednetwork.ProvisionedNetworkToPlanTable, provisionednetwork.ProvisionedNetworkToPlanColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProvisionedNetworkClient) Hooks() []Hook {
	return c.hooks.ProvisionedNetwork
}

// Interceptors returns the client interceptors.
func (c *ProvisionedNetworkClient) Interceptors() []Interceptor {
	return c.inters.ProvisionedNetwork
}

func (c *ProvisionedNetworkClient) mutate(ctx context.Context, m *ProvisionedNetworkMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProvisionedNetworkCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProvisionedNetworkUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProvisionedNetworkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProvisionedNetworkDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProvisionedNetwork mutation op: %q", m.Op())
	}
}

// ProvisioningStepClient is a client for the ProvisioningStep schema.
type ProvisioningStepClient struct {
	config
}

// NewProvisioningStepClient returns a client for the ProvisioningStep from the given config.
func NewProvisioningStepClient(c config) *ProvisioningStepClient {
	return &ProvisioningStepClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `provisioningstep.Hooks(f(g(h())))`.
func (c *ProvisioningStepClient) Use(hooks ...Hook) {
	c.hooks.ProvisioningStep = append(c.hooks.ProvisioningStep, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `provisioningstep.Intercept(f(g(h())))`.
func (c *ProvisioningStepClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProvisioningStep = append(c.inters.ProvisioningStep, interceptors...)
}

// Create returns a builder for creating a ProvisioningStep entity.
func (c *ProvisioningStepClient) Create() *ProvisioningStepCreate {
	mutation := newProvisioningStepMutation(c.config, OpCreate)
	return &ProvisioningStepCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProvisioningStep entities.
func (c *ProvisioningStepClient) CreateBulk(builders ...*ProvisioningStepCreate) *ProvisioningStepCreateBulk {
	return &ProvisioningStepCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProvisioningStepClient) MapCreateBulk(slice any, setFunc func(*ProvisioningStepCreate, int)) *ProvisioningStepCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProvisioningStepCreateBulk{err: fmt.Errorf("calling to ProvisioningStepClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProvisioningStepCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProvisioningStepCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProvisioningStep.
func (c *ProvisioningStepClient) Update() *ProvisioningStepUpdate {
	mutation := newProvisioningStepMutation(c.config, OpUpdate)
	return &ProvisioningStepUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProvisioningStepClient) UpdateOne(ps *ProvisioningStep) *ProvisioningStepUpdateOne {
	mutation := newProvisioningStepMutation(c.config, OpUpdateOne, withProvisioningStep(ps))
	return &ProvisioningStepUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProvisioningStepClient) UpdateOneID(id uuid.UUID) *ProvisioningStepUpdateOne {
	mutation := newProvisioningStepMutation(c.config, OpUpdateOne, withProvisioningStepID(id))
	return &ProvisioningStepUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProvisioningStep.
func (c *ProvisioningStepClient) Delete() *ProvisioningStepDelete {
	mutation := newProvisioningStepMutation(c.config, OpDelete)
	return &ProvisioningStepDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProvisioningStepClient) DeleteOne(ps *ProvisioningStep) *ProvisioningStepDeleteOne {
	return c.DeleteOneID(ps.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProvisioningStepClient) DeleteOneID(id uuid.UUID) *ProvisioningStepDeleteOne {
	builder := c.Delete().Where(provisioningstep.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProvisioningStepDeleteOne{builder}
}

// Query returns a query builder for ProvisioningStep.
func (c *ProvisioningStepClient) Query() *ProvisioningStepQuery {
	return &ProvisioningStepQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProvisioningStep},
		inters: c.Interceptors(),
	}
}

// Get returns a ProvisioningStep entity by its id.
func (c *ProvisioningStepClient) Get(ctx context.Context, id uuid.UUID) (*ProvisioningStep, error) {
	return c.Query().Where(provisioningstep.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProvisioningStepClient) GetX(ctx context.Context, id uuid.UUID) *ProvisioningStep {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProvisioningStepToStatus queries the ProvisioningStepToStatus edge of a ProvisioningStep.
func (c *ProvisioningStepClient) QueryProvisioningStepToStatus(ps *ProvisioningStep) *StatusQuery {
	query := (&StatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningstep.Table, provisioningstep.FieldID, id),
			sqlgraph.To(status.Table, status.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, provisioningstep.ProvisioningStepToStatusTable, provisioningstep.ProvisioningStepToStatusColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisioningStepToProvisionedHost queries the ProvisioningStepToProvisionedHost edge of a ProvisioningStep.
func (c *ProvisioningStepClient) QueryProvisioningStepToProvisionedHost(ps *ProvisioningStep) *ProvisionedHostQuery {
	query := (&ProvisionedHostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningstep.Table, provisioningstep.FieldID, id),
			sqlgraph.To(provisionedhost.Table, provisionedhost.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningstep.ProvisioningStepToProvisionedHostTable, provisioningstep.ProvisioningStepToProvisionedHostColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisioningStepToScript queries the ProvisioningStepToScript edge of a ProvisioningStep.
func (c *ProvisioningStepClient) QueryProvisioningStepToScript(ps *ProvisioningStep) *ScriptQuery {
	query := (&ScriptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningstep.Table, provisioningstep.FieldID, id),
			sqlgraph.To(script.Table, script.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningstep.ProvisioningStepToScriptTable, provisioningstep.ProvisioningStepToScriptColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisioningStepToCommand queries the ProvisioningStepToCommand edge of a ProvisioningStep.
func (c *ProvisioningStepClient) QueryProvisioningStepToCommand(ps *ProvisioningStep) *CommandQuery {
	query := (&CommandClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningstep.Table, provisioningstep.FieldID, id),
			sqlgraph.To(command.Table, command.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningstep.ProvisioningStepToCommandTable, provisioningstep.ProvisioningStepToCommandColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisioningStepToDNSRecord queries the ProvisioningStepToDNSRecord edge of a ProvisioningStep.
func (c *ProvisioningStepClient) QueryProvisioningStepToDNSRecord(ps *ProvisioningStep) *DNSRecordQuery {
	query := (&DNSRecordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningstep.Table, provisioningstep.FieldID, id),
			sqlgraph.To(dnsrecord.Table, dnsrecord.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningstep.ProvisioningStepToDNSRecordTable, provisioningstep.ProvisioningStepToDNSRecordColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisioningStepToFileDelete queries the ProvisioningStepToFileDelete edge of a ProvisioningStep.
func (c *ProvisioningStepClient) QueryProvisioningStepToFileDelete(ps *ProvisioningStep) *FileDeleteQuery {
	query := (&FileDeleteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningstep.Table, provisioningstep.FieldID, id),
			sqlgraph.To(filedelete.Table, filedelete.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningstep.ProvisioningStepToFileDeleteTable, provisioningstep.ProvisioningStepToFileDeleteColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisioningStepToFileDownload queries the ProvisioningStepToFileDownload edge of a ProvisioningStep.
func (c *ProvisioningStepClient) QueryProvisioningStepToFileDownload(ps *ProvisioningStep) *FileDownloadQuery {
	query := (&FileDownloadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningstep.Table, provisioningstep.FieldID, id),
			sqlgraph.To(filedownload.Table, filedownload.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningstep.ProvisioningStepToFileDownloadTable, provisioningstep.ProvisioningStepToFileDownloadColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisioningStepToFileExtract queries the ProvisioningStepToFileExtract edge of a ProvisioningStep.
func (c *ProvisioningStepClient) QueryProvisioningStepToFileExtract(ps *ProvisioningStep) *FileExtractQuery {
	query := (&FileExtractClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningstep.Table, provisioningstep.FieldID, id),
			sqlgraph.To(fileextract.Table, fileextract.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningstep.ProvisioningStepToFileExtractTable, provisioningstep.ProvisioningStepToFileExtractColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisioningStepToAnsible queries the ProvisioningStepToAnsible edge of a ProvisioningStep.
func (c *ProvisioningStepClient) QueryProvisioningStepToAnsible(ps *ProvisioningStep) *AnsibleQuery {
	query := (&AnsibleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningstep.Table, provisioningstep.FieldID, id),
			sqlgraph.To(ansible.Table, ansible.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningstep.ProvisioningStepToAnsibleTable, provisioningstep.ProvisioningStepToAnsibleColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisioningStepToPlan queries the ProvisioningStepToPlan edge of a ProvisioningStep.
func (c *ProvisioningStepClient) QueryProvisioningStepToPlan(ps *ProvisioningStep) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningstep.Table, provisioningstep.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, provisioningstep.ProvisioningStepToPlanTable, provisioningstep.ProvisioningStepToPlanColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisioningStepToAgentTask queries the ProvisioningStepToAgentTask edge of a ProvisioningStep.
func (c *ProvisioningStepClient) QueryProvisioningStepToAgentTask(ps *ProvisioningStep) *AgentTaskQuery {
	query := (&AgentTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningstep.Table, provisioningstep.FieldID, id),
			sqlgraph.To(agenttask.Table, agenttask.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, provisioningstep.ProvisioningStepToAgentTaskTable, provisioningstep.ProvisioningStepToAgentTaskColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisioningStepToGinFileMiddleware queries the ProvisioningStepToGinFileMiddleware edge of a ProvisioningStep.
func (c *ProvisioningStepClient) QueryProvisioningStepToGinFileMiddleware(ps *ProvisioningStep) *GinFileMiddlewareQuery {
	query := (&GinFileMiddlewareClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningstep.Table, provisioningstep.FieldID, id),
			sqlgraph.To(ginfilemiddleware.Table, ginfilemiddleware.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, provisioningstep.ProvisioningStepToGinFileMiddlewareTable, provisioningstep.ProvisioningStepToGinFileMiddlewareColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProvisioningStepClient) Hooks() []Hook {
	return c.hooks.ProvisioningStep
}

// Interceptors returns the client interceptors.
func (c *ProvisioningStepClient) Interceptors() []Interceptor {
	return c.inters.ProvisioningStep
}

func (c *ProvisioningStepClient) mutate(ctx context.Context, m *ProvisioningStepMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProvisioningStepCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProvisioningStepUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProvisioningStepUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProvisioningStepDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProvisioningStep mutation op: %q", m.Op())
	}
}

// RepoCommitClient is a client for the RepoCommit schema.
type RepoCommitClient struct {
	config
}

// NewRepoCommitClient returns a client for the RepoCommit from the given config.
func NewRepoCommitClient(c config) *RepoCommitClient {
	return &RepoCommitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `repocommit.Hooks(f(g(h())))`.
func (c *RepoCommitClient) Use(hooks ...Hook) {
	c.hooks.RepoCommit = append(c.hooks.RepoCommit, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `repocommit.Intercept(f(g(h())))`.
func (c *RepoCommitClient) Intercept(interceptors ...Interceptor) {
	c.inters.RepoCommit = append(c.inters.RepoCommit, interceptors...)
}

// Create returns a builder for creating a RepoCommit entity.
func (c *RepoCommitClient) Create() *RepoCommitCreate {
	mutation := newRepoCommitMutation(c.config, OpCreate)
	return &RepoCommitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RepoCommit entities.
func (c *RepoCommitClient) CreateBulk(builders ...*RepoCommitCreate) *RepoCommitCreateBulk {
	return &RepoCommitCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RepoCommitClient) MapCreateBulk(slice any, setFunc func(*RepoCommitCreate, int)) *RepoCommitCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RepoCommitCreateBulk{err: fmt.Errorf("calling to RepoCommitClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RepoCommitCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RepoCommitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RepoCommit.
func (c *RepoCommitClient) Update() *RepoCommitUpdate {
	mutation := newRepoCommitMutation(c.config, OpUpdate)
	return &RepoCommitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RepoCommitClient) UpdateOne(rc *RepoCommit) *RepoCommitUpdateOne {
	mutation := newRepoCommitMutation(c.config, OpUpdateOne, withRepoCommit(rc))
	return &RepoCommitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RepoCommitClient) UpdateOneID(id uuid.UUID) *RepoCommitUpdateOne {
	mutation := newRepoCommitMutation(c.config, OpUpdateOne, withRepoCommitID(id))
	return &RepoCommitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RepoCommit.
func (c *RepoCommitClient) Delete() *RepoCommitDelete {
	mutation := newRepoCommitMutation(c.config, OpDelete)
	return &RepoCommitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RepoCommitClient) DeleteOne(rc *RepoCommit) *RepoCommitDeleteOne {
	return c.DeleteOneID(rc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RepoCommitClient) DeleteOneID(id uuid.UUID) *RepoCommitDeleteOne {
	builder := c.Delete().Where(repocommit.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RepoCommitDeleteOne{builder}
}

// Query returns a query builder for RepoCommit.
func (c *RepoCommitClient) Query() *RepoCommitQuery {
	return &RepoCommitQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRepoCommit},
		inters: c.Interceptors(),
	}
}

// Get returns a RepoCommit entity by its id.
func (c *RepoCommitClient) Get(ctx context.Context, id uuid.UUID) (*RepoCommit, error) {
	return c.Query().Where(repocommit.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RepoCommitClient) GetX(ctx context.Context, id uuid.UUID) *RepoCommit {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRepoCommitToRepository queries the RepoCommitToRepository edge of a RepoCommit.
func (c *RepoCommitClient) QueryRepoCommitToRepository(rc *RepoCommit) *RepositoryQuery {
	query := (&RepositoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(repocommit.Table, repocommit.FieldID, id),
			sqlgraph.To(repository.Table, repository.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, repocommit.RepoCommitToRepositoryTable, repocommit.RepoCommitToRepositoryColumn),
		)
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RepoCommitClient) Hooks() []Hook {
	return c.hooks.RepoCommit
}

// Interceptors returns the client interceptors.
func (c *RepoCommitClient) Interceptors() []Interceptor {
	return c.inters.RepoCommit
}

func (c *RepoCommitClient) mutate(ctx context.Context, m *RepoCommitMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RepoCommitCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RepoCommitUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RepoCommitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RepoCommitDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RepoCommit mutation op: %q", m.Op())
	}
}

// RepositoryClient is a client for the Repository schema.
type RepositoryClient struct {
	config
}

// NewRepositoryClient returns a client for the Repository from the given config.
func NewRepositoryClient(c config) *RepositoryClient {
	return &RepositoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `repository.Hooks(f(g(h())))`.
func (c *RepositoryClient) Use(hooks ...Hook) {
	c.hooks.Repository = append(c.hooks.Repository, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `repository.Intercept(f(g(h())))`.
func (c *RepositoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Repository = append(c.inters.Repository, interceptors...)
}

// Create returns a builder for creating a Repository entity.
func (c *RepositoryClient) Create() *RepositoryCreate {
	mutation := newRepositoryMutation(c.config, OpCreate)
	return &RepositoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Repository entities.
func (c *RepositoryClient) CreateBulk(builders ...*RepositoryCreate) *RepositoryCreateBulk {
	return &RepositoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RepositoryClient) MapCreateBulk(slice any, setFunc func(*RepositoryCreate, int)) *RepositoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RepositoryCreateBulk{err: fmt.Errorf("calling to RepositoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RepositoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RepositoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Repository.
func (c *RepositoryClient) Update() *RepositoryUpdate {
	mutation := newRepositoryMutation(c.config, OpUpdate)
	return &RepositoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RepositoryClient) UpdateOne(r *Repository) *RepositoryUpdateOne {
	mutation := newRepositoryMutation(c.config, OpUpdateOne, withRepository(r))
	return &RepositoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RepositoryClient) UpdateOneID(id uuid.UUID) *RepositoryUpdateOne {
	mutation := newRepositoryMutation(c.config, OpUpdateOne, withRepositoryID(id))
	return &RepositoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Repository.
func (c *RepositoryClient) Delete() *RepositoryDelete {
	mutation := newRepositoryMutation(c.config, OpDelete)
	return &RepositoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RepositoryClient) DeleteOne(r *Repository) *RepositoryDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RepositoryClient) DeleteOneID(id uuid.UUID) *RepositoryDeleteOne {
	builder := c.Delete().Where(repository.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RepositoryDeleteOne{builder}
}

// Query returns a query builder for Repository.
func (c *RepositoryClient) Query() *RepositoryQuery {
	return &RepositoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRepository},
		inters: c.Interceptors(),
	}
}

// Get returns a Repository entity by its id.
func (c *RepositoryClient) Get(ctx context.Context, id uuid.UUID) (*Repository, error) {
	return c.Query().Where(repository.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RepositoryClient) GetX(ctx context.Context, id uuid.UUID) *Repository {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRepositoryToEnvironment queries the RepositoryToEnvironment edge of a Repository.
func (c *RepositoryClient) QueryRepositoryToEnvironment(r *Repository) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(repository.Table, repository.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, repository.RepositoryToEnvironmentTable, repository.RepositoryToEnvironmentPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRepositoryToRepoCommit queries the RepositoryToRepoCommit edge of a Repository.
func (c *RepositoryClient) QueryRepositoryToRepoCommit(r *Repository) *RepoCommitQuery {
	query := (&RepoCommitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(repository.Table, repository.FieldID, id),
			sqlgraph.To(repocommit.Table, repocommit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, repository.RepositoryToRepoCommitTable, repository.RepositoryToRepoCommitColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RepositoryClient) Hooks() []Hook {
	return c.hooks.Repository
}

// Interceptors returns the client interceptors.
func (c *RepositoryClient) Interceptors() []Interceptor {
	return c.inters.Repository
}

func (c *RepositoryClient) mutate(ctx context.Context, m *RepositoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RepositoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RepositoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RepositoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RepositoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Repository mutation op: %q", m.Op())
	}
}

// ScriptClient is a client for the Script schema.
type ScriptClient struct {
	config
}

// NewScriptClient returns a client for the Script from the given config.
func NewScriptClient(c config) *ScriptClient {
	return &ScriptClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `script.Hooks(f(g(h())))`.
func (c *ScriptClient) Use(hooks ...Hook) {
	c.hooks.Script = append(c.hooks.Script, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `script.Intercept(f(g(h())))`.
func (c *ScriptClient) Intercept(interceptors ...Interceptor) {
	c.inters.Script = append(c.inters.Script, interceptors...)
}

// Create returns a builder for creating a Script entity.
func (c *ScriptClient) Create() *ScriptCreate {
	mutation := newScriptMutation(c.config, OpCreate)
	return &ScriptCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Script entities.
func (c *ScriptClient) CreateBulk(builders ...*ScriptCreate) *ScriptCreateBulk {
	return &ScriptCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScriptClient) MapCreateBulk(slice any, setFunc func(*ScriptCreate, int)) *ScriptCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScriptCreateBulk{err: fmt.Errorf("calling to ScriptClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScriptCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScriptCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Script.
func (c *ScriptClient) Update() *ScriptUpdate {
	mutation := newScriptMutation(c.config, OpUpdate)
	return &ScriptUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScriptClient) UpdateOne(s *Script) *ScriptUpdateOne {
	mutation := newScriptMutation(c.config, OpUpdateOne, withScript(s))
	return &ScriptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScriptClient) UpdateOneID(id uuid.UUID) *ScriptUpdateOne {
	mutation := newScriptMutation(c.config, OpUpdateOne, withScriptID(id))
	return &ScriptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Script.
func (c *ScriptClient) Delete() *ScriptDelete {
	mutation := newScriptMutation(c.config, OpDelete)
	return &ScriptDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScriptClient) DeleteOne(s *Script) *ScriptDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScriptClient) DeleteOneID(id uuid.UUID) *ScriptDeleteOne {
	builder := c.Delete().Where(script.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScriptDeleteOne{builder}
}

// Query returns a query builder for Script.
func (c *ScriptClient) Query() *ScriptQuery {
	return &ScriptQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScript},
		inters: c.Interceptors(),
	}
}

// Get returns a Script entity by its id.
func (c *ScriptClient) Get(ctx context.Context, id uuid.UUID) (*Script, error) {
	return c.Query().Where(script.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScriptClient) GetX(ctx context.Context, id uuid.UUID) *Script {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryScriptToUser queries the ScriptToUser edge of a Script.
func (c *ScriptClient) QueryScriptToUser(s *Script) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(script.Table, script.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, script.ScriptToUserTable, script.ScriptToUserColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScriptToFinding queries the ScriptToFinding edge of a Script.
func (c *ScriptClient) QueryScriptToFinding(s *Script) *FindingQuery {
	query := (&FindingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(script.Table, script.FieldID, id),
			sqlgraph.To(finding.Table, finding.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, script.ScriptToFindingTable, script.ScriptToFindingColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScriptToEnvironment queries the ScriptToEnvironment edge of a Script.
func (c *ScriptClient) QueryScriptToEnvironment(s *Script) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(script.Table, script.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, script.ScriptToEnvironmentTable, script.ScriptToEnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScriptClient) Hooks() []Hook {
	return c.hooks.Script
}

// Interceptors returns the client interceptors.
func (c *ScriptClient) Interceptors() []Interceptor {
	return c.inters.Script
}

func (c *ScriptClient) mutate(ctx context.Context, m *ScriptMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScriptCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScriptUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScriptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScriptDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Script mutation op: %q", m.Op())
	}
}

// ServerTaskClient is a client for the ServerTask schema.
type ServerTaskClient struct {
	config
}

// NewServerTaskClient returns a client for the ServerTask from the given config.
func NewServerTaskClient(c config) *ServerTaskClient {
	return &ServerTaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `servertask.Hooks(f(g(h())))`.
func (c *ServerTaskClient) Use(hooks ...Hook) {
	c.hooks.ServerTask = append(c.hooks.ServerTask, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `servertask.Intercept(f(g(h())))`.
func (c *ServerTaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.ServerTask = append(c.inters.ServerTask, interceptors...)
}

// Create returns a builder for creating a ServerTask entity.
func (c *ServerTaskClient) Create() *ServerTaskCreate {
	mutation := newServerTaskMutation(c.config, OpCreate)
	return &ServerTaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ServerTask entities.
func (c *ServerTaskClient) CreateBulk(builders ...*ServerTaskCreate) *ServerTaskCreateBulk {
	return &ServerTaskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ServerTaskClient) MapCreateBulk(slice any, setFunc func(*ServerTaskCreate, int)) *ServerTaskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ServerTaskCreateBulk{err: fmt.Errorf("calling to ServerTaskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ServerTaskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ServerTaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ServerTask.
func (c *ServerTaskClient) Update() *ServerTaskUpdate {
	mutation := newServerTaskMutation(c.config, OpUpdate)
	return &ServerTaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServerTaskClient) UpdateOne(st *ServerTask) *ServerTaskUpdateOne {
	mutation := newServerTaskMutation(c.config, OpUpdateOne, withServerTask(st))
	return &ServerTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServerTaskClient) UpdateOneID(id uuid.UUID) *ServerTaskUpdateOne {
	mutation := newServerTaskMutation(c.config, OpUpdateOne, withServerTaskID(id))
	return &ServerTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ServerTask.
func (c *ServerTaskClient) Delete() *ServerTaskDelete {
	mutation := newServerTaskMutation(c.config, OpDelete)
	return &ServerTaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServerTaskClient) DeleteOne(st *ServerTask) *ServerTaskDeleteOne {
	return c.DeleteOneID(st.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServerTaskClient) DeleteOneID(id uuid.UUID) *ServerTaskDeleteOne {
	builder := c.Delete().Where(servertask.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServerTaskDeleteOne{builder}
}

// Query returns a query builder for ServerTask.
func (c *ServerTaskClient) Query() *ServerTaskQuery {
	return &ServerTaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeServerTask},
		inters: c.Interceptors(),
	}
}

// Get returns a ServerTask entity by its id.
func (c *ServerTaskClient) Get(ctx context.Context, id uuid.UUID) (*ServerTask, error) {
	return c.Query().Where(servertask.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServerTaskClient) GetX(ctx context.Context, id uuid.UUID) *ServerTask {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryServerTaskToAuthUser queries the ServerTaskToAuthUser edge of a ServerTask.
func (c *ServerTaskClient) QueryServerTaskToAuthUser(st *ServerTask) *AuthUserQuery {
	query := (&AuthUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servertask.Table, servertask.FieldID, id),
			sqlgraph.To(authuser.Table, authuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, servertask.ServerTaskToAuthUserTable, servertask.ServerTaskToAuthUserColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServerTaskToStatus queries the ServerTaskToStatus edge of a ServerTask.
func (c *ServerTaskClient) QueryServerTaskToStatus(st *ServerTask) *StatusQuery {
	query := (&StatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servertask.Table, servertask.FieldID, id),
			sqlgraph.To(status.Table, status.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, servertask.ServerTaskToStatusTable, servertask.ServerTaskToStatusColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServerTaskToEnvironment queries the ServerTaskToEnvironment edge of a ServerTask.
func (c *ServerTaskClient) QueryServerTaskToEnvironment(st *ServerTask) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servertask.Table, servertask.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, servertask.ServerTaskToEnvironmentTable, servertask.ServerTaskToEnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServerTaskToBuild queries the ServerTaskToBuild edge of a ServerTask.
func (c *ServerTaskClient) QueryServerTaskToBuild(st *ServerTask) *BuildQuery {
	query := (&BuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servertask.Table, servertask.FieldID, id),
			sqlgraph.To(build.Table, build.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, servertask.ServerTaskToBuildTable, servertask.ServerTaskToBuildColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServerTaskToBuildCommit queries the ServerTaskToBuildCommit edge of a ServerTask.
func (c *ServerTaskClient) QueryServerTaskToBuildCommit(st *ServerTask) *BuildCommitQuery {
	query := (&BuildCommitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servertask.Table, servertask.FieldID, id),
			sqlgraph.To(buildcommit.Table, buildcommit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, servertask.ServerTaskToBuildCommitTable, servertask.ServerTaskToBuildCommitColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServerTaskToGinFileMiddleware queries the ServerTaskToGinFileMiddleware edge of a ServerTask.
func (c *ServerTaskClient) QueryServerTaskToGinFileMiddleware(st *ServerTask) *GinFileMiddlewareQuery {
	query := (&GinFileMiddlewareClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servertask.Table, servertask.FieldID, id),
			sqlgraph.To(ginfilemiddleware.Table, ginfilemiddleware.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, servertask.ServerTaskToGinFileMiddlewareTable, servertask.ServerTaskToGinFileMiddlewareColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServerTaskClient) Hooks() []Hook {
	return c.hooks.ServerTask
}

// Interceptors returns the client interceptors.
func (c *ServerTaskClient) Interceptors() []Interceptor {
	return c.inters.ServerTask
}

func (c *ServerTaskClient) mutate(ctx context.Context, m *ServerTaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServerTaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServerTaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServerTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServerTaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ServerTask mutation op: %q", m.Op())
	}
}

// StatusClient is a client for the Status schema.
type StatusClient struct {
	config
}

// NewStatusClient returns a client for the Status from the given config.
func NewStatusClient(c config) *StatusClient {
	return &StatusClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `status.Hooks(f(g(h())))`.
func (c *StatusClient) Use(hooks ...Hook) {
	c.hooks.Status = append(c.hooks.Status, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `status.Intercept(f(g(h())))`.
func (c *StatusClient) Intercept(interceptors ...Interceptor) {
	c.inters.Status = append(c.inters.Status, interceptors...)
}

// Create returns a builder for creating a Status entity.
func (c *StatusClient) Create() *StatusCreate {
	mutation := newStatusMutation(c.config, OpCreate)
	return &StatusCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Status entities.
func (c *StatusClient) CreateBulk(builders ...*StatusCreate) *StatusCreateBulk {
	return &StatusCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StatusClient) MapCreateBulk(slice any, setFunc func(*StatusCreate, int)) *StatusCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StatusCreateBulk{err: fmt.Errorf("calling to StatusClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StatusCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StatusCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Status.
func (c *StatusClient) Update() *StatusUpdate {
	mutation := newStatusMutation(c.config, OpUpdate)
	return &StatusUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StatusClient) UpdateOne(s *Status) *StatusUpdateOne {
	mutation := newStatusMutation(c.config, OpUpdateOne, withStatus(s))
	return &StatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StatusClient) UpdateOneID(id uuid.UUID) *StatusUpdateOne {
	mutation := newStatusMutation(c.config, OpUpdateOne, withStatusID(id))
	return &StatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Status.
func (c *StatusClient) Delete() *StatusDelete {
	mutation := newStatusMutation(c.config, OpDelete)
	return &StatusDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StatusClient) DeleteOne(s *Status) *StatusDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StatusClient) DeleteOneID(id uuid.UUID) *StatusDeleteOne {
	builder := c.Delete().Where(status.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StatusDeleteOne{builder}
}

// Query returns a query builder for Status.
func (c *StatusClient) Query() *StatusQuery {
	return &StatusQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStatus},
		inters: c.Interceptors(),
	}
}

// Get returns a Status entity by its id.
func (c *StatusClient) Get(ctx context.Context, id uuid.UUID) (*Status, error) {
	return c.Query().Where(status.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StatusClient) GetX(ctx context.Context, id uuid.UUID) *Status {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStatusToBuild queries the StatusToBuild edge of a Status.
func (c *StatusClient) QueryStatusToBuild(s *Status) *BuildQuery {
	query := (&BuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(status.Table, status.FieldID, id),
			sqlgraph.To(build.Table, build.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, status.StatusToBuildTable, status.StatusToBuildColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStatusToProvisionedNetwork queries the StatusToProvisionedNetwork edge of a Status.
func (c *StatusClient) QueryStatusToProvisionedNetwork(s *Status) *ProvisionedNetworkQuery {
	query := (&ProvisionedNetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(status.Table, status.FieldID, id),
			sqlgraph.To(provisionednetwork.Table, provisionednetwork.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, status.StatusToProvisionedNetworkTable, status.StatusToProvisionedNetworkColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStatusToProvisionedHost queries the StatusToProvisionedHost edge of a Status.
func (c *StatusClient) QueryStatusToProvisionedHost(s *Status) *ProvisionedHostQuery {
	query := (&ProvisionedHostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(status.Table, status.FieldID, id),
			sqlgraph.To(provisionedhost.Table, provisionedhost.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, status.StatusToProvisionedHostTable, status.StatusToProvisionedHostColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStatusToProvisioningStep queries the StatusToProvisioningStep edge of a Status.
func (c *StatusClient) QueryStatusToProvisioningStep(s *Status) *ProvisioningStepQuery {
	query := (&ProvisioningStepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(status.Table, status.FieldID, id),
			sqlgraph.To(provisioningstep.Table, provisioningstep.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, status.StatusToProvisioningStepTable, status.StatusToProvisioningStepColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStatusToTeam queries the StatusToTeam edge of a Status.
func (c *StatusClient) QueryStatusToTeam(s *Status) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(status.Table, status.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, status.StatusToTeamTable, status.StatusToTeamColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStatusToPlan queries the StatusToPlan edge of a Status.
func (c *StatusClient) QueryStatusToPlan(s *Status) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(status.Table, status.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, status.StatusToPlanTable, status.StatusToPlanColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStatusToServerTask queries the StatusToServerTask edge of a Status.
func (c *StatusClient) QueryStatusToServerTask(s *Status) *ServerTaskQuery {
	query := (&ServerTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(status.Table, status.FieldID, id),
			sqlgraph.To(servertask.Table, servertask.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, status.StatusToServerTaskTable, status.StatusToServerTaskColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStatusToAdhocPlan queries the StatusToAdhocPlan edge of a Status.
func (c *StatusClient) QueryStatusToAdhocPlan(s *Status) *AdhocPlanQuery {
	query := (&AdhocPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(status.Table, status.FieldID, id),
			sqlgraph.To(adhocplan.Table, adhocplan.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, status.StatusToAdhocPlanTable, status.StatusToAdhocPlanColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StatusClient) Hooks() []Hook {
	return c.hooks.Status
}

// Interceptors returns the client interceptors.
func (c *StatusClient) Interceptors() []Interceptor {
	return c.inters.Status
}

func (c *StatusClient) mutate(ctx context.Context, m *StatusMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StatusCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StatusUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StatusDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Status mutation op: %q", m.Op())
	}
}

// TagClient is a client for the Tag schema.
type TagClient struct {
	config
}

// NewTagClient returns a client for the Tag from the given config.
func NewTagClient(c config) *TagClient {
	return &TagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tag.Hooks(f(g(h())))`.
func (c *TagClient) Use(hooks ...Hook) {
	c.hooks.Tag = append(c.hooks.Tag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tag.Intercept(f(g(h())))`.
func (c *TagClient) Intercept(interceptors ...Interceptor) {
	c.inters.Tag = append(c.inters.Tag, interceptors...)
}

// Create returns a builder for creating a Tag entity.
func (c *TagClient) Create() *TagCreate {
	mutation := newTagMutation(c.config, OpCreate)
	return &TagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Tag entities.
func (c *TagClient) CreateBulk(builders ...*TagCreate) *TagCreateBulk {
	return &TagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TagClient) MapCreateBulk(slice any, setFunc func(*TagCreate, int)) *TagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TagCreateBulk{err: fmt.Errorf("calling to TagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Tag.
func (c *TagClient) Update() *TagUpdate {
	mutation := newTagMutation(c.config, OpUpdate)
	return &TagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TagClient) UpdateOne(t *Tag) *TagUpdateOne {
	mutation := newTagMutation(c.config, OpUpdateOne, withTag(t))
	return &TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TagClient) UpdateOneID(id uuid.UUID) *TagUpdateOne {
	mutation := newTagMutation(c.config, OpUpdateOne, withTagID(id))
	return &TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Tag.
func (c *TagClient) Delete() *TagDelete {
	mutation := newTagMutation(c.config, OpDelete)
	return &TagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TagClient) DeleteOne(t *Tag) *TagDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TagClient) DeleteOneID(id uuid.UUID) *TagDeleteOne {
	builder := c.Delete().Where(tag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TagDeleteOne{builder}
}

// Query returns a query builder for Tag.
func (c *TagClient) Query() *TagQuery {
	return &TagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTag},
		inters: c.Interceptors(),
	}
}

// Get returns a Tag entity by its id.
func (c *TagClient) Get(ctx context.Context, id uuid.UUID) (*Tag, error) {
	return c.Query().Where(tag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TagClient) GetX(ctx context.Context, id uuid.UUID) *Tag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TagClient) Hooks() []Hook {
	return c.hooks.Tag
}

// Interceptors returns the client interceptors.
func (c *TagClient) Interceptors() []Interceptor {
	return c.inters.Tag
}

func (c *TagClient) mutate(ctx context.Context, m *TagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Tag mutation op: %q", m.Op())
	}
}

// TeamClient is a client for the Team schema.
type TeamClient struct {
	config
}

// NewTeamClient returns a client for the Team from the given config.
func NewTeamClient(c config) *TeamClient {
	return &TeamClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `team.Hooks(f(g(h())))`.
func (c *TeamClient) Use(hooks ...Hook) {
	c.hooks.Team = append(c.hooks.Team, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `team.Intercept(f(g(h())))`.
func (c *TeamClient) Intercept(interceptors ...Interceptor) {
	c.inters.Team = append(c.inters.Team, interceptors...)
}

// Create returns a builder for creating a Team entity.
func (c *TeamClient) Create() *TeamCreate {
	mutation := newTeamMutation(c.config, OpCreate)
	return &TeamCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Team entities.
func (c *TeamClient) CreateBulk(builders ...*TeamCreate) *TeamCreateBulk {
	return &TeamCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TeamClient) MapCreateBulk(slice any, setFunc func(*TeamCreate, int)) *TeamCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TeamCreateBulk{err: fmt.Errorf("calling to TeamClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TeamCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TeamCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Team.
func (c *TeamClient) Update() *TeamUpdate {
	mutation := newTeamMutation(c.config, OpUpdate)
	return &TeamUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TeamClient) UpdateOne(t *Team) *TeamUpdateOne {
	mutation := newTeamMutation(c.config, OpUpdateOne, withTeam(t))
	return &TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TeamClient) UpdateOneID(id uuid.UUID) *TeamUpdateOne {
	mutation := newTeamMutation(c.config, OpUpdateOne, withTeamID(id))
	return &TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Team.
func (c *TeamClient) Delete() *TeamDelete {
	mutation := newTeamMutation(c.config, OpDelete)
	return &TeamDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TeamClient) DeleteOne(t *Team) *TeamDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TeamClient) DeleteOneID(id uuid.UUID) *TeamDeleteOne {
	builder := c.Delete().Where(team.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TeamDeleteOne{builder}
}

// Query returns a query builder for Team.
func (c *TeamClient) Query() *TeamQuery {
	return &TeamQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTeam},
		inters: c.Interceptors(),
	}
}

// Get returns a Team entity by its id.
func (c *TeamClient) Get(ctx context.Context, id uuid.UUID) (*Team, error) {
	return c.Query().Where(team.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TeamClient) GetX(ctx context.Context, id uuid.UUID) *Team {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeamToBuild queries the TeamToBuild edge of a Team.
func (c *TeamClient) QueryTeamToBuild(t *Team) *BuildQuery {
	query := (&BuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(build.Table, build.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, team.TeamToBuildTable, team.TeamToBuildColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeamToStatus queries the TeamToStatus edge of a Team.
func (c *TeamClient) QueryTeamToStatus(t *Team) *StatusQuery {
	query := (&StatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(status.Table, status.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, team.TeamToStatusTable, team.TeamToStatusColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeamToProvisionedNetwork queries the TeamToProvisionedNetwork edge of a Team.
func (c *TeamClient) QueryTeamToProvisionedNetwork(t *Team) *ProvisionedNetworkQuery {
	query := (&ProvisionedNetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(provisionednetwork.Table, provisionednetwork.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, team.TeamToProvisionedNetworkTable, team.TeamToProvisionedNetworkColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeamToPlan queries the TeamToPlan edge of a Team.
func (c *TeamClient) QueryTeamToPlan(t *Team) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, team.TeamToPlanTable, team.TeamToPlanColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TeamClient) Hooks() []Hook {
	return c.hooks.Team
}

// Interceptors returns the client interceptors.
func (c *TeamClient) Interceptors() []Interceptor {
	return c.inters.Team
}

func (c *TeamClient) mutate(ctx context.Context, m *TeamMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TeamCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TeamUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TeamDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Team mutation op: %q", m.Op())
	}
}

// TokenClient is a client for the Token schema.
type TokenClient struct {
	config
}

// NewTokenClient returns a client for the Token from the given config.
func NewTokenClient(c config) *TokenClient {
	return &TokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `token.Hooks(f(g(h())))`.
func (c *TokenClient) Use(hooks ...Hook) {
	c.hooks.Token = append(c.hooks.Token, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `token.Intercept(f(g(h())))`.
func (c *TokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.Token = append(c.inters.Token, interceptors...)
}

// Create returns a builder for creating a Token entity.
func (c *TokenClient) Create() *TokenCreate {
	mutation := newTokenMutation(c.config, OpCreate)
	return &TokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Token entities.
func (c *TokenClient) CreateBulk(builders ...*TokenCreate) *TokenCreateBulk {
	return &TokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TokenClient) MapCreateBulk(slice any, setFunc func(*TokenCreate, int)) *TokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TokenCreateBulk{err: fmt.Errorf("calling to TokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Token.
func (c *TokenClient) Update() *TokenUpdate {
	mutation := newTokenMutation(c.config, OpUpdate)
	return &TokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TokenClient) UpdateOne(t *Token) *TokenUpdateOne {
	mutation := newTokenMutation(c.config, OpUpdateOne, withToken(t))
	return &TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TokenClient) UpdateOneID(id uuid.UUID) *TokenUpdateOne {
	mutation := newTokenMutation(c.config, OpUpdateOne, withTokenID(id))
	return &TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Token.
func (c *TokenClient) Delete() *TokenDelete {
	mutation := newTokenMutation(c.config, OpDelete)
	return &TokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TokenClient) DeleteOne(t *Token) *TokenDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TokenClient) DeleteOneID(id uuid.UUID) *TokenDeleteOne {
	builder := c.Delete().Where(token.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TokenDeleteOne{builder}
}

// Query returns a query builder for Token.
func (c *TokenClient) Query() *TokenQuery {
	return &TokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeToken},
		inters: c.Interceptors(),
	}
}

// Get returns a Token entity by its id.
func (c *TokenClient) Get(ctx context.Context, id uuid.UUID) (*Token, error) {
	return c.Query().Where(token.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TokenClient) GetX(ctx context.Context, id uuid.UUID) *Token {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTokenToAuthUser queries the TokenToAuthUser edge of a Token.
func (c *TokenClient) QueryTokenToAuthUser(t *Token) *AuthUserQuery {
	query := (&AuthUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(token.Table, token.FieldID, id),
			sqlgraph.To(authuser.Table, authuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, token.TokenToAuthUserTable, token.TokenToAuthUserColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TokenClient) Hooks() []Hook {
	return c.hooks.Token
}

// Interceptors returns the client interceptors.
func (c *TokenClient) Interceptors() []Interceptor {
	return c.inters.Token
}

func (c *TokenClient) mutate(ctx context.Context, m *TokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Token mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserToTag queries the UserToTag edge of a User.
func (c *UserClient) QueryUserToTag(u *User) *TagQuery {
	query := (&TagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(tag.Table, tag.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UserToTagTable, user.UserToTagColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserToEnvironment queries the UserToEnvironment edge of a User.
func (c *UserClient) QueryUserToEnvironment(u *User) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, user.UserToEnvironmentTable, user.UserToEnvironmentPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AdhocPlan, AgentStatus, AgentTask, Ansible, AuthUser, Build, BuildCommit,
		Command, Competition, DNS, DNSRecord, Disk, Environment, FileDelete,
		FileDownload, FileExtract, Finding, GinFileMiddleware, Host, HostDependency,
		Identity, IncludedNetwork, Network, Plan, PlanDiff, ProvisionedHost,
		ProvisionedNetwork, ProvisioningStep, RepoCommit, Repository, Script,
		ServerTask, Status, Tag, Team, Token, User []ent.Hook
	}
	inters struct {
		AdhocPlan, AgentStatus, AgentTask, Ansible, AuthUser, Build, BuildCommit,
		Command, Competition, DNS, DNSRecord, Disk, Environment, FileDelete,
		FileDownload, FileExtract, Finding, GinFileMiddleware, Host, HostDependency,
		Identity, IncludedNetwork, Network, Plan, PlanDiff, ProvisionedHost,
		ProvisionedNetwork, ProvisioningStep, RepoCommit, Repository, Script,
		ServerTask, Status, Tag, Team, Token, User []ent.Interceptor
	}
)
