// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/gen0cide/laforge/ent/migrate"
	"github.com/google/uuid"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/gen0cide/laforge/ent/adhocplan"
	"github.com/gen0cide/laforge/ent/agentstatus"
	"github.com/gen0cide/laforge/ent/agenttask"
	"github.com/gen0cide/laforge/ent/ansible"
	"github.com/gen0cide/laforge/ent/authuser"
	"github.com/gen0cide/laforge/ent/build"
	"github.com/gen0cide/laforge/ent/buildcommit"
	"github.com/gen0cide/laforge/ent/command"
	"github.com/gen0cide/laforge/ent/competition"
	"github.com/gen0cide/laforge/ent/disk"
	"github.com/gen0cide/laforge/ent/dns"
	"github.com/gen0cide/laforge/ent/dnsrecord"
	"github.com/gen0cide/laforge/ent/environment"
	"github.com/gen0cide/laforge/ent/filedelete"
	"github.com/gen0cide/laforge/ent/filedownload"
	"github.com/gen0cide/laforge/ent/fileextract"
	"github.com/gen0cide/laforge/ent/finding"
	"github.com/gen0cide/laforge/ent/ginfilemiddleware"
	"github.com/gen0cide/laforge/ent/host"
	"github.com/gen0cide/laforge/ent/hostdependency"
	"github.com/gen0cide/laforge/ent/identity"
	"github.com/gen0cide/laforge/ent/includednetwork"
	"github.com/gen0cide/laforge/ent/network"
	"github.com/gen0cide/laforge/ent/plan"
	"github.com/gen0cide/laforge/ent/plandiff"
	"github.com/gen0cide/laforge/ent/provisionedhost"
	"github.com/gen0cide/laforge/ent/provisionednetwork"
	"github.com/gen0cide/laforge/ent/provisioningscheduledstep"
	"github.com/gen0cide/laforge/ent/provisioningstep"
	"github.com/gen0cide/laforge/ent/repocommit"
	"github.com/gen0cide/laforge/ent/repository"
	"github.com/gen0cide/laforge/ent/scheduledstep"
	"github.com/gen0cide/laforge/ent/script"
	"github.com/gen0cide/laforge/ent/servertask"
	"github.com/gen0cide/laforge/ent/status"
	"github.com/gen0cide/laforge/ent/tag"
	"github.com/gen0cide/laforge/ent/team"
	"github.com/gen0cide/laforge/ent/token"
	"github.com/gen0cide/laforge/ent/user"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AdhocPlan is the client for interacting with the AdhocPlan builders.
	AdhocPlan *AdhocPlanClient
	// AgentStatus is the client for interacting with the AgentStatus builders.
	AgentStatus *AgentStatusClient
	// AgentTask is the client for interacting with the AgentTask builders.
	AgentTask *AgentTaskClient
	// Ansible is the client for interacting with the Ansible builders.
	Ansible *AnsibleClient
	// AuthUser is the client for interacting with the AuthUser builders.
	AuthUser *AuthUserClient
	// Build is the client for interacting with the Build builders.
	Build *BuildClient
	// BuildCommit is the client for interacting with the BuildCommit builders.
	BuildCommit *BuildCommitClient
	// Command is the client for interacting with the Command builders.
	Command *CommandClient
	// Competition is the client for interacting with the Competition builders.
	Competition *CompetitionClient
	// DNS is the client for interacting with the DNS builders.
	DNS *DNSClient
	// DNSRecord is the client for interacting with the DNSRecord builders.
	DNSRecord *DNSRecordClient
	// Disk is the client for interacting with the Disk builders.
	Disk *DiskClient
	// Environment is the client for interacting with the Environment builders.
	Environment *EnvironmentClient
	// FileDelete is the client for interacting with the FileDelete builders.
	FileDelete *FileDeleteClient
	// FileDownload is the client for interacting with the FileDownload builders.
	FileDownload *FileDownloadClient
	// FileExtract is the client for interacting with the FileExtract builders.
	FileExtract *FileExtractClient
	// Finding is the client for interacting with the Finding builders.
	Finding *FindingClient
	// GinFileMiddleware is the client for interacting with the GinFileMiddleware builders.
	GinFileMiddleware *GinFileMiddlewareClient
	// Host is the client for interacting with the Host builders.
	Host *HostClient
	// HostDependency is the client for interacting with the HostDependency builders.
	HostDependency *HostDependencyClient
	// Identity is the client for interacting with the Identity builders.
	Identity *IdentityClient
	// IncludedNetwork is the client for interacting with the IncludedNetwork builders.
	IncludedNetwork *IncludedNetworkClient
	// Network is the client for interacting with the Network builders.
	Network *NetworkClient
	// Plan is the client for interacting with the Plan builders.
	Plan *PlanClient
	// PlanDiff is the client for interacting with the PlanDiff builders.
	PlanDiff *PlanDiffClient
	// ProvisionedHost is the client for interacting with the ProvisionedHost builders.
	ProvisionedHost *ProvisionedHostClient
	// ProvisionedNetwork is the client for interacting with the ProvisionedNetwork builders.
	ProvisionedNetwork *ProvisionedNetworkClient
	// ProvisioningScheduledStep is the client for interacting with the ProvisioningScheduledStep builders.
	ProvisioningScheduledStep *ProvisioningScheduledStepClient
	// ProvisioningStep is the client for interacting with the ProvisioningStep builders.
	ProvisioningStep *ProvisioningStepClient
	// RepoCommit is the client for interacting with the RepoCommit builders.
	RepoCommit *RepoCommitClient
	// Repository is the client for interacting with the Repository builders.
	Repository *RepositoryClient
	// ScheduledStep is the client for interacting with the ScheduledStep builders.
	ScheduledStep *ScheduledStepClient
	// Script is the client for interacting with the Script builders.
	Script *ScriptClient
	// ServerTask is the client for interacting with the ServerTask builders.
	ServerTask *ServerTaskClient
	// Status is the client for interacting with the Status builders.
	Status *StatusClient
	// Tag is the client for interacting with the Tag builders.
	Tag *TagClient
	// Team is the client for interacting with the Team builders.
	Team *TeamClient
	// Token is the client for interacting with the Token builders.
	Token *TokenClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AdhocPlan = NewAdhocPlanClient(c.config)
	c.AgentStatus = NewAgentStatusClient(c.config)
	c.AgentTask = NewAgentTaskClient(c.config)
	c.Ansible = NewAnsibleClient(c.config)
	c.AuthUser = NewAuthUserClient(c.config)
	c.Build = NewBuildClient(c.config)
	c.BuildCommit = NewBuildCommitClient(c.config)
	c.Command = NewCommandClient(c.config)
	c.Competition = NewCompetitionClient(c.config)
	c.DNS = NewDNSClient(c.config)
	c.DNSRecord = NewDNSRecordClient(c.config)
	c.Disk = NewDiskClient(c.config)
	c.Environment = NewEnvironmentClient(c.config)
	c.FileDelete = NewFileDeleteClient(c.config)
	c.FileDownload = NewFileDownloadClient(c.config)
	c.FileExtract = NewFileExtractClient(c.config)
	c.Finding = NewFindingClient(c.config)
	c.GinFileMiddleware = NewGinFileMiddlewareClient(c.config)
	c.Host = NewHostClient(c.config)
	c.HostDependency = NewHostDependencyClient(c.config)
	c.Identity = NewIdentityClient(c.config)
	c.IncludedNetwork = NewIncludedNetworkClient(c.config)
	c.Network = NewNetworkClient(c.config)
	c.Plan = NewPlanClient(c.config)
	c.PlanDiff = NewPlanDiffClient(c.config)
	c.ProvisionedHost = NewProvisionedHostClient(c.config)
	c.ProvisionedNetwork = NewProvisionedNetworkClient(c.config)
	c.ProvisioningScheduledStep = NewProvisioningScheduledStepClient(c.config)
	c.ProvisioningStep = NewProvisioningStepClient(c.config)
	c.RepoCommit = NewRepoCommitClient(c.config)
	c.Repository = NewRepositoryClient(c.config)
	c.ScheduledStep = NewScheduledStepClient(c.config)
	c.Script = NewScriptClient(c.config)
	c.ServerTask = NewServerTaskClient(c.config)
	c.Status = NewStatusClient(c.config)
	c.Tag = NewTagClient(c.config)
	c.Team = NewTeamClient(c.config)
	c.Token = NewTokenClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                       ctx,
		config:                    cfg,
		AdhocPlan:                 NewAdhocPlanClient(cfg),
		AgentStatus:               NewAgentStatusClient(cfg),
		AgentTask:                 NewAgentTaskClient(cfg),
		Ansible:                   NewAnsibleClient(cfg),
		AuthUser:                  NewAuthUserClient(cfg),
		Build:                     NewBuildClient(cfg),
		BuildCommit:               NewBuildCommitClient(cfg),
		Command:                   NewCommandClient(cfg),
		Competition:               NewCompetitionClient(cfg),
		DNS:                       NewDNSClient(cfg),
		DNSRecord:                 NewDNSRecordClient(cfg),
		Disk:                      NewDiskClient(cfg),
		Environment:               NewEnvironmentClient(cfg),
		FileDelete:                NewFileDeleteClient(cfg),
		FileDownload:              NewFileDownloadClient(cfg),
		FileExtract:               NewFileExtractClient(cfg),
		Finding:                   NewFindingClient(cfg),
		GinFileMiddleware:         NewGinFileMiddlewareClient(cfg),
		Host:                      NewHostClient(cfg),
		HostDependency:            NewHostDependencyClient(cfg),
		Identity:                  NewIdentityClient(cfg),
		IncludedNetwork:           NewIncludedNetworkClient(cfg),
		Network:                   NewNetworkClient(cfg),
		Plan:                      NewPlanClient(cfg),
		PlanDiff:                  NewPlanDiffClient(cfg),
		ProvisionedHost:           NewProvisionedHostClient(cfg),
		ProvisionedNetwork:        NewProvisionedNetworkClient(cfg),
		ProvisioningScheduledStep: NewProvisioningScheduledStepClient(cfg),
		ProvisioningStep:          NewProvisioningStepClient(cfg),
		RepoCommit:                NewRepoCommitClient(cfg),
		Repository:                NewRepositoryClient(cfg),
		ScheduledStep:             NewScheduledStepClient(cfg),
		Script:                    NewScriptClient(cfg),
		ServerTask:                NewServerTaskClient(cfg),
		Status:                    NewStatusClient(cfg),
		Tag:                       NewTagClient(cfg),
		Team:                      NewTeamClient(cfg),
		Token:                     NewTokenClient(cfg),
		User:                      NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                       ctx,
		config:                    cfg,
		AdhocPlan:                 NewAdhocPlanClient(cfg),
		AgentStatus:               NewAgentStatusClient(cfg),
		AgentTask:                 NewAgentTaskClient(cfg),
		Ansible:                   NewAnsibleClient(cfg),
		AuthUser:                  NewAuthUserClient(cfg),
		Build:                     NewBuildClient(cfg),
		BuildCommit:               NewBuildCommitClient(cfg),
		Command:                   NewCommandClient(cfg),
		Competition:               NewCompetitionClient(cfg),
		DNS:                       NewDNSClient(cfg),
		DNSRecord:                 NewDNSRecordClient(cfg),
		Disk:                      NewDiskClient(cfg),
		Environment:               NewEnvironmentClient(cfg),
		FileDelete:                NewFileDeleteClient(cfg),
		FileDownload:              NewFileDownloadClient(cfg),
		FileExtract:               NewFileExtractClient(cfg),
		Finding:                   NewFindingClient(cfg),
		GinFileMiddleware:         NewGinFileMiddlewareClient(cfg),
		Host:                      NewHostClient(cfg),
		HostDependency:            NewHostDependencyClient(cfg),
		Identity:                  NewIdentityClient(cfg),
		IncludedNetwork:           NewIncludedNetworkClient(cfg),
		Network:                   NewNetworkClient(cfg),
		Plan:                      NewPlanClient(cfg),
		PlanDiff:                  NewPlanDiffClient(cfg),
		ProvisionedHost:           NewProvisionedHostClient(cfg),
		ProvisionedNetwork:        NewProvisionedNetworkClient(cfg),
		ProvisioningScheduledStep: NewProvisioningScheduledStepClient(cfg),
		ProvisioningStep:          NewProvisioningStepClient(cfg),
		RepoCommit:                NewRepoCommitClient(cfg),
		Repository:                NewRepositoryClient(cfg),
		ScheduledStep:             NewScheduledStepClient(cfg),
		Script:                    NewScriptClient(cfg),
		ServerTask:                NewServerTaskClient(cfg),
		Status:                    NewStatusClient(cfg),
		Tag:                       NewTagClient(cfg),
		Team:                      NewTeamClient(cfg),
		Token:                     NewTokenClient(cfg),
		User:                      NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AdhocPlan.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AdhocPlan, c.AgentStatus, c.AgentTask, c.Ansible, c.AuthUser, c.Build,
		c.BuildCommit, c.Command, c.Competition, c.DNS, c.DNSRecord, c.Disk,
		c.Environment, c.FileDelete, c.FileDownload, c.FileExtract, c.Finding,
		c.GinFileMiddleware, c.Host, c.HostDependency, c.Identity, c.IncludedNetwork,
		c.Network, c.Plan, c.PlanDiff, c.ProvisionedHost, c.ProvisionedNetwork,
		c.ProvisioningScheduledStep, c.ProvisioningStep, c.RepoCommit, c.Repository,
		c.ScheduledStep, c.Script, c.ServerTask, c.Status, c.Tag, c.Team, c.Token,
		c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AdhocPlan, c.AgentStatus, c.AgentTask, c.Ansible, c.AuthUser, c.Build,
		c.BuildCommit, c.Command, c.Competition, c.DNS, c.DNSRecord, c.Disk,
		c.Environment, c.FileDelete, c.FileDownload, c.FileExtract, c.Finding,
		c.GinFileMiddleware, c.Host, c.HostDependency, c.Identity, c.IncludedNetwork,
		c.Network, c.Plan, c.PlanDiff, c.ProvisionedHost, c.ProvisionedNetwork,
		c.ProvisioningScheduledStep, c.ProvisioningStep, c.RepoCommit, c.Repository,
		c.ScheduledStep, c.Script, c.ServerTask, c.Status, c.Tag, c.Team, c.Token,
		c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AdhocPlanMutation:
		return c.AdhocPlan.mutate(ctx, m)
	case *AgentStatusMutation:
		return c.AgentStatus.mutate(ctx, m)
	case *AgentTaskMutation:
		return c.AgentTask.mutate(ctx, m)
	case *AnsibleMutation:
		return c.Ansible.mutate(ctx, m)
	case *AuthUserMutation:
		return c.AuthUser.mutate(ctx, m)
	case *BuildMutation:
		return c.Build.mutate(ctx, m)
	case *BuildCommitMutation:
		return c.BuildCommit.mutate(ctx, m)
	case *CommandMutation:
		return c.Command.mutate(ctx, m)
	case *CompetitionMutation:
		return c.Competition.mutate(ctx, m)
	case *DNSMutation:
		return c.DNS.mutate(ctx, m)
	case *DNSRecordMutation:
		return c.DNSRecord.mutate(ctx, m)
	case *DiskMutation:
		return c.Disk.mutate(ctx, m)
	case *EnvironmentMutation:
		return c.Environment.mutate(ctx, m)
	case *FileDeleteMutation:
		return c.FileDelete.mutate(ctx, m)
	case *FileDownloadMutation:
		return c.FileDownload.mutate(ctx, m)
	case *FileExtractMutation:
		return c.FileExtract.mutate(ctx, m)
	case *FindingMutation:
		return c.Finding.mutate(ctx, m)
	case *GinFileMiddlewareMutation:
		return c.GinFileMiddleware.mutate(ctx, m)
	case *HostMutation:
		return c.Host.mutate(ctx, m)
	case *HostDependencyMutation:
		return c.HostDependency.mutate(ctx, m)
	case *IdentityMutation:
		return c.Identity.mutate(ctx, m)
	case *IncludedNetworkMutation:
		return c.IncludedNetwork.mutate(ctx, m)
	case *NetworkMutation:
		return c.Network.mutate(ctx, m)
	case *PlanMutation:
		return c.Plan.mutate(ctx, m)
	case *PlanDiffMutation:
		return c.PlanDiff.mutate(ctx, m)
	case *ProvisionedHostMutation:
		return c.ProvisionedHost.mutate(ctx, m)
	case *ProvisionedNetworkMutation:
		return c.ProvisionedNetwork.mutate(ctx, m)
	case *ProvisioningScheduledStepMutation:
		return c.ProvisioningScheduledStep.mutate(ctx, m)
	case *ProvisioningStepMutation:
		return c.ProvisioningStep.mutate(ctx, m)
	case *RepoCommitMutation:
		return c.RepoCommit.mutate(ctx, m)
	case *RepositoryMutation:
		return c.Repository.mutate(ctx, m)
	case *ScheduledStepMutation:
		return c.ScheduledStep.mutate(ctx, m)
	case *ScriptMutation:
		return c.Script.mutate(ctx, m)
	case *ServerTaskMutation:
		return c.ServerTask.mutate(ctx, m)
	case *StatusMutation:
		return c.Status.mutate(ctx, m)
	case *TagMutation:
		return c.Tag.mutate(ctx, m)
	case *TeamMutation:
		return c.Team.mutate(ctx, m)
	case *TokenMutation:
		return c.Token.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AdhocPlanClient is a client for the AdhocPlan schema.
type AdhocPlanClient struct {
	config
}

// NewAdhocPlanClient returns a client for the AdhocPlan from the given config.
func NewAdhocPlanClient(c config) *AdhocPlanClient {
	return &AdhocPlanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `adhocplan.Hooks(f(g(h())))`.
func (c *AdhocPlanClient) Use(hooks ...Hook) {
	c.hooks.AdhocPlan = append(c.hooks.AdhocPlan, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `adhocplan.Intercept(f(g(h())))`.
func (c *AdhocPlanClient) Intercept(interceptors ...Interceptor) {
	c.inters.AdhocPlan = append(c.inters.AdhocPlan, interceptors...)
}

// Create returns a builder for creating a AdhocPlan entity.
func (c *AdhocPlanClient) Create() *AdhocPlanCreate {
	mutation := newAdhocPlanMutation(c.config, OpCreate)
	return &AdhocPlanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AdhocPlan entities.
func (c *AdhocPlanClient) CreateBulk(builders ...*AdhocPlanCreate) *AdhocPlanCreateBulk {
	return &AdhocPlanCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AdhocPlanClient) MapCreateBulk(slice any, setFunc func(*AdhocPlanCreate, int)) *AdhocPlanCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AdhocPlanCreateBulk{err: fmt.Errorf("calling to AdhocPlanClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AdhocPlanCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AdhocPlanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AdhocPlan.
func (c *AdhocPlanClient) Update() *AdhocPlanUpdate {
	mutation := newAdhocPlanMutation(c.config, OpUpdate)
	return &AdhocPlanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AdhocPlanClient) UpdateOne(ap *AdhocPlan) *AdhocPlanUpdateOne {
	mutation := newAdhocPlanMutation(c.config, OpUpdateOne, withAdhocPlan(ap))
	return &AdhocPlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AdhocPlanClient) UpdateOneID(id uuid.UUID) *AdhocPlanUpdateOne {
	mutation := newAdhocPlanMutation(c.config, OpUpdateOne, withAdhocPlanID(id))
	return &AdhocPlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AdhocPlan.
func (c *AdhocPlanClient) Delete() *AdhocPlanDelete {
	mutation := newAdhocPlanMutation(c.config, OpDelete)
	return &AdhocPlanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AdhocPlanClient) DeleteOne(ap *AdhocPlan) *AdhocPlanDeleteOne {
	return c.DeleteOneID(ap.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AdhocPlanClient) DeleteOneID(id uuid.UUID) *AdhocPlanDeleteOne {
	builder := c.Delete().Where(adhocplan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AdhocPlanDeleteOne{builder}
}

// Query returns a query builder for AdhocPlan.
func (c *AdhocPlanClient) Query() *AdhocPlanQuery {
	return &AdhocPlanQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAdhocPlan},
		inters: c.Interceptors(),
	}
}

// Get returns a AdhocPlan entity by its id.
func (c *AdhocPlanClient) Get(ctx context.Context, id uuid.UUID) (*AdhocPlan, error) {
	return c.Query().Where(adhocplan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AdhocPlanClient) GetX(ctx context.Context, id uuid.UUID) *AdhocPlan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPrevAdhocPlans queries the PrevAdhocPlans edge of a AdhocPlan.
func (c *AdhocPlanClient) QueryPrevAdhocPlans(ap *AdhocPlan) *AdhocPlanQuery {
	query := (&AdhocPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(adhocplan.Table, adhocplan.FieldID, id),
			sqlgraph.To(adhocplan.Table, adhocplan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, adhocplan.PrevAdhocPlansTable, adhocplan.PrevAdhocPlansPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNextAdhocPlans queries the NextAdhocPlans edge of a AdhocPlan.
func (c *AdhocPlanClient) QueryNextAdhocPlans(ap *AdhocPlan) *AdhocPlanQuery {
	query := (&AdhocPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(adhocplan.Table, adhocplan.FieldID, id),
			sqlgraph.To(adhocplan.Table, adhocplan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, adhocplan.NextAdhocPlansTable, adhocplan.NextAdhocPlansPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuild queries the Build edge of a AdhocPlan.
func (c *AdhocPlanClient) QueryBuild(ap *AdhocPlan) *BuildQuery {
	query := (&BuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(adhocplan.Table, adhocplan.FieldID, id),
			sqlgraph.To(build.Table, build.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, adhocplan.BuildTable, adhocplan.BuildColumn),
		)
		fromV = sqlgraph.Neighbors(ap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStatus queries the Status edge of a AdhocPlan.
func (c *AdhocPlanClient) QueryStatus(ap *AdhocPlan) *StatusQuery {
	query := (&StatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(adhocplan.Table, adhocplan.FieldID, id),
			sqlgraph.To(status.Table, status.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, adhocplan.StatusTable, adhocplan.StatusColumn),
		)
		fromV = sqlgraph.Neighbors(ap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAgentTask queries the AgentTask edge of a AdhocPlan.
func (c *AdhocPlanClient) QueryAgentTask(ap *AdhocPlan) *AgentTaskQuery {
	query := (&AgentTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ap.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(adhocplan.Table, adhocplan.FieldID, id),
			sqlgraph.To(agenttask.Table, agenttask.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, adhocplan.AgentTaskTable, adhocplan.AgentTaskColumn),
		)
		fromV = sqlgraph.Neighbors(ap.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AdhocPlanClient) Hooks() []Hook {
	return c.hooks.AdhocPlan
}

// Interceptors returns the client interceptors.
func (c *AdhocPlanClient) Interceptors() []Interceptor {
	return c.inters.AdhocPlan
}

func (c *AdhocPlanClient) mutate(ctx context.Context, m *AdhocPlanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AdhocPlanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AdhocPlanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AdhocPlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AdhocPlanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AdhocPlan mutation op: %q", m.Op())
	}
}

// AgentStatusClient is a client for the AgentStatus schema.
type AgentStatusClient struct {
	config
}

// NewAgentStatusClient returns a client for the AgentStatus from the given config.
func NewAgentStatusClient(c config) *AgentStatusClient {
	return &AgentStatusClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `agentstatus.Hooks(f(g(h())))`.
func (c *AgentStatusClient) Use(hooks ...Hook) {
	c.hooks.AgentStatus = append(c.hooks.AgentStatus, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `agentstatus.Intercept(f(g(h())))`.
func (c *AgentStatusClient) Intercept(interceptors ...Interceptor) {
	c.inters.AgentStatus = append(c.inters.AgentStatus, interceptors...)
}

// Create returns a builder for creating a AgentStatus entity.
func (c *AgentStatusClient) Create() *AgentStatusCreate {
	mutation := newAgentStatusMutation(c.config, OpCreate)
	return &AgentStatusCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AgentStatus entities.
func (c *AgentStatusClient) CreateBulk(builders ...*AgentStatusCreate) *AgentStatusCreateBulk {
	return &AgentStatusCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AgentStatusClient) MapCreateBulk(slice any, setFunc func(*AgentStatusCreate, int)) *AgentStatusCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AgentStatusCreateBulk{err: fmt.Errorf("calling to AgentStatusClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AgentStatusCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AgentStatusCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AgentStatus.
func (c *AgentStatusClient) Update() *AgentStatusUpdate {
	mutation := newAgentStatusMutation(c.config, OpUpdate)
	return &AgentStatusUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AgentStatusClient) UpdateOne(as *AgentStatus) *AgentStatusUpdateOne {
	mutation := newAgentStatusMutation(c.config, OpUpdateOne, withAgentStatus(as))
	return &AgentStatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AgentStatusClient) UpdateOneID(id uuid.UUID) *AgentStatusUpdateOne {
	mutation := newAgentStatusMutation(c.config, OpUpdateOne, withAgentStatusID(id))
	return &AgentStatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AgentStatus.
func (c *AgentStatusClient) Delete() *AgentStatusDelete {
	mutation := newAgentStatusMutation(c.config, OpDelete)
	return &AgentStatusDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AgentStatusClient) DeleteOne(as *AgentStatus) *AgentStatusDeleteOne {
	return c.DeleteOneID(as.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AgentStatusClient) DeleteOneID(id uuid.UUID) *AgentStatusDeleteOne {
	builder := c.Delete().Where(agentstatus.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AgentStatusDeleteOne{builder}
}

// Query returns a query builder for AgentStatus.
func (c *AgentStatusClient) Query() *AgentStatusQuery {
	return &AgentStatusQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAgentStatus},
		inters: c.Interceptors(),
	}
}

// Get returns a AgentStatus entity by its id.
func (c *AgentStatusClient) Get(ctx context.Context, id uuid.UUID) (*AgentStatus, error) {
	return c.Query().Where(agentstatus.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AgentStatusClient) GetX(ctx context.Context, id uuid.UUID) *AgentStatus {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProvisionedHost queries the ProvisionedHost edge of a AgentStatus.
func (c *AgentStatusClient) QueryProvisionedHost(as *AgentStatus) *ProvisionedHostQuery {
	query := (&ProvisionedHostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := as.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agentstatus.Table, agentstatus.FieldID, id),
			sqlgraph.To(provisionedhost.Table, provisionedhost.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, agentstatus.ProvisionedHostTable, agentstatus.ProvisionedHostColumn),
		)
		fromV = sqlgraph.Neighbors(as.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedNetwork queries the ProvisionedNetwork edge of a AgentStatus.
func (c *AgentStatusClient) QueryProvisionedNetwork(as *AgentStatus) *ProvisionedNetworkQuery {
	query := (&ProvisionedNetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := as.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agentstatus.Table, agentstatus.FieldID, id),
			sqlgraph.To(provisionednetwork.Table, provisionednetwork.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, agentstatus.ProvisionedNetworkTable, agentstatus.ProvisionedNetworkColumn),
		)
		fromV = sqlgraph.Neighbors(as.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuild queries the Build edge of a AgentStatus.
func (c *AgentStatusClient) QueryBuild(as *AgentStatus) *BuildQuery {
	query := (&BuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := as.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agentstatus.Table, agentstatus.FieldID, id),
			sqlgraph.To(build.Table, build.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, agentstatus.BuildTable, agentstatus.BuildColumn),
		)
		fromV = sqlgraph.Neighbors(as.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AgentStatusClient) Hooks() []Hook {
	return c.hooks.AgentStatus
}

// Interceptors returns the client interceptors.
func (c *AgentStatusClient) Interceptors() []Interceptor {
	return c.inters.AgentStatus
}

func (c *AgentStatusClient) mutate(ctx context.Context, m *AgentStatusMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AgentStatusCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AgentStatusUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AgentStatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AgentStatusDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AgentStatus mutation op: %q", m.Op())
	}
}

// AgentTaskClient is a client for the AgentTask schema.
type AgentTaskClient struct {
	config
}

// NewAgentTaskClient returns a client for the AgentTask from the given config.
func NewAgentTaskClient(c config) *AgentTaskClient {
	return &AgentTaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `agenttask.Hooks(f(g(h())))`.
func (c *AgentTaskClient) Use(hooks ...Hook) {
	c.hooks.AgentTask = append(c.hooks.AgentTask, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `agenttask.Intercept(f(g(h())))`.
func (c *AgentTaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.AgentTask = append(c.inters.AgentTask, interceptors...)
}

// Create returns a builder for creating a AgentTask entity.
func (c *AgentTaskClient) Create() *AgentTaskCreate {
	mutation := newAgentTaskMutation(c.config, OpCreate)
	return &AgentTaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AgentTask entities.
func (c *AgentTaskClient) CreateBulk(builders ...*AgentTaskCreate) *AgentTaskCreateBulk {
	return &AgentTaskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AgentTaskClient) MapCreateBulk(slice any, setFunc func(*AgentTaskCreate, int)) *AgentTaskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AgentTaskCreateBulk{err: fmt.Errorf("calling to AgentTaskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AgentTaskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AgentTaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AgentTask.
func (c *AgentTaskClient) Update() *AgentTaskUpdate {
	mutation := newAgentTaskMutation(c.config, OpUpdate)
	return &AgentTaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AgentTaskClient) UpdateOne(at *AgentTask) *AgentTaskUpdateOne {
	mutation := newAgentTaskMutation(c.config, OpUpdateOne, withAgentTask(at))
	return &AgentTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AgentTaskClient) UpdateOneID(id uuid.UUID) *AgentTaskUpdateOne {
	mutation := newAgentTaskMutation(c.config, OpUpdateOne, withAgentTaskID(id))
	return &AgentTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AgentTask.
func (c *AgentTaskClient) Delete() *AgentTaskDelete {
	mutation := newAgentTaskMutation(c.config, OpDelete)
	return &AgentTaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AgentTaskClient) DeleteOne(at *AgentTask) *AgentTaskDeleteOne {
	return c.DeleteOneID(at.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AgentTaskClient) DeleteOneID(id uuid.UUID) *AgentTaskDeleteOne {
	builder := c.Delete().Where(agenttask.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AgentTaskDeleteOne{builder}
}

// Query returns a query builder for AgentTask.
func (c *AgentTaskClient) Query() *AgentTaskQuery {
	return &AgentTaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAgentTask},
		inters: c.Interceptors(),
	}
}

// Get returns a AgentTask entity by its id.
func (c *AgentTaskClient) Get(ctx context.Context, id uuid.UUID) (*AgentTask, error) {
	return c.Query().Where(agenttask.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AgentTaskClient) GetX(ctx context.Context, id uuid.UUID) *AgentTask {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProvisioningStep queries the ProvisioningStep edge of a AgentTask.
func (c *AgentTaskClient) QueryProvisioningStep(at *AgentTask) *ProvisioningStepQuery {
	query := (&ProvisioningStepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := at.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agenttask.Table, agenttask.FieldID, id),
			sqlgraph.To(provisioningstep.Table, provisioningstep.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, agenttask.ProvisioningStepTable, agenttask.ProvisioningStepColumn),
		)
		fromV = sqlgraph.Neighbors(at.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisioningScheduledStep queries the ProvisioningScheduledStep edge of a AgentTask.
func (c *AgentTaskClient) QueryProvisioningScheduledStep(at *AgentTask) *ProvisioningScheduledStepQuery {
	query := (&ProvisioningScheduledStepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := at.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agenttask.Table, agenttask.FieldID, id),
			sqlgraph.To(provisioningscheduledstep.Table, provisioningscheduledstep.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, agenttask.ProvisioningScheduledStepTable, agenttask.ProvisioningScheduledStepColumn),
		)
		fromV = sqlgraph.Neighbors(at.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedHost queries the ProvisionedHost edge of a AgentTask.
func (c *AgentTaskClient) QueryProvisionedHost(at *AgentTask) *ProvisionedHostQuery {
	query := (&ProvisionedHostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := at.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agenttask.Table, agenttask.FieldID, id),
			sqlgraph.To(provisionedhost.Table, provisionedhost.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, agenttask.ProvisionedHostTable, agenttask.ProvisionedHostColumn),
		)
		fromV = sqlgraph.Neighbors(at.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAdhocPlans queries the AdhocPlans edge of a AgentTask.
func (c *AgentTaskClient) QueryAdhocPlans(at *AgentTask) *AdhocPlanQuery {
	query := (&AdhocPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := at.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agenttask.Table, agenttask.FieldID, id),
			sqlgraph.To(adhocplan.Table, adhocplan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, agenttask.AdhocPlansTable, agenttask.AdhocPlansColumn),
		)
		fromV = sqlgraph.Neighbors(at.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AgentTaskClient) Hooks() []Hook {
	return c.hooks.AgentTask
}

// Interceptors returns the client interceptors.
func (c *AgentTaskClient) Interceptors() []Interceptor {
	return c.inters.AgentTask
}

func (c *AgentTaskClient) mutate(ctx context.Context, m *AgentTaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AgentTaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AgentTaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AgentTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AgentTaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AgentTask mutation op: %q", m.Op())
	}
}

// AnsibleClient is a client for the Ansible schema.
type AnsibleClient struct {
	config
}

// NewAnsibleClient returns a client for the Ansible from the given config.
func NewAnsibleClient(c config) *AnsibleClient {
	return &AnsibleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ansible.Hooks(f(g(h())))`.
func (c *AnsibleClient) Use(hooks ...Hook) {
	c.hooks.Ansible = append(c.hooks.Ansible, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ansible.Intercept(f(g(h())))`.
func (c *AnsibleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Ansible = append(c.inters.Ansible, interceptors...)
}

// Create returns a builder for creating a Ansible entity.
func (c *AnsibleClient) Create() *AnsibleCreate {
	mutation := newAnsibleMutation(c.config, OpCreate)
	return &AnsibleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Ansible entities.
func (c *AnsibleClient) CreateBulk(builders ...*AnsibleCreate) *AnsibleCreateBulk {
	return &AnsibleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AnsibleClient) MapCreateBulk(slice any, setFunc func(*AnsibleCreate, int)) *AnsibleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AnsibleCreateBulk{err: fmt.Errorf("calling to AnsibleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AnsibleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AnsibleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Ansible.
func (c *AnsibleClient) Update() *AnsibleUpdate {
	mutation := newAnsibleMutation(c.config, OpUpdate)
	return &AnsibleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AnsibleClient) UpdateOne(a *Ansible) *AnsibleUpdateOne {
	mutation := newAnsibleMutation(c.config, OpUpdateOne, withAnsible(a))
	return &AnsibleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AnsibleClient) UpdateOneID(id uuid.UUID) *AnsibleUpdateOne {
	mutation := newAnsibleMutation(c.config, OpUpdateOne, withAnsibleID(id))
	return &AnsibleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Ansible.
func (c *AnsibleClient) Delete() *AnsibleDelete {
	mutation := newAnsibleMutation(c.config, OpDelete)
	return &AnsibleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AnsibleClient) DeleteOne(a *Ansible) *AnsibleDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AnsibleClient) DeleteOneID(id uuid.UUID) *AnsibleDeleteOne {
	builder := c.Delete().Where(ansible.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AnsibleDeleteOne{builder}
}

// Query returns a query builder for Ansible.
func (c *AnsibleClient) Query() *AnsibleQuery {
	return &AnsibleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAnsible},
		inters: c.Interceptors(),
	}
}

// Get returns a Ansible entity by its id.
func (c *AnsibleClient) Get(ctx context.Context, id uuid.UUID) (*Ansible, error) {
	return c.Query().Where(ansible.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AnsibleClient) GetX(ctx context.Context, id uuid.UUID) *Ansible {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the Users edge of a Ansible.
func (c *AnsibleClient) QueryUsers(a *Ansible) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ansible.Table, ansible.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ansible.UsersTable, ansible.UsersColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironment queries the Environment edge of a Ansible.
func (c *AnsibleClient) QueryEnvironment(a *Ansible) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ansible.Table, ansible.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ansible.EnvironmentTable, ansible.EnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AnsibleClient) Hooks() []Hook {
	return c.hooks.Ansible
}

// Interceptors returns the client interceptors.
func (c *AnsibleClient) Interceptors() []Interceptor {
	return c.inters.Ansible
}

func (c *AnsibleClient) mutate(ctx context.Context, m *AnsibleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AnsibleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AnsibleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AnsibleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AnsibleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Ansible mutation op: %q", m.Op())
	}
}

// AuthUserClient is a client for the AuthUser schema.
type AuthUserClient struct {
	config
}

// NewAuthUserClient returns a client for the AuthUser from the given config.
func NewAuthUserClient(c config) *AuthUserClient {
	return &AuthUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authuser.Hooks(f(g(h())))`.
func (c *AuthUserClient) Use(hooks ...Hook) {
	c.hooks.AuthUser = append(c.hooks.AuthUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authuser.Intercept(f(g(h())))`.
func (c *AuthUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthUser = append(c.inters.AuthUser, interceptors...)
}

// Create returns a builder for creating a AuthUser entity.
func (c *AuthUserClient) Create() *AuthUserCreate {
	mutation := newAuthUserMutation(c.config, OpCreate)
	return &AuthUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthUser entities.
func (c *AuthUserClient) CreateBulk(builders ...*AuthUserCreate) *AuthUserCreateBulk {
	return &AuthUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthUserClient) MapCreateBulk(slice any, setFunc func(*AuthUserCreate, int)) *AuthUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthUserCreateBulk{err: fmt.Errorf("calling to AuthUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthUser.
func (c *AuthUserClient) Update() *AuthUserUpdate {
	mutation := newAuthUserMutation(c.config, OpUpdate)
	return &AuthUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthUserClient) UpdateOne(au *AuthUser) *AuthUserUpdateOne {
	mutation := newAuthUserMutation(c.config, OpUpdateOne, withAuthUser(au))
	return &AuthUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthUserClient) UpdateOneID(id uuid.UUID) *AuthUserUpdateOne {
	mutation := newAuthUserMutation(c.config, OpUpdateOne, withAuthUserID(id))
	return &AuthUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthUser.
func (c *AuthUserClient) Delete() *AuthUserDelete {
	mutation := newAuthUserMutation(c.config, OpDelete)
	return &AuthUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthUserClient) DeleteOne(au *AuthUser) *AuthUserDeleteOne {
	return c.DeleteOneID(au.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthUserClient) DeleteOneID(id uuid.UUID) *AuthUserDeleteOne {
	builder := c.Delete().Where(authuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthUserDeleteOne{builder}
}

// Query returns a query builder for AuthUser.
func (c *AuthUserClient) Query() *AuthUserQuery {
	return &AuthUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthUser},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthUser entity by its id.
func (c *AuthUserClient) Get(ctx context.Context, id uuid.UUID) (*AuthUser, error) {
	return c.Query().Where(authuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthUserClient) GetX(ctx context.Context, id uuid.UUID) *AuthUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTokens queries the Tokens edge of a AuthUser.
func (c *AuthUserClient) QueryTokens(au *AuthUser) *TokenQuery {
	query := (&TokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := au.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(authuser.Table, authuser.FieldID, id),
			sqlgraph.To(token.Table, token.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, authuser.TokensTable, authuser.TokensColumn),
		)
		fromV = sqlgraph.Neighbors(au.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServerTasks queries the ServerTasks edge of a AuthUser.
func (c *AuthUserClient) QueryServerTasks(au *AuthUser) *ServerTaskQuery {
	query := (&ServerTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := au.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(authuser.Table, authuser.FieldID, id),
			sqlgraph.To(servertask.Table, servertask.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, authuser.ServerTasksTable, authuser.ServerTasksColumn),
		)
		fromV = sqlgraph.Neighbors(au.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AuthUserClient) Hooks() []Hook {
	return c.hooks.AuthUser
}

// Interceptors returns the client interceptors.
func (c *AuthUserClient) Interceptors() []Interceptor {
	return c.inters.AuthUser
}

func (c *AuthUserClient) mutate(ctx context.Context, m *AuthUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuthUser mutation op: %q", m.Op())
	}
}

// BuildClient is a client for the Build schema.
type BuildClient struct {
	config
}

// NewBuildClient returns a client for the Build from the given config.
func NewBuildClient(c config) *BuildClient {
	return &BuildClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `build.Hooks(f(g(h())))`.
func (c *BuildClient) Use(hooks ...Hook) {
	c.hooks.Build = append(c.hooks.Build, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `build.Intercept(f(g(h())))`.
func (c *BuildClient) Intercept(interceptors ...Interceptor) {
	c.inters.Build = append(c.inters.Build, interceptors...)
}

// Create returns a builder for creating a Build entity.
func (c *BuildClient) Create() *BuildCreate {
	mutation := newBuildMutation(c.config, OpCreate)
	return &BuildCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Build entities.
func (c *BuildClient) CreateBulk(builders ...*BuildCreate) *BuildCreateBulk {
	return &BuildCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BuildClient) MapCreateBulk(slice any, setFunc func(*BuildCreate, int)) *BuildCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BuildCreateBulk{err: fmt.Errorf("calling to BuildClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BuildCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BuildCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Build.
func (c *BuildClient) Update() *BuildUpdate {
	mutation := newBuildMutation(c.config, OpUpdate)
	return &BuildUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BuildClient) UpdateOne(b *Build) *BuildUpdateOne {
	mutation := newBuildMutation(c.config, OpUpdateOne, withBuild(b))
	return &BuildUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BuildClient) UpdateOneID(id uuid.UUID) *BuildUpdateOne {
	mutation := newBuildMutation(c.config, OpUpdateOne, withBuildID(id))
	return &BuildUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Build.
func (c *BuildClient) Delete() *BuildDelete {
	mutation := newBuildMutation(c.config, OpDelete)
	return &BuildDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BuildClient) DeleteOne(b *Build) *BuildDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BuildClient) DeleteOneID(id uuid.UUID) *BuildDeleteOne {
	builder := c.Delete().Where(build.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BuildDeleteOne{builder}
}

// Query returns a query builder for Build.
func (c *BuildClient) Query() *BuildQuery {
	return &BuildQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBuild},
		inters: c.Interceptors(),
	}
}

// Get returns a Build entity by its id.
func (c *BuildClient) Get(ctx context.Context, id uuid.UUID) (*Build, error) {
	return c.Query().Where(build.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BuildClient) GetX(ctx context.Context, id uuid.UUID) *Build {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStatus queries the Status edge of a Build.
func (c *BuildClient) QueryStatus(b *Build) *StatusQuery {
	query := (&StatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(status.Table, status.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, build.StatusTable, build.StatusColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironment queries the Environment edge of a Build.
func (c *BuildClient) QueryEnvironment(b *Build) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, build.EnvironmentTable, build.EnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCompetition queries the Competition edge of a Build.
func (c *BuildClient) QueryCompetition(b *Build) *CompetitionQuery {
	query := (&CompetitionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(competition.Table, competition.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, build.CompetitionTable, build.CompetitionColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLatestBuildCommit queries the LatestBuildCommit edge of a Build.
func (c *BuildClient) QueryLatestBuildCommit(b *Build) *BuildCommitQuery {
	query := (&BuildCommitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(buildcommit.Table, buildcommit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, build.LatestBuildCommitTable, build.LatestBuildCommitColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRepoCommit queries the RepoCommit edge of a Build.
func (c *BuildClient) QueryRepoCommit(b *Build) *RepoCommitQuery {
	query := (&RepoCommitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(repocommit.Table, repocommit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, build.RepoCommitTable, build.RepoCommitColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedNetworks queries the ProvisionedNetworks edge of a Build.
func (c *BuildClient) QueryProvisionedNetworks(b *Build) *ProvisionedNetworkQuery {
	query := (&ProvisionedNetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(provisionednetwork.Table, provisionednetwork.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, build.ProvisionedNetworksTable, build.ProvisionedNetworksColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeams queries the Teams edge of a Build.
func (c *BuildClient) QueryTeams(b *Build) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, build.TeamsTable, build.TeamsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlans queries the Plans edge of a Build.
func (c *BuildClient) QueryPlans(b *Build) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, build.PlansTable, build.PlansColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuildCommits queries the BuildCommits edge of a Build.
func (c *BuildClient) QueryBuildCommits(b *Build) *BuildCommitQuery {
	query := (&BuildCommitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(buildcommit.Table, buildcommit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, build.BuildCommitsTable, build.BuildCommitsColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAdhocPlans queries the AdhocPlans edge of a Build.
func (c *BuildClient) QueryAdhocPlans(b *Build) *AdhocPlanQuery {
	query := (&AdhocPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(adhocplan.Table, adhocplan.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, build.AdhocPlansTable, build.AdhocPlansColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAgentStatuses queries the AgentStatuses edge of a Build.
func (c *BuildClient) QueryAgentStatuses(b *Build) *AgentStatusQuery {
	query := (&AgentStatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(agentstatus.Table, agentstatus.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, build.AgentStatusesTable, build.AgentStatusesColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServerTasks queries the ServerTasks edge of a Build.
func (c *BuildClient) QueryServerTasks(b *Build) *ServerTaskQuery {
	query := (&ServerTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(build.Table, build.FieldID, id),
			sqlgraph.To(servertask.Table, servertask.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, build.ServerTasksTable, build.ServerTasksColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BuildClient) Hooks() []Hook {
	return c.hooks.Build
}

// Interceptors returns the client interceptors.
func (c *BuildClient) Interceptors() []Interceptor {
	return c.inters.Build
}

func (c *BuildClient) mutate(ctx context.Context, m *BuildMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BuildCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BuildUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BuildUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BuildDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Build mutation op: %q", m.Op())
	}
}

// BuildCommitClient is a client for the BuildCommit schema.
type BuildCommitClient struct {
	config
}

// NewBuildCommitClient returns a client for the BuildCommit from the given config.
func NewBuildCommitClient(c config) *BuildCommitClient {
	return &BuildCommitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `buildcommit.Hooks(f(g(h())))`.
func (c *BuildCommitClient) Use(hooks ...Hook) {
	c.hooks.BuildCommit = append(c.hooks.BuildCommit, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `buildcommit.Intercept(f(g(h())))`.
func (c *BuildCommitClient) Intercept(interceptors ...Interceptor) {
	c.inters.BuildCommit = append(c.inters.BuildCommit, interceptors...)
}

// Create returns a builder for creating a BuildCommit entity.
func (c *BuildCommitClient) Create() *BuildCommitCreate {
	mutation := newBuildCommitMutation(c.config, OpCreate)
	return &BuildCommitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BuildCommit entities.
func (c *BuildCommitClient) CreateBulk(builders ...*BuildCommitCreate) *BuildCommitCreateBulk {
	return &BuildCommitCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BuildCommitClient) MapCreateBulk(slice any, setFunc func(*BuildCommitCreate, int)) *BuildCommitCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BuildCommitCreateBulk{err: fmt.Errorf("calling to BuildCommitClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BuildCommitCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BuildCommitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BuildCommit.
func (c *BuildCommitClient) Update() *BuildCommitUpdate {
	mutation := newBuildCommitMutation(c.config, OpUpdate)
	return &BuildCommitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BuildCommitClient) UpdateOne(bc *BuildCommit) *BuildCommitUpdateOne {
	mutation := newBuildCommitMutation(c.config, OpUpdateOne, withBuildCommit(bc))
	return &BuildCommitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BuildCommitClient) UpdateOneID(id uuid.UUID) *BuildCommitUpdateOne {
	mutation := newBuildCommitMutation(c.config, OpUpdateOne, withBuildCommitID(id))
	return &BuildCommitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BuildCommit.
func (c *BuildCommitClient) Delete() *BuildCommitDelete {
	mutation := newBuildCommitMutation(c.config, OpDelete)
	return &BuildCommitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BuildCommitClient) DeleteOne(bc *BuildCommit) *BuildCommitDeleteOne {
	return c.DeleteOneID(bc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BuildCommitClient) DeleteOneID(id uuid.UUID) *BuildCommitDeleteOne {
	builder := c.Delete().Where(buildcommit.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BuildCommitDeleteOne{builder}
}

// Query returns a query builder for BuildCommit.
func (c *BuildCommitClient) Query() *BuildCommitQuery {
	return &BuildCommitQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBuildCommit},
		inters: c.Interceptors(),
	}
}

// Get returns a BuildCommit entity by its id.
func (c *BuildCommitClient) Get(ctx context.Context, id uuid.UUID) (*BuildCommit, error) {
	return c.Query().Where(buildcommit.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BuildCommitClient) GetX(ctx context.Context, id uuid.UUID) *BuildCommit {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBuild queries the Build edge of a BuildCommit.
func (c *BuildCommitClient) QueryBuild(bc *BuildCommit) *BuildQuery {
	query := (&BuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(buildcommit.Table, buildcommit.FieldID, id),
			sqlgraph.To(build.Table, build.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, buildcommit.BuildTable, buildcommit.BuildColumn),
		)
		fromV = sqlgraph.Neighbors(bc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServerTasks queries the ServerTasks edge of a BuildCommit.
func (c *BuildCommitClient) QueryServerTasks(bc *BuildCommit) *ServerTaskQuery {
	query := (&ServerTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(buildcommit.Table, buildcommit.FieldID, id),
			sqlgraph.To(servertask.Table, servertask.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, buildcommit.ServerTasksTable, buildcommit.ServerTasksColumn),
		)
		fromV = sqlgraph.Neighbors(bc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlanDiffs queries the PlanDiffs edge of a BuildCommit.
func (c *BuildCommitClient) QueryPlanDiffs(bc *BuildCommit) *PlanDiffQuery {
	query := (&PlanDiffClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(buildcommit.Table, buildcommit.FieldID, id),
			sqlgraph.To(plandiff.Table, plandiff.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, buildcommit.PlanDiffsTable, buildcommit.PlanDiffsColumn),
		)
		fromV = sqlgraph.Neighbors(bc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BuildCommitClient) Hooks() []Hook {
	return c.hooks.BuildCommit
}

// Interceptors returns the client interceptors.
func (c *BuildCommitClient) Interceptors() []Interceptor {
	return c.inters.BuildCommit
}

func (c *BuildCommitClient) mutate(ctx context.Context, m *BuildCommitMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BuildCommitCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BuildCommitUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BuildCommitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BuildCommitDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BuildCommit mutation op: %q", m.Op())
	}
}

// CommandClient is a client for the Command schema.
type CommandClient struct {
	config
}

// NewCommandClient returns a client for the Command from the given config.
func NewCommandClient(c config) *CommandClient {
	return &CommandClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `command.Hooks(f(g(h())))`.
func (c *CommandClient) Use(hooks ...Hook) {
	c.hooks.Command = append(c.hooks.Command, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `command.Intercept(f(g(h())))`.
func (c *CommandClient) Intercept(interceptors ...Interceptor) {
	c.inters.Command = append(c.inters.Command, interceptors...)
}

// Create returns a builder for creating a Command entity.
func (c *CommandClient) Create() *CommandCreate {
	mutation := newCommandMutation(c.config, OpCreate)
	return &CommandCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Command entities.
func (c *CommandClient) CreateBulk(builders ...*CommandCreate) *CommandCreateBulk {
	return &CommandCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CommandClient) MapCreateBulk(slice any, setFunc func(*CommandCreate, int)) *CommandCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CommandCreateBulk{err: fmt.Errorf("calling to CommandClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CommandCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CommandCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Command.
func (c *CommandClient) Update() *CommandUpdate {
	mutation := newCommandMutation(c.config, OpUpdate)
	return &CommandUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CommandClient) UpdateOne(co *Command) *CommandUpdateOne {
	mutation := newCommandMutation(c.config, OpUpdateOne, withCommand(co))
	return &CommandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CommandClient) UpdateOneID(id uuid.UUID) *CommandUpdateOne {
	mutation := newCommandMutation(c.config, OpUpdateOne, withCommandID(id))
	return &CommandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Command.
func (c *CommandClient) Delete() *CommandDelete {
	mutation := newCommandMutation(c.config, OpDelete)
	return &CommandDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CommandClient) DeleteOne(co *Command) *CommandDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CommandClient) DeleteOneID(id uuid.UUID) *CommandDeleteOne {
	builder := c.Delete().Where(command.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CommandDeleteOne{builder}
}

// Query returns a query builder for Command.
func (c *CommandClient) Query() *CommandQuery {
	return &CommandQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCommand},
		inters: c.Interceptors(),
	}
}

// Get returns a Command entity by its id.
func (c *CommandClient) Get(ctx context.Context, id uuid.UUID) (*Command, error) {
	return c.Query().Where(command.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CommandClient) GetX(ctx context.Context, id uuid.UUID) *Command {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the Users edge of a Command.
func (c *CommandClient) QueryUsers(co *Command) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(command.Table, command.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, command.UsersTable, command.UsersColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironment queries the Environment edge of a Command.
func (c *CommandClient) QueryEnvironment(co *Command) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(command.Table, command.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, command.EnvironmentTable, command.EnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CommandClient) Hooks() []Hook {
	return c.hooks.Command
}

// Interceptors returns the client interceptors.
func (c *CommandClient) Interceptors() []Interceptor {
	return c.inters.Command
}

func (c *CommandClient) mutate(ctx context.Context, m *CommandMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CommandCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CommandUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CommandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CommandDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Command mutation op: %q", m.Op())
	}
}

// CompetitionClient is a client for the Competition schema.
type CompetitionClient struct {
	config
}

// NewCompetitionClient returns a client for the Competition from the given config.
func NewCompetitionClient(c config) *CompetitionClient {
	return &CompetitionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `competition.Hooks(f(g(h())))`.
func (c *CompetitionClient) Use(hooks ...Hook) {
	c.hooks.Competition = append(c.hooks.Competition, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `competition.Intercept(f(g(h())))`.
func (c *CompetitionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Competition = append(c.inters.Competition, interceptors...)
}

// Create returns a builder for creating a Competition entity.
func (c *CompetitionClient) Create() *CompetitionCreate {
	mutation := newCompetitionMutation(c.config, OpCreate)
	return &CompetitionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Competition entities.
func (c *CompetitionClient) CreateBulk(builders ...*CompetitionCreate) *CompetitionCreateBulk {
	return &CompetitionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CompetitionClient) MapCreateBulk(slice any, setFunc func(*CompetitionCreate, int)) *CompetitionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CompetitionCreateBulk{err: fmt.Errorf("calling to CompetitionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CompetitionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CompetitionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Competition.
func (c *CompetitionClient) Update() *CompetitionUpdate {
	mutation := newCompetitionMutation(c.config, OpUpdate)
	return &CompetitionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CompetitionClient) UpdateOne(co *Competition) *CompetitionUpdateOne {
	mutation := newCompetitionMutation(c.config, OpUpdateOne, withCompetition(co))
	return &CompetitionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CompetitionClient) UpdateOneID(id uuid.UUID) *CompetitionUpdateOne {
	mutation := newCompetitionMutation(c.config, OpUpdateOne, withCompetitionID(id))
	return &CompetitionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Competition.
func (c *CompetitionClient) Delete() *CompetitionDelete {
	mutation := newCompetitionMutation(c.config, OpDelete)
	return &CompetitionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CompetitionClient) DeleteOne(co *Competition) *CompetitionDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CompetitionClient) DeleteOneID(id uuid.UUID) *CompetitionDeleteOne {
	builder := c.Delete().Where(competition.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CompetitionDeleteOne{builder}
}

// Query returns a query builder for Competition.
func (c *CompetitionClient) Query() *CompetitionQuery {
	return &CompetitionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCompetition},
		inters: c.Interceptors(),
	}
}

// Get returns a Competition entity by its id.
func (c *CompetitionClient) Get(ctx context.Context, id uuid.UUID) (*Competition, error) {
	return c.Query().Where(competition.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CompetitionClient) GetX(ctx context.Context, id uuid.UUID) *Competition {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDNS queries the DNS edge of a Competition.
func (c *CompetitionClient) QueryDNS(co *Competition) *DNSQuery {
	query := (&DNSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(competition.Table, competition.FieldID, id),
			sqlgraph.To(dns.Table, dns.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, competition.DNSTable, competition.DNSPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironment queries the Environment edge of a Competition.
func (c *CompetitionClient) QueryEnvironment(co *Competition) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(competition.Table, competition.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, competition.EnvironmentTable, competition.EnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuilds queries the Builds edge of a Competition.
func (c *CompetitionClient) QueryBuilds(co *Competition) *BuildQuery {
	query := (&BuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(competition.Table, competition.FieldID, id),
			sqlgraph.To(build.Table, build.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, competition.BuildsTable, competition.BuildsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CompetitionClient) Hooks() []Hook {
	return c.hooks.Competition
}

// Interceptors returns the client interceptors.
func (c *CompetitionClient) Interceptors() []Interceptor {
	return c.inters.Competition
}

func (c *CompetitionClient) mutate(ctx context.Context, m *CompetitionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CompetitionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CompetitionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CompetitionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CompetitionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Competition mutation op: %q", m.Op())
	}
}

// DNSClient is a client for the DNS schema.
type DNSClient struct {
	config
}

// NewDNSClient returns a client for the DNS from the given config.
func NewDNSClient(c config) *DNSClient {
	return &DNSClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dns.Hooks(f(g(h())))`.
func (c *DNSClient) Use(hooks ...Hook) {
	c.hooks.DNS = append(c.hooks.DNS, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dns.Intercept(f(g(h())))`.
func (c *DNSClient) Intercept(interceptors ...Interceptor) {
	c.inters.DNS = append(c.inters.DNS, interceptors...)
}

// Create returns a builder for creating a DNS entity.
func (c *DNSClient) Create() *DNSCreate {
	mutation := newDNSMutation(c.config, OpCreate)
	return &DNSCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DNS entities.
func (c *DNSClient) CreateBulk(builders ...*DNSCreate) *DNSCreateBulk {
	return &DNSCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DNSClient) MapCreateBulk(slice any, setFunc func(*DNSCreate, int)) *DNSCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DNSCreateBulk{err: fmt.Errorf("calling to DNSClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DNSCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DNSCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DNS.
func (c *DNSClient) Update() *DNSUpdate {
	mutation := newDNSMutation(c.config, OpUpdate)
	return &DNSUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DNSClient) UpdateOne(d *DNS) *DNSUpdateOne {
	mutation := newDNSMutation(c.config, OpUpdateOne, withDNS(d))
	return &DNSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DNSClient) UpdateOneID(id uuid.UUID) *DNSUpdateOne {
	mutation := newDNSMutation(c.config, OpUpdateOne, withDNSID(id))
	return &DNSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DNS.
func (c *DNSClient) Delete() *DNSDelete {
	mutation := newDNSMutation(c.config, OpDelete)
	return &DNSDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DNSClient) DeleteOne(d *DNS) *DNSDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DNSClient) DeleteOneID(id uuid.UUID) *DNSDeleteOne {
	builder := c.Delete().Where(dns.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DNSDeleteOne{builder}
}

// Query returns a query builder for DNS.
func (c *DNSClient) Query() *DNSQuery {
	return &DNSQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDNS},
		inters: c.Interceptors(),
	}
}

// Get returns a DNS entity by its id.
func (c *DNSClient) Get(ctx context.Context, id uuid.UUID) (*DNS, error) {
	return c.Query().Where(dns.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DNSClient) GetX(ctx context.Context, id uuid.UUID) *DNS {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEnvironments queries the Environments edge of a DNS.
func (c *DNSClient) QueryEnvironments(d *DNS) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dns.Table, dns.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, dns.EnvironmentsTable, dns.EnvironmentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCompetitions queries the Competitions edge of a DNS.
func (c *DNSClient) QueryCompetitions(d *DNS) *CompetitionQuery {
	query := (&CompetitionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dns.Table, dns.FieldID, id),
			sqlgraph.To(competition.Table, competition.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, dns.CompetitionsTable, dns.CompetitionsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DNSClient) Hooks() []Hook {
	return c.hooks.DNS
}

// Interceptors returns the client interceptors.
func (c *DNSClient) Interceptors() []Interceptor {
	return c.inters.DNS
}

func (c *DNSClient) mutate(ctx context.Context, m *DNSMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DNSCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DNSUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DNSUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DNSDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DNS mutation op: %q", m.Op())
	}
}

// DNSRecordClient is a client for the DNSRecord schema.
type DNSRecordClient struct {
	config
}

// NewDNSRecordClient returns a client for the DNSRecord from the given config.
func NewDNSRecordClient(c config) *DNSRecordClient {
	return &DNSRecordClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dnsrecord.Hooks(f(g(h())))`.
func (c *DNSRecordClient) Use(hooks ...Hook) {
	c.hooks.DNSRecord = append(c.hooks.DNSRecord, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dnsrecord.Intercept(f(g(h())))`.
func (c *DNSRecordClient) Intercept(interceptors ...Interceptor) {
	c.inters.DNSRecord = append(c.inters.DNSRecord, interceptors...)
}

// Create returns a builder for creating a DNSRecord entity.
func (c *DNSRecordClient) Create() *DNSRecordCreate {
	mutation := newDNSRecordMutation(c.config, OpCreate)
	return &DNSRecordCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DNSRecord entities.
func (c *DNSRecordClient) CreateBulk(builders ...*DNSRecordCreate) *DNSRecordCreateBulk {
	return &DNSRecordCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DNSRecordClient) MapCreateBulk(slice any, setFunc func(*DNSRecordCreate, int)) *DNSRecordCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DNSRecordCreateBulk{err: fmt.Errorf("calling to DNSRecordClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DNSRecordCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DNSRecordCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DNSRecord.
func (c *DNSRecordClient) Update() *DNSRecordUpdate {
	mutation := newDNSRecordMutation(c.config, OpUpdate)
	return &DNSRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DNSRecordClient) UpdateOne(dr *DNSRecord) *DNSRecordUpdateOne {
	mutation := newDNSRecordMutation(c.config, OpUpdateOne, withDNSRecord(dr))
	return &DNSRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DNSRecordClient) UpdateOneID(id uuid.UUID) *DNSRecordUpdateOne {
	mutation := newDNSRecordMutation(c.config, OpUpdateOne, withDNSRecordID(id))
	return &DNSRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DNSRecord.
func (c *DNSRecordClient) Delete() *DNSRecordDelete {
	mutation := newDNSRecordMutation(c.config, OpDelete)
	return &DNSRecordDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DNSRecordClient) DeleteOne(dr *DNSRecord) *DNSRecordDeleteOne {
	return c.DeleteOneID(dr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DNSRecordClient) DeleteOneID(id uuid.UUID) *DNSRecordDeleteOne {
	builder := c.Delete().Where(dnsrecord.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DNSRecordDeleteOne{builder}
}

// Query returns a query builder for DNSRecord.
func (c *DNSRecordClient) Query() *DNSRecordQuery {
	return &DNSRecordQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDNSRecord},
		inters: c.Interceptors(),
	}
}

// Get returns a DNSRecord entity by its id.
func (c *DNSRecordClient) Get(ctx context.Context, id uuid.UUID) (*DNSRecord, error) {
	return c.Query().Where(dnsrecord.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DNSRecordClient) GetX(ctx context.Context, id uuid.UUID) *DNSRecord {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEnvironment queries the Environment edge of a DNSRecord.
func (c *DNSRecordClient) QueryEnvironment(dr *DNSRecord) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dnsrecord.Table, dnsrecord.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, dnsrecord.EnvironmentTable, dnsrecord.EnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(dr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DNSRecordClient) Hooks() []Hook {
	return c.hooks.DNSRecord
}

// Interceptors returns the client interceptors.
func (c *DNSRecordClient) Interceptors() []Interceptor {
	return c.inters.DNSRecord
}

func (c *DNSRecordClient) mutate(ctx context.Context, m *DNSRecordMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DNSRecordCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DNSRecordUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DNSRecordUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DNSRecordDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DNSRecord mutation op: %q", m.Op())
	}
}

// DiskClient is a client for the Disk schema.
type DiskClient struct {
	config
}

// NewDiskClient returns a client for the Disk from the given config.
func NewDiskClient(c config) *DiskClient {
	return &DiskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `disk.Hooks(f(g(h())))`.
func (c *DiskClient) Use(hooks ...Hook) {
	c.hooks.Disk = append(c.hooks.Disk, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `disk.Intercept(f(g(h())))`.
func (c *DiskClient) Intercept(interceptors ...Interceptor) {
	c.inters.Disk = append(c.inters.Disk, interceptors...)
}

// Create returns a builder for creating a Disk entity.
func (c *DiskClient) Create() *DiskCreate {
	mutation := newDiskMutation(c.config, OpCreate)
	return &DiskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Disk entities.
func (c *DiskClient) CreateBulk(builders ...*DiskCreate) *DiskCreateBulk {
	return &DiskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DiskClient) MapCreateBulk(slice any, setFunc func(*DiskCreate, int)) *DiskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DiskCreateBulk{err: fmt.Errorf("calling to DiskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DiskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DiskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Disk.
func (c *DiskClient) Update() *DiskUpdate {
	mutation := newDiskMutation(c.config, OpUpdate)
	return &DiskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DiskClient) UpdateOne(d *Disk) *DiskUpdateOne {
	mutation := newDiskMutation(c.config, OpUpdateOne, withDisk(d))
	return &DiskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DiskClient) UpdateOneID(id uuid.UUID) *DiskUpdateOne {
	mutation := newDiskMutation(c.config, OpUpdateOne, withDiskID(id))
	return &DiskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Disk.
func (c *DiskClient) Delete() *DiskDelete {
	mutation := newDiskMutation(c.config, OpDelete)
	return &DiskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DiskClient) DeleteOne(d *Disk) *DiskDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DiskClient) DeleteOneID(id uuid.UUID) *DiskDeleteOne {
	builder := c.Delete().Where(disk.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DiskDeleteOne{builder}
}

// Query returns a query builder for Disk.
func (c *DiskClient) Query() *DiskQuery {
	return &DiskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDisk},
		inters: c.Interceptors(),
	}
}

// Get returns a Disk entity by its id.
func (c *DiskClient) Get(ctx context.Context, id uuid.UUID) (*Disk, error) {
	return c.Query().Where(disk.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DiskClient) GetX(ctx context.Context, id uuid.UUID) *Disk {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryHost queries the Host edge of a Disk.
func (c *DiskClient) QueryHost(d *Disk) *HostQuery {
	query := (&HostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(disk.Table, disk.FieldID, id),
			sqlgraph.To(host.Table, host.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, disk.HostTable, disk.HostColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DiskClient) Hooks() []Hook {
	return c.hooks.Disk
}

// Interceptors returns the client interceptors.
func (c *DiskClient) Interceptors() []Interceptor {
	return c.inters.Disk
}

func (c *DiskClient) mutate(ctx context.Context, m *DiskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DiskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DiskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DiskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DiskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Disk mutation op: %q", m.Op())
	}
}

// EnvironmentClient is a client for the Environment schema.
type EnvironmentClient struct {
	config
}

// NewEnvironmentClient returns a client for the Environment from the given config.
func NewEnvironmentClient(c config) *EnvironmentClient {
	return &EnvironmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `environment.Hooks(f(g(h())))`.
func (c *EnvironmentClient) Use(hooks ...Hook) {
	c.hooks.Environment = append(c.hooks.Environment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `environment.Intercept(f(g(h())))`.
func (c *EnvironmentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Environment = append(c.inters.Environment, interceptors...)
}

// Create returns a builder for creating a Environment entity.
func (c *EnvironmentClient) Create() *EnvironmentCreate {
	mutation := newEnvironmentMutation(c.config, OpCreate)
	return &EnvironmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Environment entities.
func (c *EnvironmentClient) CreateBulk(builders ...*EnvironmentCreate) *EnvironmentCreateBulk {
	return &EnvironmentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EnvironmentClient) MapCreateBulk(slice any, setFunc func(*EnvironmentCreate, int)) *EnvironmentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EnvironmentCreateBulk{err: fmt.Errorf("calling to EnvironmentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EnvironmentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EnvironmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Environment.
func (c *EnvironmentClient) Update() *EnvironmentUpdate {
	mutation := newEnvironmentMutation(c.config, OpUpdate)
	return &EnvironmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EnvironmentClient) UpdateOne(e *Environment) *EnvironmentUpdateOne {
	mutation := newEnvironmentMutation(c.config, OpUpdateOne, withEnvironment(e))
	return &EnvironmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EnvironmentClient) UpdateOneID(id uuid.UUID) *EnvironmentUpdateOne {
	mutation := newEnvironmentMutation(c.config, OpUpdateOne, withEnvironmentID(id))
	return &EnvironmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Environment.
func (c *EnvironmentClient) Delete() *EnvironmentDelete {
	mutation := newEnvironmentMutation(c.config, OpDelete)
	return &EnvironmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EnvironmentClient) DeleteOne(e *Environment) *EnvironmentDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EnvironmentClient) DeleteOneID(id uuid.UUID) *EnvironmentDeleteOne {
	builder := c.Delete().Where(environment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EnvironmentDeleteOne{builder}
}

// Query returns a query builder for Environment.
func (c *EnvironmentClient) Query() *EnvironmentQuery {
	return &EnvironmentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEnvironment},
		inters: c.Interceptors(),
	}
}

// Get returns a Environment entity by its id.
func (c *EnvironmentClient) Get(ctx context.Context, id uuid.UUID) (*Environment, error) {
	return c.Query().Where(environment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EnvironmentClient) GetX(ctx context.Context, id uuid.UUID) *Environment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the Users edge of a Environment.
func (c *EnvironmentClient) QueryUsers(e *Environment) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, environment.UsersTable, environment.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHosts queries the Hosts edge of a Environment.
func (c *EnvironmentClient) QueryHosts(e *Environment) *HostQuery {
	query := (&HostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(host.Table, host.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.HostsTable, environment.HostsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCompetitions queries the Competitions edge of a Environment.
func (c *EnvironmentClient) QueryCompetitions(e *Environment) *CompetitionQuery {
	query := (&CompetitionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(competition.Table, competition.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.CompetitionsTable, environment.CompetitionsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIdentities queries the Identities edge of a Environment.
func (c *EnvironmentClient) QueryIdentities(e *Environment) *IdentityQuery {
	query := (&IdentityClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(identity.Table, identity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.IdentitiesTable, environment.IdentitiesColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCommands queries the Commands edge of a Environment.
func (c *EnvironmentClient) QueryCommands(e *Environment) *CommandQuery {
	query := (&CommandClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(command.Table, command.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.CommandsTable, environment.CommandsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScripts queries the Scripts edge of a Environment.
func (c *EnvironmentClient) QueryScripts(e *Environment) *ScriptQuery {
	query := (&ScriptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(script.Table, script.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.ScriptsTable, environment.ScriptsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFileDownloads queries the FileDownloads edge of a Environment.
func (c *EnvironmentClient) QueryFileDownloads(e *Environment) *FileDownloadQuery {
	query := (&FileDownloadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(filedownload.Table, filedownload.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.FileDownloadsTable, environment.FileDownloadsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFileDeletes queries the FileDeletes edge of a Environment.
func (c *EnvironmentClient) QueryFileDeletes(e *Environment) *FileDeleteQuery {
	query := (&FileDeleteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(filedelete.Table, filedelete.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.FileDeletesTable, environment.FileDeletesColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFileExtracts queries the FileExtracts edge of a Environment.
func (c *EnvironmentClient) QueryFileExtracts(e *Environment) *FileExtractQuery {
	query := (&FileExtractClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(fileextract.Table, fileextract.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.FileExtractsTable, environment.FileExtractsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncludedNetworks queries the IncludedNetworks edge of a Environment.
func (c *EnvironmentClient) QueryIncludedNetworks(e *Environment) *IncludedNetworkQuery {
	query := (&IncludedNetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(includednetwork.Table, includednetwork.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, environment.IncludedNetworksTable, environment.IncludedNetworksPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFindings queries the Findings edge of a Environment.
func (c *EnvironmentClient) QueryFindings(e *Environment) *FindingQuery {
	query := (&FindingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(finding.Table, finding.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.FindingsTable, environment.FindingsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDNSRecords queries the DNSRecords edge of a Environment.
func (c *EnvironmentClient) QueryDNSRecords(e *Environment) *DNSRecordQuery {
	query := (&DNSRecordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(dnsrecord.Table, dnsrecord.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.DNSRecordsTable, environment.DNSRecordsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDNS queries the DNS edge of a Environment.
func (c *EnvironmentClient) QueryDNS(e *Environment) *DNSQuery {
	query := (&DNSClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(dns.Table, dns.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, environment.DNSTable, environment.DNSPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNetworks queries the Networks edge of a Environment.
func (c *EnvironmentClient) QueryNetworks(e *Environment) *NetworkQuery {
	query := (&NetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(network.Table, network.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.NetworksTable, environment.NetworksColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHostDependencies queries the HostDependencies edge of a Environment.
func (c *EnvironmentClient) QueryHostDependencies(e *Environment) *HostDependencyQuery {
	query := (&HostDependencyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(hostdependency.Table, hostdependency.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.HostDependenciesTable, environment.HostDependenciesColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAnsibles queries the Ansibles edge of a Environment.
func (c *EnvironmentClient) QueryAnsibles(e *Environment) *AnsibleQuery {
	query := (&AnsibleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(ansible.Table, ansible.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.AnsiblesTable, environment.AnsiblesColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScheduledSteps queries the ScheduledSteps edge of a Environment.
func (c *EnvironmentClient) QueryScheduledSteps(e *Environment) *ScheduledStepQuery {
	query := (&ScheduledStepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(scheduledstep.Table, scheduledstep.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, environment.ScheduledStepsTable, environment.ScheduledStepsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuilds queries the Builds edge of a Environment.
func (c *EnvironmentClient) QueryBuilds(e *Environment) *BuildQuery {
	query := (&BuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(build.Table, build.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, environment.BuildsTable, environment.BuildsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRepositories queries the Repositories edge of a Environment.
func (c *EnvironmentClient) QueryRepositories(e *Environment) *RepositoryQuery {
	query := (&RepositoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(repository.Table, repository.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, environment.RepositoriesTable, environment.RepositoriesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServerTasks queries the ServerTasks edge of a Environment.
func (c *EnvironmentClient) QueryServerTasks(e *Environment) *ServerTaskQuery {
	query := (&ServerTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(environment.Table, environment.FieldID, id),
			sqlgraph.To(servertask.Table, servertask.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, environment.ServerTasksTable, environment.ServerTasksColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EnvironmentClient) Hooks() []Hook {
	return c.hooks.Environment
}

// Interceptors returns the client interceptors.
func (c *EnvironmentClient) Interceptors() []Interceptor {
	return c.inters.Environment
}

func (c *EnvironmentClient) mutate(ctx context.Context, m *EnvironmentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EnvironmentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EnvironmentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EnvironmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EnvironmentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Environment mutation op: %q", m.Op())
	}
}

// FileDeleteClient is a client for the FileDelete schema.
type FileDeleteClient struct {
	config
}

// NewFileDeleteClient returns a client for the FileDelete from the given config.
func NewFileDeleteClient(c config) *FileDeleteClient {
	return &FileDeleteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `filedelete.Hooks(f(g(h())))`.
func (c *FileDeleteClient) Use(hooks ...Hook) {
	c.hooks.FileDelete = append(c.hooks.FileDelete, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `filedelete.Intercept(f(g(h())))`.
func (c *FileDeleteClient) Intercept(interceptors ...Interceptor) {
	c.inters.FileDelete = append(c.inters.FileDelete, interceptors...)
}

// Create returns a builder for creating a FileDelete entity.
func (c *FileDeleteClient) Create() *FileDeleteCreate {
	mutation := newFileDeleteMutation(c.config, OpCreate)
	return &FileDeleteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FileDelete entities.
func (c *FileDeleteClient) CreateBulk(builders ...*FileDeleteCreate) *FileDeleteCreateBulk {
	return &FileDeleteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FileDeleteClient) MapCreateBulk(slice any, setFunc func(*FileDeleteCreate, int)) *FileDeleteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FileDeleteCreateBulk{err: fmt.Errorf("calling to FileDeleteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FileDeleteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FileDeleteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FileDelete.
func (c *FileDeleteClient) Update() *FileDeleteUpdate {
	mutation := newFileDeleteMutation(c.config, OpUpdate)
	return &FileDeleteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FileDeleteClient) UpdateOne(fd *FileDelete) *FileDeleteUpdateOne {
	mutation := newFileDeleteMutation(c.config, OpUpdateOne, withFileDelete(fd))
	return &FileDeleteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FileDeleteClient) UpdateOneID(id uuid.UUID) *FileDeleteUpdateOne {
	mutation := newFileDeleteMutation(c.config, OpUpdateOne, withFileDeleteID(id))
	return &FileDeleteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FileDelete.
func (c *FileDeleteClient) Delete() *FileDeleteDelete {
	mutation := newFileDeleteMutation(c.config, OpDelete)
	return &FileDeleteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FileDeleteClient) DeleteOne(fd *FileDelete) *FileDeleteDeleteOne {
	return c.DeleteOneID(fd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FileDeleteClient) DeleteOneID(id uuid.UUID) *FileDeleteDeleteOne {
	builder := c.Delete().Where(filedelete.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FileDeleteDeleteOne{builder}
}

// Query returns a query builder for FileDelete.
func (c *FileDeleteClient) Query() *FileDeleteQuery {
	return &FileDeleteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFileDelete},
		inters: c.Interceptors(),
	}
}

// Get returns a FileDelete entity by its id.
func (c *FileDeleteClient) Get(ctx context.Context, id uuid.UUID) (*FileDelete, error) {
	return c.Query().Where(filedelete.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FileDeleteClient) GetX(ctx context.Context, id uuid.UUID) *FileDelete {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEnvironment queries the Environment edge of a FileDelete.
func (c *FileDeleteClient) QueryEnvironment(fd *FileDelete) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(filedelete.Table, filedelete.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, filedelete.EnvironmentTable, filedelete.EnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(fd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FileDeleteClient) Hooks() []Hook {
	return c.hooks.FileDelete
}

// Interceptors returns the client interceptors.
func (c *FileDeleteClient) Interceptors() []Interceptor {
	return c.inters.FileDelete
}

func (c *FileDeleteClient) mutate(ctx context.Context, m *FileDeleteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FileDeleteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FileDeleteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FileDeleteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FileDeleteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FileDelete mutation op: %q", m.Op())
	}
}

// FileDownloadClient is a client for the FileDownload schema.
type FileDownloadClient struct {
	config
}

// NewFileDownloadClient returns a client for the FileDownload from the given config.
func NewFileDownloadClient(c config) *FileDownloadClient {
	return &FileDownloadClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `filedownload.Hooks(f(g(h())))`.
func (c *FileDownloadClient) Use(hooks ...Hook) {
	c.hooks.FileDownload = append(c.hooks.FileDownload, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `filedownload.Intercept(f(g(h())))`.
func (c *FileDownloadClient) Intercept(interceptors ...Interceptor) {
	c.inters.FileDownload = append(c.inters.FileDownload, interceptors...)
}

// Create returns a builder for creating a FileDownload entity.
func (c *FileDownloadClient) Create() *FileDownloadCreate {
	mutation := newFileDownloadMutation(c.config, OpCreate)
	return &FileDownloadCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FileDownload entities.
func (c *FileDownloadClient) CreateBulk(builders ...*FileDownloadCreate) *FileDownloadCreateBulk {
	return &FileDownloadCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FileDownloadClient) MapCreateBulk(slice any, setFunc func(*FileDownloadCreate, int)) *FileDownloadCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FileDownloadCreateBulk{err: fmt.Errorf("calling to FileDownloadClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FileDownloadCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FileDownloadCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FileDownload.
func (c *FileDownloadClient) Update() *FileDownloadUpdate {
	mutation := newFileDownloadMutation(c.config, OpUpdate)
	return &FileDownloadUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FileDownloadClient) UpdateOne(fd *FileDownload) *FileDownloadUpdateOne {
	mutation := newFileDownloadMutation(c.config, OpUpdateOne, withFileDownload(fd))
	return &FileDownloadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FileDownloadClient) UpdateOneID(id uuid.UUID) *FileDownloadUpdateOne {
	mutation := newFileDownloadMutation(c.config, OpUpdateOne, withFileDownloadID(id))
	return &FileDownloadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FileDownload.
func (c *FileDownloadClient) Delete() *FileDownloadDelete {
	mutation := newFileDownloadMutation(c.config, OpDelete)
	return &FileDownloadDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FileDownloadClient) DeleteOne(fd *FileDownload) *FileDownloadDeleteOne {
	return c.DeleteOneID(fd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FileDownloadClient) DeleteOneID(id uuid.UUID) *FileDownloadDeleteOne {
	builder := c.Delete().Where(filedownload.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FileDownloadDeleteOne{builder}
}

// Query returns a query builder for FileDownload.
func (c *FileDownloadClient) Query() *FileDownloadQuery {
	return &FileDownloadQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFileDownload},
		inters: c.Interceptors(),
	}
}

// Get returns a FileDownload entity by its id.
func (c *FileDownloadClient) Get(ctx context.Context, id uuid.UUID) (*FileDownload, error) {
	return c.Query().Where(filedownload.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FileDownloadClient) GetX(ctx context.Context, id uuid.UUID) *FileDownload {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEnvironment queries the Environment edge of a FileDownload.
func (c *FileDownloadClient) QueryEnvironment(fd *FileDownload) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(filedownload.Table, filedownload.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, filedownload.EnvironmentTable, filedownload.EnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(fd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FileDownloadClient) Hooks() []Hook {
	return c.hooks.FileDownload
}

// Interceptors returns the client interceptors.
func (c *FileDownloadClient) Interceptors() []Interceptor {
	return c.inters.FileDownload
}

func (c *FileDownloadClient) mutate(ctx context.Context, m *FileDownloadMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FileDownloadCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FileDownloadUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FileDownloadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FileDownloadDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FileDownload mutation op: %q", m.Op())
	}
}

// FileExtractClient is a client for the FileExtract schema.
type FileExtractClient struct {
	config
}

// NewFileExtractClient returns a client for the FileExtract from the given config.
func NewFileExtractClient(c config) *FileExtractClient {
	return &FileExtractClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fileextract.Hooks(f(g(h())))`.
func (c *FileExtractClient) Use(hooks ...Hook) {
	c.hooks.FileExtract = append(c.hooks.FileExtract, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `fileextract.Intercept(f(g(h())))`.
func (c *FileExtractClient) Intercept(interceptors ...Interceptor) {
	c.inters.FileExtract = append(c.inters.FileExtract, interceptors...)
}

// Create returns a builder for creating a FileExtract entity.
func (c *FileExtractClient) Create() *FileExtractCreate {
	mutation := newFileExtractMutation(c.config, OpCreate)
	return &FileExtractCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FileExtract entities.
func (c *FileExtractClient) CreateBulk(builders ...*FileExtractCreate) *FileExtractCreateBulk {
	return &FileExtractCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FileExtractClient) MapCreateBulk(slice any, setFunc func(*FileExtractCreate, int)) *FileExtractCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FileExtractCreateBulk{err: fmt.Errorf("calling to FileExtractClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FileExtractCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FileExtractCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FileExtract.
func (c *FileExtractClient) Update() *FileExtractUpdate {
	mutation := newFileExtractMutation(c.config, OpUpdate)
	return &FileExtractUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FileExtractClient) UpdateOne(fe *FileExtract) *FileExtractUpdateOne {
	mutation := newFileExtractMutation(c.config, OpUpdateOne, withFileExtract(fe))
	return &FileExtractUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FileExtractClient) UpdateOneID(id uuid.UUID) *FileExtractUpdateOne {
	mutation := newFileExtractMutation(c.config, OpUpdateOne, withFileExtractID(id))
	return &FileExtractUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FileExtract.
func (c *FileExtractClient) Delete() *FileExtractDelete {
	mutation := newFileExtractMutation(c.config, OpDelete)
	return &FileExtractDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FileExtractClient) DeleteOne(fe *FileExtract) *FileExtractDeleteOne {
	return c.DeleteOneID(fe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FileExtractClient) DeleteOneID(id uuid.UUID) *FileExtractDeleteOne {
	builder := c.Delete().Where(fileextract.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FileExtractDeleteOne{builder}
}

// Query returns a query builder for FileExtract.
func (c *FileExtractClient) Query() *FileExtractQuery {
	return &FileExtractQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFileExtract},
		inters: c.Interceptors(),
	}
}

// Get returns a FileExtract entity by its id.
func (c *FileExtractClient) Get(ctx context.Context, id uuid.UUID) (*FileExtract, error) {
	return c.Query().Where(fileextract.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FileExtractClient) GetX(ctx context.Context, id uuid.UUID) *FileExtract {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEnvironment queries the Environment edge of a FileExtract.
func (c *FileExtractClient) QueryEnvironment(fe *FileExtract) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fileextract.Table, fileextract.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fileextract.EnvironmentTable, fileextract.EnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(fe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FileExtractClient) Hooks() []Hook {
	return c.hooks.FileExtract
}

// Interceptors returns the client interceptors.
func (c *FileExtractClient) Interceptors() []Interceptor {
	return c.inters.FileExtract
}

func (c *FileExtractClient) mutate(ctx context.Context, m *FileExtractMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FileExtractCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FileExtractUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FileExtractUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FileExtractDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FileExtract mutation op: %q", m.Op())
	}
}

// FindingClient is a client for the Finding schema.
type FindingClient struct {
	config
}

// NewFindingClient returns a client for the Finding from the given config.
func NewFindingClient(c config) *FindingClient {
	return &FindingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `finding.Hooks(f(g(h())))`.
func (c *FindingClient) Use(hooks ...Hook) {
	c.hooks.Finding = append(c.hooks.Finding, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `finding.Intercept(f(g(h())))`.
func (c *FindingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Finding = append(c.inters.Finding, interceptors...)
}

// Create returns a builder for creating a Finding entity.
func (c *FindingClient) Create() *FindingCreate {
	mutation := newFindingMutation(c.config, OpCreate)
	return &FindingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Finding entities.
func (c *FindingClient) CreateBulk(builders ...*FindingCreate) *FindingCreateBulk {
	return &FindingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FindingClient) MapCreateBulk(slice any, setFunc func(*FindingCreate, int)) *FindingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FindingCreateBulk{err: fmt.Errorf("calling to FindingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FindingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FindingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Finding.
func (c *FindingClient) Update() *FindingUpdate {
	mutation := newFindingMutation(c.config, OpUpdate)
	return &FindingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FindingClient) UpdateOne(f *Finding) *FindingUpdateOne {
	mutation := newFindingMutation(c.config, OpUpdateOne, withFinding(f))
	return &FindingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FindingClient) UpdateOneID(id uuid.UUID) *FindingUpdateOne {
	mutation := newFindingMutation(c.config, OpUpdateOne, withFindingID(id))
	return &FindingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Finding.
func (c *FindingClient) Delete() *FindingDelete {
	mutation := newFindingMutation(c.config, OpDelete)
	return &FindingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FindingClient) DeleteOne(f *Finding) *FindingDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FindingClient) DeleteOneID(id uuid.UUID) *FindingDeleteOne {
	builder := c.Delete().Where(finding.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FindingDeleteOne{builder}
}

// Query returns a query builder for Finding.
func (c *FindingClient) Query() *FindingQuery {
	return &FindingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFinding},
		inters: c.Interceptors(),
	}
}

// Get returns a Finding entity by its id.
func (c *FindingClient) Get(ctx context.Context, id uuid.UUID) (*Finding, error) {
	return c.Query().Where(finding.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FindingClient) GetX(ctx context.Context, id uuid.UUID) *Finding {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the Users edge of a Finding.
func (c *FindingClient) QueryUsers(f *Finding) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, finding.UsersTable, finding.UsersColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHost queries the Host edge of a Finding.
func (c *FindingClient) QueryHost(f *Finding) *HostQuery {
	query := (&HostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(host.Table, host.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, finding.HostTable, finding.HostColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScript queries the Script edge of a Finding.
func (c *FindingClient) QueryScript(f *Finding) *ScriptQuery {
	query := (&ScriptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(script.Table, script.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, finding.ScriptTable, finding.ScriptColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironment queries the Environment edge of a Finding.
func (c *FindingClient) QueryEnvironment(f *Finding) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(finding.Table, finding.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, finding.EnvironmentTable, finding.EnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FindingClient) Hooks() []Hook {
	return c.hooks.Finding
}

// Interceptors returns the client interceptors.
func (c *FindingClient) Interceptors() []Interceptor {
	return c.inters.Finding
}

func (c *FindingClient) mutate(ctx context.Context, m *FindingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FindingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FindingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FindingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FindingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Finding mutation op: %q", m.Op())
	}
}

// GinFileMiddlewareClient is a client for the GinFileMiddleware schema.
type GinFileMiddlewareClient struct {
	config
}

// NewGinFileMiddlewareClient returns a client for the GinFileMiddleware from the given config.
func NewGinFileMiddlewareClient(c config) *GinFileMiddlewareClient {
	return &GinFileMiddlewareClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ginfilemiddleware.Hooks(f(g(h())))`.
func (c *GinFileMiddlewareClient) Use(hooks ...Hook) {
	c.hooks.GinFileMiddleware = append(c.hooks.GinFileMiddleware, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ginfilemiddleware.Intercept(f(g(h())))`.
func (c *GinFileMiddlewareClient) Intercept(interceptors ...Interceptor) {
	c.inters.GinFileMiddleware = append(c.inters.GinFileMiddleware, interceptors...)
}

// Create returns a builder for creating a GinFileMiddleware entity.
func (c *GinFileMiddlewareClient) Create() *GinFileMiddlewareCreate {
	mutation := newGinFileMiddlewareMutation(c.config, OpCreate)
	return &GinFileMiddlewareCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GinFileMiddleware entities.
func (c *GinFileMiddlewareClient) CreateBulk(builders ...*GinFileMiddlewareCreate) *GinFileMiddlewareCreateBulk {
	return &GinFileMiddlewareCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GinFileMiddlewareClient) MapCreateBulk(slice any, setFunc func(*GinFileMiddlewareCreate, int)) *GinFileMiddlewareCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GinFileMiddlewareCreateBulk{err: fmt.Errorf("calling to GinFileMiddlewareClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GinFileMiddlewareCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GinFileMiddlewareCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GinFileMiddleware.
func (c *GinFileMiddlewareClient) Update() *GinFileMiddlewareUpdate {
	mutation := newGinFileMiddlewareMutation(c.config, OpUpdate)
	return &GinFileMiddlewareUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GinFileMiddlewareClient) UpdateOne(gfm *GinFileMiddleware) *GinFileMiddlewareUpdateOne {
	mutation := newGinFileMiddlewareMutation(c.config, OpUpdateOne, withGinFileMiddleware(gfm))
	return &GinFileMiddlewareUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GinFileMiddlewareClient) UpdateOneID(id uuid.UUID) *GinFileMiddlewareUpdateOne {
	mutation := newGinFileMiddlewareMutation(c.config, OpUpdateOne, withGinFileMiddlewareID(id))
	return &GinFileMiddlewareUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GinFileMiddleware.
func (c *GinFileMiddlewareClient) Delete() *GinFileMiddlewareDelete {
	mutation := newGinFileMiddlewareMutation(c.config, OpDelete)
	return &GinFileMiddlewareDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GinFileMiddlewareClient) DeleteOne(gfm *GinFileMiddleware) *GinFileMiddlewareDeleteOne {
	return c.DeleteOneID(gfm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GinFileMiddlewareClient) DeleteOneID(id uuid.UUID) *GinFileMiddlewareDeleteOne {
	builder := c.Delete().Where(ginfilemiddleware.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GinFileMiddlewareDeleteOne{builder}
}

// Query returns a query builder for GinFileMiddleware.
func (c *GinFileMiddlewareClient) Query() *GinFileMiddlewareQuery {
	return &GinFileMiddlewareQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGinFileMiddleware},
		inters: c.Interceptors(),
	}
}

// Get returns a GinFileMiddleware entity by its id.
func (c *GinFileMiddlewareClient) Get(ctx context.Context, id uuid.UUID) (*GinFileMiddleware, error) {
	return c.Query().Where(ginfilemiddleware.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GinFileMiddlewareClient) GetX(ctx context.Context, id uuid.UUID) *GinFileMiddleware {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProvisionedHost queries the ProvisionedHost edge of a GinFileMiddleware.
func (c *GinFileMiddlewareClient) QueryProvisionedHost(gfm *GinFileMiddleware) *ProvisionedHostQuery {
	query := (&ProvisionedHostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gfm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ginfilemiddleware.Table, ginfilemiddleware.FieldID, id),
			sqlgraph.To(provisionedhost.Table, provisionedhost.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, ginfilemiddleware.ProvisionedHostTable, ginfilemiddleware.ProvisionedHostColumn),
		)
		fromV = sqlgraph.Neighbors(gfm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisioningStep queries the ProvisioningStep edge of a GinFileMiddleware.
func (c *GinFileMiddlewareClient) QueryProvisioningStep(gfm *GinFileMiddleware) *ProvisioningStepQuery {
	query := (&ProvisioningStepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gfm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ginfilemiddleware.Table, ginfilemiddleware.FieldID, id),
			sqlgraph.To(provisioningstep.Table, provisioningstep.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, ginfilemiddleware.ProvisioningStepTable, ginfilemiddleware.ProvisioningStepColumn),
		)
		fromV = sqlgraph.Neighbors(gfm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisioningScheduledStep queries the ProvisioningScheduledStep edge of a GinFileMiddleware.
func (c *GinFileMiddlewareClient) QueryProvisioningScheduledStep(gfm *GinFileMiddleware) *ProvisioningScheduledStepQuery {
	query := (&ProvisioningScheduledStepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gfm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ginfilemiddleware.Table, ginfilemiddleware.FieldID, id),
			sqlgraph.To(provisioningscheduledstep.Table, provisioningscheduledstep.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, ginfilemiddleware.ProvisioningScheduledStepTable, ginfilemiddleware.ProvisioningScheduledStepColumn),
		)
		fromV = sqlgraph.Neighbors(gfm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GinFileMiddlewareClient) Hooks() []Hook {
	return c.hooks.GinFileMiddleware
}

// Interceptors returns the client interceptors.
func (c *GinFileMiddlewareClient) Interceptors() []Interceptor {
	return c.inters.GinFileMiddleware
}

func (c *GinFileMiddlewareClient) mutate(ctx context.Context, m *GinFileMiddlewareMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GinFileMiddlewareCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GinFileMiddlewareUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GinFileMiddlewareUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GinFileMiddlewareDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GinFileMiddleware mutation op: %q", m.Op())
	}
}

// HostClient is a client for the Host schema.
type HostClient struct {
	config
}

// NewHostClient returns a client for the Host from the given config.
func NewHostClient(c config) *HostClient {
	return &HostClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `host.Hooks(f(g(h())))`.
func (c *HostClient) Use(hooks ...Hook) {
	c.hooks.Host = append(c.hooks.Host, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `host.Intercept(f(g(h())))`.
func (c *HostClient) Intercept(interceptors ...Interceptor) {
	c.inters.Host = append(c.inters.Host, interceptors...)
}

// Create returns a builder for creating a Host entity.
func (c *HostClient) Create() *HostCreate {
	mutation := newHostMutation(c.config, OpCreate)
	return &HostCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Host entities.
func (c *HostClient) CreateBulk(builders ...*HostCreate) *HostCreateBulk {
	return &HostCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HostClient) MapCreateBulk(slice any, setFunc func(*HostCreate, int)) *HostCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HostCreateBulk{err: fmt.Errorf("calling to HostClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HostCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HostCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Host.
func (c *HostClient) Update() *HostUpdate {
	mutation := newHostMutation(c.config, OpUpdate)
	return &HostUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HostClient) UpdateOne(h *Host) *HostUpdateOne {
	mutation := newHostMutation(c.config, OpUpdateOne, withHost(h))
	return &HostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HostClient) UpdateOneID(id uuid.UUID) *HostUpdateOne {
	mutation := newHostMutation(c.config, OpUpdateOne, withHostID(id))
	return &HostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Host.
func (c *HostClient) Delete() *HostDelete {
	mutation := newHostMutation(c.config, OpDelete)
	return &HostDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HostClient) DeleteOne(h *Host) *HostDeleteOne {
	return c.DeleteOneID(h.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HostClient) DeleteOneID(id uuid.UUID) *HostDeleteOne {
	builder := c.Delete().Where(host.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HostDeleteOne{builder}
}

// Query returns a query builder for Host.
func (c *HostClient) Query() *HostQuery {
	return &HostQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHost},
		inters: c.Interceptors(),
	}
}

// Get returns a Host entity by its id.
func (c *HostClient) Get(ctx context.Context, id uuid.UUID) (*Host, error) {
	return c.Query().Where(host.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HostClient) GetX(ctx context.Context, id uuid.UUID) *Host {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDisk queries the Disk edge of a Host.
func (c *HostClient) QueryDisk(h *Host) *DiskQuery {
	query := (&DiskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(host.Table, host.FieldID, id),
			sqlgraph.To(disk.Table, disk.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, host.DiskTable, host.DiskColumn),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the Users edge of a Host.
func (c *HostClient) QueryUsers(h *Host) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(host.Table, host.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, host.UsersTable, host.UsersColumn),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironment queries the Environment edge of a Host.
func (c *HostClient) QueryEnvironment(h *Host) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(host.Table, host.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, host.EnvironmentTable, host.EnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncludedNetworks queries the IncludedNetworks edge of a Host.
func (c *HostClient) QueryIncludedNetworks(h *Host) *IncludedNetworkQuery {
	query := (&IncludedNetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(host.Table, host.FieldID, id),
			sqlgraph.To(includednetwork.Table, includednetwork.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, host.IncludedNetworksTable, host.IncludedNetworksPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependOnHostDependencies queries the DependOnHostDependencies edge of a Host.
func (c *HostClient) QueryDependOnHostDependencies(h *Host) *HostDependencyQuery {
	query := (&HostDependencyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(host.Table, host.FieldID, id),
			sqlgraph.To(hostdependency.Table, hostdependency.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, host.DependOnHostDependenciesTable, host.DependOnHostDependenciesColumn),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRequiredByHostDependencies queries the RequiredByHostDependencies edge of a Host.
func (c *HostClient) QueryRequiredByHostDependencies(h *Host) *HostDependencyQuery {
	query := (&HostDependencyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(host.Table, host.FieldID, id),
			sqlgraph.To(hostdependency.Table, hostdependency.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, host.RequiredByHostDependenciesTable, host.RequiredByHostDependenciesColumn),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HostClient) Hooks() []Hook {
	return c.hooks.Host
}

// Interceptors returns the client interceptors.
func (c *HostClient) Interceptors() []Interceptor {
	return c.inters.Host
}

func (c *HostClient) mutate(ctx context.Context, m *HostMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HostCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HostUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HostDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Host mutation op: %q", m.Op())
	}
}

// HostDependencyClient is a client for the HostDependency schema.
type HostDependencyClient struct {
	config
}

// NewHostDependencyClient returns a client for the HostDependency from the given config.
func NewHostDependencyClient(c config) *HostDependencyClient {
	return &HostDependencyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hostdependency.Hooks(f(g(h())))`.
func (c *HostDependencyClient) Use(hooks ...Hook) {
	c.hooks.HostDependency = append(c.hooks.HostDependency, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `hostdependency.Intercept(f(g(h())))`.
func (c *HostDependencyClient) Intercept(interceptors ...Interceptor) {
	c.inters.HostDependency = append(c.inters.HostDependency, interceptors...)
}

// Create returns a builder for creating a HostDependency entity.
func (c *HostDependencyClient) Create() *HostDependencyCreate {
	mutation := newHostDependencyMutation(c.config, OpCreate)
	return &HostDependencyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of HostDependency entities.
func (c *HostDependencyClient) CreateBulk(builders ...*HostDependencyCreate) *HostDependencyCreateBulk {
	return &HostDependencyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HostDependencyClient) MapCreateBulk(slice any, setFunc func(*HostDependencyCreate, int)) *HostDependencyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HostDependencyCreateBulk{err: fmt.Errorf("calling to HostDependencyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HostDependencyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HostDependencyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for HostDependency.
func (c *HostDependencyClient) Update() *HostDependencyUpdate {
	mutation := newHostDependencyMutation(c.config, OpUpdate)
	return &HostDependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HostDependencyClient) UpdateOne(hd *HostDependency) *HostDependencyUpdateOne {
	mutation := newHostDependencyMutation(c.config, OpUpdateOne, withHostDependency(hd))
	return &HostDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HostDependencyClient) UpdateOneID(id uuid.UUID) *HostDependencyUpdateOne {
	mutation := newHostDependencyMutation(c.config, OpUpdateOne, withHostDependencyID(id))
	return &HostDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for HostDependency.
func (c *HostDependencyClient) Delete() *HostDependencyDelete {
	mutation := newHostDependencyMutation(c.config, OpDelete)
	return &HostDependencyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HostDependencyClient) DeleteOne(hd *HostDependency) *HostDependencyDeleteOne {
	return c.DeleteOneID(hd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HostDependencyClient) DeleteOneID(id uuid.UUID) *HostDependencyDeleteOne {
	builder := c.Delete().Where(hostdependency.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HostDependencyDeleteOne{builder}
}

// Query returns a query builder for HostDependency.
func (c *HostDependencyClient) Query() *HostDependencyQuery {
	return &HostDependencyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHostDependency},
		inters: c.Interceptors(),
	}
}

// Get returns a HostDependency entity by its id.
func (c *HostDependencyClient) Get(ctx context.Context, id uuid.UUID) (*HostDependency, error) {
	return c.Query().Where(hostdependency.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HostDependencyClient) GetX(ctx context.Context, id uuid.UUID) *HostDependency {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRequiredBy queries the RequiredBy edge of a HostDependency.
func (c *HostDependencyClient) QueryRequiredBy(hd *HostDependency) *HostQuery {
	query := (&HostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := hd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hostdependency.Table, hostdependency.FieldID, id),
			sqlgraph.To(host.Table, host.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, hostdependency.RequiredByTable, hostdependency.RequiredByColumn),
		)
		fromV = sqlgraph.Neighbors(hd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependOnHost queries the DependOnHost edge of a HostDependency.
func (c *HostDependencyClient) QueryDependOnHost(hd *HostDependency) *HostQuery {
	query := (&HostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := hd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hostdependency.Table, hostdependency.FieldID, id),
			sqlgraph.To(host.Table, host.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, hostdependency.DependOnHostTable, hostdependency.DependOnHostColumn),
		)
		fromV = sqlgraph.Neighbors(hd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDependOnNetwork queries the DependOnNetwork edge of a HostDependency.
func (c *HostDependencyClient) QueryDependOnNetwork(hd *HostDependency) *NetworkQuery {
	query := (&NetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := hd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hostdependency.Table, hostdependency.FieldID, id),
			sqlgraph.To(network.Table, network.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, hostdependency.DependOnNetworkTable, hostdependency.DependOnNetworkColumn),
		)
		fromV = sqlgraph.Neighbors(hd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironment queries the Environment edge of a HostDependency.
func (c *HostDependencyClient) QueryEnvironment(hd *HostDependency) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := hd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hostdependency.Table, hostdependency.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, hostdependency.EnvironmentTable, hostdependency.EnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(hd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HostDependencyClient) Hooks() []Hook {
	return c.hooks.HostDependency
}

// Interceptors returns the client interceptors.
func (c *HostDependencyClient) Interceptors() []Interceptor {
	return c.inters.HostDependency
}

func (c *HostDependencyClient) mutate(ctx context.Context, m *HostDependencyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HostDependencyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HostDependencyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HostDependencyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HostDependencyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown HostDependency mutation op: %q", m.Op())
	}
}

// IdentityClient is a client for the Identity schema.
type IdentityClient struct {
	config
}

// NewIdentityClient returns a client for the Identity from the given config.
func NewIdentityClient(c config) *IdentityClient {
	return &IdentityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `identity.Hooks(f(g(h())))`.
func (c *IdentityClient) Use(hooks ...Hook) {
	c.hooks.Identity = append(c.hooks.Identity, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `identity.Intercept(f(g(h())))`.
func (c *IdentityClient) Intercept(interceptors ...Interceptor) {
	c.inters.Identity = append(c.inters.Identity, interceptors...)
}

// Create returns a builder for creating a Identity entity.
func (c *IdentityClient) Create() *IdentityCreate {
	mutation := newIdentityMutation(c.config, OpCreate)
	return &IdentityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Identity entities.
func (c *IdentityClient) CreateBulk(builders ...*IdentityCreate) *IdentityCreateBulk {
	return &IdentityCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IdentityClient) MapCreateBulk(slice any, setFunc func(*IdentityCreate, int)) *IdentityCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IdentityCreateBulk{err: fmt.Errorf("calling to IdentityClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IdentityCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IdentityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Identity.
func (c *IdentityClient) Update() *IdentityUpdate {
	mutation := newIdentityMutation(c.config, OpUpdate)
	return &IdentityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IdentityClient) UpdateOne(i *Identity) *IdentityUpdateOne {
	mutation := newIdentityMutation(c.config, OpUpdateOne, withIdentity(i))
	return &IdentityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IdentityClient) UpdateOneID(id uuid.UUID) *IdentityUpdateOne {
	mutation := newIdentityMutation(c.config, OpUpdateOne, withIdentityID(id))
	return &IdentityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Identity.
func (c *IdentityClient) Delete() *IdentityDelete {
	mutation := newIdentityMutation(c.config, OpDelete)
	return &IdentityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IdentityClient) DeleteOne(i *Identity) *IdentityDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IdentityClient) DeleteOneID(id uuid.UUID) *IdentityDeleteOne {
	builder := c.Delete().Where(identity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IdentityDeleteOne{builder}
}

// Query returns a query builder for Identity.
func (c *IdentityClient) Query() *IdentityQuery {
	return &IdentityQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIdentity},
		inters: c.Interceptors(),
	}
}

// Get returns a Identity entity by its id.
func (c *IdentityClient) Get(ctx context.Context, id uuid.UUID) (*Identity, error) {
	return c.Query().Where(identity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IdentityClient) GetX(ctx context.Context, id uuid.UUID) *Identity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEnvironment queries the Environment edge of a Identity.
func (c *IdentityClient) QueryEnvironment(i *Identity) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(identity.Table, identity.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, identity.EnvironmentTable, identity.EnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IdentityClient) Hooks() []Hook {
	return c.hooks.Identity
}

// Interceptors returns the client interceptors.
func (c *IdentityClient) Interceptors() []Interceptor {
	return c.inters.Identity
}

func (c *IdentityClient) mutate(ctx context.Context, m *IdentityMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IdentityCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IdentityUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IdentityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IdentityDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Identity mutation op: %q", m.Op())
	}
}

// IncludedNetworkClient is a client for the IncludedNetwork schema.
type IncludedNetworkClient struct {
	config
}

// NewIncludedNetworkClient returns a client for the IncludedNetwork from the given config.
func NewIncludedNetworkClient(c config) *IncludedNetworkClient {
	return &IncludedNetworkClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `includednetwork.Hooks(f(g(h())))`.
func (c *IncludedNetworkClient) Use(hooks ...Hook) {
	c.hooks.IncludedNetwork = append(c.hooks.IncludedNetwork, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `includednetwork.Intercept(f(g(h())))`.
func (c *IncludedNetworkClient) Intercept(interceptors ...Interceptor) {
	c.inters.IncludedNetwork = append(c.inters.IncludedNetwork, interceptors...)
}

// Create returns a builder for creating a IncludedNetwork entity.
func (c *IncludedNetworkClient) Create() *IncludedNetworkCreate {
	mutation := newIncludedNetworkMutation(c.config, OpCreate)
	return &IncludedNetworkCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IncludedNetwork entities.
func (c *IncludedNetworkClient) CreateBulk(builders ...*IncludedNetworkCreate) *IncludedNetworkCreateBulk {
	return &IncludedNetworkCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *IncludedNetworkClient) MapCreateBulk(slice any, setFunc func(*IncludedNetworkCreate, int)) *IncludedNetworkCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &IncludedNetworkCreateBulk{err: fmt.Errorf("calling to IncludedNetworkClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*IncludedNetworkCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &IncludedNetworkCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IncludedNetwork.
func (c *IncludedNetworkClient) Update() *IncludedNetworkUpdate {
	mutation := newIncludedNetworkMutation(c.config, OpUpdate)
	return &IncludedNetworkUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IncludedNetworkClient) UpdateOne(in *IncludedNetwork) *IncludedNetworkUpdateOne {
	mutation := newIncludedNetworkMutation(c.config, OpUpdateOne, withIncludedNetwork(in))
	return &IncludedNetworkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IncludedNetworkClient) UpdateOneID(id uuid.UUID) *IncludedNetworkUpdateOne {
	mutation := newIncludedNetworkMutation(c.config, OpUpdateOne, withIncludedNetworkID(id))
	return &IncludedNetworkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IncludedNetwork.
func (c *IncludedNetworkClient) Delete() *IncludedNetworkDelete {
	mutation := newIncludedNetworkMutation(c.config, OpDelete)
	return &IncludedNetworkDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IncludedNetworkClient) DeleteOne(in *IncludedNetwork) *IncludedNetworkDeleteOne {
	return c.DeleteOneID(in.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IncludedNetworkClient) DeleteOneID(id uuid.UUID) *IncludedNetworkDeleteOne {
	builder := c.Delete().Where(includednetwork.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IncludedNetworkDeleteOne{builder}
}

// Query returns a query builder for IncludedNetwork.
func (c *IncludedNetworkClient) Query() *IncludedNetworkQuery {
	return &IncludedNetworkQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIncludedNetwork},
		inters: c.Interceptors(),
	}
}

// Get returns a IncludedNetwork entity by its id.
func (c *IncludedNetworkClient) Get(ctx context.Context, id uuid.UUID) (*IncludedNetwork, error) {
	return c.Query().Where(includednetwork.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IncludedNetworkClient) GetX(ctx context.Context, id uuid.UUID) *IncludedNetwork {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTags queries the Tags edge of a IncludedNetwork.
func (c *IncludedNetworkClient) QueryTags(in *IncludedNetwork) *TagQuery {
	query := (&TagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := in.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(includednetwork.Table, includednetwork.FieldID, id),
			sqlgraph.To(tag.Table, tag.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, includednetwork.TagsTable, includednetwork.TagsColumn),
		)
		fromV = sqlgraph.Neighbors(in.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHosts queries the Hosts edge of a IncludedNetwork.
func (c *IncludedNetworkClient) QueryHosts(in *IncludedNetwork) *HostQuery {
	query := (&HostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := in.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(includednetwork.Table, includednetwork.FieldID, id),
			sqlgraph.To(host.Table, host.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, includednetwork.HostsTable, includednetwork.HostsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(in.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNetwork queries the Network edge of a IncludedNetwork.
func (c *IncludedNetworkClient) QueryNetwork(in *IncludedNetwork) *NetworkQuery {
	query := (&NetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := in.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(includednetwork.Table, includednetwork.FieldID, id),
			sqlgraph.To(network.Table, network.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, includednetwork.NetworkTable, includednetwork.NetworkColumn),
		)
		fromV = sqlgraph.Neighbors(in.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironments queries the Environments edge of a IncludedNetwork.
func (c *IncludedNetworkClient) QueryEnvironments(in *IncludedNetwork) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := in.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(includednetwork.Table, includednetwork.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, includednetwork.EnvironmentsTable, includednetwork.EnvironmentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(in.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IncludedNetworkClient) Hooks() []Hook {
	return c.hooks.IncludedNetwork
}

// Interceptors returns the client interceptors.
func (c *IncludedNetworkClient) Interceptors() []Interceptor {
	return c.inters.IncludedNetwork
}

func (c *IncludedNetworkClient) mutate(ctx context.Context, m *IncludedNetworkMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IncludedNetworkCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IncludedNetworkUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IncludedNetworkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IncludedNetworkDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IncludedNetwork mutation op: %q", m.Op())
	}
}

// NetworkClient is a client for the Network schema.
type NetworkClient struct {
	config
}

// NewNetworkClient returns a client for the Network from the given config.
func NewNetworkClient(c config) *NetworkClient {
	return &NetworkClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `network.Hooks(f(g(h())))`.
func (c *NetworkClient) Use(hooks ...Hook) {
	c.hooks.Network = append(c.hooks.Network, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `network.Intercept(f(g(h())))`.
func (c *NetworkClient) Intercept(interceptors ...Interceptor) {
	c.inters.Network = append(c.inters.Network, interceptors...)
}

// Create returns a builder for creating a Network entity.
func (c *NetworkClient) Create() *NetworkCreate {
	mutation := newNetworkMutation(c.config, OpCreate)
	return &NetworkCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Network entities.
func (c *NetworkClient) CreateBulk(builders ...*NetworkCreate) *NetworkCreateBulk {
	return &NetworkCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NetworkClient) MapCreateBulk(slice any, setFunc func(*NetworkCreate, int)) *NetworkCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NetworkCreateBulk{err: fmt.Errorf("calling to NetworkClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NetworkCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NetworkCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Network.
func (c *NetworkClient) Update() *NetworkUpdate {
	mutation := newNetworkMutation(c.config, OpUpdate)
	return &NetworkUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NetworkClient) UpdateOne(n *Network) *NetworkUpdateOne {
	mutation := newNetworkMutation(c.config, OpUpdateOne, withNetwork(n))
	return &NetworkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NetworkClient) UpdateOneID(id uuid.UUID) *NetworkUpdateOne {
	mutation := newNetworkMutation(c.config, OpUpdateOne, withNetworkID(id))
	return &NetworkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Network.
func (c *NetworkClient) Delete() *NetworkDelete {
	mutation := newNetworkMutation(c.config, OpDelete)
	return &NetworkDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NetworkClient) DeleteOne(n *Network) *NetworkDeleteOne {
	return c.DeleteOneID(n.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NetworkClient) DeleteOneID(id uuid.UUID) *NetworkDeleteOne {
	builder := c.Delete().Where(network.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NetworkDeleteOne{builder}
}

// Query returns a query builder for Network.
func (c *NetworkClient) Query() *NetworkQuery {
	return &NetworkQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNetwork},
		inters: c.Interceptors(),
	}
}

// Get returns a Network entity by its id.
func (c *NetworkClient) Get(ctx context.Context, id uuid.UUID) (*Network, error) {
	return c.Query().Where(network.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NetworkClient) GetX(ctx context.Context, id uuid.UUID) *Network {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEnvironment queries the Environment edge of a Network.
func (c *NetworkClient) QueryEnvironment(n *Network) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(network.Table, network.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, network.EnvironmentTable, network.EnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHostDependencies queries the HostDependencies edge of a Network.
func (c *NetworkClient) QueryHostDependencies(n *Network) *HostDependencyQuery {
	query := (&HostDependencyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(network.Table, network.FieldID, id),
			sqlgraph.To(hostdependency.Table, hostdependency.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, network.HostDependenciesTable, network.HostDependenciesColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIncludedNetworks queries the IncludedNetworks edge of a Network.
func (c *NetworkClient) QueryIncludedNetworks(n *Network) *IncludedNetworkQuery {
	query := (&IncludedNetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(network.Table, network.FieldID, id),
			sqlgraph.To(includednetwork.Table, includednetwork.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, network.IncludedNetworksTable, network.IncludedNetworksColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NetworkClient) Hooks() []Hook {
	return c.hooks.Network
}

// Interceptors returns the client interceptors.
func (c *NetworkClient) Interceptors() []Interceptor {
	return c.inters.Network
}

func (c *NetworkClient) mutate(ctx context.Context, m *NetworkMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NetworkCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NetworkUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NetworkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NetworkDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Network mutation op: %q", m.Op())
	}
}

// PlanClient is a client for the Plan schema.
type PlanClient struct {
	config
}

// NewPlanClient returns a client for the Plan from the given config.
func NewPlanClient(c config) *PlanClient {
	return &PlanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `plan.Hooks(f(g(h())))`.
func (c *PlanClient) Use(hooks ...Hook) {
	c.hooks.Plan = append(c.hooks.Plan, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `plan.Intercept(f(g(h())))`.
func (c *PlanClient) Intercept(interceptors ...Interceptor) {
	c.inters.Plan = append(c.inters.Plan, interceptors...)
}

// Create returns a builder for creating a Plan entity.
func (c *PlanClient) Create() *PlanCreate {
	mutation := newPlanMutation(c.config, OpCreate)
	return &PlanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Plan entities.
func (c *PlanClient) CreateBulk(builders ...*PlanCreate) *PlanCreateBulk {
	return &PlanCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PlanClient) MapCreateBulk(slice any, setFunc func(*PlanCreate, int)) *PlanCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PlanCreateBulk{err: fmt.Errorf("calling to PlanClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PlanCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PlanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Plan.
func (c *PlanClient) Update() *PlanUpdate {
	mutation := newPlanMutation(c.config, OpUpdate)
	return &PlanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlanClient) UpdateOne(pl *Plan) *PlanUpdateOne {
	mutation := newPlanMutation(c.config, OpUpdateOne, withPlan(pl))
	return &PlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlanClient) UpdateOneID(id uuid.UUID) *PlanUpdateOne {
	mutation := newPlanMutation(c.config, OpUpdateOne, withPlanID(id))
	return &PlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Plan.
func (c *PlanClient) Delete() *PlanDelete {
	mutation := newPlanMutation(c.config, OpDelete)
	return &PlanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlanClient) DeleteOne(pl *Plan) *PlanDeleteOne {
	return c.DeleteOneID(pl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlanClient) DeleteOneID(id uuid.UUID) *PlanDeleteOne {
	builder := c.Delete().Where(plan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlanDeleteOne{builder}
}

// Query returns a query builder for Plan.
func (c *PlanClient) Query() *PlanQuery {
	return &PlanQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlan},
		inters: c.Interceptors(),
	}
}

// Get returns a Plan entity by its id.
func (c *PlanClient) Get(ctx context.Context, id uuid.UUID) (*Plan, error) {
	return c.Query().Where(plan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlanClient) GetX(ctx context.Context, id uuid.UUID) *Plan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPrevPlans queries the PrevPlans edge of a Plan.
func (c *PlanClient) QueryPrevPlans(pl *Plan) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, plan.PrevPlansTable, plan.PrevPlansPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNextPlans queries the NextPlans edge of a Plan.
func (c *PlanClient) QueryNextPlans(pl *Plan) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, plan.NextPlansTable, plan.NextPlansPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuild queries the Build edge of a Plan.
func (c *PlanClient) QueryBuild(pl *Plan) *BuildQuery {
	query := (&BuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(build.Table, build.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, plan.BuildTable, plan.BuildColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeam queries the Team edge of a Plan.
func (c *PlanClient) QueryTeam(pl *Plan) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, plan.TeamTable, plan.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedNetwork queries the ProvisionedNetwork edge of a Plan.
func (c *PlanClient) QueryProvisionedNetwork(pl *Plan) *ProvisionedNetworkQuery {
	query := (&ProvisionedNetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(provisionednetwork.Table, provisionednetwork.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, plan.ProvisionedNetworkTable, plan.ProvisionedNetworkColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedHost queries the ProvisionedHost edge of a Plan.
func (c *PlanClient) QueryProvisionedHost(pl *Plan) *ProvisionedHostQuery {
	query := (&ProvisionedHostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(provisionedhost.Table, provisionedhost.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, plan.ProvisionedHostTable, plan.ProvisionedHostColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisioningStep queries the ProvisioningStep edge of a Plan.
func (c *PlanClient) QueryProvisioningStep(pl *Plan) *ProvisioningStepQuery {
	query := (&ProvisioningStepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(provisioningstep.Table, provisioningstep.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, plan.ProvisioningStepTable, plan.ProvisioningStepColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisioningScheduledStep queries the ProvisioningScheduledStep edge of a Plan.
func (c *PlanClient) QueryProvisioningScheduledStep(pl *Plan) *ProvisioningScheduledStepQuery {
	query := (&ProvisioningScheduledStepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(provisioningscheduledstep.Table, provisioningscheduledstep.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, plan.ProvisioningScheduledStepTable, plan.ProvisioningScheduledStepColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStatus queries the Status edge of a Plan.
func (c *PlanClient) QueryStatus(pl *Plan) *StatusQuery {
	query := (&StatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(status.Table, status.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, plan.StatusTable, plan.StatusColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlanDiffs queries the PlanDiffs edge of a Plan.
func (c *PlanClient) QueryPlanDiffs(pl *Plan) *PlanDiffQuery {
	query := (&PlanDiffClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plan.Table, plan.FieldID, id),
			sqlgraph.To(plandiff.Table, plandiff.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, plan.PlanDiffsTable, plan.PlanDiffsColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlanClient) Hooks() []Hook {
	return c.hooks.Plan
}

// Interceptors returns the client interceptors.
func (c *PlanClient) Interceptors() []Interceptor {
	return c.inters.Plan
}

func (c *PlanClient) mutate(ctx context.Context, m *PlanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Plan mutation op: %q", m.Op())
	}
}

// PlanDiffClient is a client for the PlanDiff schema.
type PlanDiffClient struct {
	config
}

// NewPlanDiffClient returns a client for the PlanDiff from the given config.
func NewPlanDiffClient(c config) *PlanDiffClient {
	return &PlanDiffClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `plandiff.Hooks(f(g(h())))`.
func (c *PlanDiffClient) Use(hooks ...Hook) {
	c.hooks.PlanDiff = append(c.hooks.PlanDiff, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `plandiff.Intercept(f(g(h())))`.
func (c *PlanDiffClient) Intercept(interceptors ...Interceptor) {
	c.inters.PlanDiff = append(c.inters.PlanDiff, interceptors...)
}

// Create returns a builder for creating a PlanDiff entity.
func (c *PlanDiffClient) Create() *PlanDiffCreate {
	mutation := newPlanDiffMutation(c.config, OpCreate)
	return &PlanDiffCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PlanDiff entities.
func (c *PlanDiffClient) CreateBulk(builders ...*PlanDiffCreate) *PlanDiffCreateBulk {
	return &PlanDiffCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PlanDiffClient) MapCreateBulk(slice any, setFunc func(*PlanDiffCreate, int)) *PlanDiffCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PlanDiffCreateBulk{err: fmt.Errorf("calling to PlanDiffClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PlanDiffCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PlanDiffCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PlanDiff.
func (c *PlanDiffClient) Update() *PlanDiffUpdate {
	mutation := newPlanDiffMutation(c.config, OpUpdate)
	return &PlanDiffUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlanDiffClient) UpdateOne(pd *PlanDiff) *PlanDiffUpdateOne {
	mutation := newPlanDiffMutation(c.config, OpUpdateOne, withPlanDiff(pd))
	return &PlanDiffUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlanDiffClient) UpdateOneID(id uuid.UUID) *PlanDiffUpdateOne {
	mutation := newPlanDiffMutation(c.config, OpUpdateOne, withPlanDiffID(id))
	return &PlanDiffUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PlanDiff.
func (c *PlanDiffClient) Delete() *PlanDiffDelete {
	mutation := newPlanDiffMutation(c.config, OpDelete)
	return &PlanDiffDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlanDiffClient) DeleteOne(pd *PlanDiff) *PlanDiffDeleteOne {
	return c.DeleteOneID(pd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlanDiffClient) DeleteOneID(id uuid.UUID) *PlanDiffDeleteOne {
	builder := c.Delete().Where(plandiff.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlanDiffDeleteOne{builder}
}

// Query returns a query builder for PlanDiff.
func (c *PlanDiffClient) Query() *PlanDiffQuery {
	return &PlanDiffQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlanDiff},
		inters: c.Interceptors(),
	}
}

// Get returns a PlanDiff entity by its id.
func (c *PlanDiffClient) Get(ctx context.Context, id uuid.UUID) (*PlanDiff, error) {
	return c.Query().Where(plandiff.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlanDiffClient) GetX(ctx context.Context, id uuid.UUID) *PlanDiff {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBuildCommit queries the BuildCommit edge of a PlanDiff.
func (c *PlanDiffClient) QueryBuildCommit(pd *PlanDiff) *BuildCommitQuery {
	query := (&BuildCommitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plandiff.Table, plandiff.FieldID, id),
			sqlgraph.To(buildcommit.Table, buildcommit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, plandiff.BuildCommitTable, plandiff.BuildCommitColumn),
		)
		fromV = sqlgraph.Neighbors(pd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlan queries the Plan edge of a PlanDiff.
func (c *PlanDiffClient) QueryPlan(pd *PlanDiff) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(plandiff.Table, plandiff.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, plandiff.PlanTable, plandiff.PlanColumn),
		)
		fromV = sqlgraph.Neighbors(pd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlanDiffClient) Hooks() []Hook {
	return c.hooks.PlanDiff
}

// Interceptors returns the client interceptors.
func (c *PlanDiffClient) Interceptors() []Interceptor {
	return c.inters.PlanDiff
}

func (c *PlanDiffClient) mutate(ctx context.Context, m *PlanDiffMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlanDiffCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlanDiffUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlanDiffUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlanDiffDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PlanDiff mutation op: %q", m.Op())
	}
}

// ProvisionedHostClient is a client for the ProvisionedHost schema.
type ProvisionedHostClient struct {
	config
}

// NewProvisionedHostClient returns a client for the ProvisionedHost from the given config.
func NewProvisionedHostClient(c config) *ProvisionedHostClient {
	return &ProvisionedHostClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `provisionedhost.Hooks(f(g(h())))`.
func (c *ProvisionedHostClient) Use(hooks ...Hook) {
	c.hooks.ProvisionedHost = append(c.hooks.ProvisionedHost, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `provisionedhost.Intercept(f(g(h())))`.
func (c *ProvisionedHostClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProvisionedHost = append(c.inters.ProvisionedHost, interceptors...)
}

// Create returns a builder for creating a ProvisionedHost entity.
func (c *ProvisionedHostClient) Create() *ProvisionedHostCreate {
	mutation := newProvisionedHostMutation(c.config, OpCreate)
	return &ProvisionedHostCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProvisionedHost entities.
func (c *ProvisionedHostClient) CreateBulk(builders ...*ProvisionedHostCreate) *ProvisionedHostCreateBulk {
	return &ProvisionedHostCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProvisionedHostClient) MapCreateBulk(slice any, setFunc func(*ProvisionedHostCreate, int)) *ProvisionedHostCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProvisionedHostCreateBulk{err: fmt.Errorf("calling to ProvisionedHostClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProvisionedHostCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProvisionedHostCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProvisionedHost.
func (c *ProvisionedHostClient) Update() *ProvisionedHostUpdate {
	mutation := newProvisionedHostMutation(c.config, OpUpdate)
	return &ProvisionedHostUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProvisionedHostClient) UpdateOne(ph *ProvisionedHost) *ProvisionedHostUpdateOne {
	mutation := newProvisionedHostMutation(c.config, OpUpdateOne, withProvisionedHost(ph))
	return &ProvisionedHostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProvisionedHostClient) UpdateOneID(id uuid.UUID) *ProvisionedHostUpdateOne {
	mutation := newProvisionedHostMutation(c.config, OpUpdateOne, withProvisionedHostID(id))
	return &ProvisionedHostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProvisionedHost.
func (c *ProvisionedHostClient) Delete() *ProvisionedHostDelete {
	mutation := newProvisionedHostMutation(c.config, OpDelete)
	return &ProvisionedHostDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProvisionedHostClient) DeleteOne(ph *ProvisionedHost) *ProvisionedHostDeleteOne {
	return c.DeleteOneID(ph.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProvisionedHostClient) DeleteOneID(id uuid.UUID) *ProvisionedHostDeleteOne {
	builder := c.Delete().Where(provisionedhost.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProvisionedHostDeleteOne{builder}
}

// Query returns a query builder for ProvisionedHost.
func (c *ProvisionedHostClient) Query() *ProvisionedHostQuery {
	return &ProvisionedHostQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProvisionedHost},
		inters: c.Interceptors(),
	}
}

// Get returns a ProvisionedHost entity by its id.
func (c *ProvisionedHostClient) Get(ctx context.Context, id uuid.UUID) (*ProvisionedHost, error) {
	return c.Query().Where(provisionedhost.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProvisionedHostClient) GetX(ctx context.Context, id uuid.UUID) *ProvisionedHost {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStatus queries the Status edge of a ProvisionedHost.
func (c *ProvisionedHostClient) QueryStatus(ph *ProvisionedHost) *StatusQuery {
	query := (&StatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ph.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionedhost.Table, provisionedhost.FieldID, id),
			sqlgraph.To(status.Table, status.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, provisionedhost.StatusTable, provisionedhost.StatusColumn),
		)
		fromV = sqlgraph.Neighbors(ph.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedNetwork queries the ProvisionedNetwork edge of a ProvisionedHost.
func (c *ProvisionedHostClient) QueryProvisionedNetwork(ph *ProvisionedHost) *ProvisionedNetworkQuery {
	query := (&ProvisionedNetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ph.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionedhost.Table, provisionedhost.FieldID, id),
			sqlgraph.To(provisionednetwork.Table, provisionednetwork.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisionedhost.ProvisionedNetworkTable, provisionedhost.ProvisionedNetworkColumn),
		)
		fromV = sqlgraph.Neighbors(ph.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHost queries the Host edge of a ProvisionedHost.
func (c *ProvisionedHostClient) QueryHost(ph *ProvisionedHost) *HostQuery {
	query := (&HostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ph.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionedhost.Table, provisionedhost.FieldID, id),
			sqlgraph.To(host.Table, host.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisionedhost.HostTable, provisionedhost.HostColumn),
		)
		fromV = sqlgraph.Neighbors(ph.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEndStepPlan queries the EndStepPlan edge of a ProvisionedHost.
func (c *ProvisionedHostClient) QueryEndStepPlan(ph *ProvisionedHost) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ph.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionedhost.Table, provisionedhost.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisionedhost.EndStepPlanTable, provisionedhost.EndStepPlanColumn),
		)
		fromV = sqlgraph.Neighbors(ph.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuild queries the Build edge of a ProvisionedHost.
func (c *ProvisionedHostClient) QueryBuild(ph *ProvisionedHost) *BuildQuery {
	query := (&BuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ph.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionedhost.Table, provisionedhost.FieldID, id),
			sqlgraph.To(build.Table, build.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisionedhost.BuildTable, provisionedhost.BuildColumn),
		)
		fromV = sqlgraph.Neighbors(ph.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisioningSteps queries the ProvisioningSteps edge of a ProvisionedHost.
func (c *ProvisionedHostClient) QueryProvisioningSteps(ph *ProvisionedHost) *ProvisioningStepQuery {
	query := (&ProvisioningStepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ph.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionedhost.Table, provisionedhost.FieldID, id),
			sqlgraph.To(provisioningstep.Table, provisioningstep.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, provisionedhost.ProvisioningStepsTable, provisionedhost.ProvisioningStepsColumn),
		)
		fromV = sqlgraph.Neighbors(ph.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisioningScheduledSteps queries the ProvisioningScheduledSteps edge of a ProvisionedHost.
func (c *ProvisionedHostClient) QueryProvisioningScheduledSteps(ph *ProvisionedHost) *ProvisioningScheduledStepQuery {
	query := (&ProvisioningScheduledStepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ph.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionedhost.Table, provisionedhost.FieldID, id),
			sqlgraph.To(provisioningscheduledstep.Table, provisioningscheduledstep.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, provisionedhost.ProvisioningScheduledStepsTable, provisionedhost.ProvisioningScheduledStepsColumn),
		)
		fromV = sqlgraph.Neighbors(ph.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAgentStatuses queries the AgentStatuses edge of a ProvisionedHost.
func (c *ProvisionedHostClient) QueryAgentStatuses(ph *ProvisionedHost) *AgentStatusQuery {
	query := (&AgentStatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ph.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionedhost.Table, provisionedhost.FieldID, id),
			sqlgraph.To(agentstatus.Table, agentstatus.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, provisionedhost.AgentStatusesTable, provisionedhost.AgentStatusesColumn),
		)
		fromV = sqlgraph.Neighbors(ph.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAgentTasks queries the AgentTasks edge of a ProvisionedHost.
func (c *ProvisionedHostClient) QueryAgentTasks(ph *ProvisionedHost) *AgentTaskQuery {
	query := (&AgentTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ph.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionedhost.Table, provisionedhost.FieldID, id),
			sqlgraph.To(agenttask.Table, agenttask.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, provisionedhost.AgentTasksTable, provisionedhost.AgentTasksColumn),
		)
		fromV = sqlgraph.Neighbors(ph.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlan queries the Plan edge of a ProvisionedHost.
func (c *ProvisionedHostClient) QueryPlan(ph *ProvisionedHost) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ph.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionedhost.Table, provisionedhost.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, provisionedhost.PlanTable, provisionedhost.PlanColumn),
		)
		fromV = sqlgraph.Neighbors(ph.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGinFileMiddleware queries the GinFileMiddleware edge of a ProvisionedHost.
func (c *ProvisionedHostClient) QueryGinFileMiddleware(ph *ProvisionedHost) *GinFileMiddlewareQuery {
	query := (&GinFileMiddlewareClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ph.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionedhost.Table, provisionedhost.FieldID, id),
			sqlgraph.To(ginfilemiddleware.Table, ginfilemiddleware.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, provisionedhost.GinFileMiddlewareTable, provisionedhost.GinFileMiddlewareColumn),
		)
		fromV = sqlgraph.Neighbors(ph.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProvisionedHostClient) Hooks() []Hook {
	return c.hooks.ProvisionedHost
}

// Interceptors returns the client interceptors.
func (c *ProvisionedHostClient) Interceptors() []Interceptor {
	return c.inters.ProvisionedHost
}

func (c *ProvisionedHostClient) mutate(ctx context.Context, m *ProvisionedHostMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProvisionedHostCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProvisionedHostUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProvisionedHostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProvisionedHostDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProvisionedHost mutation op: %q", m.Op())
	}
}

// ProvisionedNetworkClient is a client for the ProvisionedNetwork schema.
type ProvisionedNetworkClient struct {
	config
}

// NewProvisionedNetworkClient returns a client for the ProvisionedNetwork from the given config.
func NewProvisionedNetworkClient(c config) *ProvisionedNetworkClient {
	return &ProvisionedNetworkClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `provisionednetwork.Hooks(f(g(h())))`.
func (c *ProvisionedNetworkClient) Use(hooks ...Hook) {
	c.hooks.ProvisionedNetwork = append(c.hooks.ProvisionedNetwork, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `provisionednetwork.Intercept(f(g(h())))`.
func (c *ProvisionedNetworkClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProvisionedNetwork = append(c.inters.ProvisionedNetwork, interceptors...)
}

// Create returns a builder for creating a ProvisionedNetwork entity.
func (c *ProvisionedNetworkClient) Create() *ProvisionedNetworkCreate {
	mutation := newProvisionedNetworkMutation(c.config, OpCreate)
	return &ProvisionedNetworkCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProvisionedNetwork entities.
func (c *ProvisionedNetworkClient) CreateBulk(builders ...*ProvisionedNetworkCreate) *ProvisionedNetworkCreateBulk {
	return &ProvisionedNetworkCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProvisionedNetworkClient) MapCreateBulk(slice any, setFunc func(*ProvisionedNetworkCreate, int)) *ProvisionedNetworkCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProvisionedNetworkCreateBulk{err: fmt.Errorf("calling to ProvisionedNetworkClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProvisionedNetworkCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProvisionedNetworkCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProvisionedNetwork.
func (c *ProvisionedNetworkClient) Update() *ProvisionedNetworkUpdate {
	mutation := newProvisionedNetworkMutation(c.config, OpUpdate)
	return &ProvisionedNetworkUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProvisionedNetworkClient) UpdateOne(pn *ProvisionedNetwork) *ProvisionedNetworkUpdateOne {
	mutation := newProvisionedNetworkMutation(c.config, OpUpdateOne, withProvisionedNetwork(pn))
	return &ProvisionedNetworkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProvisionedNetworkClient) UpdateOneID(id uuid.UUID) *ProvisionedNetworkUpdateOne {
	mutation := newProvisionedNetworkMutation(c.config, OpUpdateOne, withProvisionedNetworkID(id))
	return &ProvisionedNetworkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProvisionedNetwork.
func (c *ProvisionedNetworkClient) Delete() *ProvisionedNetworkDelete {
	mutation := newProvisionedNetworkMutation(c.config, OpDelete)
	return &ProvisionedNetworkDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProvisionedNetworkClient) DeleteOne(pn *ProvisionedNetwork) *ProvisionedNetworkDeleteOne {
	return c.DeleteOneID(pn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProvisionedNetworkClient) DeleteOneID(id uuid.UUID) *ProvisionedNetworkDeleteOne {
	builder := c.Delete().Where(provisionednetwork.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProvisionedNetworkDeleteOne{builder}
}

// Query returns a query builder for ProvisionedNetwork.
func (c *ProvisionedNetworkClient) Query() *ProvisionedNetworkQuery {
	return &ProvisionedNetworkQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProvisionedNetwork},
		inters: c.Interceptors(),
	}
}

// Get returns a ProvisionedNetwork entity by its id.
func (c *ProvisionedNetworkClient) Get(ctx context.Context, id uuid.UUID) (*ProvisionedNetwork, error) {
	return c.Query().Where(provisionednetwork.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProvisionedNetworkClient) GetX(ctx context.Context, id uuid.UUID) *ProvisionedNetwork {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStatus queries the Status edge of a ProvisionedNetwork.
func (c *ProvisionedNetworkClient) QueryStatus(pn *ProvisionedNetwork) *StatusQuery {
	query := (&StatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionednetwork.Table, provisionednetwork.FieldID, id),
			sqlgraph.To(status.Table, status.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, provisionednetwork.StatusTable, provisionednetwork.StatusColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNetwork queries the Network edge of a ProvisionedNetwork.
func (c *ProvisionedNetworkClient) QueryNetwork(pn *ProvisionedNetwork) *NetworkQuery {
	query := (&NetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionednetwork.Table, provisionednetwork.FieldID, id),
			sqlgraph.To(network.Table, network.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisionednetwork.NetworkTable, provisionednetwork.NetworkColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuild queries the Build edge of a ProvisionedNetwork.
func (c *ProvisionedNetworkClient) QueryBuild(pn *ProvisionedNetwork) *BuildQuery {
	query := (&BuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionednetwork.Table, provisionednetwork.FieldID, id),
			sqlgraph.To(build.Table, build.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisionednetwork.BuildTable, provisionednetwork.BuildColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeam queries the Team edge of a ProvisionedNetwork.
func (c *ProvisionedNetworkClient) QueryTeam(pn *ProvisionedNetwork) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionednetwork.Table, provisionednetwork.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisionednetwork.TeamTable, provisionednetwork.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedHosts queries the ProvisionedHosts edge of a ProvisionedNetwork.
func (c *ProvisionedNetworkClient) QueryProvisionedHosts(pn *ProvisionedNetwork) *ProvisionedHostQuery {
	query := (&ProvisionedHostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionednetwork.Table, provisionednetwork.FieldID, id),
			sqlgraph.To(provisionedhost.Table, provisionedhost.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, provisionednetwork.ProvisionedHostsTable, provisionednetwork.ProvisionedHostsColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlan queries the Plan edge of a ProvisionedNetwork.
func (c *ProvisionedNetworkClient) QueryPlan(pn *ProvisionedNetwork) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pn.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisionednetwork.Table, provisionednetwork.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, provisionednetwork.PlanTable, provisionednetwork.PlanColumn),
		)
		fromV = sqlgraph.Neighbors(pn.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProvisionedNetworkClient) Hooks() []Hook {
	return c.hooks.ProvisionedNetwork
}

// Interceptors returns the client interceptors.
func (c *ProvisionedNetworkClient) Interceptors() []Interceptor {
	return c.inters.ProvisionedNetwork
}

func (c *ProvisionedNetworkClient) mutate(ctx context.Context, m *ProvisionedNetworkMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProvisionedNetworkCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProvisionedNetworkUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProvisionedNetworkUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProvisionedNetworkDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProvisionedNetwork mutation op: %q", m.Op())
	}
}

// ProvisioningScheduledStepClient is a client for the ProvisioningScheduledStep schema.
type ProvisioningScheduledStepClient struct {
	config
}

// NewProvisioningScheduledStepClient returns a client for the ProvisioningScheduledStep from the given config.
func NewProvisioningScheduledStepClient(c config) *ProvisioningScheduledStepClient {
	return &ProvisioningScheduledStepClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `provisioningscheduledstep.Hooks(f(g(h())))`.
func (c *ProvisioningScheduledStepClient) Use(hooks ...Hook) {
	c.hooks.ProvisioningScheduledStep = append(c.hooks.ProvisioningScheduledStep, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `provisioningscheduledstep.Intercept(f(g(h())))`.
func (c *ProvisioningScheduledStepClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProvisioningScheduledStep = append(c.inters.ProvisioningScheduledStep, interceptors...)
}

// Create returns a builder for creating a ProvisioningScheduledStep entity.
func (c *ProvisioningScheduledStepClient) Create() *ProvisioningScheduledStepCreate {
	mutation := newProvisioningScheduledStepMutation(c.config, OpCreate)
	return &ProvisioningScheduledStepCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProvisioningScheduledStep entities.
func (c *ProvisioningScheduledStepClient) CreateBulk(builders ...*ProvisioningScheduledStepCreate) *ProvisioningScheduledStepCreateBulk {
	return &ProvisioningScheduledStepCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProvisioningScheduledStepClient) MapCreateBulk(slice any, setFunc func(*ProvisioningScheduledStepCreate, int)) *ProvisioningScheduledStepCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProvisioningScheduledStepCreateBulk{err: fmt.Errorf("calling to ProvisioningScheduledStepClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProvisioningScheduledStepCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProvisioningScheduledStepCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProvisioningScheduledStep.
func (c *ProvisioningScheduledStepClient) Update() *ProvisioningScheduledStepUpdate {
	mutation := newProvisioningScheduledStepMutation(c.config, OpUpdate)
	return &ProvisioningScheduledStepUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProvisioningScheduledStepClient) UpdateOne(pss *ProvisioningScheduledStep) *ProvisioningScheduledStepUpdateOne {
	mutation := newProvisioningScheduledStepMutation(c.config, OpUpdateOne, withProvisioningScheduledStep(pss))
	return &ProvisioningScheduledStepUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProvisioningScheduledStepClient) UpdateOneID(id uuid.UUID) *ProvisioningScheduledStepUpdateOne {
	mutation := newProvisioningScheduledStepMutation(c.config, OpUpdateOne, withProvisioningScheduledStepID(id))
	return &ProvisioningScheduledStepUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProvisioningScheduledStep.
func (c *ProvisioningScheduledStepClient) Delete() *ProvisioningScheduledStepDelete {
	mutation := newProvisioningScheduledStepMutation(c.config, OpDelete)
	return &ProvisioningScheduledStepDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProvisioningScheduledStepClient) DeleteOne(pss *ProvisioningScheduledStep) *ProvisioningScheduledStepDeleteOne {
	return c.DeleteOneID(pss.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProvisioningScheduledStepClient) DeleteOneID(id uuid.UUID) *ProvisioningScheduledStepDeleteOne {
	builder := c.Delete().Where(provisioningscheduledstep.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProvisioningScheduledStepDeleteOne{builder}
}

// Query returns a query builder for ProvisioningScheduledStep.
func (c *ProvisioningScheduledStepClient) Query() *ProvisioningScheduledStepQuery {
	return &ProvisioningScheduledStepQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProvisioningScheduledStep},
		inters: c.Interceptors(),
	}
}

// Get returns a ProvisioningScheduledStep entity by its id.
func (c *ProvisioningScheduledStepClient) Get(ctx context.Context, id uuid.UUID) (*ProvisioningScheduledStep, error) {
	return c.Query().Where(provisioningscheduledstep.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProvisioningScheduledStepClient) GetX(ctx context.Context, id uuid.UUID) *ProvisioningScheduledStep {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStatus queries the Status edge of a ProvisioningScheduledStep.
func (c *ProvisioningScheduledStepClient) QueryStatus(pss *ProvisioningScheduledStep) *StatusQuery {
	query := (&StatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pss.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningscheduledstep.Table, provisioningscheduledstep.FieldID, id),
			sqlgraph.To(status.Table, status.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, provisioningscheduledstep.StatusTable, provisioningscheduledstep.StatusColumn),
		)
		fromV = sqlgraph.Neighbors(pss.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScheduledStep queries the ScheduledStep edge of a ProvisioningScheduledStep.
func (c *ProvisioningScheduledStepClient) QueryScheduledStep(pss *ProvisioningScheduledStep) *ScheduledStepQuery {
	query := (&ScheduledStepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pss.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningscheduledstep.Table, provisioningscheduledstep.FieldID, id),
			sqlgraph.To(scheduledstep.Table, scheduledstep.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningscheduledstep.ScheduledStepTable, provisioningscheduledstep.ScheduledStepColumn),
		)
		fromV = sqlgraph.Neighbors(pss.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedHost queries the ProvisionedHost edge of a ProvisioningScheduledStep.
func (c *ProvisioningScheduledStepClient) QueryProvisionedHost(pss *ProvisioningScheduledStep) *ProvisionedHostQuery {
	query := (&ProvisionedHostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pss.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningscheduledstep.Table, provisioningscheduledstep.FieldID, id),
			sqlgraph.To(provisionedhost.Table, provisionedhost.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningscheduledstep.ProvisionedHostTable, provisioningscheduledstep.ProvisionedHostColumn),
		)
		fromV = sqlgraph.Neighbors(pss.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScript queries the Script edge of a ProvisioningScheduledStep.
func (c *ProvisioningScheduledStepClient) QueryScript(pss *ProvisioningScheduledStep) *ScriptQuery {
	query := (&ScriptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pss.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningscheduledstep.Table, provisioningscheduledstep.FieldID, id),
			sqlgraph.To(script.Table, script.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningscheduledstep.ScriptTable, provisioningscheduledstep.ScriptColumn),
		)
		fromV = sqlgraph.Neighbors(pss.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCommand queries the Command edge of a ProvisioningScheduledStep.
func (c *ProvisioningScheduledStepClient) QueryCommand(pss *ProvisioningScheduledStep) *CommandQuery {
	query := (&CommandClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pss.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningscheduledstep.Table, provisioningscheduledstep.FieldID, id),
			sqlgraph.To(command.Table, command.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningscheduledstep.CommandTable, provisioningscheduledstep.CommandColumn),
		)
		fromV = sqlgraph.Neighbors(pss.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDNSRecord queries the DNSRecord edge of a ProvisioningScheduledStep.
func (c *ProvisioningScheduledStepClient) QueryDNSRecord(pss *ProvisioningScheduledStep) *DNSRecordQuery {
	query := (&DNSRecordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pss.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningscheduledstep.Table, provisioningscheduledstep.FieldID, id),
			sqlgraph.To(dnsrecord.Table, dnsrecord.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningscheduledstep.DNSRecordTable, provisioningscheduledstep.DNSRecordColumn),
		)
		fromV = sqlgraph.Neighbors(pss.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFileDelete queries the FileDelete edge of a ProvisioningScheduledStep.
func (c *ProvisioningScheduledStepClient) QueryFileDelete(pss *ProvisioningScheduledStep) *FileDeleteQuery {
	query := (&FileDeleteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pss.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningscheduledstep.Table, provisioningscheduledstep.FieldID, id),
			sqlgraph.To(filedelete.Table, filedelete.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningscheduledstep.FileDeleteTable, provisioningscheduledstep.FileDeleteColumn),
		)
		fromV = sqlgraph.Neighbors(pss.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFileDownload queries the FileDownload edge of a ProvisioningScheduledStep.
func (c *ProvisioningScheduledStepClient) QueryFileDownload(pss *ProvisioningScheduledStep) *FileDownloadQuery {
	query := (&FileDownloadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pss.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningscheduledstep.Table, provisioningscheduledstep.FieldID, id),
			sqlgraph.To(filedownload.Table, filedownload.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningscheduledstep.FileDownloadTable, provisioningscheduledstep.FileDownloadColumn),
		)
		fromV = sqlgraph.Neighbors(pss.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFileExtract queries the FileExtract edge of a ProvisioningScheduledStep.
func (c *ProvisioningScheduledStepClient) QueryFileExtract(pss *ProvisioningScheduledStep) *FileExtractQuery {
	query := (&FileExtractClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pss.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningscheduledstep.Table, provisioningscheduledstep.FieldID, id),
			sqlgraph.To(fileextract.Table, fileextract.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningscheduledstep.FileExtractTable, provisioningscheduledstep.FileExtractColumn),
		)
		fromV = sqlgraph.Neighbors(pss.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAnsible queries the Ansible edge of a ProvisioningScheduledStep.
func (c *ProvisioningScheduledStepClient) QueryAnsible(pss *ProvisioningScheduledStep) *AnsibleQuery {
	query := (&AnsibleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pss.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningscheduledstep.Table, provisioningscheduledstep.FieldID, id),
			sqlgraph.To(ansible.Table, ansible.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningscheduledstep.AnsibleTable, provisioningscheduledstep.AnsibleColumn),
		)
		fromV = sqlgraph.Neighbors(pss.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAgentTasks queries the AgentTasks edge of a ProvisioningScheduledStep.
func (c *ProvisioningScheduledStepClient) QueryAgentTasks(pss *ProvisioningScheduledStep) *AgentTaskQuery {
	query := (&AgentTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pss.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningscheduledstep.Table, provisioningscheduledstep.FieldID, id),
			sqlgraph.To(agenttask.Table, agenttask.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, provisioningscheduledstep.AgentTasksTable, provisioningscheduledstep.AgentTasksColumn),
		)
		fromV = sqlgraph.Neighbors(pss.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlan queries the Plan edge of a ProvisioningScheduledStep.
func (c *ProvisioningScheduledStepClient) QueryPlan(pss *ProvisioningScheduledStep) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pss.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningscheduledstep.Table, provisioningscheduledstep.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, provisioningscheduledstep.PlanTable, provisioningscheduledstep.PlanColumn),
		)
		fromV = sqlgraph.Neighbors(pss.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGinFileMiddleware queries the GinFileMiddleware edge of a ProvisioningScheduledStep.
func (c *ProvisioningScheduledStepClient) QueryGinFileMiddleware(pss *ProvisioningScheduledStep) *GinFileMiddlewareQuery {
	query := (&GinFileMiddlewareClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pss.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningscheduledstep.Table, provisioningscheduledstep.FieldID, id),
			sqlgraph.To(ginfilemiddleware.Table, ginfilemiddleware.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, provisioningscheduledstep.GinFileMiddlewareTable, provisioningscheduledstep.GinFileMiddlewareColumn),
		)
		fromV = sqlgraph.Neighbors(pss.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProvisioningScheduledStepClient) Hooks() []Hook {
	return c.hooks.ProvisioningScheduledStep
}

// Interceptors returns the client interceptors.
func (c *ProvisioningScheduledStepClient) Interceptors() []Interceptor {
	return c.inters.ProvisioningScheduledStep
}

func (c *ProvisioningScheduledStepClient) mutate(ctx context.Context, m *ProvisioningScheduledStepMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProvisioningScheduledStepCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProvisioningScheduledStepUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProvisioningScheduledStepUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProvisioningScheduledStepDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProvisioningScheduledStep mutation op: %q", m.Op())
	}
}

// ProvisioningStepClient is a client for the ProvisioningStep schema.
type ProvisioningStepClient struct {
	config
}

// NewProvisioningStepClient returns a client for the ProvisioningStep from the given config.
func NewProvisioningStepClient(c config) *ProvisioningStepClient {
	return &ProvisioningStepClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `provisioningstep.Hooks(f(g(h())))`.
func (c *ProvisioningStepClient) Use(hooks ...Hook) {
	c.hooks.ProvisioningStep = append(c.hooks.ProvisioningStep, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `provisioningstep.Intercept(f(g(h())))`.
func (c *ProvisioningStepClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProvisioningStep = append(c.inters.ProvisioningStep, interceptors...)
}

// Create returns a builder for creating a ProvisioningStep entity.
func (c *ProvisioningStepClient) Create() *ProvisioningStepCreate {
	mutation := newProvisioningStepMutation(c.config, OpCreate)
	return &ProvisioningStepCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProvisioningStep entities.
func (c *ProvisioningStepClient) CreateBulk(builders ...*ProvisioningStepCreate) *ProvisioningStepCreateBulk {
	return &ProvisioningStepCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProvisioningStepClient) MapCreateBulk(slice any, setFunc func(*ProvisioningStepCreate, int)) *ProvisioningStepCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProvisioningStepCreateBulk{err: fmt.Errorf("calling to ProvisioningStepClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProvisioningStepCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProvisioningStepCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProvisioningStep.
func (c *ProvisioningStepClient) Update() *ProvisioningStepUpdate {
	mutation := newProvisioningStepMutation(c.config, OpUpdate)
	return &ProvisioningStepUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProvisioningStepClient) UpdateOne(ps *ProvisioningStep) *ProvisioningStepUpdateOne {
	mutation := newProvisioningStepMutation(c.config, OpUpdateOne, withProvisioningStep(ps))
	return &ProvisioningStepUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProvisioningStepClient) UpdateOneID(id uuid.UUID) *ProvisioningStepUpdateOne {
	mutation := newProvisioningStepMutation(c.config, OpUpdateOne, withProvisioningStepID(id))
	return &ProvisioningStepUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProvisioningStep.
func (c *ProvisioningStepClient) Delete() *ProvisioningStepDelete {
	mutation := newProvisioningStepMutation(c.config, OpDelete)
	return &ProvisioningStepDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProvisioningStepClient) DeleteOne(ps *ProvisioningStep) *ProvisioningStepDeleteOne {
	return c.DeleteOneID(ps.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProvisioningStepClient) DeleteOneID(id uuid.UUID) *ProvisioningStepDeleteOne {
	builder := c.Delete().Where(provisioningstep.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProvisioningStepDeleteOne{builder}
}

// Query returns a query builder for ProvisioningStep.
func (c *ProvisioningStepClient) Query() *ProvisioningStepQuery {
	return &ProvisioningStepQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProvisioningStep},
		inters: c.Interceptors(),
	}
}

// Get returns a ProvisioningStep entity by its id.
func (c *ProvisioningStepClient) Get(ctx context.Context, id uuid.UUID) (*ProvisioningStep, error) {
	return c.Query().Where(provisioningstep.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProvisioningStepClient) GetX(ctx context.Context, id uuid.UUID) *ProvisioningStep {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStatus queries the Status edge of a ProvisioningStep.
func (c *ProvisioningStepClient) QueryStatus(ps *ProvisioningStep) *StatusQuery {
	query := (&StatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningstep.Table, provisioningstep.FieldID, id),
			sqlgraph.To(status.Table, status.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, provisioningstep.StatusTable, provisioningstep.StatusColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedHost queries the ProvisionedHost edge of a ProvisioningStep.
func (c *ProvisioningStepClient) QueryProvisionedHost(ps *ProvisioningStep) *ProvisionedHostQuery {
	query := (&ProvisionedHostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningstep.Table, provisioningstep.FieldID, id),
			sqlgraph.To(provisionedhost.Table, provisionedhost.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningstep.ProvisionedHostTable, provisioningstep.ProvisionedHostColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryScript queries the Script edge of a ProvisioningStep.
func (c *ProvisioningStepClient) QueryScript(ps *ProvisioningStep) *ScriptQuery {
	query := (&ScriptClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningstep.Table, provisioningstep.FieldID, id),
			sqlgraph.To(script.Table, script.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningstep.ScriptTable, provisioningstep.ScriptColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCommand queries the Command edge of a ProvisioningStep.
func (c *ProvisioningStepClient) QueryCommand(ps *ProvisioningStep) *CommandQuery {
	query := (&CommandClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningstep.Table, provisioningstep.FieldID, id),
			sqlgraph.To(command.Table, command.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningstep.CommandTable, provisioningstep.CommandColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDNSRecord queries the DNSRecord edge of a ProvisioningStep.
func (c *ProvisioningStepClient) QueryDNSRecord(ps *ProvisioningStep) *DNSRecordQuery {
	query := (&DNSRecordClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningstep.Table, provisioningstep.FieldID, id),
			sqlgraph.To(dnsrecord.Table, dnsrecord.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningstep.DNSRecordTable, provisioningstep.DNSRecordColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFileDelete queries the FileDelete edge of a ProvisioningStep.
func (c *ProvisioningStepClient) QueryFileDelete(ps *ProvisioningStep) *FileDeleteQuery {
	query := (&FileDeleteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningstep.Table, provisioningstep.FieldID, id),
			sqlgraph.To(filedelete.Table, filedelete.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningstep.FileDeleteTable, provisioningstep.FileDeleteColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFileDownload queries the FileDownload edge of a ProvisioningStep.
func (c *ProvisioningStepClient) QueryFileDownload(ps *ProvisioningStep) *FileDownloadQuery {
	query := (&FileDownloadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningstep.Table, provisioningstep.FieldID, id),
			sqlgraph.To(filedownload.Table, filedownload.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningstep.FileDownloadTable, provisioningstep.FileDownloadColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFileExtract queries the FileExtract edge of a ProvisioningStep.
func (c *ProvisioningStepClient) QueryFileExtract(ps *ProvisioningStep) *FileExtractQuery {
	query := (&FileExtractClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningstep.Table, provisioningstep.FieldID, id),
			sqlgraph.To(fileextract.Table, fileextract.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningstep.FileExtractTable, provisioningstep.FileExtractColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAnsible queries the Ansible edge of a ProvisioningStep.
func (c *ProvisioningStepClient) QueryAnsible(ps *ProvisioningStep) *AnsibleQuery {
	query := (&AnsibleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningstep.Table, provisioningstep.FieldID, id),
			sqlgraph.To(ansible.Table, ansible.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, provisioningstep.AnsibleTable, provisioningstep.AnsibleColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlan queries the Plan edge of a ProvisioningStep.
func (c *ProvisioningStepClient) QueryPlan(ps *ProvisioningStep) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningstep.Table, provisioningstep.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, provisioningstep.PlanTable, provisioningstep.PlanColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAgentTasks queries the AgentTasks edge of a ProvisioningStep.
func (c *ProvisioningStepClient) QueryAgentTasks(ps *ProvisioningStep) *AgentTaskQuery {
	query := (&AgentTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningstep.Table, provisioningstep.FieldID, id),
			sqlgraph.To(agenttask.Table, agenttask.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, provisioningstep.AgentTasksTable, provisioningstep.AgentTasksColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGinFileMiddleware queries the GinFileMiddleware edge of a ProvisioningStep.
func (c *ProvisioningStepClient) QueryGinFileMiddleware(ps *ProvisioningStep) *GinFileMiddlewareQuery {
	query := (&GinFileMiddlewareClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(provisioningstep.Table, provisioningstep.FieldID, id),
			sqlgraph.To(ginfilemiddleware.Table, ginfilemiddleware.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, provisioningstep.GinFileMiddlewareTable, provisioningstep.GinFileMiddlewareColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProvisioningStepClient) Hooks() []Hook {
	return c.hooks.ProvisioningStep
}

// Interceptors returns the client interceptors.
func (c *ProvisioningStepClient) Interceptors() []Interceptor {
	return c.inters.ProvisioningStep
}

func (c *ProvisioningStepClient) mutate(ctx context.Context, m *ProvisioningStepMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProvisioningStepCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProvisioningStepUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProvisioningStepUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProvisioningStepDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProvisioningStep mutation op: %q", m.Op())
	}
}

// RepoCommitClient is a client for the RepoCommit schema.
type RepoCommitClient struct {
	config
}

// NewRepoCommitClient returns a client for the RepoCommit from the given config.
func NewRepoCommitClient(c config) *RepoCommitClient {
	return &RepoCommitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `repocommit.Hooks(f(g(h())))`.
func (c *RepoCommitClient) Use(hooks ...Hook) {
	c.hooks.RepoCommit = append(c.hooks.RepoCommit, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `repocommit.Intercept(f(g(h())))`.
func (c *RepoCommitClient) Intercept(interceptors ...Interceptor) {
	c.inters.RepoCommit = append(c.inters.RepoCommit, interceptors...)
}

// Create returns a builder for creating a RepoCommit entity.
func (c *RepoCommitClient) Create() *RepoCommitCreate {
	mutation := newRepoCommitMutation(c.config, OpCreate)
	return &RepoCommitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RepoCommit entities.
func (c *RepoCommitClient) CreateBulk(builders ...*RepoCommitCreate) *RepoCommitCreateBulk {
	return &RepoCommitCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RepoCommitClient) MapCreateBulk(slice any, setFunc func(*RepoCommitCreate, int)) *RepoCommitCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RepoCommitCreateBulk{err: fmt.Errorf("calling to RepoCommitClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RepoCommitCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RepoCommitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RepoCommit.
func (c *RepoCommitClient) Update() *RepoCommitUpdate {
	mutation := newRepoCommitMutation(c.config, OpUpdate)
	return &RepoCommitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RepoCommitClient) UpdateOne(rc *RepoCommit) *RepoCommitUpdateOne {
	mutation := newRepoCommitMutation(c.config, OpUpdateOne, withRepoCommit(rc))
	return &RepoCommitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RepoCommitClient) UpdateOneID(id uuid.UUID) *RepoCommitUpdateOne {
	mutation := newRepoCommitMutation(c.config, OpUpdateOne, withRepoCommitID(id))
	return &RepoCommitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RepoCommit.
func (c *RepoCommitClient) Delete() *RepoCommitDelete {
	mutation := newRepoCommitMutation(c.config, OpDelete)
	return &RepoCommitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RepoCommitClient) DeleteOne(rc *RepoCommit) *RepoCommitDeleteOne {
	return c.DeleteOneID(rc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RepoCommitClient) DeleteOneID(id uuid.UUID) *RepoCommitDeleteOne {
	builder := c.Delete().Where(repocommit.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RepoCommitDeleteOne{builder}
}

// Query returns a query builder for RepoCommit.
func (c *RepoCommitClient) Query() *RepoCommitQuery {
	return &RepoCommitQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRepoCommit},
		inters: c.Interceptors(),
	}
}

// Get returns a RepoCommit entity by its id.
func (c *RepoCommitClient) Get(ctx context.Context, id uuid.UUID) (*RepoCommit, error) {
	return c.Query().Where(repocommit.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RepoCommitClient) GetX(ctx context.Context, id uuid.UUID) *RepoCommit {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRepository queries the Repository edge of a RepoCommit.
func (c *RepoCommitClient) QueryRepository(rc *RepoCommit) *RepositoryQuery {
	query := (&RepositoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(repocommit.Table, repocommit.FieldID, id),
			sqlgraph.To(repository.Table, repository.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, repocommit.RepositoryTable, repocommit.RepositoryColumn),
		)
		fromV = sqlgraph.Neighbors(rc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RepoCommitClient) Hooks() []Hook {
	return c.hooks.RepoCommit
}

// Interceptors returns the client interceptors.
func (c *RepoCommitClient) Interceptors() []Interceptor {
	return c.inters.RepoCommit
}

func (c *RepoCommitClient) mutate(ctx context.Context, m *RepoCommitMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RepoCommitCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RepoCommitUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RepoCommitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RepoCommitDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RepoCommit mutation op: %q", m.Op())
	}
}

// RepositoryClient is a client for the Repository schema.
type RepositoryClient struct {
	config
}

// NewRepositoryClient returns a client for the Repository from the given config.
func NewRepositoryClient(c config) *RepositoryClient {
	return &RepositoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `repository.Hooks(f(g(h())))`.
func (c *RepositoryClient) Use(hooks ...Hook) {
	c.hooks.Repository = append(c.hooks.Repository, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `repository.Intercept(f(g(h())))`.
func (c *RepositoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Repository = append(c.inters.Repository, interceptors...)
}

// Create returns a builder for creating a Repository entity.
func (c *RepositoryClient) Create() *RepositoryCreate {
	mutation := newRepositoryMutation(c.config, OpCreate)
	return &RepositoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Repository entities.
func (c *RepositoryClient) CreateBulk(builders ...*RepositoryCreate) *RepositoryCreateBulk {
	return &RepositoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RepositoryClient) MapCreateBulk(slice any, setFunc func(*RepositoryCreate, int)) *RepositoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RepositoryCreateBulk{err: fmt.Errorf("calling to RepositoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RepositoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RepositoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Repository.
func (c *RepositoryClient) Update() *RepositoryUpdate {
	mutation := newRepositoryMutation(c.config, OpUpdate)
	return &RepositoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RepositoryClient) UpdateOne(r *Repository) *RepositoryUpdateOne {
	mutation := newRepositoryMutation(c.config, OpUpdateOne, withRepository(r))
	return &RepositoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RepositoryClient) UpdateOneID(id uuid.UUID) *RepositoryUpdateOne {
	mutation := newRepositoryMutation(c.config, OpUpdateOne, withRepositoryID(id))
	return &RepositoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Repository.
func (c *RepositoryClient) Delete() *RepositoryDelete {
	mutation := newRepositoryMutation(c.config, OpDelete)
	return &RepositoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RepositoryClient) DeleteOne(r *Repository) *RepositoryDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RepositoryClient) DeleteOneID(id uuid.UUID) *RepositoryDeleteOne {
	builder := c.Delete().Where(repository.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RepositoryDeleteOne{builder}
}

// Query returns a query builder for Repository.
func (c *RepositoryClient) Query() *RepositoryQuery {
	return &RepositoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRepository},
		inters: c.Interceptors(),
	}
}

// Get returns a Repository entity by its id.
func (c *RepositoryClient) Get(ctx context.Context, id uuid.UUID) (*Repository, error) {
	return c.Query().Where(repository.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RepositoryClient) GetX(ctx context.Context, id uuid.UUID) *Repository {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEnvironments queries the Environments edge of a Repository.
func (c *RepositoryClient) QueryEnvironments(r *Repository) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(repository.Table, repository.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, repository.EnvironmentsTable, repository.EnvironmentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRepoCommits queries the RepoCommits edge of a Repository.
func (c *RepositoryClient) QueryRepoCommits(r *Repository) *RepoCommitQuery {
	query := (&RepoCommitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(repository.Table, repository.FieldID, id),
			sqlgraph.To(repocommit.Table, repocommit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, repository.RepoCommitsTable, repository.RepoCommitsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RepositoryClient) Hooks() []Hook {
	return c.hooks.Repository
}

// Interceptors returns the client interceptors.
func (c *RepositoryClient) Interceptors() []Interceptor {
	return c.inters.Repository
}

func (c *RepositoryClient) mutate(ctx context.Context, m *RepositoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RepositoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RepositoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RepositoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RepositoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Repository mutation op: %q", m.Op())
	}
}

// ScheduledStepClient is a client for the ScheduledStep schema.
type ScheduledStepClient struct {
	config
}

// NewScheduledStepClient returns a client for the ScheduledStep from the given config.
func NewScheduledStepClient(c config) *ScheduledStepClient {
	return &ScheduledStepClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `scheduledstep.Hooks(f(g(h())))`.
func (c *ScheduledStepClient) Use(hooks ...Hook) {
	c.hooks.ScheduledStep = append(c.hooks.ScheduledStep, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `scheduledstep.Intercept(f(g(h())))`.
func (c *ScheduledStepClient) Intercept(interceptors ...Interceptor) {
	c.inters.ScheduledStep = append(c.inters.ScheduledStep, interceptors...)
}

// Create returns a builder for creating a ScheduledStep entity.
func (c *ScheduledStepClient) Create() *ScheduledStepCreate {
	mutation := newScheduledStepMutation(c.config, OpCreate)
	return &ScheduledStepCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ScheduledStep entities.
func (c *ScheduledStepClient) CreateBulk(builders ...*ScheduledStepCreate) *ScheduledStepCreateBulk {
	return &ScheduledStepCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScheduledStepClient) MapCreateBulk(slice any, setFunc func(*ScheduledStepCreate, int)) *ScheduledStepCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScheduledStepCreateBulk{err: fmt.Errorf("calling to ScheduledStepClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScheduledStepCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScheduledStepCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ScheduledStep.
func (c *ScheduledStepClient) Update() *ScheduledStepUpdate {
	mutation := newScheduledStepMutation(c.config, OpUpdate)
	return &ScheduledStepUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScheduledStepClient) UpdateOne(ss *ScheduledStep) *ScheduledStepUpdateOne {
	mutation := newScheduledStepMutation(c.config, OpUpdateOne, withScheduledStep(ss))
	return &ScheduledStepUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScheduledStepClient) UpdateOneID(id uuid.UUID) *ScheduledStepUpdateOne {
	mutation := newScheduledStepMutation(c.config, OpUpdateOne, withScheduledStepID(id))
	return &ScheduledStepUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ScheduledStep.
func (c *ScheduledStepClient) Delete() *ScheduledStepDelete {
	mutation := newScheduledStepMutation(c.config, OpDelete)
	return &ScheduledStepDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScheduledStepClient) DeleteOne(ss *ScheduledStep) *ScheduledStepDeleteOne {
	return c.DeleteOneID(ss.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScheduledStepClient) DeleteOneID(id uuid.UUID) *ScheduledStepDeleteOne {
	builder := c.Delete().Where(scheduledstep.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScheduledStepDeleteOne{builder}
}

// Query returns a query builder for ScheduledStep.
func (c *ScheduledStepClient) Query() *ScheduledStepQuery {
	return &ScheduledStepQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScheduledStep},
		inters: c.Interceptors(),
	}
}

// Get returns a ScheduledStep entity by its id.
func (c *ScheduledStepClient) Get(ctx context.Context, id uuid.UUID) (*ScheduledStep, error) {
	return c.Query().Where(scheduledstep.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScheduledStepClient) GetX(ctx context.Context, id uuid.UUID) *ScheduledStep {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEnvironment queries the Environment edge of a ScheduledStep.
func (c *ScheduledStepClient) QueryEnvironment(ss *ScheduledStep) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ss.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(scheduledstep.Table, scheduledstep.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, scheduledstep.EnvironmentTable, scheduledstep.EnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(ss.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScheduledStepClient) Hooks() []Hook {
	return c.hooks.ScheduledStep
}

// Interceptors returns the client interceptors.
func (c *ScheduledStepClient) Interceptors() []Interceptor {
	return c.inters.ScheduledStep
}

func (c *ScheduledStepClient) mutate(ctx context.Context, m *ScheduledStepMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScheduledStepCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScheduledStepUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScheduledStepUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScheduledStepDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ScheduledStep mutation op: %q", m.Op())
	}
}

// ScriptClient is a client for the Script schema.
type ScriptClient struct {
	config
}

// NewScriptClient returns a client for the Script from the given config.
func NewScriptClient(c config) *ScriptClient {
	return &ScriptClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `script.Hooks(f(g(h())))`.
func (c *ScriptClient) Use(hooks ...Hook) {
	c.hooks.Script = append(c.hooks.Script, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `script.Intercept(f(g(h())))`.
func (c *ScriptClient) Intercept(interceptors ...Interceptor) {
	c.inters.Script = append(c.inters.Script, interceptors...)
}

// Create returns a builder for creating a Script entity.
func (c *ScriptClient) Create() *ScriptCreate {
	mutation := newScriptMutation(c.config, OpCreate)
	return &ScriptCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Script entities.
func (c *ScriptClient) CreateBulk(builders ...*ScriptCreate) *ScriptCreateBulk {
	return &ScriptCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ScriptClient) MapCreateBulk(slice any, setFunc func(*ScriptCreate, int)) *ScriptCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ScriptCreateBulk{err: fmt.Errorf("calling to ScriptClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ScriptCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ScriptCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Script.
func (c *ScriptClient) Update() *ScriptUpdate {
	mutation := newScriptMutation(c.config, OpUpdate)
	return &ScriptUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScriptClient) UpdateOne(s *Script) *ScriptUpdateOne {
	mutation := newScriptMutation(c.config, OpUpdateOne, withScript(s))
	return &ScriptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScriptClient) UpdateOneID(id uuid.UUID) *ScriptUpdateOne {
	mutation := newScriptMutation(c.config, OpUpdateOne, withScriptID(id))
	return &ScriptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Script.
func (c *ScriptClient) Delete() *ScriptDelete {
	mutation := newScriptMutation(c.config, OpDelete)
	return &ScriptDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ScriptClient) DeleteOne(s *Script) *ScriptDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ScriptClient) DeleteOneID(id uuid.UUID) *ScriptDeleteOne {
	builder := c.Delete().Where(script.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScriptDeleteOne{builder}
}

// Query returns a query builder for Script.
func (c *ScriptClient) Query() *ScriptQuery {
	return &ScriptQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeScript},
		inters: c.Interceptors(),
	}
}

// Get returns a Script entity by its id.
func (c *ScriptClient) Get(ctx context.Context, id uuid.UUID) (*Script, error) {
	return c.Query().Where(script.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScriptClient) GetX(ctx context.Context, id uuid.UUID) *Script {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the Users edge of a Script.
func (c *ScriptClient) QueryUsers(s *Script) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(script.Table, script.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, script.UsersTable, script.UsersColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFindings queries the Findings edge of a Script.
func (c *ScriptClient) QueryFindings(s *Script) *FindingQuery {
	query := (&FindingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(script.Table, script.FieldID, id),
			sqlgraph.To(finding.Table, finding.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, script.FindingsTable, script.FindingsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironment queries the Environment edge of a Script.
func (c *ScriptClient) QueryEnvironment(s *Script) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(script.Table, script.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, script.EnvironmentTable, script.EnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScriptClient) Hooks() []Hook {
	return c.hooks.Script
}

// Interceptors returns the client interceptors.
func (c *ScriptClient) Interceptors() []Interceptor {
	return c.inters.Script
}

func (c *ScriptClient) mutate(ctx context.Context, m *ScriptMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ScriptCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ScriptUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ScriptUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ScriptDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Script mutation op: %q", m.Op())
	}
}

// ServerTaskClient is a client for the ServerTask schema.
type ServerTaskClient struct {
	config
}

// NewServerTaskClient returns a client for the ServerTask from the given config.
func NewServerTaskClient(c config) *ServerTaskClient {
	return &ServerTaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `servertask.Hooks(f(g(h())))`.
func (c *ServerTaskClient) Use(hooks ...Hook) {
	c.hooks.ServerTask = append(c.hooks.ServerTask, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `servertask.Intercept(f(g(h())))`.
func (c *ServerTaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.ServerTask = append(c.inters.ServerTask, interceptors...)
}

// Create returns a builder for creating a ServerTask entity.
func (c *ServerTaskClient) Create() *ServerTaskCreate {
	mutation := newServerTaskMutation(c.config, OpCreate)
	return &ServerTaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ServerTask entities.
func (c *ServerTaskClient) CreateBulk(builders ...*ServerTaskCreate) *ServerTaskCreateBulk {
	return &ServerTaskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ServerTaskClient) MapCreateBulk(slice any, setFunc func(*ServerTaskCreate, int)) *ServerTaskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ServerTaskCreateBulk{err: fmt.Errorf("calling to ServerTaskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ServerTaskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ServerTaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ServerTask.
func (c *ServerTaskClient) Update() *ServerTaskUpdate {
	mutation := newServerTaskMutation(c.config, OpUpdate)
	return &ServerTaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServerTaskClient) UpdateOne(st *ServerTask) *ServerTaskUpdateOne {
	mutation := newServerTaskMutation(c.config, OpUpdateOne, withServerTask(st))
	return &ServerTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServerTaskClient) UpdateOneID(id uuid.UUID) *ServerTaskUpdateOne {
	mutation := newServerTaskMutation(c.config, OpUpdateOne, withServerTaskID(id))
	return &ServerTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ServerTask.
func (c *ServerTaskClient) Delete() *ServerTaskDelete {
	mutation := newServerTaskMutation(c.config, OpDelete)
	return &ServerTaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServerTaskClient) DeleteOne(st *ServerTask) *ServerTaskDeleteOne {
	return c.DeleteOneID(st.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServerTaskClient) DeleteOneID(id uuid.UUID) *ServerTaskDeleteOne {
	builder := c.Delete().Where(servertask.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServerTaskDeleteOne{builder}
}

// Query returns a query builder for ServerTask.
func (c *ServerTaskClient) Query() *ServerTaskQuery {
	return &ServerTaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeServerTask},
		inters: c.Interceptors(),
	}
}

// Get returns a ServerTask entity by its id.
func (c *ServerTaskClient) Get(ctx context.Context, id uuid.UUID) (*ServerTask, error) {
	return c.Query().Where(servertask.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServerTaskClient) GetX(ctx context.Context, id uuid.UUID) *ServerTask {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAuthUser queries the AuthUser edge of a ServerTask.
func (c *ServerTaskClient) QueryAuthUser(st *ServerTask) *AuthUserQuery {
	query := (&AuthUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servertask.Table, servertask.FieldID, id),
			sqlgraph.To(authuser.Table, authuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, servertask.AuthUserTable, servertask.AuthUserColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStatus queries the Status edge of a ServerTask.
func (c *ServerTaskClient) QueryStatus(st *ServerTask) *StatusQuery {
	query := (&StatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servertask.Table, servertask.FieldID, id),
			sqlgraph.To(status.Table, status.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, servertask.StatusTable, servertask.StatusColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironment queries the Environment edge of a ServerTask.
func (c *ServerTaskClient) QueryEnvironment(st *ServerTask) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servertask.Table, servertask.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, servertask.EnvironmentTable, servertask.EnvironmentColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuild queries the Build edge of a ServerTask.
func (c *ServerTaskClient) QueryBuild(st *ServerTask) *BuildQuery {
	query := (&BuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servertask.Table, servertask.FieldID, id),
			sqlgraph.To(build.Table, build.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, servertask.BuildTable, servertask.BuildColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuildCommit queries the BuildCommit edge of a ServerTask.
func (c *ServerTaskClient) QueryBuildCommit(st *ServerTask) *BuildCommitQuery {
	query := (&BuildCommitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servertask.Table, servertask.FieldID, id),
			sqlgraph.To(buildcommit.Table, buildcommit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, servertask.BuildCommitTable, servertask.BuildCommitColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGinFileMiddleware queries the GinFileMiddleware edge of a ServerTask.
func (c *ServerTaskClient) QueryGinFileMiddleware(st *ServerTask) *GinFileMiddlewareQuery {
	query := (&GinFileMiddlewareClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := st.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(servertask.Table, servertask.FieldID, id),
			sqlgraph.To(ginfilemiddleware.Table, ginfilemiddleware.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, servertask.GinFileMiddlewareTable, servertask.GinFileMiddlewareColumn),
		)
		fromV = sqlgraph.Neighbors(st.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServerTaskClient) Hooks() []Hook {
	return c.hooks.ServerTask
}

// Interceptors returns the client interceptors.
func (c *ServerTaskClient) Interceptors() []Interceptor {
	return c.inters.ServerTask
}

func (c *ServerTaskClient) mutate(ctx context.Context, m *ServerTaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServerTaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServerTaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServerTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServerTaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ServerTask mutation op: %q", m.Op())
	}
}

// StatusClient is a client for the Status schema.
type StatusClient struct {
	config
}

// NewStatusClient returns a client for the Status from the given config.
func NewStatusClient(c config) *StatusClient {
	return &StatusClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `status.Hooks(f(g(h())))`.
func (c *StatusClient) Use(hooks ...Hook) {
	c.hooks.Status = append(c.hooks.Status, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `status.Intercept(f(g(h())))`.
func (c *StatusClient) Intercept(interceptors ...Interceptor) {
	c.inters.Status = append(c.inters.Status, interceptors...)
}

// Create returns a builder for creating a Status entity.
func (c *StatusClient) Create() *StatusCreate {
	mutation := newStatusMutation(c.config, OpCreate)
	return &StatusCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Status entities.
func (c *StatusClient) CreateBulk(builders ...*StatusCreate) *StatusCreateBulk {
	return &StatusCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StatusClient) MapCreateBulk(slice any, setFunc func(*StatusCreate, int)) *StatusCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StatusCreateBulk{err: fmt.Errorf("calling to StatusClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StatusCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StatusCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Status.
func (c *StatusClient) Update() *StatusUpdate {
	mutation := newStatusMutation(c.config, OpUpdate)
	return &StatusUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StatusClient) UpdateOne(s *Status) *StatusUpdateOne {
	mutation := newStatusMutation(c.config, OpUpdateOne, withStatus(s))
	return &StatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StatusClient) UpdateOneID(id uuid.UUID) *StatusUpdateOne {
	mutation := newStatusMutation(c.config, OpUpdateOne, withStatusID(id))
	return &StatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Status.
func (c *StatusClient) Delete() *StatusDelete {
	mutation := newStatusMutation(c.config, OpDelete)
	return &StatusDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StatusClient) DeleteOne(s *Status) *StatusDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StatusClient) DeleteOneID(id uuid.UUID) *StatusDeleteOne {
	builder := c.Delete().Where(status.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StatusDeleteOne{builder}
}

// Query returns a query builder for Status.
func (c *StatusClient) Query() *StatusQuery {
	return &StatusQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStatus},
		inters: c.Interceptors(),
	}
}

// Get returns a Status entity by its id.
func (c *StatusClient) Get(ctx context.Context, id uuid.UUID) (*Status, error) {
	return c.Query().Where(status.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StatusClient) GetX(ctx context.Context, id uuid.UUID) *Status {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBuild queries the Build edge of a Status.
func (c *StatusClient) QueryBuild(s *Status) *BuildQuery {
	query := (&BuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(status.Table, status.FieldID, id),
			sqlgraph.To(build.Table, build.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, status.BuildTable, status.BuildColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedNetwork queries the ProvisionedNetwork edge of a Status.
func (c *StatusClient) QueryProvisionedNetwork(s *Status) *ProvisionedNetworkQuery {
	query := (&ProvisionedNetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(status.Table, status.FieldID, id),
			sqlgraph.To(provisionednetwork.Table, provisionednetwork.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, status.ProvisionedNetworkTable, status.ProvisionedNetworkColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedHost queries the ProvisionedHost edge of a Status.
func (c *StatusClient) QueryProvisionedHost(s *Status) *ProvisionedHostQuery {
	query := (&ProvisionedHostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(status.Table, status.FieldID, id),
			sqlgraph.To(provisionedhost.Table, provisionedhost.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, status.ProvisionedHostTable, status.ProvisionedHostColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisioningStep queries the ProvisioningStep edge of a Status.
func (c *StatusClient) QueryProvisioningStep(s *Status) *ProvisioningStepQuery {
	query := (&ProvisioningStepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(status.Table, status.FieldID, id),
			sqlgraph.To(provisioningstep.Table, provisioningstep.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, status.ProvisioningStepTable, status.ProvisioningStepColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeam queries the Team edge of a Status.
func (c *StatusClient) QueryTeam(s *Status) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(status.Table, status.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, status.TeamTable, status.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlan queries the Plan edge of a Status.
func (c *StatusClient) QueryPlan(s *Status) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(status.Table, status.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, status.PlanTable, status.PlanColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServerTask queries the ServerTask edge of a Status.
func (c *StatusClient) QueryServerTask(s *Status) *ServerTaskQuery {
	query := (&ServerTaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(status.Table, status.FieldID, id),
			sqlgraph.To(servertask.Table, servertask.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, status.ServerTaskTable, status.ServerTaskColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAdhocPlan queries the AdhocPlan edge of a Status.
func (c *StatusClient) QueryAdhocPlan(s *Status) *AdhocPlanQuery {
	query := (&AdhocPlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(status.Table, status.FieldID, id),
			sqlgraph.To(adhocplan.Table, adhocplan.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, status.AdhocPlanTable, status.AdhocPlanColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisioningScheduledStep queries the ProvisioningScheduledStep edge of a Status.
func (c *StatusClient) QueryProvisioningScheduledStep(s *Status) *ProvisioningScheduledStepQuery {
	query := (&ProvisioningScheduledStepClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(status.Table, status.FieldID, id),
			sqlgraph.To(provisioningscheduledstep.Table, provisioningscheduledstep.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, status.ProvisioningScheduledStepTable, status.ProvisioningScheduledStepColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StatusClient) Hooks() []Hook {
	return c.hooks.Status
}

// Interceptors returns the client interceptors.
func (c *StatusClient) Interceptors() []Interceptor {
	return c.inters.Status
}

func (c *StatusClient) mutate(ctx context.Context, m *StatusMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StatusCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StatusUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StatusDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Status mutation op: %q", m.Op())
	}
}

// TagClient is a client for the Tag schema.
type TagClient struct {
	config
}

// NewTagClient returns a client for the Tag from the given config.
func NewTagClient(c config) *TagClient {
	return &TagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tag.Hooks(f(g(h())))`.
func (c *TagClient) Use(hooks ...Hook) {
	c.hooks.Tag = append(c.hooks.Tag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tag.Intercept(f(g(h())))`.
func (c *TagClient) Intercept(interceptors ...Interceptor) {
	c.inters.Tag = append(c.inters.Tag, interceptors...)
}

// Create returns a builder for creating a Tag entity.
func (c *TagClient) Create() *TagCreate {
	mutation := newTagMutation(c.config, OpCreate)
	return &TagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Tag entities.
func (c *TagClient) CreateBulk(builders ...*TagCreate) *TagCreateBulk {
	return &TagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TagClient) MapCreateBulk(slice any, setFunc func(*TagCreate, int)) *TagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TagCreateBulk{err: fmt.Errorf("calling to TagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Tag.
func (c *TagClient) Update() *TagUpdate {
	mutation := newTagMutation(c.config, OpUpdate)
	return &TagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TagClient) UpdateOne(t *Tag) *TagUpdateOne {
	mutation := newTagMutation(c.config, OpUpdateOne, withTag(t))
	return &TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TagClient) UpdateOneID(id uuid.UUID) *TagUpdateOne {
	mutation := newTagMutation(c.config, OpUpdateOne, withTagID(id))
	return &TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Tag.
func (c *TagClient) Delete() *TagDelete {
	mutation := newTagMutation(c.config, OpDelete)
	return &TagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TagClient) DeleteOne(t *Tag) *TagDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TagClient) DeleteOneID(id uuid.UUID) *TagDeleteOne {
	builder := c.Delete().Where(tag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TagDeleteOne{builder}
}

// Query returns a query builder for Tag.
func (c *TagClient) Query() *TagQuery {
	return &TagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTag},
		inters: c.Interceptors(),
	}
}

// Get returns a Tag entity by its id.
func (c *TagClient) Get(ctx context.Context, id uuid.UUID) (*Tag, error) {
	return c.Query().Where(tag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TagClient) GetX(ctx context.Context, id uuid.UUID) *Tag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TagClient) Hooks() []Hook {
	return c.hooks.Tag
}

// Interceptors returns the client interceptors.
func (c *TagClient) Interceptors() []Interceptor {
	return c.inters.Tag
}

func (c *TagClient) mutate(ctx context.Context, m *TagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Tag mutation op: %q", m.Op())
	}
}

// TeamClient is a client for the Team schema.
type TeamClient struct {
	config
}

// NewTeamClient returns a client for the Team from the given config.
func NewTeamClient(c config) *TeamClient {
	return &TeamClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `team.Hooks(f(g(h())))`.
func (c *TeamClient) Use(hooks ...Hook) {
	c.hooks.Team = append(c.hooks.Team, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `team.Intercept(f(g(h())))`.
func (c *TeamClient) Intercept(interceptors ...Interceptor) {
	c.inters.Team = append(c.inters.Team, interceptors...)
}

// Create returns a builder for creating a Team entity.
func (c *TeamClient) Create() *TeamCreate {
	mutation := newTeamMutation(c.config, OpCreate)
	return &TeamCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Team entities.
func (c *TeamClient) CreateBulk(builders ...*TeamCreate) *TeamCreateBulk {
	return &TeamCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TeamClient) MapCreateBulk(slice any, setFunc func(*TeamCreate, int)) *TeamCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TeamCreateBulk{err: fmt.Errorf("calling to TeamClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TeamCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TeamCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Team.
func (c *TeamClient) Update() *TeamUpdate {
	mutation := newTeamMutation(c.config, OpUpdate)
	return &TeamUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TeamClient) UpdateOne(t *Team) *TeamUpdateOne {
	mutation := newTeamMutation(c.config, OpUpdateOne, withTeam(t))
	return &TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TeamClient) UpdateOneID(id uuid.UUID) *TeamUpdateOne {
	mutation := newTeamMutation(c.config, OpUpdateOne, withTeamID(id))
	return &TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Team.
func (c *TeamClient) Delete() *TeamDelete {
	mutation := newTeamMutation(c.config, OpDelete)
	return &TeamDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TeamClient) DeleteOne(t *Team) *TeamDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TeamClient) DeleteOneID(id uuid.UUID) *TeamDeleteOne {
	builder := c.Delete().Where(team.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TeamDeleteOne{builder}
}

// Query returns a query builder for Team.
func (c *TeamClient) Query() *TeamQuery {
	return &TeamQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTeam},
		inters: c.Interceptors(),
	}
}

// Get returns a Team entity by its id.
func (c *TeamClient) Get(ctx context.Context, id uuid.UUID) (*Team, error) {
	return c.Query().Where(team.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TeamClient) GetX(ctx context.Context, id uuid.UUID) *Team {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBuild queries the Build edge of a Team.
func (c *TeamClient) QueryBuild(t *Team) *BuildQuery {
	query := (&BuildClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(build.Table, build.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, team.BuildTable, team.BuildColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStatus queries the Status edge of a Team.
func (c *TeamClient) QueryStatus(t *Team) *StatusQuery {
	query := (&StatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(status.Table, status.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, team.StatusTable, team.StatusColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProvisionedNetworks queries the ProvisionedNetworks edge of a Team.
func (c *TeamClient) QueryProvisionedNetworks(t *Team) *ProvisionedNetworkQuery {
	query := (&ProvisionedNetworkClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(provisionednetwork.Table, provisionednetwork.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, team.ProvisionedNetworksTable, team.ProvisionedNetworksColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlan queries the Plan edge of a Team.
func (c *TeamClient) QueryPlan(t *Team) *PlanQuery {
	query := (&PlanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(plan.Table, plan.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, team.PlanTable, team.PlanColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TeamClient) Hooks() []Hook {
	return c.hooks.Team
}

// Interceptors returns the client interceptors.
func (c *TeamClient) Interceptors() []Interceptor {
	return c.inters.Team
}

func (c *TeamClient) mutate(ctx context.Context, m *TeamMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TeamCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TeamUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TeamDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Team mutation op: %q", m.Op())
	}
}

// TokenClient is a client for the Token schema.
type TokenClient struct {
	config
}

// NewTokenClient returns a client for the Token from the given config.
func NewTokenClient(c config) *TokenClient {
	return &TokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `token.Hooks(f(g(h())))`.
func (c *TokenClient) Use(hooks ...Hook) {
	c.hooks.Token = append(c.hooks.Token, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `token.Intercept(f(g(h())))`.
func (c *TokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.Token = append(c.inters.Token, interceptors...)
}

// Create returns a builder for creating a Token entity.
func (c *TokenClient) Create() *TokenCreate {
	mutation := newTokenMutation(c.config, OpCreate)
	return &TokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Token entities.
func (c *TokenClient) CreateBulk(builders ...*TokenCreate) *TokenCreateBulk {
	return &TokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TokenClient) MapCreateBulk(slice any, setFunc func(*TokenCreate, int)) *TokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TokenCreateBulk{err: fmt.Errorf("calling to TokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Token.
func (c *TokenClient) Update() *TokenUpdate {
	mutation := newTokenMutation(c.config, OpUpdate)
	return &TokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TokenClient) UpdateOne(t *Token) *TokenUpdateOne {
	mutation := newTokenMutation(c.config, OpUpdateOne, withToken(t))
	return &TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TokenClient) UpdateOneID(id uuid.UUID) *TokenUpdateOne {
	mutation := newTokenMutation(c.config, OpUpdateOne, withTokenID(id))
	return &TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Token.
func (c *TokenClient) Delete() *TokenDelete {
	mutation := newTokenMutation(c.config, OpDelete)
	return &TokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TokenClient) DeleteOne(t *Token) *TokenDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TokenClient) DeleteOneID(id uuid.UUID) *TokenDeleteOne {
	builder := c.Delete().Where(token.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TokenDeleteOne{builder}
}

// Query returns a query builder for Token.
func (c *TokenClient) Query() *TokenQuery {
	return &TokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeToken},
		inters: c.Interceptors(),
	}
}

// Get returns a Token entity by its id.
func (c *TokenClient) Get(ctx context.Context, id uuid.UUID) (*Token, error) {
	return c.Query().Where(token.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TokenClient) GetX(ctx context.Context, id uuid.UUID) *Token {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAuthUser queries the AuthUser edge of a Token.
func (c *TokenClient) QueryAuthUser(t *Token) *AuthUserQuery {
	query := (&AuthUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(token.Table, token.FieldID, id),
			sqlgraph.To(authuser.Table, authuser.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, token.AuthUserTable, token.AuthUserColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TokenClient) Hooks() []Hook {
	return c.hooks.Token
}

// Interceptors returns the client interceptors.
func (c *TokenClient) Interceptors() []Interceptor {
	return c.inters.Token
}

func (c *TokenClient) mutate(ctx context.Context, m *TokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Token mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTag queries the Tag edge of a User.
func (c *UserClient) QueryTag(u *User) *TagQuery {
	query := (&TagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(tag.Table, tag.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TagTable, user.TagColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEnvironments queries the Environments edge of a User.
func (c *UserClient) QueryEnvironments(u *User) *EnvironmentQuery {
	query := (&EnvironmentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(environment.Table, environment.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, user.EnvironmentsTable, user.EnvironmentsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AdhocPlan, AgentStatus, AgentTask, Ansible, AuthUser, Build, BuildCommit,
		Command, Competition, DNS, DNSRecord, Disk, Environment, FileDelete,
		FileDownload, FileExtract, Finding, GinFileMiddleware, Host, HostDependency,
		Identity, IncludedNetwork, Network, Plan, PlanDiff, ProvisionedHost,
		ProvisionedNetwork, ProvisioningScheduledStep, ProvisioningStep, RepoCommit,
		Repository, ScheduledStep, Script, ServerTask, Status, Tag, Team, Token,
		User []ent.Hook
	}
	inters struct {
		AdhocPlan, AgentStatus, AgentTask, Ansible, AuthUser, Build, BuildCommit,
		Command, Competition, DNS, DNSRecord, Disk, Environment, FileDelete,
		FileDownload, FileExtract, Finding, GinFileMiddleware, Host, HostDependency,
		Identity, IncludedNetwork, Network, Plan, PlanDiff, ProvisionedHost,
		ProvisionedNetwork, ProvisioningScheduledStep, ProvisioningStep, RepoCommit,
		Repository, ScheduledStep, Script, ServerTask, Status, Tag, Team, Token,
		User []ent.Interceptor
	}
)
