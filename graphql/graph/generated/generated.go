// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/gen0cide/laforge/ent"
	"github.com/gen0cide/laforge/graphql/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	AdhocPlan() AdhocPlanResolver
	AgentTask() AgentTaskResolver
	Ansible() AnsibleResolver
	AuthUser() AuthUserResolver
	Build() BuildResolver
	BuildCommit() BuildCommitResolver
	Command() CommandResolver
	Competition() CompetitionResolver
	DNS() DNSResolver
	DNSRecord() DNSRecordResolver
	Disk() DiskResolver
	Environment() EnvironmentResolver
	FileDelete() FileDeleteResolver
	FileDownload() FileDownloadResolver
	FileExtract() FileExtractResolver
	Finding() FindingResolver
	GinFileMiddleware() GinFileMiddlewareResolver
	Host() HostResolver
	HostDependency() HostDependencyResolver
	Identity() IdentityResolver
	IncludedNetwork() IncludedNetworkResolver
	Mutation() MutationResolver
	Network() NetworkResolver
	Plan() PlanResolver
	PlanDiff() PlanDiffResolver
	ProvisionedHost() ProvisionedHostResolver
	ProvisionedNetwork() ProvisionedNetworkResolver
	ProvisioningScheduledStep() ProvisioningScheduledStepResolver
	ProvisioningStep() ProvisioningStepResolver
	Query() QueryResolver
	RepoCommit() RepoCommitResolver
	Repository() RepositoryResolver
	ScheduledStep() ScheduledStepResolver
	Script() ScriptResolver
	ServerTask() ServerTaskResolver
	Status() StatusResolver
	Subscription() SubscriptionResolver
	Tag() TagResolver
	Team() TeamResolver
	User() UserResolver
}

type DirectiveRoot struct {
	HasRole func(ctx context.Context, obj interface{}, next graphql.Resolver, roles []model.RoleLevel) (res interface{}, err error)
}

type ComplexityRoot struct {
	AdhocPlan struct {
		AgentTask      func(childComplexity int) int
		Build          func(childComplexity int) int
		ID             func(childComplexity int) int
		NextAdhocPlans func(childComplexity int) int
		PrevAdhocPlans func(childComplexity int) int
		Status         func(childComplexity int) int
	}

	AgentStatus struct {
		BootTime           func(childComplexity int) int
		Build              func(childComplexity int) int
		ClientID           func(childComplexity int) int
		FreeMem            func(childComplexity int) int
		HostID             func(childComplexity int) int
		Hostname           func(childComplexity int) int
		Load1              func(childComplexity int) int
		Load15             func(childComplexity int) int
		Load5              func(childComplexity int) int
		NumProcs           func(childComplexity int) int
		Os                 func(childComplexity int) int
		ProvisionedHost    func(childComplexity int) int
		ProvisionedNetwork func(childComplexity int) int
		Timestamp          func(childComplexity int) int
		TotalMem           func(childComplexity int) int
		UpTime             func(childComplexity int) int
		UsedMem            func(childComplexity int) int
	}

	AgentStatusBatch struct {
		AgentStatuses func(childComplexity int) int
		PageInfo      func(childComplexity int) int
	}

	AgentTask struct {
		AdhocPlans                func(childComplexity int) int
		Args                      func(childComplexity int) int
		Command                   func(childComplexity int) int
		ErrorMessage              func(childComplexity int) int
		ID                        func(childComplexity int) int
		Number                    func(childComplexity int) int
		Output                    func(childComplexity int) int
		ProvisionedHost           func(childComplexity int) int
		ProvisioningScheduledStep func(childComplexity int) int
		ProvisioningStep          func(childComplexity int) int
		State                     func(childComplexity int) int
	}

	Ansible struct {
		AbsPath      func(childComplexity int) int
		Description  func(childComplexity int) int
		Environment  func(childComplexity int) int
		HclID        func(childComplexity int) int
		ID           func(childComplexity int) int
		Inventory    func(childComplexity int) int
		Method       func(childComplexity int) int
		Name         func(childComplexity int) int
		PlaybookName func(childComplexity int) int
		Source       func(childComplexity int) int
		Tags         func(childComplexity int) int
		Users        func(childComplexity int) int
	}

	AuthUser struct {
		Company     func(childComplexity int) int
		Email       func(childComplexity int) int
		FirstName   func(childComplexity int) int
		ID          func(childComplexity int) int
		LastName    func(childComplexity int) int
		Occupation  func(childComplexity int) int
		Phone       func(childComplexity int) int
		Provider    func(childComplexity int) int
		PublicKey   func(childComplexity int) int
		Role        func(childComplexity int) int
		ServerTasks func(childComplexity int) int
		Username    func(childComplexity int) int
	}

	Build struct {
		AdhocPlans          func(childComplexity int) int
		AgentStatuses       func(childComplexity int) int
		BuildCommits        func(childComplexity int) int
		Competition         func(childComplexity int) int
		CompletedPlan       func(childComplexity int) int
		Environment         func(childComplexity int) int
		EnvironmentRevision func(childComplexity int) int
		ID                  func(childComplexity int) int
		LatestBuildCommit   func(childComplexity int) int
		Plans               func(childComplexity int) int
		ProvisionedNetworks func(childComplexity int) int
		RepoCommit          func(childComplexity int) int
		Revision            func(childComplexity int) int
		ServerTasks         func(childComplexity int) int
		Status              func(childComplexity int) int
		Teams               func(childComplexity int) int
	}

	BuildCommit struct {
		Build       func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		PlanDiffs   func(childComplexity int) int
		Revision    func(childComplexity int) int
		ServerTasks func(childComplexity int) int
		State       func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	Command struct {
		Args         func(childComplexity int) int
		Cooldown     func(childComplexity int) int
		Description  func(childComplexity int) int
		Disabled     func(childComplexity int) int
		Environment  func(childComplexity int) int
		HclID        func(childComplexity int) int
		ID           func(childComplexity int) int
		IgnoreErrors func(childComplexity int) int
		Name         func(childComplexity int) int
		Program      func(childComplexity int) int
		Tags         func(childComplexity int) int
		Timeout      func(childComplexity int) int
		Users        func(childComplexity int) int
		Vars         func(childComplexity int) int
	}

	Competition struct {
		Builds       func(childComplexity int) int
		Config       func(childComplexity int) int
		DNS          func(childComplexity int) int
		Environment  func(childComplexity int) int
		HclID        func(childComplexity int) int
		ID           func(childComplexity int) int
		RootPassword func(childComplexity int) int
		StartTime    func(childComplexity int) int
		StopTime     func(childComplexity int) int
		Tags         func(childComplexity int) int
	}

	DNS struct {
		Competitions func(childComplexity int) int
		Config       func(childComplexity int) int
		DNSServers   func(childComplexity int) int
		Environments func(childComplexity int) int
		HclID        func(childComplexity int) int
		ID           func(childComplexity int) int
		NtpServers   func(childComplexity int) int
		RootDomain   func(childComplexity int) int
		Type         func(childComplexity int) int
	}

	DNSRecord struct {
		Disabled    func(childComplexity int) int
		Environment func(childComplexity int) int
		HclID       func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Tags        func(childComplexity int) int
		Type        func(childComplexity int) int
		Values      func(childComplexity int) int
		Vars        func(childComplexity int) int
		Zone        func(childComplexity int) int
	}

	Disk struct {
		Host func(childComplexity int) int
		ID   func(childComplexity int) int
		Size func(childComplexity int) int
	}

	Environment struct {
		AdminCidrs       func(childComplexity int) int
		Ansibles         func(childComplexity int) int
		Builder          func(childComplexity int) int
		Builds           func(childComplexity int) int
		Commands         func(childComplexity int) int
		CompetitionID    func(childComplexity int) int
		Competitions     func(childComplexity int) int
		Config           func(childComplexity int) int
		DNS              func(childComplexity int) int
		DNSRecords       func(childComplexity int) int
		Description      func(childComplexity int) int
		ExposedVdiPorts  func(childComplexity int) int
		FileDeletes      func(childComplexity int) int
		FileDownloads    func(childComplexity int) int
		FileExtracts     func(childComplexity int) int
		Findings         func(childComplexity int) int
		HclID            func(childComplexity int) int
		HostDependencies func(childComplexity int) int
		Hosts            func(childComplexity int) int
		ID               func(childComplexity int) int
		Identities       func(childComplexity int) int
		IncludedNetworks func(childComplexity int) int
		Name             func(childComplexity int) int
		Networks         func(childComplexity int) int
		Repositories     func(childComplexity int) int
		Revision         func(childComplexity int) int
		ScheduledSteps   func(childComplexity int) int
		Scripts          func(childComplexity int) int
		ServerTasks      func(childComplexity int) int
		Tags             func(childComplexity int) int
		TeamCount        func(childComplexity int) int
		Users            func(childComplexity int) int
	}

	FileDelete struct {
		Environment func(childComplexity int) int
		HclID       func(childComplexity int) int
		ID          func(childComplexity int) int
		Path        func(childComplexity int) int
		Tags        func(childComplexity int) int
	}

	FileDownload struct {
		AbsPath     func(childComplexity int) int
		Destination func(childComplexity int) int
		Disabled    func(childComplexity int) int
		Environment func(childComplexity int) int
		HclID       func(childComplexity int) int
		ID          func(childComplexity int) int
		Md5         func(childComplexity int) int
		Perms       func(childComplexity int) int
		Source      func(childComplexity int) int
		SourceType  func(childComplexity int) int
		Tags        func(childComplexity int) int
		Template    func(childComplexity int) int
	}

	FileExtract struct {
		Destination func(childComplexity int) int
		Environment func(childComplexity int) int
		HclID       func(childComplexity int) int
		ID          func(childComplexity int) int
		Source      func(childComplexity int) int
		Tags        func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	Finding struct {
		Description func(childComplexity int) int
		Difficulty  func(childComplexity int) int
		Environment func(childComplexity int) int
		Host        func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Script      func(childComplexity int) int
		Severity    func(childComplexity int) int
		Tags        func(childComplexity int) int
		Users       func(childComplexity int) int
	}

	GinFileMiddleware struct {
		Accessed                  func(childComplexity int) int
		FilePath                  func(childComplexity int) int
		ID                        func(childComplexity int) int
		ProvisionedHost           func(childComplexity int) int
		ProvisioningScheduledStep func(childComplexity int) int
		ProvisioningStep          func(childComplexity int) int
		URLID                     func(childComplexity int) int
	}

	Host struct {
		AllowMACChanges            func(childComplexity int) int
		DependOnHostDependencies   func(childComplexity int) int
		Description                func(childComplexity int) int
		Disk                       func(childComplexity int) int
		Environment                func(childComplexity int) int
		ExposedTCPPorts            func(childComplexity int) int
		ExposedUDPPorts            func(childComplexity int) int
		HclID                      func(childComplexity int) int
		Hostname                   func(childComplexity int) int
		ID                         func(childComplexity int) int
		IncludedNetworks           func(childComplexity int) int
		InstanceSize               func(childComplexity int) int
		LastOctet                  func(childComplexity int) int
		OS                         func(childComplexity int) int
		OverridePassword           func(childComplexity int) int
		ProvisionSteps             func(childComplexity int) int
		RequiredByHostDependencies func(childComplexity int) int
		Tags                       func(childComplexity int) int
		UserGroups                 func(childComplexity int) int
		Users                      func(childComplexity int) int
		Vars                       func(childComplexity int) int
	}

	HostDependency struct {
		DependOnHost    func(childComplexity int) int
		DependOnNetwork func(childComplexity int) int
		Environment     func(childComplexity int) int
		HostID          func(childComplexity int) int
		ID              func(childComplexity int) int
		NetworkID       func(childComplexity int) int
		RequiredBy      func(childComplexity int) int
	}

	Identity struct {
		AvatarFile  func(childComplexity int) int
		Description func(childComplexity int) int
		Email       func(childComplexity int) int
		Environment func(childComplexity int) int
		FirstName   func(childComplexity int) int
		HclID       func(childComplexity int) int
		ID          func(childComplexity int) int
		LastName    func(childComplexity int) int
		Password    func(childComplexity int) int
		Tags        func(childComplexity int) int
		Vars        func(childComplexity int) int
	}

	IncludedNetwork struct {
		Environments  func(childComplexity int) int
		Hosts         func(childComplexity int) int
		ID            func(childComplexity int) int
		IncludedHosts func(childComplexity int) int
		Name          func(childComplexity int) int
		Network       func(childComplexity int) int
		Tags          func(childComplexity int) int
	}

	LaForgePageInfo struct {
		NextOffset func(childComplexity int) int
		Total      func(childComplexity int) int
	}

	Mutation struct {
		ApproveCommit            func(childComplexity int, commitUUID string) int
		CancelBuild              func(childComplexity int, buildUUID string) int
		CancelCommit             func(childComplexity int, commitUUID string) int
		CreateAgentTasks         func(childComplexity int, hostHclid string, command model.AgentCommand, buildUUID string, args []string, teams []int) int
		CreateBatchAgentTasks    func(childComplexity int, proHostUUIDs []string, command model.AgentCommand, args []string) int
		CreateBuild              func(childComplexity int, envUUID string, renderFiles bool) int
		CreateEnviromentFromRepo func(childComplexity int, repoURL string, branchName string, envFilePath string) int
		CreateTask               func(childComplexity int, proHostUUID string, command model.AgentCommand, args string) int
		CreateUser               func(childComplexity int, username string, password string, role model.RoleLevel, provider model.ProviderType) int
		DeleteBuild              func(childComplexity int, buildUUID string) int
		DeleteUser               func(childComplexity int, userUUID string) int
		DumpBuild                func(childComplexity int, buildUUID string) int
		ExecutePlan              func(childComplexity int, buildUUID string) int
		LoadEnvironment          func(childComplexity int, envFilePath string) int
		ModifyAdminPassword      func(childComplexity int, userID string, newPassword string) int
		ModifyAdminUserInfo      func(childComplexity int, userID string, username *string, firstName *string, lastName *string, email *string, phone *string, company *string, occupation *string, role *model.RoleLevel, provider *model.ProviderType) int
		ModifySelfPassword       func(childComplexity int, currentPassword string, newPassword string) int
		ModifySelfUserInfo       func(childComplexity int, firstName *string, lastName *string, email *string, phone *string, company *string, occupation *string) int
		NukeBackend              func(childComplexity int) int
		Rebuild                  func(childComplexity int, rootPlans []*string) int
		UpdateEnviromentViaPull  func(childComplexity int, envUUID string) int
	}

	Network struct {
		Cidr             func(childComplexity int) int
		Environment      func(childComplexity int) int
		HclID            func(childComplexity int) int
		HostDependencies func(childComplexity int) int
		ID               func(childComplexity int) int
		IncludedNetworks func(childComplexity int) int
		Name             func(childComplexity int) int
		Tags             func(childComplexity int) int
		Vars             func(childComplexity int) int
		VdiVisible       func(childComplexity int) int
	}

	Plan struct {
		Build                     func(childComplexity int) int
		ID                        func(childComplexity int) int
		NextPlans                 func(childComplexity int) int
		PlanDiffs                 func(childComplexity int) int
		PrevPlans                 func(childComplexity int) int
		ProvisionedHost           func(childComplexity int) int
		ProvisionedNetwork        func(childComplexity int) int
		ProvisioningScheduledStep func(childComplexity int) int
		ProvisioningStep          func(childComplexity int) int
		Status                    func(childComplexity int) int
		StepNumber                func(childComplexity int) int
		Team                      func(childComplexity int) int
		Type                      func(childComplexity int) int
	}

	PlanCounts struct {
		Awaiting         func(childComplexity int) int
		Cancelled        func(childComplexity int) int
		Complete         func(childComplexity int) int
		DeleteInProgress func(childComplexity int) int
		Deleted          func(childComplexity int) int
		Failed           func(childComplexity int) int
		InProgress       func(childComplexity int) int
		ParentAwaiting   func(childComplexity int) int
		Planning         func(childComplexity int) int
		Tainted          func(childComplexity int) int
		ToDelete         func(childComplexity int) int
		ToRebuild        func(childComplexity int) int
		Undefined        func(childComplexity int) int
	}

	PlanDiff struct {
		BuildCommit func(childComplexity int) int
		ID          func(childComplexity int) int
		NewState    func(childComplexity int) int
		Plan        func(childComplexity int) int
		Revision    func(childComplexity int) int
	}

	ProvisionedHost struct {
		AddonType                  func(childComplexity int) int
		AgentStatus                func(childComplexity int) int
		AgentTasks                 func(childComplexity int) int
		Build                      func(childComplexity int) int
		EndStepPlan                func(childComplexity int) int
		GinFileMiddleware          func(childComplexity int) int
		Host                       func(childComplexity int) int
		ID                         func(childComplexity int) int
		Plan                       func(childComplexity int) int
		ProvisionedNetwork         func(childComplexity int) int
		ProvisioningScheduledSteps func(childComplexity int) int
		ProvisioningSteps          func(childComplexity int) int
		Status                     func(childComplexity int) int
		SubnetIP                   func(childComplexity int) int
		Vars                       func(childComplexity int) int
	}

	ProvisionedNetwork struct {
		Build            func(childComplexity int) int
		Cidr             func(childComplexity int) int
		ID               func(childComplexity int) int
		Name             func(childComplexity int) int
		Network          func(childComplexity int) int
		Plan             func(childComplexity int) int
		ProvisionedHosts func(childComplexity int) int
		Status           func(childComplexity int) int
		Team             func(childComplexity int) int
		Vars             func(childComplexity int) int
	}

	ProvisioningScheduledStep struct {
		AgentTasks        func(childComplexity int) int
		Ansible           func(childComplexity int) int
		Command           func(childComplexity int) int
		DNSRecord         func(childComplexity int) int
		FileDelete        func(childComplexity int) int
		FileDownload      func(childComplexity int) int
		FileExtract       func(childComplexity int) int
		GinFileMiddleware func(childComplexity int) int
		ID                func(childComplexity int) int
		Plan              func(childComplexity int) int
		ProvisionedHost   func(childComplexity int) int
		RunTime           func(childComplexity int) int
		ScheduledStep     func(childComplexity int) int
		Script            func(childComplexity int) int
		Status            func(childComplexity int) int
		Type              func(childComplexity int) int
	}

	ProvisioningStep struct {
		AgentTasks        func(childComplexity int) int
		Ansible           func(childComplexity int) int
		Command           func(childComplexity int) int
		DNSRecord         func(childComplexity int) int
		FileDelete        func(childComplexity int) int
		FileDownload      func(childComplexity int) int
		FileExtract       func(childComplexity int) int
		GinFileMiddleware func(childComplexity int) int
		ID                func(childComplexity int) int
		Plan              func(childComplexity int) int
		ProvisionedHost   func(childComplexity int) int
		Script            func(childComplexity int) int
		Status            func(childComplexity int) int
		StepNumber        func(childComplexity int) int
		Type              func(childComplexity int) int
	}

	Query struct {
		AgentStatus         func(childComplexity int, clientID string) int
		Build               func(childComplexity int, buildUUID string) int
		CurrentUser         func(childComplexity int) int
		Environment         func(childComplexity int, envUUID string) int
		Environments        func(childComplexity int) int
		GetAgentTasks       func(childComplexity int, proStepUUID string) int
		GetAllAgentStatus   func(childComplexity int, buildUUID string, count int, offset int) int
		GetAllPlanStatus    func(childComplexity int, buildUUID string, count int, offset int) int
		GetBuildCommit      func(childComplexity int, buildCommitUUID string) int
		GetBuildCommits     func(childComplexity int, envUUID string) int
		GetBuilds           func(childComplexity int) int
		GetCurrentUserTasks func(childComplexity int) int
		GetPlanStatusCounts func(childComplexity int, buildUUID string) int
		GetServerTasks      func(childComplexity int) int
		GetUserList         func(childComplexity int) int
		ListAgentStatuses   func(childComplexity int, buildUUID string) int
		ListBuildStatuses   func(childComplexity int, buildUUID string) int
		Plan                func(childComplexity int, planUUID string) int
		ProvisionedHost     func(childComplexity int, proHostUUID string) int
		ProvisionedNetwork  func(childComplexity int, proNetUUID string) int
		ProvisionedStep     func(childComplexity int, proStepUUID string) int
		ServerTasks         func(childComplexity int, taskUUIDs []*string) int
		Status              func(childComplexity int, statusUUID string) int
		ViewAgentTask       func(childComplexity int, taskID string) int
		ViewServerTaskLogs  func(childComplexity int, taskID string) int
	}

	RepoCommit struct {
		Author       func(childComplexity int) int
		Committer    func(childComplexity int) int
		Hash         func(childComplexity int) int
		ID           func(childComplexity int) int
		Message      func(childComplexity int) int
		ParentHashes func(childComplexity int) int
		PgpSignature func(childComplexity int) int
		Repository   func(childComplexity int) int
		Revision     func(childComplexity int) int
		TreeHash     func(childComplexity int) int
	}

	Repository struct {
		BranchName          func(childComplexity int) int
		EnvironmentFilepath func(childComplexity int) int
		Environments        func(childComplexity int) int
		ID                  func(childComplexity int) int
		RepoCommits         func(childComplexity int) int
		RepoURL             func(childComplexity int) int
	}

	ScheduledStep struct {
		Description func(childComplexity int) int
		Environment func(childComplexity int) int
		HclID       func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		RunAt       func(childComplexity int) int
		Schedule    func(childComplexity int) int
		Step        func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	Script struct {
		AbsPath      func(childComplexity int) int
		Args         func(childComplexity int) int
		Cooldown     func(childComplexity int) int
		Description  func(childComplexity int) int
		Disabled     func(childComplexity int) int
		Environment  func(childComplexity int) int
		Findings     func(childComplexity int) int
		HclID        func(childComplexity int) int
		ID           func(childComplexity int) int
		IgnoreErrors func(childComplexity int) int
		Language     func(childComplexity int) int
		Name         func(childComplexity int) int
		Source       func(childComplexity int) int
		SourceType   func(childComplexity int) int
		Tags         func(childComplexity int) int
		Timeout      func(childComplexity int) int
		Users        func(childComplexity int) int
		Vars         func(childComplexity int) int
	}

	ServerTask struct {
		AuthUser          func(childComplexity int) int
		Build             func(childComplexity int) int
		BuildCommit       func(childComplexity int) int
		EndTime           func(childComplexity int) int
		Environment       func(childComplexity int) int
		Errors            func(childComplexity int) int
		GinFileMiddleware func(childComplexity int) int
		ID                func(childComplexity int) int
		LogFilePath       func(childComplexity int) int
		StartTime         func(childComplexity int) int
		Status            func(childComplexity int) int
		Type              func(childComplexity int) int
	}

	Status struct {
		AdhocPlan                 func(childComplexity int) int
		Build                     func(childComplexity int) int
		Completed                 func(childComplexity int) int
		EndedAt                   func(childComplexity int) int
		Error                     func(childComplexity int) int
		Failed                    func(childComplexity int) int
		ID                        func(childComplexity int) int
		Plan                      func(childComplexity int) int
		ProvisionedHost           func(childComplexity int) int
		ProvisionedNetwork        func(childComplexity int) int
		ProvisioningScheduledStep func(childComplexity int) int
		ProvisioningStep          func(childComplexity int) int
		ServerTask                func(childComplexity int) int
		StartedAt                 func(childComplexity int) int
		State                     func(childComplexity int) int
		StatusFor                 func(childComplexity int) int
		Team                      func(childComplexity int) int
	}

	StatusBatch struct {
		PageInfo func(childComplexity int) int
		Statuses func(childComplexity int) int
	}

	Subscription struct {
		StreamServerTaskLog func(childComplexity int, taskID string) int
		UpdatedAgentStatus  func(childComplexity int) int
		UpdatedAgentTask    func(childComplexity int) int
		UpdatedBuild        func(childComplexity int) int
		UpdatedCommit       func(childComplexity int) int
		UpdatedServerTask   func(childComplexity int) int
		UpdatedStatus       func(childComplexity int) int
	}

	Tag struct {
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		UUID        func(childComplexity int) int
	}

	Team struct {
		Build               func(childComplexity int) int
		ID                  func(childComplexity int) int
		Plan                func(childComplexity int) int
		ProvisionedNetworks func(childComplexity int) int
		Status              func(childComplexity int) int
		TeamNumber          func(childComplexity int) int
	}

	User struct {
		Email        func(childComplexity int) int
		Environments func(childComplexity int) int
		HclID        func(childComplexity int) int
		ID           func(childComplexity int) int
		Name         func(childComplexity int) int
		Tag          func(childComplexity int) int
		UUID         func(childComplexity int) int
	}

	ConfigMap struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	IntMap struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	TagMap struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	VarsMap struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}
}

type AdhocPlanResolver interface {
	ID(ctx context.Context, obj *ent.AdhocPlan) (string, error)
}
type AgentTaskResolver interface {
	ID(ctx context.Context, obj *ent.AgentTask) (string, error)

	Command(ctx context.Context, obj *ent.AgentTask) (model.AgentCommand, error)

	State(ctx context.Context, obj *ent.AgentTask) (model.AgentTaskState, error)
}
type AnsibleResolver interface {
	ID(ctx context.Context, obj *ent.Ansible) (string, error)

	Method(ctx context.Context, obj *ent.Ansible) (model.AnsibleMethod, error)

	Tags(ctx context.Context, obj *ent.Ansible) ([]*model.TagMap, error)
}
type AuthUserResolver interface {
	ID(ctx context.Context, obj *ent.AuthUser) (string, error)

	PublicKey(ctx context.Context, obj *ent.AuthUser) (string, error)
	Role(ctx context.Context, obj *ent.AuthUser) (model.RoleLevel, error)
	Provider(ctx context.Context, obj *ent.AuthUser) (model.ProviderType, error)
}
type BuildResolver interface {
	ID(ctx context.Context, obj *ent.Build) (string, error)
}
type BuildCommitResolver interface {
	ID(ctx context.Context, obj *ent.BuildCommit) (string, error)
	Type(ctx context.Context, obj *ent.BuildCommit) (model.BuildCommitType, error)

	State(ctx context.Context, obj *ent.BuildCommit) (model.BuildCommitState, error)
}
type CommandResolver interface {
	ID(ctx context.Context, obj *ent.Command) (string, error)

	Vars(ctx context.Context, obj *ent.Command) ([]*model.VarsMap, error)
	Tags(ctx context.Context, obj *ent.Command) ([]*model.TagMap, error)
}
type CompetitionResolver interface {
	ID(ctx context.Context, obj *ent.Competition) (string, error)

	Config(ctx context.Context, obj *ent.Competition) ([]*model.ConfigMap, error)
	Tags(ctx context.Context, obj *ent.Competition) ([]*model.TagMap, error)
}
type DNSResolver interface {
	ID(ctx context.Context, obj *ent.DNS) (string, error)

	Config(ctx context.Context, obj *ent.DNS) ([]*model.ConfigMap, error)
}
type DNSRecordResolver interface {
	ID(ctx context.Context, obj *ent.DNSRecord) (string, error)

	Vars(ctx context.Context, obj *ent.DNSRecord) ([]*model.VarsMap, error)

	Tags(ctx context.Context, obj *ent.DNSRecord) ([]*model.TagMap, error)
}
type DiskResolver interface {
	ID(ctx context.Context, obj *ent.Disk) (string, error)
}
type EnvironmentResolver interface {
	ID(ctx context.Context, obj *ent.Environment) (string, error)

	Config(ctx context.Context, obj *ent.Environment) ([]*model.ConfigMap, error)
	Tags(ctx context.Context, obj *ent.Environment) ([]*model.TagMap, error)
}
type FileDeleteResolver interface {
	ID(ctx context.Context, obj *ent.FileDelete) (string, error)

	Tags(ctx context.Context, obj *ent.FileDelete) ([]*model.TagMap, error)
}
type FileDownloadResolver interface {
	ID(ctx context.Context, obj *ent.FileDownload) (string, error)

	Tags(ctx context.Context, obj *ent.FileDownload) ([]*model.TagMap, error)
}
type FileExtractResolver interface {
	ID(ctx context.Context, obj *ent.FileExtract) (string, error)

	Tags(ctx context.Context, obj *ent.FileExtract) ([]*model.TagMap, error)
}
type FindingResolver interface {
	ID(ctx context.Context, obj *ent.Finding) (string, error)

	Severity(ctx context.Context, obj *ent.Finding) (model.FindingSeverity, error)
	Difficulty(ctx context.Context, obj *ent.Finding) (model.FindingDifficulty, error)
	Tags(ctx context.Context, obj *ent.Finding) ([]*model.TagMap, error)
}
type GinFileMiddlewareResolver interface {
	ID(ctx context.Context, obj *ent.GinFileMiddleware) (string, error)
}
type HostResolver interface {
	ID(ctx context.Context, obj *ent.Host) (string, error)

	Vars(ctx context.Context, obj *ent.Host) ([]*model.VarsMap, error)

	Tags(ctx context.Context, obj *ent.Host) ([]*model.TagMap, error)
}
type HostDependencyResolver interface {
	ID(ctx context.Context, obj *ent.HostDependency) (string, error)
}
type IdentityResolver interface {
	ID(ctx context.Context, obj *ent.Identity) (string, error)

	Vars(ctx context.Context, obj *ent.Identity) ([]*model.VarsMap, error)
	Tags(ctx context.Context, obj *ent.Identity) ([]*model.TagMap, error)
}
type IncludedNetworkResolver interface {
	ID(ctx context.Context, obj *ent.IncludedNetwork) (string, error)
}
type MutationResolver interface {
	LoadEnvironment(ctx context.Context, envFilePath string) ([]*ent.Environment, error)
	CreateBuild(ctx context.Context, envUUID string, renderFiles bool) (*ent.Build, error)
	DeleteUser(ctx context.Context, userUUID string) (bool, error)
	ExecutePlan(ctx context.Context, buildUUID string) (*ent.Build, error)
	DeleteBuild(ctx context.Context, buildUUID string) (string, error)
	CreateTask(ctx context.Context, proHostUUID string, command model.AgentCommand, args string) (bool, error)
	DumpBuild(ctx context.Context, buildUUID string) (string, error)
	Rebuild(ctx context.Context, rootPlans []*string) (bool, error)
	ApproveCommit(ctx context.Context, commitUUID string) (bool, error)
	CancelCommit(ctx context.Context, commitUUID string) (bool, error)
	CreateAgentTasks(ctx context.Context, hostHclid string, command model.AgentCommand, buildUUID string, args []string, teams []int) ([]*ent.AgentTask, error)
	CreateBatchAgentTasks(ctx context.Context, proHostUUIDs []string, command model.AgentCommand, args []string) ([]*ent.AgentTask, error)
	CreateEnviromentFromRepo(ctx context.Context, repoURL string, branchName string, envFilePath string) ([]*ent.Environment, error)
	UpdateEnviromentViaPull(ctx context.Context, envUUID string) ([]*ent.Environment, error)
	CancelBuild(ctx context.Context, buildUUID string) (bool, error)
	ModifySelfPassword(ctx context.Context, currentPassword string, newPassword string) (bool, error)
	ModifySelfUserInfo(ctx context.Context, firstName *string, lastName *string, email *string, phone *string, company *string, occupation *string) (*ent.AuthUser, error)
	CreateUser(ctx context.Context, username string, password string, role model.RoleLevel, provider model.ProviderType) (*ent.AuthUser, error)
	ModifyAdminUserInfo(ctx context.Context, userID string, username *string, firstName *string, lastName *string, email *string, phone *string, company *string, occupation *string, role *model.RoleLevel, provider *model.ProviderType) (*ent.AuthUser, error)
	ModifyAdminPassword(ctx context.Context, userID string, newPassword string) (bool, error)
	NukeBackend(ctx context.Context) ([]*model.IntMap, error)
}
type NetworkResolver interface {
	ID(ctx context.Context, obj *ent.Network) (string, error)

	Vars(ctx context.Context, obj *ent.Network) ([]*model.VarsMap, error)
	Tags(ctx context.Context, obj *ent.Network) ([]*model.TagMap, error)
}
type PlanResolver interface {
	ID(ctx context.Context, obj *ent.Plan) (string, error)

	Type(ctx context.Context, obj *ent.Plan) (model.PlanType, error)
}
type PlanDiffResolver interface {
	ID(ctx context.Context, obj *ent.PlanDiff) (string, error)

	NewState(ctx context.Context, obj *ent.PlanDiff) (model.ProvisionStatus, error)
}
type ProvisionedHostResolver interface {
	ID(ctx context.Context, obj *ent.ProvisionedHost) (string, error)

	AddonType(ctx context.Context, obj *ent.ProvisionedHost) (*model.ProvisionedHostAddonType, error)
	Vars(ctx context.Context, obj *ent.ProvisionedHost) ([]*model.VarsMap, error)
}
type ProvisionedNetworkResolver interface {
	ID(ctx context.Context, obj *ent.ProvisionedNetwork) (string, error)

	Vars(ctx context.Context, obj *ent.ProvisionedNetwork) ([]*model.VarsMap, error)
}
type ProvisioningScheduledStepResolver interface {
	ID(ctx context.Context, obj *ent.ProvisioningScheduledStep) (string, error)
	Type(ctx context.Context, obj *ent.ProvisioningScheduledStep) (model.ProvisioningScheduledStepType, error)
}
type ProvisioningStepResolver interface {
	ID(ctx context.Context, obj *ent.ProvisioningStep) (string, error)
	Type(ctx context.Context, obj *ent.ProvisioningStep) (model.ProvisioningStepType, error)
}
type QueryResolver interface {
	Environments(ctx context.Context) ([]*ent.Environment, error)
	Environment(ctx context.Context, envUUID string) (*ent.Environment, error)
	ProvisionedHost(ctx context.Context, proHostUUID string) (*ent.ProvisionedHost, error)
	ProvisionedNetwork(ctx context.Context, proNetUUID string) (*ent.ProvisionedNetwork, error)
	ProvisionedStep(ctx context.Context, proStepUUID string) (*ent.ProvisioningStep, error)
	Plan(ctx context.Context, planUUID string) (*ent.Plan, error)
	GetBuilds(ctx context.Context) ([]*ent.Build, error)
	Build(ctx context.Context, buildUUID string) (*ent.Build, error)
	GetBuildCommits(ctx context.Context, envUUID string) ([]*ent.BuildCommit, error)
	GetBuildCommit(ctx context.Context, buildCommitUUID string) (*ent.BuildCommit, error)
	Status(ctx context.Context, statusUUID string) (*ent.Status, error)
	AgentStatus(ctx context.Context, clientID string) (*ent.AgentStatus, error)
	GetServerTasks(ctx context.Context) ([]*ent.ServerTask, error)
	CurrentUser(ctx context.Context) (*ent.AuthUser, error)
	GetUserList(ctx context.Context) ([]*ent.AuthUser, error)
	GetCurrentUserTasks(ctx context.Context) ([]*ent.ServerTask, error)
	GetAgentTasks(ctx context.Context, proStepUUID string) ([]*ent.AgentTask, error)
	ListAgentStatuses(ctx context.Context, buildUUID string) ([]*ent.AgentStatus, error)
	ListBuildStatuses(ctx context.Context, buildUUID string) ([]*ent.Status, error)
	GetAllAgentStatus(ctx context.Context, buildUUID string, count int, offset int) (*model.AgentStatusBatch, error)
	GetAllPlanStatus(ctx context.Context, buildUUID string, count int, offset int) (*model.StatusBatch, error)
	GetPlanStatusCounts(ctx context.Context, buildUUID string) (*model.PlanCounts, error)
	ViewServerTaskLogs(ctx context.Context, taskID string) (string, error)
	ViewAgentTask(ctx context.Context, taskID string) (*ent.AgentTask, error)
	ServerTasks(ctx context.Context, taskUUIDs []*string) ([]*ent.ServerTask, error)
}
type RepoCommitResolver interface {
	ID(ctx context.Context, obj *ent.RepoCommit) (string, error)

	Author(ctx context.Context, obj *ent.RepoCommit) (string, error)
	Committer(ctx context.Context, obj *ent.RepoCommit) (string, error)
}
type RepositoryResolver interface {
	ID(ctx context.Context, obj *ent.Repository) (string, error)

	EnvironmentFilepath(ctx context.Context, obj *ent.Repository) (string, error)
}
type ScheduledStepResolver interface {
	ID(ctx context.Context, obj *ent.ScheduledStep) (string, error)

	Type(ctx context.Context, obj *ent.ScheduledStep) (model.ScheduledStepType, error)
}
type ScriptResolver interface {
	ID(ctx context.Context, obj *ent.Script) (string, error)

	Vars(ctx context.Context, obj *ent.Script) ([]*model.VarsMap, error)

	Tags(ctx context.Context, obj *ent.Script) ([]*model.TagMap, error)
}
type ServerTaskResolver interface {
	ID(ctx context.Context, obj *ent.ServerTask) (string, error)
	Type(ctx context.Context, obj *ent.ServerTask) (model.ServerTaskType, error)
}
type StatusResolver interface {
	ID(ctx context.Context, obj *ent.Status) (string, error)
	State(ctx context.Context, obj *ent.Status) (model.ProvisionStatus, error)
	StatusFor(ctx context.Context, obj *ent.Status) (model.ProvisionStatusFor, error)
	StartedAt(ctx context.Context, obj *ent.Status) (string, error)
	EndedAt(ctx context.Context, obj *ent.Status) (string, error)
}
type SubscriptionResolver interface {
	UpdatedAgentStatus(ctx context.Context) (<-chan *ent.AgentStatus, error)
	UpdatedStatus(ctx context.Context) (<-chan *ent.Status, error)
	UpdatedServerTask(ctx context.Context) (<-chan *ent.ServerTask, error)
	UpdatedBuild(ctx context.Context) (<-chan *ent.Build, error)
	UpdatedCommit(ctx context.Context) (<-chan *ent.BuildCommit, error)
	UpdatedAgentTask(ctx context.Context) (<-chan *ent.AgentTask, error)
	StreamServerTaskLog(ctx context.Context, taskID string) (<-chan string, error)
}
type TagResolver interface {
	ID(ctx context.Context, obj *ent.Tag) (string, error)
	UUID(ctx context.Context, obj *ent.Tag) (string, error)

	Description(ctx context.Context, obj *ent.Tag) ([]*model.TagMap, error)
}
type TeamResolver interface {
	ID(ctx context.Context, obj *ent.Team) (string, error)
}
type UserResolver interface {
	ID(ctx context.Context, obj *ent.User) (string, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "AdhocPlan.AgentTask":
		if e.complexity.AdhocPlan.AgentTask == nil {
			break
		}

		return e.complexity.AdhocPlan.AgentTask(childComplexity), true

	case "AdhocPlan.Build":
		if e.complexity.AdhocPlan.Build == nil {
			break
		}

		return e.complexity.AdhocPlan.Build(childComplexity), true

	case "AdhocPlan.id":
		if e.complexity.AdhocPlan.ID == nil {
			break
		}

		return e.complexity.AdhocPlan.ID(childComplexity), true

	case "AdhocPlan.NextAdhocPlans":
		if e.complexity.AdhocPlan.NextAdhocPlans == nil {
			break
		}

		return e.complexity.AdhocPlan.NextAdhocPlans(childComplexity), true

	case "AdhocPlan.PrevAdhocPlans":
		if e.complexity.AdhocPlan.PrevAdhocPlans == nil {
			break
		}

		return e.complexity.AdhocPlan.PrevAdhocPlans(childComplexity), true

	case "AdhocPlan.Status":
		if e.complexity.AdhocPlan.Status == nil {
			break
		}

		return e.complexity.AdhocPlan.Status(childComplexity), true

	case "AgentStatus.bootTime":
		if e.complexity.AgentStatus.BootTime == nil {
			break
		}

		return e.complexity.AgentStatus.BootTime(childComplexity), true

	case "AgentStatus.Build":
		if e.complexity.AgentStatus.Build == nil {
			break
		}

		return e.complexity.AgentStatus.Build(childComplexity), true

	case "AgentStatus.clientId":
		if e.complexity.AgentStatus.ClientID == nil {
			break
		}

		return e.complexity.AgentStatus.ClientID(childComplexity), true

	case "AgentStatus.freeMem":
		if e.complexity.AgentStatus.FreeMem == nil {
			break
		}

		return e.complexity.AgentStatus.FreeMem(childComplexity), true

	case "AgentStatus.hostID":
		if e.complexity.AgentStatus.HostID == nil {
			break
		}

		return e.complexity.AgentStatus.HostID(childComplexity), true

	case "AgentStatus.hostname":
		if e.complexity.AgentStatus.Hostname == nil {
			break
		}

		return e.complexity.AgentStatus.Hostname(childComplexity), true

	case "AgentStatus.load1":
		if e.complexity.AgentStatus.Load1 == nil {
			break
		}

		return e.complexity.AgentStatus.Load1(childComplexity), true

	case "AgentStatus.load15":
		if e.complexity.AgentStatus.Load15 == nil {
			break
		}

		return e.complexity.AgentStatus.Load15(childComplexity), true

	case "AgentStatus.load5":
		if e.complexity.AgentStatus.Load5 == nil {
			break
		}

		return e.complexity.AgentStatus.Load5(childComplexity), true

	case "AgentStatus.numProcs":
		if e.complexity.AgentStatus.NumProcs == nil {
			break
		}

		return e.complexity.AgentStatus.NumProcs(childComplexity), true

	case "AgentStatus.OS":
		if e.complexity.AgentStatus.Os == nil {
			break
		}

		return e.complexity.AgentStatus.Os(childComplexity), true

	case "AgentStatus.ProvisionedHost":
		if e.complexity.AgentStatus.ProvisionedHost == nil {
			break
		}

		return e.complexity.AgentStatus.ProvisionedHost(childComplexity), true

	case "AgentStatus.ProvisionedNetwork":
		if e.complexity.AgentStatus.ProvisionedNetwork == nil {
			break
		}

		return e.complexity.AgentStatus.ProvisionedNetwork(childComplexity), true

	case "AgentStatus.timestamp":
		if e.complexity.AgentStatus.Timestamp == nil {
			break
		}

		return e.complexity.AgentStatus.Timestamp(childComplexity), true

	case "AgentStatus.totalMem":
		if e.complexity.AgentStatus.TotalMem == nil {
			break
		}

		return e.complexity.AgentStatus.TotalMem(childComplexity), true

	case "AgentStatus.upTime":
		if e.complexity.AgentStatus.UpTime == nil {
			break
		}

		return e.complexity.AgentStatus.UpTime(childComplexity), true

	case "AgentStatus.usedMem":
		if e.complexity.AgentStatus.UsedMem == nil {
			break
		}

		return e.complexity.AgentStatus.UsedMem(childComplexity), true

	case "AgentStatusBatch.agentStatuses":
		if e.complexity.AgentStatusBatch.AgentStatuses == nil {
			break
		}

		return e.complexity.AgentStatusBatch.AgentStatuses(childComplexity), true

	case "AgentStatusBatch.pageInfo":
		if e.complexity.AgentStatusBatch.PageInfo == nil {
			break
		}

		return e.complexity.AgentStatusBatch.PageInfo(childComplexity), true

	case "AgentTask.AdhocPlans":
		if e.complexity.AgentTask.AdhocPlans == nil {
			break
		}

		return e.complexity.AgentTask.AdhocPlans(childComplexity), true

	case "AgentTask.args":
		if e.complexity.AgentTask.Args == nil {
			break
		}

		return e.complexity.AgentTask.Args(childComplexity), true

	case "AgentTask.command":
		if e.complexity.AgentTask.Command == nil {
			break
		}

		return e.complexity.AgentTask.Command(childComplexity), true

	case "AgentTask.errorMessage":
		if e.complexity.AgentTask.ErrorMessage == nil {
			break
		}

		return e.complexity.AgentTask.ErrorMessage(childComplexity), true

	case "AgentTask.id":
		if e.complexity.AgentTask.ID == nil {
			break
		}

		return e.complexity.AgentTask.ID(childComplexity), true

	case "AgentTask.number":
		if e.complexity.AgentTask.Number == nil {
			break
		}

		return e.complexity.AgentTask.Number(childComplexity), true

	case "AgentTask.output":
		if e.complexity.AgentTask.Output == nil {
			break
		}

		return e.complexity.AgentTask.Output(childComplexity), true

	case "AgentTask.ProvisionedHost":
		if e.complexity.AgentTask.ProvisionedHost == nil {
			break
		}

		return e.complexity.AgentTask.ProvisionedHost(childComplexity), true

	case "AgentTask.ProvisioningScheduledStep":
		if e.complexity.AgentTask.ProvisioningScheduledStep == nil {
			break
		}

		return e.complexity.AgentTask.ProvisioningScheduledStep(childComplexity), true

	case "AgentTask.ProvisioningStep":
		if e.complexity.AgentTask.ProvisioningStep == nil {
			break
		}

		return e.complexity.AgentTask.ProvisioningStep(childComplexity), true

	case "AgentTask.state":
		if e.complexity.AgentTask.State == nil {
			break
		}

		return e.complexity.AgentTask.State(childComplexity), true

	case "Ansible.absPath":
		if e.complexity.Ansible.AbsPath == nil {
			break
		}

		return e.complexity.Ansible.AbsPath(childComplexity), true

	case "Ansible.description":
		if e.complexity.Ansible.Description == nil {
			break
		}

		return e.complexity.Ansible.Description(childComplexity), true

	case "Ansible.Environment":
		if e.complexity.Ansible.Environment == nil {
			break
		}

		return e.complexity.Ansible.Environment(childComplexity), true

	case "Ansible.hclId":
		if e.complexity.Ansible.HclID == nil {
			break
		}

		return e.complexity.Ansible.HclID(childComplexity), true

	case "Ansible.id":
		if e.complexity.Ansible.ID == nil {
			break
		}

		return e.complexity.Ansible.ID(childComplexity), true

	case "Ansible.inventory":
		if e.complexity.Ansible.Inventory == nil {
			break
		}

		return e.complexity.Ansible.Inventory(childComplexity), true

	case "Ansible.method":
		if e.complexity.Ansible.Method == nil {
			break
		}

		return e.complexity.Ansible.Method(childComplexity), true

	case "Ansible.name":
		if e.complexity.Ansible.Name == nil {
			break
		}

		return e.complexity.Ansible.Name(childComplexity), true

	case "Ansible.playbookName":
		if e.complexity.Ansible.PlaybookName == nil {
			break
		}

		return e.complexity.Ansible.PlaybookName(childComplexity), true

	case "Ansible.source":
		if e.complexity.Ansible.Source == nil {
			break
		}

		return e.complexity.Ansible.Source(childComplexity), true

	case "Ansible.tags":
		if e.complexity.Ansible.Tags == nil {
			break
		}

		return e.complexity.Ansible.Tags(childComplexity), true

	case "Ansible.Users":
		if e.complexity.Ansible.Users == nil {
			break
		}

		return e.complexity.Ansible.Users(childComplexity), true

	case "AuthUser.company":
		if e.complexity.AuthUser.Company == nil {
			break
		}

		return e.complexity.AuthUser.Company(childComplexity), true

	case "AuthUser.email":
		if e.complexity.AuthUser.Email == nil {
			break
		}

		return e.complexity.AuthUser.Email(childComplexity), true

	case "AuthUser.firstName":
		if e.complexity.AuthUser.FirstName == nil {
			break
		}

		return e.complexity.AuthUser.FirstName(childComplexity), true

	case "AuthUser.id":
		if e.complexity.AuthUser.ID == nil {
			break
		}

		return e.complexity.AuthUser.ID(childComplexity), true

	case "AuthUser.lastName":
		if e.complexity.AuthUser.LastName == nil {
			break
		}

		return e.complexity.AuthUser.LastName(childComplexity), true

	case "AuthUser.occupation":
		if e.complexity.AuthUser.Occupation == nil {
			break
		}

		return e.complexity.AuthUser.Occupation(childComplexity), true

	case "AuthUser.phone":
		if e.complexity.AuthUser.Phone == nil {
			break
		}

		return e.complexity.AuthUser.Phone(childComplexity), true

	case "AuthUser.provider":
		if e.complexity.AuthUser.Provider == nil {
			break
		}

		return e.complexity.AuthUser.Provider(childComplexity), true

	case "AuthUser.publicKey":
		if e.complexity.AuthUser.PublicKey == nil {
			break
		}

		return e.complexity.AuthUser.PublicKey(childComplexity), true

	case "AuthUser.role":
		if e.complexity.AuthUser.Role == nil {
			break
		}

		return e.complexity.AuthUser.Role(childComplexity), true

	case "AuthUser.ServerTasks":
		if e.complexity.AuthUser.ServerTasks == nil {
			break
		}

		return e.complexity.AuthUser.ServerTasks(childComplexity), true

	case "AuthUser.username":
		if e.complexity.AuthUser.Username == nil {
			break
		}

		return e.complexity.AuthUser.Username(childComplexity), true

	case "Build.AdhocPlans":
		if e.complexity.Build.AdhocPlans == nil {
			break
		}

		return e.complexity.Build.AdhocPlans(childComplexity), true

	case "Build.AgentStatuses":
		if e.complexity.Build.AgentStatuses == nil {
			break
		}

		return e.complexity.Build.AgentStatuses(childComplexity), true

	case "Build.BuildCommits":
		if e.complexity.Build.BuildCommits == nil {
			break
		}

		return e.complexity.Build.BuildCommits(childComplexity), true

	case "Build.Competition":
		if e.complexity.Build.Competition == nil {
			break
		}

		return e.complexity.Build.Competition(childComplexity), true

	case "Build.completedPlan":
		if e.complexity.Build.CompletedPlan == nil {
			break
		}

		return e.complexity.Build.CompletedPlan(childComplexity), true

	case "Build.Environment":
		if e.complexity.Build.Environment == nil {
			break
		}

		return e.complexity.Build.Environment(childComplexity), true

	case "Build.environmentRevision":
		if e.complexity.Build.EnvironmentRevision == nil {
			break
		}

		return e.complexity.Build.EnvironmentRevision(childComplexity), true

	case "Build.id":
		if e.complexity.Build.ID == nil {
			break
		}

		return e.complexity.Build.ID(childComplexity), true

	case "Build.LatestBuildCommit":
		if e.complexity.Build.LatestBuildCommit == nil {
			break
		}

		return e.complexity.Build.LatestBuildCommit(childComplexity), true

	case "Build.Plans":
		if e.complexity.Build.Plans == nil {
			break
		}

		return e.complexity.Build.Plans(childComplexity), true

	case "Build.ProvisionedNetworks":
		if e.complexity.Build.ProvisionedNetworks == nil {
			break
		}

		return e.complexity.Build.ProvisionedNetworks(childComplexity), true

	case "Build.RepoCommit":
		if e.complexity.Build.RepoCommit == nil {
			break
		}

		return e.complexity.Build.RepoCommit(childComplexity), true

	case "Build.revision":
		if e.complexity.Build.Revision == nil {
			break
		}

		return e.complexity.Build.Revision(childComplexity), true

	case "Build.ServerTasks":
		if e.complexity.Build.ServerTasks == nil {
			break
		}

		return e.complexity.Build.ServerTasks(childComplexity), true

	case "Build.Status":
		if e.complexity.Build.Status == nil {
			break
		}

		return e.complexity.Build.Status(childComplexity), true

	case "Build.Teams":
		if e.complexity.Build.Teams == nil {
			break
		}

		return e.complexity.Build.Teams(childComplexity), true

	case "BuildCommit.Build":
		if e.complexity.BuildCommit.Build == nil {
			break
		}

		return e.complexity.BuildCommit.Build(childComplexity), true

	case "BuildCommit.createdAt":
		if e.complexity.BuildCommit.CreatedAt == nil {
			break
		}

		return e.complexity.BuildCommit.CreatedAt(childComplexity), true

	case "BuildCommit.id":
		if e.complexity.BuildCommit.ID == nil {
			break
		}

		return e.complexity.BuildCommit.ID(childComplexity), true

	case "BuildCommit.PlanDiffs":
		if e.complexity.BuildCommit.PlanDiffs == nil {
			break
		}

		return e.complexity.BuildCommit.PlanDiffs(childComplexity), true

	case "BuildCommit.revision":
		if e.complexity.BuildCommit.Revision == nil {
			break
		}

		return e.complexity.BuildCommit.Revision(childComplexity), true

	case "BuildCommit.ServerTasks":
		if e.complexity.BuildCommit.ServerTasks == nil {
			break
		}

		return e.complexity.BuildCommit.ServerTasks(childComplexity), true

	case "BuildCommit.state":
		if e.complexity.BuildCommit.State == nil {
			break
		}

		return e.complexity.BuildCommit.State(childComplexity), true

	case "BuildCommit.type":
		if e.complexity.BuildCommit.Type == nil {
			break
		}

		return e.complexity.BuildCommit.Type(childComplexity), true

	case "Command.args":
		if e.complexity.Command.Args == nil {
			break
		}

		return e.complexity.Command.Args(childComplexity), true

	case "Command.cooldown":
		if e.complexity.Command.Cooldown == nil {
			break
		}

		return e.complexity.Command.Cooldown(childComplexity), true

	case "Command.description":
		if e.complexity.Command.Description == nil {
			break
		}

		return e.complexity.Command.Description(childComplexity), true

	case "Command.disabled":
		if e.complexity.Command.Disabled == nil {
			break
		}

		return e.complexity.Command.Disabled(childComplexity), true

	case "Command.Environment":
		if e.complexity.Command.Environment == nil {
			break
		}

		return e.complexity.Command.Environment(childComplexity), true

	case "Command.hclId":
		if e.complexity.Command.HclID == nil {
			break
		}

		return e.complexity.Command.HclID(childComplexity), true

	case "Command.id":
		if e.complexity.Command.ID == nil {
			break
		}

		return e.complexity.Command.ID(childComplexity), true

	case "Command.ignoreErrors":
		if e.complexity.Command.IgnoreErrors == nil {
			break
		}

		return e.complexity.Command.IgnoreErrors(childComplexity), true

	case "Command.name":
		if e.complexity.Command.Name == nil {
			break
		}

		return e.complexity.Command.Name(childComplexity), true

	case "Command.program":
		if e.complexity.Command.Program == nil {
			break
		}

		return e.complexity.Command.Program(childComplexity), true

	case "Command.tags":
		if e.complexity.Command.Tags == nil {
			break
		}

		return e.complexity.Command.Tags(childComplexity), true

	case "Command.timeout":
		if e.complexity.Command.Timeout == nil {
			break
		}

		return e.complexity.Command.Timeout(childComplexity), true

	case "Command.Users":
		if e.complexity.Command.Users == nil {
			break
		}

		return e.complexity.Command.Users(childComplexity), true

	case "Command.vars":
		if e.complexity.Command.Vars == nil {
			break
		}

		return e.complexity.Command.Vars(childComplexity), true

	case "Competition.Builds":
		if e.complexity.Competition.Builds == nil {
			break
		}

		return e.complexity.Competition.Builds(childComplexity), true

	case "Competition.config":
		if e.complexity.Competition.Config == nil {
			break
		}

		return e.complexity.Competition.Config(childComplexity), true

	case "Competition.DNS":
		if e.complexity.Competition.DNS == nil {
			break
		}

		return e.complexity.Competition.DNS(childComplexity), true

	case "Competition.Environment":
		if e.complexity.Competition.Environment == nil {
			break
		}

		return e.complexity.Competition.Environment(childComplexity), true

	case "Competition.hclId":
		if e.complexity.Competition.HclID == nil {
			break
		}

		return e.complexity.Competition.HclID(childComplexity), true

	case "Competition.id":
		if e.complexity.Competition.ID == nil {
			break
		}

		return e.complexity.Competition.ID(childComplexity), true

	case "Competition.rootPassword":
		if e.complexity.Competition.RootPassword == nil {
			break
		}

		return e.complexity.Competition.RootPassword(childComplexity), true

	case "Competition.startTime":
		if e.complexity.Competition.StartTime == nil {
			break
		}

		return e.complexity.Competition.StartTime(childComplexity), true

	case "Competition.stopTime":
		if e.complexity.Competition.StopTime == nil {
			break
		}

		return e.complexity.Competition.StopTime(childComplexity), true

	case "Competition.tags":
		if e.complexity.Competition.Tags == nil {
			break
		}

		return e.complexity.Competition.Tags(childComplexity), true

	case "DNS.Competitions":
		if e.complexity.DNS.Competitions == nil {
			break
		}

		return e.complexity.DNS.Competitions(childComplexity), true

	case "DNS.config":
		if e.complexity.DNS.Config == nil {
			break
		}

		return e.complexity.DNS.Config(childComplexity), true

	case "DNS.dnsServers":
		if e.complexity.DNS.DNSServers == nil {
			break
		}

		return e.complexity.DNS.DNSServers(childComplexity), true

	case "DNS.Environments":
		if e.complexity.DNS.Environments == nil {
			break
		}

		return e.complexity.DNS.Environments(childComplexity), true

	case "DNS.hclId":
		if e.complexity.DNS.HclID == nil {
			break
		}

		return e.complexity.DNS.HclID(childComplexity), true

	case "DNS.id":
		if e.complexity.DNS.ID == nil {
			break
		}

		return e.complexity.DNS.ID(childComplexity), true

	case "DNS.ntpServers":
		if e.complexity.DNS.NtpServers == nil {
			break
		}

		return e.complexity.DNS.NtpServers(childComplexity), true

	case "DNS.rootDomain":
		if e.complexity.DNS.RootDomain == nil {
			break
		}

		return e.complexity.DNS.RootDomain(childComplexity), true

	case "DNS.type":
		if e.complexity.DNS.Type == nil {
			break
		}

		return e.complexity.DNS.Type(childComplexity), true

	case "DNSRecord.disabled":
		if e.complexity.DNSRecord.Disabled == nil {
			break
		}

		return e.complexity.DNSRecord.Disabled(childComplexity), true

	case "DNSRecord.Environment":
		if e.complexity.DNSRecord.Environment == nil {
			break
		}

		return e.complexity.DNSRecord.Environment(childComplexity), true

	case "DNSRecord.hclId":
		if e.complexity.DNSRecord.HclID == nil {
			break
		}

		return e.complexity.DNSRecord.HclID(childComplexity), true

	case "DNSRecord.id":
		if e.complexity.DNSRecord.ID == nil {
			break
		}

		return e.complexity.DNSRecord.ID(childComplexity), true

	case "DNSRecord.name":
		if e.complexity.DNSRecord.Name == nil {
			break
		}

		return e.complexity.DNSRecord.Name(childComplexity), true

	case "DNSRecord.tags":
		if e.complexity.DNSRecord.Tags == nil {
			break
		}

		return e.complexity.DNSRecord.Tags(childComplexity), true

	case "DNSRecord.type":
		if e.complexity.DNSRecord.Type == nil {
			break
		}

		return e.complexity.DNSRecord.Type(childComplexity), true

	case "DNSRecord.values":
		if e.complexity.DNSRecord.Values == nil {
			break
		}

		return e.complexity.DNSRecord.Values(childComplexity), true

	case "DNSRecord.vars":
		if e.complexity.DNSRecord.Vars == nil {
			break
		}

		return e.complexity.DNSRecord.Vars(childComplexity), true

	case "DNSRecord.zone":
		if e.complexity.DNSRecord.Zone == nil {
			break
		}

		return e.complexity.DNSRecord.Zone(childComplexity), true

	case "Disk.Host":
		if e.complexity.Disk.Host == nil {
			break
		}

		return e.complexity.Disk.Host(childComplexity), true

	case "Disk.id":
		if e.complexity.Disk.ID == nil {
			break
		}

		return e.complexity.Disk.ID(childComplexity), true

	case "Disk.size":
		if e.complexity.Disk.Size == nil {
			break
		}

		return e.complexity.Disk.Size(childComplexity), true

	case "Environment.adminCidrs":
		if e.complexity.Environment.AdminCidrs == nil {
			break
		}

		return e.complexity.Environment.AdminCidrs(childComplexity), true

	case "Environment.Ansibles":
		if e.complexity.Environment.Ansibles == nil {
			break
		}

		return e.complexity.Environment.Ansibles(childComplexity), true

	case "Environment.builder":
		if e.complexity.Environment.Builder == nil {
			break
		}

		return e.complexity.Environment.Builder(childComplexity), true

	case "Environment.Builds":
		if e.complexity.Environment.Builds == nil {
			break
		}

		return e.complexity.Environment.Builds(childComplexity), true

	case "Environment.Commands":
		if e.complexity.Environment.Commands == nil {
			break
		}

		return e.complexity.Environment.Commands(childComplexity), true

	case "Environment.competitionId":
		if e.complexity.Environment.CompetitionID == nil {
			break
		}

		return e.complexity.Environment.CompetitionID(childComplexity), true

	case "Environment.Competitions":
		if e.complexity.Environment.Competitions == nil {
			break
		}

		return e.complexity.Environment.Competitions(childComplexity), true

	case "Environment.config":
		if e.complexity.Environment.Config == nil {
			break
		}

		return e.complexity.Environment.Config(childComplexity), true

	case "Environment.DNS":
		if e.complexity.Environment.DNS == nil {
			break
		}

		return e.complexity.Environment.DNS(childComplexity), true

	case "Environment.DNSRecords":
		if e.complexity.Environment.DNSRecords == nil {
			break
		}

		return e.complexity.Environment.DNSRecords(childComplexity), true

	case "Environment.description":
		if e.complexity.Environment.Description == nil {
			break
		}

		return e.complexity.Environment.Description(childComplexity), true

	case "Environment.exposedVdiPorts":
		if e.complexity.Environment.ExposedVdiPorts == nil {
			break
		}

		return e.complexity.Environment.ExposedVdiPorts(childComplexity), true

	case "Environment.FileDeletes":
		if e.complexity.Environment.FileDeletes == nil {
			break
		}

		return e.complexity.Environment.FileDeletes(childComplexity), true

	case "Environment.FileDownloads":
		if e.complexity.Environment.FileDownloads == nil {
			break
		}

		return e.complexity.Environment.FileDownloads(childComplexity), true

	case "Environment.FileExtracts":
		if e.complexity.Environment.FileExtracts == nil {
			break
		}

		return e.complexity.Environment.FileExtracts(childComplexity), true

	case "Environment.Findings":
		if e.complexity.Environment.Findings == nil {
			break
		}

		return e.complexity.Environment.Findings(childComplexity), true

	case "Environment.hclId":
		if e.complexity.Environment.HclID == nil {
			break
		}

		return e.complexity.Environment.HclID(childComplexity), true

	case "Environment.HostDependencies":
		if e.complexity.Environment.HostDependencies == nil {
			break
		}

		return e.complexity.Environment.HostDependencies(childComplexity), true

	case "Environment.Hosts":
		if e.complexity.Environment.Hosts == nil {
			break
		}

		return e.complexity.Environment.Hosts(childComplexity), true

	case "Environment.id":
		if e.complexity.Environment.ID == nil {
			break
		}

		return e.complexity.Environment.ID(childComplexity), true

	case "Environment.Identities":
		if e.complexity.Environment.Identities == nil {
			break
		}

		return e.complexity.Environment.Identities(childComplexity), true

	case "Environment.IncludedNetworks":
		if e.complexity.Environment.IncludedNetworks == nil {
			break
		}

		return e.complexity.Environment.IncludedNetworks(childComplexity), true

	case "Environment.name":
		if e.complexity.Environment.Name == nil {
			break
		}

		return e.complexity.Environment.Name(childComplexity), true

	case "Environment.Networks":
		if e.complexity.Environment.Networks == nil {
			break
		}

		return e.complexity.Environment.Networks(childComplexity), true

	case "Environment.Repositories":
		if e.complexity.Environment.Repositories == nil {
			break
		}

		return e.complexity.Environment.Repositories(childComplexity), true

	case "Environment.revision":
		if e.complexity.Environment.Revision == nil {
			break
		}

		return e.complexity.Environment.Revision(childComplexity), true

	case "Environment.ScheduledSteps":
		if e.complexity.Environment.ScheduledSteps == nil {
			break
		}

		return e.complexity.Environment.ScheduledSteps(childComplexity), true

	case "Environment.Scripts":
		if e.complexity.Environment.Scripts == nil {
			break
		}

		return e.complexity.Environment.Scripts(childComplexity), true

	case "Environment.ServerTasks":
		if e.complexity.Environment.ServerTasks == nil {
			break
		}

		return e.complexity.Environment.ServerTasks(childComplexity), true

	case "Environment.tags":
		if e.complexity.Environment.Tags == nil {
			break
		}

		return e.complexity.Environment.Tags(childComplexity), true

	case "Environment.teamCount":
		if e.complexity.Environment.TeamCount == nil {
			break
		}

		return e.complexity.Environment.TeamCount(childComplexity), true

	case "Environment.Users":
		if e.complexity.Environment.Users == nil {
			break
		}

		return e.complexity.Environment.Users(childComplexity), true

	case "FileDelete.Environment":
		if e.complexity.FileDelete.Environment == nil {
			break
		}

		return e.complexity.FileDelete.Environment(childComplexity), true

	case "FileDelete.hclId":
		if e.complexity.FileDelete.HclID == nil {
			break
		}

		return e.complexity.FileDelete.HclID(childComplexity), true

	case "FileDelete.id":
		if e.complexity.FileDelete.ID == nil {
			break
		}

		return e.complexity.FileDelete.ID(childComplexity), true

	case "FileDelete.path":
		if e.complexity.FileDelete.Path == nil {
			break
		}

		return e.complexity.FileDelete.Path(childComplexity), true

	case "FileDelete.tags":
		if e.complexity.FileDelete.Tags == nil {
			break
		}

		return e.complexity.FileDelete.Tags(childComplexity), true

	case "FileDownload.absPath":
		if e.complexity.FileDownload.AbsPath == nil {
			break
		}

		return e.complexity.FileDownload.AbsPath(childComplexity), true

	case "FileDownload.destination":
		if e.complexity.FileDownload.Destination == nil {
			break
		}

		return e.complexity.FileDownload.Destination(childComplexity), true

	case "FileDownload.disabled":
		if e.complexity.FileDownload.Disabled == nil {
			break
		}

		return e.complexity.FileDownload.Disabled(childComplexity), true

	case "FileDownload.Environment":
		if e.complexity.FileDownload.Environment == nil {
			break
		}

		return e.complexity.FileDownload.Environment(childComplexity), true

	case "FileDownload.hclId":
		if e.complexity.FileDownload.HclID == nil {
			break
		}

		return e.complexity.FileDownload.HclID(childComplexity), true

	case "FileDownload.id":
		if e.complexity.FileDownload.ID == nil {
			break
		}

		return e.complexity.FileDownload.ID(childComplexity), true

	case "FileDownload.md5":
		if e.complexity.FileDownload.Md5 == nil {
			break
		}

		return e.complexity.FileDownload.Md5(childComplexity), true

	case "FileDownload.perms":
		if e.complexity.FileDownload.Perms == nil {
			break
		}

		return e.complexity.FileDownload.Perms(childComplexity), true

	case "FileDownload.source":
		if e.complexity.FileDownload.Source == nil {
			break
		}

		return e.complexity.FileDownload.Source(childComplexity), true

	case "FileDownload.sourceType":
		if e.complexity.FileDownload.SourceType == nil {
			break
		}

		return e.complexity.FileDownload.SourceType(childComplexity), true

	case "FileDownload.tags":
		if e.complexity.FileDownload.Tags == nil {
			break
		}

		return e.complexity.FileDownload.Tags(childComplexity), true

	case "FileDownload.template":
		if e.complexity.FileDownload.Template == nil {
			break
		}

		return e.complexity.FileDownload.Template(childComplexity), true

	case "FileExtract.destination":
		if e.complexity.FileExtract.Destination == nil {
			break
		}

		return e.complexity.FileExtract.Destination(childComplexity), true

	case "FileExtract.Environment":
		if e.complexity.FileExtract.Environment == nil {
			break
		}

		return e.complexity.FileExtract.Environment(childComplexity), true

	case "FileExtract.hclId":
		if e.complexity.FileExtract.HclID == nil {
			break
		}

		return e.complexity.FileExtract.HclID(childComplexity), true

	case "FileExtract.id":
		if e.complexity.FileExtract.ID == nil {
			break
		}

		return e.complexity.FileExtract.ID(childComplexity), true

	case "FileExtract.source":
		if e.complexity.FileExtract.Source == nil {
			break
		}

		return e.complexity.FileExtract.Source(childComplexity), true

	case "FileExtract.tags":
		if e.complexity.FileExtract.Tags == nil {
			break
		}

		return e.complexity.FileExtract.Tags(childComplexity), true

	case "FileExtract.type":
		if e.complexity.FileExtract.Type == nil {
			break
		}

		return e.complexity.FileExtract.Type(childComplexity), true

	case "Finding.description":
		if e.complexity.Finding.Description == nil {
			break
		}

		return e.complexity.Finding.Description(childComplexity), true

	case "Finding.difficulty":
		if e.complexity.Finding.Difficulty == nil {
			break
		}

		return e.complexity.Finding.Difficulty(childComplexity), true

	case "Finding.Environment":
		if e.complexity.Finding.Environment == nil {
			break
		}

		return e.complexity.Finding.Environment(childComplexity), true

	case "Finding.Host":
		if e.complexity.Finding.Host == nil {
			break
		}

		return e.complexity.Finding.Host(childComplexity), true

	case "Finding.id":
		if e.complexity.Finding.ID == nil {
			break
		}

		return e.complexity.Finding.ID(childComplexity), true

	case "Finding.name":
		if e.complexity.Finding.Name == nil {
			break
		}

		return e.complexity.Finding.Name(childComplexity), true

	case "Finding.Script":
		if e.complexity.Finding.Script == nil {
			break
		}

		return e.complexity.Finding.Script(childComplexity), true

	case "Finding.severity":
		if e.complexity.Finding.Severity == nil {
			break
		}

		return e.complexity.Finding.Severity(childComplexity), true

	case "Finding.tags":
		if e.complexity.Finding.Tags == nil {
			break
		}

		return e.complexity.Finding.Tags(childComplexity), true

	case "Finding.Users":
		if e.complexity.Finding.Users == nil {
			break
		}

		return e.complexity.Finding.Users(childComplexity), true

	case "GinFileMiddleware.accessed":
		if e.complexity.GinFileMiddleware.Accessed == nil {
			break
		}

		return e.complexity.GinFileMiddleware.Accessed(childComplexity), true

	case "GinFileMiddleware.filePath":
		if e.complexity.GinFileMiddleware.FilePath == nil {
			break
		}

		return e.complexity.GinFileMiddleware.FilePath(childComplexity), true

	case "GinFileMiddleware.id":
		if e.complexity.GinFileMiddleware.ID == nil {
			break
		}

		return e.complexity.GinFileMiddleware.ID(childComplexity), true

	case "GinFileMiddleware.ProvisionedHost":
		if e.complexity.GinFileMiddleware.ProvisionedHost == nil {
			break
		}

		return e.complexity.GinFileMiddleware.ProvisionedHost(childComplexity), true

	case "GinFileMiddleware.ProvisioningScheduledStep":
		if e.complexity.GinFileMiddleware.ProvisioningScheduledStep == nil {
			break
		}

		return e.complexity.GinFileMiddleware.ProvisioningScheduledStep(childComplexity), true

	case "GinFileMiddleware.ProvisioningStep":
		if e.complexity.GinFileMiddleware.ProvisioningStep == nil {
			break
		}

		return e.complexity.GinFileMiddleware.ProvisioningStep(childComplexity), true

	case "GinFileMiddleware.urlId":
		if e.complexity.GinFileMiddleware.URLID == nil {
			break
		}

		return e.complexity.GinFileMiddleware.URLID(childComplexity), true

	case "Host.allowMacChanges":
		if e.complexity.Host.AllowMACChanges == nil {
			break
		}

		return e.complexity.Host.AllowMACChanges(childComplexity), true

	case "Host.DependOnHostDependencies":
		if e.complexity.Host.DependOnHostDependencies == nil {
			break
		}

		return e.complexity.Host.DependOnHostDependencies(childComplexity), true

	case "Host.description":
		if e.complexity.Host.Description == nil {
			break
		}

		return e.complexity.Host.Description(childComplexity), true

	case "Host.Disk":
		if e.complexity.Host.Disk == nil {
			break
		}

		return e.complexity.Host.Disk(childComplexity), true

	case "Host.Environment":
		if e.complexity.Host.Environment == nil {
			break
		}

		return e.complexity.Host.Environment(childComplexity), true

	case "Host.exposedTcpPorts":
		if e.complexity.Host.ExposedTCPPorts == nil {
			break
		}

		return e.complexity.Host.ExposedTCPPorts(childComplexity), true

	case "Host.exposedUdpPorts":
		if e.complexity.Host.ExposedUDPPorts == nil {
			break
		}

		return e.complexity.Host.ExposedUDPPorts(childComplexity), true

	case "Host.hclId":
		if e.complexity.Host.HclID == nil {
			break
		}

		return e.complexity.Host.HclID(childComplexity), true

	case "Host.hostname":
		if e.complexity.Host.Hostname == nil {
			break
		}

		return e.complexity.Host.Hostname(childComplexity), true

	case "Host.id":
		if e.complexity.Host.ID == nil {
			break
		}

		return e.complexity.Host.ID(childComplexity), true

	case "Host.IncludedNetworks":
		if e.complexity.Host.IncludedNetworks == nil {
			break
		}

		return e.complexity.Host.IncludedNetworks(childComplexity), true

	case "Host.instanceSize":
		if e.complexity.Host.InstanceSize == nil {
			break
		}

		return e.complexity.Host.InstanceSize(childComplexity), true

	case "Host.lastOctet":
		if e.complexity.Host.LastOctet == nil {
			break
		}

		return e.complexity.Host.LastOctet(childComplexity), true

	case "Host.OS":
		if e.complexity.Host.OS == nil {
			break
		}

		return e.complexity.Host.OS(childComplexity), true

	case "Host.overridePassword":
		if e.complexity.Host.OverridePassword == nil {
			break
		}

		return e.complexity.Host.OverridePassword(childComplexity), true

	case "Host.provisionSteps":
		if e.complexity.Host.ProvisionSteps == nil {
			break
		}

		return e.complexity.Host.ProvisionSteps(childComplexity), true

	case "Host.RequiredByHostDependencies":
		if e.complexity.Host.RequiredByHostDependencies == nil {
			break
		}

		return e.complexity.Host.RequiredByHostDependencies(childComplexity), true

	case "Host.tags":
		if e.complexity.Host.Tags == nil {
			break
		}

		return e.complexity.Host.Tags(childComplexity), true

	case "Host.userGroups":
		if e.complexity.Host.UserGroups == nil {
			break
		}

		return e.complexity.Host.UserGroups(childComplexity), true

	case "Host.Users":
		if e.complexity.Host.Users == nil {
			break
		}

		return e.complexity.Host.Users(childComplexity), true

	case "Host.vars":
		if e.complexity.Host.Vars == nil {
			break
		}

		return e.complexity.Host.Vars(childComplexity), true

	case "HostDependency.DependOnHost":
		if e.complexity.HostDependency.DependOnHost == nil {
			break
		}

		return e.complexity.HostDependency.DependOnHost(childComplexity), true

	case "HostDependency.DependOnNetwork":
		if e.complexity.HostDependency.DependOnNetwork == nil {
			break
		}

		return e.complexity.HostDependency.DependOnNetwork(childComplexity), true

	case "HostDependency.Environment":
		if e.complexity.HostDependency.Environment == nil {
			break
		}

		return e.complexity.HostDependency.Environment(childComplexity), true

	case "HostDependency.hostId":
		if e.complexity.HostDependency.HostID == nil {
			break
		}

		return e.complexity.HostDependency.HostID(childComplexity), true

	case "HostDependency.id":
		if e.complexity.HostDependency.ID == nil {
			break
		}

		return e.complexity.HostDependency.ID(childComplexity), true

	case "HostDependency.networkId":
		if e.complexity.HostDependency.NetworkID == nil {
			break
		}

		return e.complexity.HostDependency.NetworkID(childComplexity), true

	case "HostDependency.RequiredBy":
		if e.complexity.HostDependency.RequiredBy == nil {
			break
		}

		return e.complexity.HostDependency.RequiredBy(childComplexity), true

	case "Identity.avatarFile":
		if e.complexity.Identity.AvatarFile == nil {
			break
		}

		return e.complexity.Identity.AvatarFile(childComplexity), true

	case "Identity.description":
		if e.complexity.Identity.Description == nil {
			break
		}

		return e.complexity.Identity.Description(childComplexity), true

	case "Identity.email":
		if e.complexity.Identity.Email == nil {
			break
		}

		return e.complexity.Identity.Email(childComplexity), true

	case "Identity.Environment":
		if e.complexity.Identity.Environment == nil {
			break
		}

		return e.complexity.Identity.Environment(childComplexity), true

	case "Identity.firstName":
		if e.complexity.Identity.FirstName == nil {
			break
		}

		return e.complexity.Identity.FirstName(childComplexity), true

	case "Identity.hclid":
		if e.complexity.Identity.HclID == nil {
			break
		}

		return e.complexity.Identity.HclID(childComplexity), true

	case "Identity.id":
		if e.complexity.Identity.ID == nil {
			break
		}

		return e.complexity.Identity.ID(childComplexity), true

	case "Identity.lastName":
		if e.complexity.Identity.LastName == nil {
			break
		}

		return e.complexity.Identity.LastName(childComplexity), true

	case "Identity.password":
		if e.complexity.Identity.Password == nil {
			break
		}

		return e.complexity.Identity.Password(childComplexity), true

	case "Identity.tags":
		if e.complexity.Identity.Tags == nil {
			break
		}

		return e.complexity.Identity.Tags(childComplexity), true

	case "Identity.vars":
		if e.complexity.Identity.Vars == nil {
			break
		}

		return e.complexity.Identity.Vars(childComplexity), true

	case "IncludedNetwork.Environments":
		if e.complexity.IncludedNetwork.Environments == nil {
			break
		}

		return e.complexity.IncludedNetwork.Environments(childComplexity), true

	case "IncludedNetwork.Hosts":
		if e.complexity.IncludedNetwork.Hosts == nil {
			break
		}

		return e.complexity.IncludedNetwork.Hosts(childComplexity), true

	case "IncludedNetwork.id":
		if e.complexity.IncludedNetwork.ID == nil {
			break
		}

		return e.complexity.IncludedNetwork.ID(childComplexity), true

	case "IncludedNetwork.includedHosts":
		if e.complexity.IncludedNetwork.IncludedHosts == nil {
			break
		}

		return e.complexity.IncludedNetwork.IncludedHosts(childComplexity), true

	case "IncludedNetwork.name":
		if e.complexity.IncludedNetwork.Name == nil {
			break
		}

		return e.complexity.IncludedNetwork.Name(childComplexity), true

	case "IncludedNetwork.Network":
		if e.complexity.IncludedNetwork.Network == nil {
			break
		}

		return e.complexity.IncludedNetwork.Network(childComplexity), true

	case "IncludedNetwork.Tags":
		if e.complexity.IncludedNetwork.Tags == nil {
			break
		}

		return e.complexity.IncludedNetwork.Tags(childComplexity), true

	case "LaForgePageInfo.nextOffset":
		if e.complexity.LaForgePageInfo.NextOffset == nil {
			break
		}

		return e.complexity.LaForgePageInfo.NextOffset(childComplexity), true

	case "LaForgePageInfo.total":
		if e.complexity.LaForgePageInfo.Total == nil {
			break
		}

		return e.complexity.LaForgePageInfo.Total(childComplexity), true

	case "Mutation.approveCommit":
		if e.complexity.Mutation.ApproveCommit == nil {
			break
		}

		args, err := ec.field_Mutation_approveCommit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ApproveCommit(childComplexity, args["commitUUID"].(string)), true

	case "Mutation.cancelBuild":
		if e.complexity.Mutation.CancelBuild == nil {
			break
		}

		args, err := ec.field_Mutation_cancelBuild_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelBuild(childComplexity, args["buildUUID"].(string)), true

	case "Mutation.cancelCommit":
		if e.complexity.Mutation.CancelCommit == nil {
			break
		}

		args, err := ec.field_Mutation_cancelCommit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelCommit(childComplexity, args["commitUUID"].(string)), true

	case "Mutation.createAgentTasks":
		if e.complexity.Mutation.CreateAgentTasks == nil {
			break
		}

		args, err := ec.field_Mutation_createAgentTasks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateAgentTasks(childComplexity, args["hostHCLID"].(string), args["command"].(model.AgentCommand), args["buildUUID"].(string), args["args"].([]string), args["teams"].([]int)), true

	case "Mutation.createBatchAgentTasks":
		if e.complexity.Mutation.CreateBatchAgentTasks == nil {
			break
		}

		args, err := ec.field_Mutation_createBatchAgentTasks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateBatchAgentTasks(childComplexity, args["proHostUUIDs"].([]string), args["command"].(model.AgentCommand), args["args"].([]string)), true

	case "Mutation.createBuild":
		if e.complexity.Mutation.CreateBuild == nil {
			break
		}

		args, err := ec.field_Mutation_createBuild_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateBuild(childComplexity, args["envUUID"].(string), args["renderFiles"].(bool)), true

	case "Mutation.createEnviromentFromRepo":
		if e.complexity.Mutation.CreateEnviromentFromRepo == nil {
			break
		}

		args, err := ec.field_Mutation_createEnviromentFromRepo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateEnviromentFromRepo(childComplexity, args["repoURL"].(string), args["branchName"].(string), args["envFilePath"].(string)), true

	case "Mutation.createTask":
		if e.complexity.Mutation.CreateTask == nil {
			break
		}

		args, err := ec.field_Mutation_createTask_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTask(childComplexity, args["proHostUUID"].(string), args["command"].(model.AgentCommand), args["args"].(string)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["username"].(string), args["password"].(string), args["role"].(model.RoleLevel), args["provider"].(model.ProviderType)), true

	case "Mutation.deleteBuild":
		if e.complexity.Mutation.DeleteBuild == nil {
			break
		}

		args, err := ec.field_Mutation_deleteBuild_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteBuild(childComplexity, args["buildUUID"].(string)), true

	case "Mutation.deleteUser":
		if e.complexity.Mutation.DeleteUser == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUser(childComplexity, args["userUUID"].(string)), true

	case "Mutation.dumpBuild":
		if e.complexity.Mutation.DumpBuild == nil {
			break
		}

		args, err := ec.field_Mutation_dumpBuild_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DumpBuild(childComplexity, args["buildUUID"].(string)), true

	case "Mutation.executePlan":
		if e.complexity.Mutation.ExecutePlan == nil {
			break
		}

		args, err := ec.field_Mutation_executePlan_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ExecutePlan(childComplexity, args["buildUUID"].(string)), true

	case "Mutation.loadEnvironment":
		if e.complexity.Mutation.LoadEnvironment == nil {
			break
		}

		args, err := ec.field_Mutation_loadEnvironment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.LoadEnvironment(childComplexity, args["envFilePath"].(string)), true

	case "Mutation.modifyAdminPassword":
		if e.complexity.Mutation.ModifyAdminPassword == nil {
			break
		}

		args, err := ec.field_Mutation_modifyAdminPassword_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ModifyAdminPassword(childComplexity, args["userID"].(string), args["newPassword"].(string)), true

	case "Mutation.modifyAdminUserInfo":
		if e.complexity.Mutation.ModifyAdminUserInfo == nil {
			break
		}

		args, err := ec.field_Mutation_modifyAdminUserInfo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ModifyAdminUserInfo(childComplexity, args["userID"].(string), args["username"].(*string), args["firstName"].(*string), args["lastName"].(*string), args["email"].(*string), args["phone"].(*string), args["company"].(*string), args["occupation"].(*string), args["role"].(*model.RoleLevel), args["provider"].(*model.ProviderType)), true

	case "Mutation.modifySelfPassword":
		if e.complexity.Mutation.ModifySelfPassword == nil {
			break
		}

		args, err := ec.field_Mutation_modifySelfPassword_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ModifySelfPassword(childComplexity, args["currentPassword"].(string), args["newPassword"].(string)), true

	case "Mutation.modifySelfUserInfo":
		if e.complexity.Mutation.ModifySelfUserInfo == nil {
			break
		}

		args, err := ec.field_Mutation_modifySelfUserInfo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ModifySelfUserInfo(childComplexity, args["firstName"].(*string), args["lastName"].(*string), args["email"].(*string), args["phone"].(*string), args["company"].(*string), args["occupation"].(*string)), true

	case "Mutation.nukeBackend":
		if e.complexity.Mutation.NukeBackend == nil {
			break
		}

		return e.complexity.Mutation.NukeBackend(childComplexity), true

	case "Mutation.rebuild":
		if e.complexity.Mutation.Rebuild == nil {
			break
		}

		args, err := ec.field_Mutation_rebuild_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Rebuild(childComplexity, args["rootPlans"].([]*string)), true

	case "Mutation.updateEnviromentViaPull":
		if e.complexity.Mutation.UpdateEnviromentViaPull == nil {
			break
		}

		args, err := ec.field_Mutation_updateEnviromentViaPull_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEnviromentViaPull(childComplexity, args["envUUID"].(string)), true

	case "Network.cidr":
		if e.complexity.Network.Cidr == nil {
			break
		}

		return e.complexity.Network.Cidr(childComplexity), true

	case "Network.Environment":
		if e.complexity.Network.Environment == nil {
			break
		}

		return e.complexity.Network.Environment(childComplexity), true

	case "Network.hclId":
		if e.complexity.Network.HclID == nil {
			break
		}

		return e.complexity.Network.HclID(childComplexity), true

	case "Network.HostDependencies":
		if e.complexity.Network.HostDependencies == nil {
			break
		}

		return e.complexity.Network.HostDependencies(childComplexity), true

	case "Network.id":
		if e.complexity.Network.ID == nil {
			break
		}

		return e.complexity.Network.ID(childComplexity), true

	case "Network.IncludedNetworks":
		if e.complexity.Network.IncludedNetworks == nil {
			break
		}

		return e.complexity.Network.IncludedNetworks(childComplexity), true

	case "Network.name":
		if e.complexity.Network.Name == nil {
			break
		}

		return e.complexity.Network.Name(childComplexity), true

	case "Network.tags":
		if e.complexity.Network.Tags == nil {
			break
		}

		return e.complexity.Network.Tags(childComplexity), true

	case "Network.vars":
		if e.complexity.Network.Vars == nil {
			break
		}

		return e.complexity.Network.Vars(childComplexity), true

	case "Network.vdiVisible":
		if e.complexity.Network.VdiVisible == nil {
			break
		}

		return e.complexity.Network.VdiVisible(childComplexity), true

	case "Plan.Build":
		if e.complexity.Plan.Build == nil {
			break
		}

		return e.complexity.Plan.Build(childComplexity), true

	case "Plan.id":
		if e.complexity.Plan.ID == nil {
			break
		}

		return e.complexity.Plan.ID(childComplexity), true

	case "Plan.NextPlans":
		if e.complexity.Plan.NextPlans == nil {
			break
		}

		return e.complexity.Plan.NextPlans(childComplexity), true

	case "Plan.PlanDiffs":
		if e.complexity.Plan.PlanDiffs == nil {
			break
		}

		return e.complexity.Plan.PlanDiffs(childComplexity), true

	case "Plan.PrevPlans":
		if e.complexity.Plan.PrevPlans == nil {
			break
		}

		return e.complexity.Plan.PrevPlans(childComplexity), true

	case "Plan.ProvisionedHost":
		if e.complexity.Plan.ProvisionedHost == nil {
			break
		}

		return e.complexity.Plan.ProvisionedHost(childComplexity), true

	case "Plan.ProvisionedNetwork":
		if e.complexity.Plan.ProvisionedNetwork == nil {
			break
		}

		return e.complexity.Plan.ProvisionedNetwork(childComplexity), true

	case "Plan.ProvisioningScheduledStep":
		if e.complexity.Plan.ProvisioningScheduledStep == nil {
			break
		}

		return e.complexity.Plan.ProvisioningScheduledStep(childComplexity), true

	case "Plan.ProvisioningStep":
		if e.complexity.Plan.ProvisioningStep == nil {
			break
		}

		return e.complexity.Plan.ProvisioningStep(childComplexity), true

	case "Plan.Status":
		if e.complexity.Plan.Status == nil {
			break
		}

		return e.complexity.Plan.Status(childComplexity), true

	case "Plan.stepNumber":
		if e.complexity.Plan.StepNumber == nil {
			break
		}

		return e.complexity.Plan.StepNumber(childComplexity), true

	case "Plan.Team":
		if e.complexity.Plan.Team == nil {
			break
		}

		return e.complexity.Plan.Team(childComplexity), true

	case "Plan.type":
		if e.complexity.Plan.Type == nil {
			break
		}

		return e.complexity.Plan.Type(childComplexity), true

	case "PlanCounts.awaiting":
		if e.complexity.PlanCounts.Awaiting == nil {
			break
		}

		return e.complexity.PlanCounts.Awaiting(childComplexity), true

	case "PlanCounts.cancelled":
		if e.complexity.PlanCounts.Cancelled == nil {
			break
		}

		return e.complexity.PlanCounts.Cancelled(childComplexity), true

	case "PlanCounts.complete":
		if e.complexity.PlanCounts.Complete == nil {
			break
		}

		return e.complexity.PlanCounts.Complete(childComplexity), true

	case "PlanCounts.deleteInProgress":
		if e.complexity.PlanCounts.DeleteInProgress == nil {
			break
		}

		return e.complexity.PlanCounts.DeleteInProgress(childComplexity), true

	case "PlanCounts.deleted":
		if e.complexity.PlanCounts.Deleted == nil {
			break
		}

		return e.complexity.PlanCounts.Deleted(childComplexity), true

	case "PlanCounts.failed":
		if e.complexity.PlanCounts.Failed == nil {
			break
		}

		return e.complexity.PlanCounts.Failed(childComplexity), true

	case "PlanCounts.inProgress":
		if e.complexity.PlanCounts.InProgress == nil {
			break
		}

		return e.complexity.PlanCounts.InProgress(childComplexity), true

	case "PlanCounts.parentAwaiting":
		if e.complexity.PlanCounts.ParentAwaiting == nil {
			break
		}

		return e.complexity.PlanCounts.ParentAwaiting(childComplexity), true

	case "PlanCounts.planning":
		if e.complexity.PlanCounts.Planning == nil {
			break
		}

		return e.complexity.PlanCounts.Planning(childComplexity), true

	case "PlanCounts.tainted":
		if e.complexity.PlanCounts.Tainted == nil {
			break
		}

		return e.complexity.PlanCounts.Tainted(childComplexity), true

	case "PlanCounts.toDelete":
		if e.complexity.PlanCounts.ToDelete == nil {
			break
		}

		return e.complexity.PlanCounts.ToDelete(childComplexity), true

	case "PlanCounts.toRebuild":
		if e.complexity.PlanCounts.ToRebuild == nil {
			break
		}

		return e.complexity.PlanCounts.ToRebuild(childComplexity), true

	case "PlanCounts.undefined":
		if e.complexity.PlanCounts.Undefined == nil {
			break
		}

		return e.complexity.PlanCounts.Undefined(childComplexity), true

	case "PlanDiff.BuildCommit":
		if e.complexity.PlanDiff.BuildCommit == nil {
			break
		}

		return e.complexity.PlanDiff.BuildCommit(childComplexity), true

	case "PlanDiff.id":
		if e.complexity.PlanDiff.ID == nil {
			break
		}

		return e.complexity.PlanDiff.ID(childComplexity), true

	case "PlanDiff.newState":
		if e.complexity.PlanDiff.NewState == nil {
			break
		}

		return e.complexity.PlanDiff.NewState(childComplexity), true

	case "PlanDiff.Plan":
		if e.complexity.PlanDiff.Plan == nil {
			break
		}

		return e.complexity.PlanDiff.Plan(childComplexity), true

	case "PlanDiff.revision":
		if e.complexity.PlanDiff.Revision == nil {
			break
		}

		return e.complexity.PlanDiff.Revision(childComplexity), true

	case "ProvisionedHost.addonType":
		if e.complexity.ProvisionedHost.AddonType == nil {
			break
		}

		return e.complexity.ProvisionedHost.AddonType(childComplexity), true

	case "ProvisionedHost.AgentStatus":
		if e.complexity.ProvisionedHost.AgentStatus == nil {
			break
		}

		return e.complexity.ProvisionedHost.AgentStatus(childComplexity), true

	case "ProvisionedHost.AgentTasks":
		if e.complexity.ProvisionedHost.AgentTasks == nil {
			break
		}

		return e.complexity.ProvisionedHost.AgentTasks(childComplexity), true

	case "ProvisionedHost.Build":
		if e.complexity.ProvisionedHost.Build == nil {
			break
		}

		return e.complexity.ProvisionedHost.Build(childComplexity), true

	case "ProvisionedHost.EndStepPlan":
		if e.complexity.ProvisionedHost.EndStepPlan == nil {
			break
		}

		return e.complexity.ProvisionedHost.EndStepPlan(childComplexity), true

	case "ProvisionedHost.GinFileMiddleware":
		if e.complexity.ProvisionedHost.GinFileMiddleware == nil {
			break
		}

		return e.complexity.ProvisionedHost.GinFileMiddleware(childComplexity), true

	case "ProvisionedHost.Host":
		if e.complexity.ProvisionedHost.Host == nil {
			break
		}

		return e.complexity.ProvisionedHost.Host(childComplexity), true

	case "ProvisionedHost.id":
		if e.complexity.ProvisionedHost.ID == nil {
			break
		}

		return e.complexity.ProvisionedHost.ID(childComplexity), true

	case "ProvisionedHost.Plan":
		if e.complexity.ProvisionedHost.Plan == nil {
			break
		}

		return e.complexity.ProvisionedHost.Plan(childComplexity), true

	case "ProvisionedHost.ProvisionedNetwork":
		if e.complexity.ProvisionedHost.ProvisionedNetwork == nil {
			break
		}

		return e.complexity.ProvisionedHost.ProvisionedNetwork(childComplexity), true

	case "ProvisionedHost.ProvisioningScheduledSteps":
		if e.complexity.ProvisionedHost.ProvisioningScheduledSteps == nil {
			break
		}

		return e.complexity.ProvisionedHost.ProvisioningScheduledSteps(childComplexity), true

	case "ProvisionedHost.ProvisioningSteps":
		if e.complexity.ProvisionedHost.ProvisioningSteps == nil {
			break
		}

		return e.complexity.ProvisionedHost.ProvisioningSteps(childComplexity), true

	case "ProvisionedHost.Status":
		if e.complexity.ProvisionedHost.Status == nil {
			break
		}

		return e.complexity.ProvisionedHost.Status(childComplexity), true

	case "ProvisionedHost.subnetIp":
		if e.complexity.ProvisionedHost.SubnetIP == nil {
			break
		}

		return e.complexity.ProvisionedHost.SubnetIP(childComplexity), true

	case "ProvisionedHost.vars":
		if e.complexity.ProvisionedHost.Vars == nil {
			break
		}

		return e.complexity.ProvisionedHost.Vars(childComplexity), true

	case "ProvisionedNetwork.Build":
		if e.complexity.ProvisionedNetwork.Build == nil {
			break
		}

		return e.complexity.ProvisionedNetwork.Build(childComplexity), true

	case "ProvisionedNetwork.cidr":
		if e.complexity.ProvisionedNetwork.Cidr == nil {
			break
		}

		return e.complexity.ProvisionedNetwork.Cidr(childComplexity), true

	case "ProvisionedNetwork.id":
		if e.complexity.ProvisionedNetwork.ID == nil {
			break
		}

		return e.complexity.ProvisionedNetwork.ID(childComplexity), true

	case "ProvisionedNetwork.name":
		if e.complexity.ProvisionedNetwork.Name == nil {
			break
		}

		return e.complexity.ProvisionedNetwork.Name(childComplexity), true

	case "ProvisionedNetwork.Network":
		if e.complexity.ProvisionedNetwork.Network == nil {
			break
		}

		return e.complexity.ProvisionedNetwork.Network(childComplexity), true

	case "ProvisionedNetwork.Plan":
		if e.complexity.ProvisionedNetwork.Plan == nil {
			break
		}

		return e.complexity.ProvisionedNetwork.Plan(childComplexity), true

	case "ProvisionedNetwork.ProvisionedHosts":
		if e.complexity.ProvisionedNetwork.ProvisionedHosts == nil {
			break
		}

		return e.complexity.ProvisionedNetwork.ProvisionedHosts(childComplexity), true

	case "ProvisionedNetwork.Status":
		if e.complexity.ProvisionedNetwork.Status == nil {
			break
		}

		return e.complexity.ProvisionedNetwork.Status(childComplexity), true

	case "ProvisionedNetwork.Team":
		if e.complexity.ProvisionedNetwork.Team == nil {
			break
		}

		return e.complexity.ProvisionedNetwork.Team(childComplexity), true

	case "ProvisionedNetwork.vars":
		if e.complexity.ProvisionedNetwork.Vars == nil {
			break
		}

		return e.complexity.ProvisionedNetwork.Vars(childComplexity), true

	case "ProvisioningScheduledStep.AgentTasks":
		if e.complexity.ProvisioningScheduledStep.AgentTasks == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.AgentTasks(childComplexity), true

	case "ProvisioningScheduledStep.Ansible":
		if e.complexity.ProvisioningScheduledStep.Ansible == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.Ansible(childComplexity), true

	case "ProvisioningScheduledStep.Command":
		if e.complexity.ProvisioningScheduledStep.Command == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.Command(childComplexity), true

	case "ProvisioningScheduledStep.DNSRecord":
		if e.complexity.ProvisioningScheduledStep.DNSRecord == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.DNSRecord(childComplexity), true

	case "ProvisioningScheduledStep.FileDelete":
		if e.complexity.ProvisioningScheduledStep.FileDelete == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.FileDelete(childComplexity), true

	case "ProvisioningScheduledStep.FileDownload":
		if e.complexity.ProvisioningScheduledStep.FileDownload == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.FileDownload(childComplexity), true

	case "ProvisioningScheduledStep.FileExtract":
		if e.complexity.ProvisioningScheduledStep.FileExtract == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.FileExtract(childComplexity), true

	case "ProvisioningScheduledStep.GinFileMiddleware":
		if e.complexity.ProvisioningScheduledStep.GinFileMiddleware == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.GinFileMiddleware(childComplexity), true

	case "ProvisioningScheduledStep.id":
		if e.complexity.ProvisioningScheduledStep.ID == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.ID(childComplexity), true

	case "ProvisioningScheduledStep.Plan":
		if e.complexity.ProvisioningScheduledStep.Plan == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.Plan(childComplexity), true

	case "ProvisioningScheduledStep.ProvisionedHost":
		if e.complexity.ProvisioningScheduledStep.ProvisionedHost == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.ProvisionedHost(childComplexity), true

	case "ProvisioningScheduledStep.runTime":
		if e.complexity.ProvisioningScheduledStep.RunTime == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.RunTime(childComplexity), true

	case "ProvisioningScheduledStep.ScheduledStep":
		if e.complexity.ProvisioningScheduledStep.ScheduledStep == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.ScheduledStep(childComplexity), true

	case "ProvisioningScheduledStep.Script":
		if e.complexity.ProvisioningScheduledStep.Script == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.Script(childComplexity), true

	case "ProvisioningScheduledStep.Status":
		if e.complexity.ProvisioningScheduledStep.Status == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.Status(childComplexity), true

	case "ProvisioningScheduledStep.type":
		if e.complexity.ProvisioningScheduledStep.Type == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.Type(childComplexity), true

	case "ProvisioningStep.AgentTasks":
		if e.complexity.ProvisioningStep.AgentTasks == nil {
			break
		}

		return e.complexity.ProvisioningStep.AgentTasks(childComplexity), true

	case "ProvisioningStep.Ansible":
		if e.complexity.ProvisioningStep.Ansible == nil {
			break
		}

		return e.complexity.ProvisioningStep.Ansible(childComplexity), true

	case "ProvisioningStep.Command":
		if e.complexity.ProvisioningStep.Command == nil {
			break
		}

		return e.complexity.ProvisioningStep.Command(childComplexity), true

	case "ProvisioningStep.DNSRecord":
		if e.complexity.ProvisioningStep.DNSRecord == nil {
			break
		}

		return e.complexity.ProvisioningStep.DNSRecord(childComplexity), true

	case "ProvisioningStep.FileDelete":
		if e.complexity.ProvisioningStep.FileDelete == nil {
			break
		}

		return e.complexity.ProvisioningStep.FileDelete(childComplexity), true

	case "ProvisioningStep.FileDownload":
		if e.complexity.ProvisioningStep.FileDownload == nil {
			break
		}

		return e.complexity.ProvisioningStep.FileDownload(childComplexity), true

	case "ProvisioningStep.FileExtract":
		if e.complexity.ProvisioningStep.FileExtract == nil {
			break
		}

		return e.complexity.ProvisioningStep.FileExtract(childComplexity), true

	case "ProvisioningStep.GinFileMiddleware":
		if e.complexity.ProvisioningStep.GinFileMiddleware == nil {
			break
		}

		return e.complexity.ProvisioningStep.GinFileMiddleware(childComplexity), true

	case "ProvisioningStep.id":
		if e.complexity.ProvisioningStep.ID == nil {
			break
		}

		return e.complexity.ProvisioningStep.ID(childComplexity), true

	case "ProvisioningStep.Plan":
		if e.complexity.ProvisioningStep.Plan == nil {
			break
		}

		return e.complexity.ProvisioningStep.Plan(childComplexity), true

	case "ProvisioningStep.ProvisionedHost":
		if e.complexity.ProvisioningStep.ProvisionedHost == nil {
			break
		}

		return e.complexity.ProvisioningStep.ProvisionedHost(childComplexity), true

	case "ProvisioningStep.Script":
		if e.complexity.ProvisioningStep.Script == nil {
			break
		}

		return e.complexity.ProvisioningStep.Script(childComplexity), true

	case "ProvisioningStep.Status":
		if e.complexity.ProvisioningStep.Status == nil {
			break
		}

		return e.complexity.ProvisioningStep.Status(childComplexity), true

	case "ProvisioningStep.stepNumber":
		if e.complexity.ProvisioningStep.StepNumber == nil {
			break
		}

		return e.complexity.ProvisioningStep.StepNumber(childComplexity), true

	case "ProvisioningStep.type":
		if e.complexity.ProvisioningStep.Type == nil {
			break
		}

		return e.complexity.ProvisioningStep.Type(childComplexity), true

	case "Query.agentStatus":
		if e.complexity.Query.AgentStatus == nil {
			break
		}

		args, err := ec.field_Query_agentStatus_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AgentStatus(childComplexity, args["clientId"].(string)), true

	case "Query.build":
		if e.complexity.Query.Build == nil {
			break
		}

		args, err := ec.field_Query_build_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Build(childComplexity, args["buildUUID"].(string)), true

	case "Query.currentUser":
		if e.complexity.Query.CurrentUser == nil {
			break
		}

		return e.complexity.Query.CurrentUser(childComplexity), true

	case "Query.environment":
		if e.complexity.Query.Environment == nil {
			break
		}

		args, err := ec.field_Query_environment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Environment(childComplexity, args["envUUID"].(string)), true

	case "Query.environments":
		if e.complexity.Query.Environments == nil {
			break
		}

		return e.complexity.Query.Environments(childComplexity), true

	case "Query.getAgentTasks":
		if e.complexity.Query.GetAgentTasks == nil {
			break
		}

		args, err := ec.field_Query_getAgentTasks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetAgentTasks(childComplexity, args["proStepUUID"].(string)), true

	case "Query.getAllAgentStatus":
		if e.complexity.Query.GetAllAgentStatus == nil {
			break
		}

		args, err := ec.field_Query_getAllAgentStatus_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetAllAgentStatus(childComplexity, args["buildUUID"].(string), args["count"].(int), args["offset"].(int)), true

	case "Query.getAllPlanStatus":
		if e.complexity.Query.GetAllPlanStatus == nil {
			break
		}

		args, err := ec.field_Query_getAllPlanStatus_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetAllPlanStatus(childComplexity, args["buildUUID"].(string), args["count"].(int), args["offset"].(int)), true

	case "Query.getBuildCommit":
		if e.complexity.Query.GetBuildCommit == nil {
			break
		}

		args, err := ec.field_Query_getBuildCommit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetBuildCommit(childComplexity, args["buildCommitUUID"].(string)), true

	case "Query.getBuildCommits":
		if e.complexity.Query.GetBuildCommits == nil {
			break
		}

		args, err := ec.field_Query_getBuildCommits_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetBuildCommits(childComplexity, args["envUUID"].(string)), true

	case "Query.getBuilds":
		if e.complexity.Query.GetBuilds == nil {
			break
		}

		return e.complexity.Query.GetBuilds(childComplexity), true

	case "Query.getCurrentUserTasks":
		if e.complexity.Query.GetCurrentUserTasks == nil {
			break
		}

		return e.complexity.Query.GetCurrentUserTasks(childComplexity), true

	case "Query.getPlanStatusCounts":
		if e.complexity.Query.GetPlanStatusCounts == nil {
			break
		}

		args, err := ec.field_Query_getPlanStatusCounts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetPlanStatusCounts(childComplexity, args["buildUUID"].(string)), true

	case "Query.getServerTasks":
		if e.complexity.Query.GetServerTasks == nil {
			break
		}

		return e.complexity.Query.GetServerTasks(childComplexity), true

	case "Query.getUserList":
		if e.complexity.Query.GetUserList == nil {
			break
		}

		return e.complexity.Query.GetUserList(childComplexity), true

	case "Query.listAgentStatuses":
		if e.complexity.Query.ListAgentStatuses == nil {
			break
		}

		args, err := ec.field_Query_listAgentStatuses_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListAgentStatuses(childComplexity, args["buildUUID"].(string)), true

	case "Query.listBuildStatuses":
		if e.complexity.Query.ListBuildStatuses == nil {
			break
		}

		args, err := ec.field_Query_listBuildStatuses_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListBuildStatuses(childComplexity, args["buildUUID"].(string)), true

	case "Query.plan":
		if e.complexity.Query.Plan == nil {
			break
		}

		args, err := ec.field_Query_plan_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Plan(childComplexity, args["planUUID"].(string)), true

	case "Query.provisionedHost":
		if e.complexity.Query.ProvisionedHost == nil {
			break
		}

		args, err := ec.field_Query_provisionedHost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ProvisionedHost(childComplexity, args["proHostUUID"].(string)), true

	case "Query.provisionedNetwork":
		if e.complexity.Query.ProvisionedNetwork == nil {
			break
		}

		args, err := ec.field_Query_provisionedNetwork_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ProvisionedNetwork(childComplexity, args["proNetUUID"].(string)), true

	case "Query.provisionedStep":
		if e.complexity.Query.ProvisionedStep == nil {
			break
		}

		args, err := ec.field_Query_provisionedStep_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ProvisionedStep(childComplexity, args["proStepUUID"].(string)), true

	case "Query.serverTasks":
		if e.complexity.Query.ServerTasks == nil {
			break
		}

		args, err := ec.field_Query_serverTasks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ServerTasks(childComplexity, args["taskUUIDs"].([]*string)), true

	case "Query.status":
		if e.complexity.Query.Status == nil {
			break
		}

		args, err := ec.field_Query_status_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Status(childComplexity, args["statusUUID"].(string)), true

	case "Query.viewAgentTask":
		if e.complexity.Query.ViewAgentTask == nil {
			break
		}

		args, err := ec.field_Query_viewAgentTask_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ViewAgentTask(childComplexity, args["taskID"].(string)), true

	case "Query.viewServerTaskLogs":
		if e.complexity.Query.ViewServerTaskLogs == nil {
			break
		}

		args, err := ec.field_Query_viewServerTaskLogs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ViewServerTaskLogs(childComplexity, args["taskID"].(string)), true

	case "RepoCommit.author":
		if e.complexity.RepoCommit.Author == nil {
			break
		}

		return e.complexity.RepoCommit.Author(childComplexity), true

	case "RepoCommit.committer":
		if e.complexity.RepoCommit.Committer == nil {
			break
		}

		return e.complexity.RepoCommit.Committer(childComplexity), true

	case "RepoCommit.hash":
		if e.complexity.RepoCommit.Hash == nil {
			break
		}

		return e.complexity.RepoCommit.Hash(childComplexity), true

	case "RepoCommit.id":
		if e.complexity.RepoCommit.ID == nil {
			break
		}

		return e.complexity.RepoCommit.ID(childComplexity), true

	case "RepoCommit.message":
		if e.complexity.RepoCommit.Message == nil {
			break
		}

		return e.complexity.RepoCommit.Message(childComplexity), true

	case "RepoCommit.parentHashes":
		if e.complexity.RepoCommit.ParentHashes == nil {
			break
		}

		return e.complexity.RepoCommit.ParentHashes(childComplexity), true

	case "RepoCommit.pgpSignature":
		if e.complexity.RepoCommit.PgpSignature == nil {
			break
		}

		return e.complexity.RepoCommit.PgpSignature(childComplexity), true

	case "RepoCommit.Repository":
		if e.complexity.RepoCommit.Repository == nil {
			break
		}

		return e.complexity.RepoCommit.Repository(childComplexity), true

	case "RepoCommit.revision":
		if e.complexity.RepoCommit.Revision == nil {
			break
		}

		return e.complexity.RepoCommit.Revision(childComplexity), true

	case "RepoCommit.treeHash":
		if e.complexity.RepoCommit.TreeHash == nil {
			break
		}

		return e.complexity.RepoCommit.TreeHash(childComplexity), true

	case "Repository.branchName":
		if e.complexity.Repository.BranchName == nil {
			break
		}

		return e.complexity.Repository.BranchName(childComplexity), true

	case "Repository.environmentFilepath":
		if e.complexity.Repository.EnvironmentFilepath == nil {
			break
		}

		return e.complexity.Repository.EnvironmentFilepath(childComplexity), true

	case "Repository.Environments":
		if e.complexity.Repository.Environments == nil {
			break
		}

		return e.complexity.Repository.Environments(childComplexity), true

	case "Repository.id":
		if e.complexity.Repository.ID == nil {
			break
		}

		return e.complexity.Repository.ID(childComplexity), true

	case "Repository.RepoCommits":
		if e.complexity.Repository.RepoCommits == nil {
			break
		}

		return e.complexity.Repository.RepoCommits(childComplexity), true

	case "Repository.repoUrl":
		if e.complexity.Repository.RepoURL == nil {
			break
		}

		return e.complexity.Repository.RepoURL(childComplexity), true

	case "ScheduledStep.description":
		if e.complexity.ScheduledStep.Description == nil {
			break
		}

		return e.complexity.ScheduledStep.Description(childComplexity), true

	case "ScheduledStep.Environment":
		if e.complexity.ScheduledStep.Environment == nil {
			break
		}

		return e.complexity.ScheduledStep.Environment(childComplexity), true

	case "ScheduledStep.hclId":
		if e.complexity.ScheduledStep.HclID == nil {
			break
		}

		return e.complexity.ScheduledStep.HclID(childComplexity), true

	case "ScheduledStep.id":
		if e.complexity.ScheduledStep.ID == nil {
			break
		}

		return e.complexity.ScheduledStep.ID(childComplexity), true

	case "ScheduledStep.name":
		if e.complexity.ScheduledStep.Name == nil {
			break
		}

		return e.complexity.ScheduledStep.Name(childComplexity), true

	case "ScheduledStep.runAt":
		if e.complexity.ScheduledStep.RunAt == nil {
			break
		}

		return e.complexity.ScheduledStep.RunAt(childComplexity), true

	case "ScheduledStep.schedule":
		if e.complexity.ScheduledStep.Schedule == nil {
			break
		}

		return e.complexity.ScheduledStep.Schedule(childComplexity), true

	case "ScheduledStep.step":
		if e.complexity.ScheduledStep.Step == nil {
			break
		}

		return e.complexity.ScheduledStep.Step(childComplexity), true

	case "ScheduledStep.type":
		if e.complexity.ScheduledStep.Type == nil {
			break
		}

		return e.complexity.ScheduledStep.Type(childComplexity), true

	case "Script.absPath":
		if e.complexity.Script.AbsPath == nil {
			break
		}

		return e.complexity.Script.AbsPath(childComplexity), true

	case "Script.args":
		if e.complexity.Script.Args == nil {
			break
		}

		return e.complexity.Script.Args(childComplexity), true

	case "Script.cooldown":
		if e.complexity.Script.Cooldown == nil {
			break
		}

		return e.complexity.Script.Cooldown(childComplexity), true

	case "Script.description":
		if e.complexity.Script.Description == nil {
			break
		}

		return e.complexity.Script.Description(childComplexity), true

	case "Script.disabled":
		if e.complexity.Script.Disabled == nil {
			break
		}

		return e.complexity.Script.Disabled(childComplexity), true

	case "Script.Environment":
		if e.complexity.Script.Environment == nil {
			break
		}

		return e.complexity.Script.Environment(childComplexity), true

	case "Script.Findings":
		if e.complexity.Script.Findings == nil {
			break
		}

		return e.complexity.Script.Findings(childComplexity), true

	case "Script.hclId":
		if e.complexity.Script.HclID == nil {
			break
		}

		return e.complexity.Script.HclID(childComplexity), true

	case "Script.id":
		if e.complexity.Script.ID == nil {
			break
		}

		return e.complexity.Script.ID(childComplexity), true

	case "Script.ignoreErrors":
		if e.complexity.Script.IgnoreErrors == nil {
			break
		}

		return e.complexity.Script.IgnoreErrors(childComplexity), true

	case "Script.language":
		if e.complexity.Script.Language == nil {
			break
		}

		return e.complexity.Script.Language(childComplexity), true

	case "Script.name":
		if e.complexity.Script.Name == nil {
			break
		}

		return e.complexity.Script.Name(childComplexity), true

	case "Script.source":
		if e.complexity.Script.Source == nil {
			break
		}

		return e.complexity.Script.Source(childComplexity), true

	case "Script.sourceType":
		if e.complexity.Script.SourceType == nil {
			break
		}

		return e.complexity.Script.SourceType(childComplexity), true

	case "Script.tags":
		if e.complexity.Script.Tags == nil {
			break
		}

		return e.complexity.Script.Tags(childComplexity), true

	case "Script.timeout":
		if e.complexity.Script.Timeout == nil {
			break
		}

		return e.complexity.Script.Timeout(childComplexity), true

	case "Script.Users":
		if e.complexity.Script.Users == nil {
			break
		}

		return e.complexity.Script.Users(childComplexity), true

	case "Script.vars":
		if e.complexity.Script.Vars == nil {
			break
		}

		return e.complexity.Script.Vars(childComplexity), true

	case "ServerTask.AuthUser":
		if e.complexity.ServerTask.AuthUser == nil {
			break
		}

		return e.complexity.ServerTask.AuthUser(childComplexity), true

	case "ServerTask.Build":
		if e.complexity.ServerTask.Build == nil {
			break
		}

		return e.complexity.ServerTask.Build(childComplexity), true

	case "ServerTask.BuildCommit":
		if e.complexity.ServerTask.BuildCommit == nil {
			break
		}

		return e.complexity.ServerTask.BuildCommit(childComplexity), true

	case "ServerTask.endTime":
		if e.complexity.ServerTask.EndTime == nil {
			break
		}

		return e.complexity.ServerTask.EndTime(childComplexity), true

	case "ServerTask.Environment":
		if e.complexity.ServerTask.Environment == nil {
			break
		}

		return e.complexity.ServerTask.Environment(childComplexity), true

	case "ServerTask.errors":
		if e.complexity.ServerTask.Errors == nil {
			break
		}

		return e.complexity.ServerTask.Errors(childComplexity), true

	case "ServerTask.GinFileMiddleware":
		if e.complexity.ServerTask.GinFileMiddleware == nil {
			break
		}

		return e.complexity.ServerTask.GinFileMiddleware(childComplexity), true

	case "ServerTask.id":
		if e.complexity.ServerTask.ID == nil {
			break
		}

		return e.complexity.ServerTask.ID(childComplexity), true

	case "ServerTask.logFilePath":
		if e.complexity.ServerTask.LogFilePath == nil {
			break
		}

		return e.complexity.ServerTask.LogFilePath(childComplexity), true

	case "ServerTask.startTime":
		if e.complexity.ServerTask.StartTime == nil {
			break
		}

		return e.complexity.ServerTask.StartTime(childComplexity), true

	case "ServerTask.Status":
		if e.complexity.ServerTask.Status == nil {
			break
		}

		return e.complexity.ServerTask.Status(childComplexity), true

	case "ServerTask.type":
		if e.complexity.ServerTask.Type == nil {
			break
		}

		return e.complexity.ServerTask.Type(childComplexity), true

	case "Status.AdhocPlan":
		if e.complexity.Status.AdhocPlan == nil {
			break
		}

		return e.complexity.Status.AdhocPlan(childComplexity), true

	case "Status.Build":
		if e.complexity.Status.Build == nil {
			break
		}

		return e.complexity.Status.Build(childComplexity), true

	case "Status.completed":
		if e.complexity.Status.Completed == nil {
			break
		}

		return e.complexity.Status.Completed(childComplexity), true

	case "Status.endedAt":
		if e.complexity.Status.EndedAt == nil {
			break
		}

		return e.complexity.Status.EndedAt(childComplexity), true

	case "Status.error":
		if e.complexity.Status.Error == nil {
			break
		}

		return e.complexity.Status.Error(childComplexity), true

	case "Status.failed":
		if e.complexity.Status.Failed == nil {
			break
		}

		return e.complexity.Status.Failed(childComplexity), true

	case "Status.id":
		if e.complexity.Status.ID == nil {
			break
		}

		return e.complexity.Status.ID(childComplexity), true

	case "Status.Plan":
		if e.complexity.Status.Plan == nil {
			break
		}

		return e.complexity.Status.Plan(childComplexity), true

	case "Status.ProvisionedHost":
		if e.complexity.Status.ProvisionedHost == nil {
			break
		}

		return e.complexity.Status.ProvisionedHost(childComplexity), true

	case "Status.ProvisionedNetwork":
		if e.complexity.Status.ProvisionedNetwork == nil {
			break
		}

		return e.complexity.Status.ProvisionedNetwork(childComplexity), true

	case "Status.ProvisioningScheduledStep":
		if e.complexity.Status.ProvisioningScheduledStep == nil {
			break
		}

		return e.complexity.Status.ProvisioningScheduledStep(childComplexity), true

	case "Status.ProvisioningStep":
		if e.complexity.Status.ProvisioningStep == nil {
			break
		}

		return e.complexity.Status.ProvisioningStep(childComplexity), true

	case "Status.ServerTask":
		if e.complexity.Status.ServerTask == nil {
			break
		}

		return e.complexity.Status.ServerTask(childComplexity), true

	case "Status.startedAt":
		if e.complexity.Status.StartedAt == nil {
			break
		}

		return e.complexity.Status.StartedAt(childComplexity), true

	case "Status.state":
		if e.complexity.Status.State == nil {
			break
		}

		return e.complexity.Status.State(childComplexity), true

	case "Status.statusFor":
		if e.complexity.Status.StatusFor == nil {
			break
		}

		return e.complexity.Status.StatusFor(childComplexity), true

	case "Status.Team":
		if e.complexity.Status.Team == nil {
			break
		}

		return e.complexity.Status.Team(childComplexity), true

	case "StatusBatch.pageInfo":
		if e.complexity.StatusBatch.PageInfo == nil {
			break
		}

		return e.complexity.StatusBatch.PageInfo(childComplexity), true

	case "StatusBatch.statuses":
		if e.complexity.StatusBatch.Statuses == nil {
			break
		}

		return e.complexity.StatusBatch.Statuses(childComplexity), true

	case "Subscription.streamServerTaskLog":
		if e.complexity.Subscription.StreamServerTaskLog == nil {
			break
		}

		args, err := ec.field_Subscription_streamServerTaskLog_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.StreamServerTaskLog(childComplexity, args["taskID"].(string)), true

	case "Subscription.updatedAgentStatus":
		if e.complexity.Subscription.UpdatedAgentStatus == nil {
			break
		}

		return e.complexity.Subscription.UpdatedAgentStatus(childComplexity), true

	case "Subscription.updatedAgentTask":
		if e.complexity.Subscription.UpdatedAgentTask == nil {
			break
		}

		return e.complexity.Subscription.UpdatedAgentTask(childComplexity), true

	case "Subscription.updatedBuild":
		if e.complexity.Subscription.UpdatedBuild == nil {
			break
		}

		return e.complexity.Subscription.UpdatedBuild(childComplexity), true

	case "Subscription.updatedCommit":
		if e.complexity.Subscription.UpdatedCommit == nil {
			break
		}

		return e.complexity.Subscription.UpdatedCommit(childComplexity), true

	case "Subscription.updatedServerTask":
		if e.complexity.Subscription.UpdatedServerTask == nil {
			break
		}

		return e.complexity.Subscription.UpdatedServerTask(childComplexity), true

	case "Subscription.updatedStatus":
		if e.complexity.Subscription.UpdatedStatus == nil {
			break
		}

		return e.complexity.Subscription.UpdatedStatus(childComplexity), true

	case "Tag.description":
		if e.complexity.Tag.Description == nil {
			break
		}

		return e.complexity.Tag.Description(childComplexity), true

	case "Tag.id":
		if e.complexity.Tag.ID == nil {
			break
		}

		return e.complexity.Tag.ID(childComplexity), true

	case "Tag.name":
		if e.complexity.Tag.Name == nil {
			break
		}

		return e.complexity.Tag.Name(childComplexity), true

	case "Tag.uuid":
		if e.complexity.Tag.UUID == nil {
			break
		}

		return e.complexity.Tag.UUID(childComplexity), true

	case "Team.Build":
		if e.complexity.Team.Build == nil {
			break
		}

		return e.complexity.Team.Build(childComplexity), true

	case "Team.id":
		if e.complexity.Team.ID == nil {
			break
		}

		return e.complexity.Team.ID(childComplexity), true

	case "Team.Plan":
		if e.complexity.Team.Plan == nil {
			break
		}

		return e.complexity.Team.Plan(childComplexity), true

	case "Team.ProvisionedNetworks":
		if e.complexity.Team.ProvisionedNetworks == nil {
			break
		}

		return e.complexity.Team.ProvisionedNetworks(childComplexity), true

	case "Team.Status":
		if e.complexity.Team.Status == nil {
			break
		}

		return e.complexity.Team.Status(childComplexity), true

	case "Team.teamNumber":
		if e.complexity.Team.TeamNumber == nil {
			break
		}

		return e.complexity.Team.TeamNumber(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.Environments":
		if e.complexity.User.Environments == nil {
			break
		}

		return e.complexity.User.Environments(childComplexity), true

	case "User.hclId":
		if e.complexity.User.HclID == nil {
			break
		}

		return e.complexity.User.HclID(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.Tag":
		if e.complexity.User.Tag == nil {
			break
		}

		return e.complexity.User.Tag(childComplexity), true

	case "User.uuid":
		if e.complexity.User.UUID == nil {
			break
		}

		return e.complexity.User.UUID(childComplexity), true

	case "configMap.key":
		if e.complexity.ConfigMap.Key == nil {
			break
		}

		return e.complexity.ConfigMap.Key(childComplexity), true

	case "configMap.value":
		if e.complexity.ConfigMap.Value == nil {
			break
		}

		return e.complexity.ConfigMap.Value(childComplexity), true

	case "intMap.key":
		if e.complexity.IntMap.Key == nil {
			break
		}

		return e.complexity.IntMap.Key(childComplexity), true

	case "intMap.value":
		if e.complexity.IntMap.Value == nil {
			break
		}

		return e.complexity.IntMap.Value(childComplexity), true

	case "tagMap.key":
		if e.complexity.TagMap.Key == nil {
			break
		}

		return e.complexity.TagMap.Key(childComplexity), true

	case "tagMap.value":
		if e.complexity.TagMap.Value == nil {
			break
		}

		return e.complexity.TagMap.Value(childComplexity), true

	case "varsMap.key":
		if e.complexity.VarsMap.Key == nil {
			break
		}

		return e.complexity.VarsMap.Key(childComplexity), true

	case "varsMap.value":
		if e.complexity.VarsMap.Value == nil {
			break
		}

		return e.complexity.VarsMap.Value(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap()
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema.graphqls", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

scalar Time

type varsMap {
  key: String!
  value: String!
}

type configMap {
  key: String!
  value: String!
}

type tagMap {
  key: String!
  value: String!
}

type intMap {
  key: String!
  value: Int!
}

enum FindingSeverity {
  ZeroSeverity
  LowSeverity
  MediumSeverity
  HighSeverity
  CriticalSeverity
  NullSeverity
}

enum FindingDifficulty {
  ZeroDifficulty
  NoviceDifficulty
  AdvancedDifficulty
  ExpertDifficulty
  NullDifficulty
}

enum ProvisionStatus {
  PLANNING
  AWAITING
  PARENTAWAITING
  INPROGRESS
  FAILED
  COMPLETE
  TAINTED
  UNDEFINED
  TODELETE
  DELETEINPROGRESS
  DELETED
  TOREBUILD
  CANCELLED
}

enum ProvisionStatusFor {
  Build
  Team
  Plan
  ProvisionedNetwork
  ProvisionedHost
  ProvisioningStep
  Undefined
}

enum PlanType {
  start_build
  start_team
  provision_network
  provision_host
  execute_step
  undefined
}

enum ProvisioningStepType {
  Ansible
  Script
  Command
  DNSRecord
  FileDelete
  FileDownload
  FileExtract
  Undefined
}

enum ProvisioningScheduledStepType {
  Ansible
  Script
  Command
  DNSRecord
  FileDelete
  FileDownload
  FileExtract
  Undefined
}

enum RoleLevel {
  ADMIN
  USER
  UNDEFINED
}

enum ProviderType {
  LOCAL
  GITHUB
  OPENID
  UNDEFINED
}

enum AgentCommand {
  DEFAULT
  DELETE
  REBOOT
  EXTRACT
  DOWNLOAD
  CREATEUSER
  CREATEUSERPASS
  ADDTOGROUP
  EXECUTE
  VALIDATE
  CHANGEPERMS
  APPENDFILE
}

enum AgentTaskState {
  AWAITING
  INPROGRESS
  FAILED
  COMPLETE
}

enum ServerTaskType {
  LOADENV
  CREATEBUILD
  RENDERFILES
  DELETEBUILD
  REBUILD
  EXECUTEBUILD
}

enum BuildCommitType {
  ROOT
  REBUILD
  DELETE
}

enum BuildCommitState {
  PLANNING
  INPROGRESS
  APPLIED
  CANCELLED
  APPROVED
}

enum AnsibleMethod {
  LOCAL
}

enum ProvisionedHostAddonType {
  DNS
}

enum ScheduledStepType {
  CRON
  RUNONCE
}

type AdhocPlan {
  id: ID!
  NextAdhocPlans: [AdhocPlan]
  PrevAdhocPlans: [AdhocPlan]
  Build: Build!
  Status: Status!
  AgentTask: AgentTask!
}

type AgentStatus {
  clientId: String!
  hostname: String!
  upTime: Int!
  bootTime: Int!
  numProcs: Int!
  OS: String!
  hostID: String!
  load1: Float
  load5: Float
  load15: Float
  totalMem: Int!
  freeMem: Int!
  usedMem: Int!
  timestamp: Int!
  ProvisionedHost: ProvisionedHost
  ProvisionedNetwork: ProvisionedNetwork
  Build: Build
}

type AgentTask {
  id: ID!
  args: String
  command: AgentCommand!
  number: Int!
  output: String
  state: AgentTaskState!
  errorMessage: String
  ProvisioningStep: ProvisioningStep
  ProvisioningScheduledStep: ProvisioningScheduledStep
  ProvisionedHost: ProvisionedHost!
  AdhocPlans: [AdhocPlan]
}

type Ansible {
  id: ID!
  hclId: String!
  name: String!
  description: String!
  source: String!
  playbookName: String!
  method: AnsibleMethod!
  inventory: String!
  absPath: String!
  tags: [tagMap]
  Users: [User]
  Environment: Environment
}

type AuthUser {
  id: ID!
  username: String!
  # password <- hidden
  firstName: String!
  lastName: String!
  email: String!
  phone: String!
  company: String!
  occupation: String!
  # privateKeyPath <- hidden
  publicKey: String!
  role: RoleLevel!
  provider: ProviderType!
  # Tokens <- hidden
  ServerTasks: [ServerTask]
}

type Build {
  id: ID!
  revision: Int!
  environmentRevision: Int!
  completedPlan: Boolean!
  Status: Status!
  Environment: Environment!
  Competition: Competition!
  LatestBuildCommit: BuildCommit
  RepoCommit: RepoCommit!
  ProvisionedNetworks: [ProvisionedNetwork]!
  Teams: [Team]!
  Plans: [Plan]!
  BuildCommits: [BuildCommit]!
  AdhocPlans: [AdhocPlan]!
  AgentStatuses: [AgentStatus]!
  ServerTasks: [ServerTask]!
}

type BuildCommit {
  id: ID!
  type: BuildCommitType!
  revision: Int!
  state: BuildCommitState!
  createdAt: Time!
  Build: Build!
  ServerTasks: [ServerTask]!
  PlanDiffs: [PlanDiff]!
}

type Command {
  id: ID!
  hclId: String!
  name: String!
  description: String!
  program: String!
  args: [String]!
  ignoreErrors: Boolean!
  disabled: Boolean!
  cooldown: Int!
  timeout: Int!
  vars: [varsMap]
  tags: [tagMap]
  Users: [User]!
  Environment: Environment!
}

type Competition {
  id: ID!
  hclId: String!
  rootPassword: String!
  startTime: Int
  stopTime: Int
  config: [configMap]
  tags: [tagMap]
  DNS: [DNS]!
  Environment: Environment!
  Builds: [Build]!
}

type Disk {
  id: ID!
  size: Int!
  Host: Host!
}

type DNS {
  id: ID!
  hclId: String!
  type: String!
  rootDomain: String!
  dnsServers: [String]!
  ntpServers: [String]!
  config: [configMap]
  Environments: [Environment]!
  Competitions: [Competition]!
}

type DNSRecord {
  id: ID!
  hclId: String!
  name: String!
  values: [String]!
  type: String!
  zone: String!
  vars: [varsMap]!
  disabled: Boolean!
  tags: [tagMap]!
  Environment: Environment!
}

type Environment {
  id: ID!
  hclId: String!
  competitionId: String!
  name: String!
  description: String!
  builder: String!
  teamCount: Int!
  revision: Int!
  adminCidrs: [String]!
  exposedVdiPorts: [String]!
  config: [configMap]
  tags: [tagMap]
  Users: [User]!
  Hosts: [Host]!
  Competitions: [Competition]!
  Identities: [Identity]!
  Commands: [Command]!
  Scripts: [Script]!
  FileDownloads: [FileDownload]!
  FileDeletes: [FileDelete]!
  FileExtracts: [FileExtract]!
  IncludedNetworks: [IncludedNetwork]!
  Findings: [Finding]!
  DNSRecords: [DNSRecord]!
  DNS: [DNS]!
  Networks: [Network]!
  HostDependencies: [HostDependency]!
  Ansibles: [Ansible]!
  ScheduledSteps: [ScheduledStep]!
  Builds: [Build]!
  Repositories: [Repository]!
  ServerTasks: [ServerTask]!
}

type FileDelete {
  id: ID!
  hclId: String!
  path: String!
  tags: [tagMap]!
  Environment: Environment!
}

type FileDownload {
  id: ID!
  hclId: String!
  sourceType: String!
  source: String!
  destination: String!
  template: Boolean!
  perms: String!
  disabled: Boolean!
  md5: String!
  absPath: String!
  tags: [tagMap]!
  Environment: Environment!
}

type FileExtract {
  id: ID!
  hclId: String!
  source: String!
  destination: String!
  type: String!
  tags: [tagMap]!
  Environment: Environment!
}

type Finding {
  id: ID!
  name: String!
  description: String!
  severity: FindingSeverity!
  difficulty: FindingDifficulty!
  tags: [tagMap]!
  Users: [User]!
  Host: Host
  Script: Script
  Environment: Environment
}

type GinFileMiddleware {
  id: ID!
  urlId: String!
  filePath: String!
  accessed: Boolean!
  ProvisionedHost: ProvisionedHost
  ProvisioningStep: ProvisioningStep
  ProvisioningScheduledStep: ProvisioningScheduledStep
}

type Host {
  id: ID!
  hclId: String!
  hostname: String!
  description: String!
  OS: String!
  lastOctet: Int!
  instanceSize: String!
  allowMacChanges: Boolean!
  exposedTcpPorts: [String]!
  exposedUdpPorts: [String]!
  overridePassword: String!
  vars: [varsMap]
  userGroups: [String]!
  provisionSteps: [String]!
  tags: [tagMap]!
  Disk: Disk!
  Users: [User]!
  Environment: Environment!
  IncludedNetworks: [IncludedNetwork]!
  DependOnHostDependencies: [HostDependency]!
  RequiredByHostDependencies: [HostDependency]!
}

type HostDependency {
  id: ID!
  hostId: String!
  networkId: String!
  RequiredBy: Host
  DependOnHost: Host
  DependOnNetwork: Network
  Environment: Environment
}

type Identity {
  id: ID!
  hclid: String!
  firstName: String!
  lastName: String!
  email: String!
  password: String!
  description: String!
  avatarFile: String!
  vars: [varsMap]!
  tags: [tagMap]!
  Environment: Environment!
}

type IncludedNetwork {
  id: ID!
  name: String!
  includedHosts: [String]!
  Tags: [Tag]!
  Hosts: [Host]!
  Network: Network
  Environments: [Environment]!
}

type Network {
  id: ID!
  hclId: String!
  name: String!
  cidr: String!
  vdiVisible: Boolean!
  vars: [varsMap]
  tags: [tagMap]!
  Environment: Environment!
  HostDependencies: [HostDependency]!
  IncludedNetworks: [IncludedNetwork]!
}

type Plan {
  id: ID!
  stepNumber: Int!
  type: PlanType!
  NextPlans: [Plan]!
  PrevPlans: [Plan]!
  Build: Build
  Team: Team
  ProvisionedNetwork: ProvisionedNetwork
  ProvisionedHost: ProvisionedHost
  ProvisioningStep: ProvisioningStep
  ProvisioningScheduledStep: ProvisioningScheduledStep
  Status: Status!
  PlanDiffs: [PlanDiff]!
}

type PlanDiff {
  id: ID!
  revision: Int!
  newState: ProvisionStatus!
  BuildCommit: BuildCommit!
  Plan: Plan!
}

type ProvisionedHost {
  id: ID!
  subnetIp: String!
  addonType: ProvisionedHostAddonType
  vars: [varsMap]
  Status: Status!
  ProvisionedNetwork: ProvisionedNetwork!
  Host: Host!
  EndStepPlan: Plan
  Build: Build!
  ProvisioningSteps: [ProvisioningStep]!
  ProvisioningScheduledSteps: [ProvisioningScheduledStep]!
  AgentStatus: AgentStatus
  AgentTasks: [AgentTask]!
  Plan: Plan!
  GinFileMiddleware: GinFileMiddleware
}

type ProvisionedNetwork {
  id: ID!
  name: String!
  cidr: String!
  vars: [varsMap]
  Status: Status
  Network: Network
  Build: Build
  Team: Team
  ProvisionedHosts: [ProvisionedHost]!
  Plan: Plan
}

type ProvisioningScheduledStep {
  id: ID!
  type: ProvisioningScheduledStepType!
  runTime: Time!
  Status: Status
  ScheduledStep: ScheduledStep!
  ProvisionedHost: ProvisionedHost!
  Script: Script
  Command: Command
  DNSRecord: DNSRecord
  FileDelete: FileDelete
  FileDownload: FileDownload
  FileExtract: FileExtract
  Ansible: Ansible
  AgentTasks: [AgentTask]!
  Plan: Plan
  GinFileMiddleware: GinFileMiddleware
}

type ProvisioningStep {
  id: ID!
  type: ProvisioningStepType!
  stepNumber: Int!
  Status: Status
  ProvisionedHost: ProvisionedHost!
  Script: Script
  Command: Command
  DNSRecord: DNSRecord
  FileDelete: FileDelete
  FileDownload: FileDownload
  FileExtract: FileExtract
  Ansible: Ansible
  Plan: Plan
  AgentTasks: [AgentTask]!
  GinFileMiddleware: GinFileMiddleware
}

type RepoCommit {
  id: ID!
  revision: Int!
  hash: String!
  author: String!
  committer: String!
  pgpSignature: String!
  message: String!
  treeHash: String!
  parentHashes: [String]!
  Repository: Repository!
}

type Repository {
  id: ID!
  repoUrl: String!
  branchName: String!
  environmentFilepath: String!
  Environments: [Environment]!
  RepoCommits: [RepoCommit]!
}

type ScheduledStep {
  id: ID!
  hclId: String!
  name: String!
  description: String!
  step: String!
  type: ScheduledStepType!
  schedule: String
  runAt: Int
  Environment: Environment
}

type Script {
  id: ID!
  hclId: String!
  name: String!
  language: String!
  description: String!
  source: String!
  sourceType: String!
  cooldown: Int!
  timeout: Int!
  ignoreErrors: Boolean!
  args: [String]!
  disabled: Boolean!
  vars: [varsMap]
  absPath: String!
  tags: [tagMap]
  Users: [User]!
  Findings: [Finding]!
  Environment: Environment!
}

type ServerTask {
  id: ID!
  type: ServerTaskType!
  startTime: Time
  endTime: Time
  errors: [String]
  logFilePath: String
  AuthUser: AuthUser!
  Status: Status!
  Environment: Environment
  Build: Build
  BuildCommit: BuildCommit
  GinFileMiddleware: [GinFileMiddleware]!
}

type Status {
  id: ID!
  state: ProvisionStatus!
  statusFor: ProvisionStatusFor!
  startedAt: String!
  endedAt: String!
  failed: Boolean!
  completed: Boolean!
  error: String
  Build: Build
  ProvisionedNetwork: ProvisionedNetwork
  ProvisionedHost: ProvisionedHost
  ProvisioningStep: ProvisioningStep
  Team: Team
  Plan: Plan
  ServerTask: ServerTask
  AdhocPlan: AdhocPlan
  ProvisioningScheduledStep: ProvisioningScheduledStep
}

type Tag {
  id: ID!
  uuid: ID!
  name: String!
  description: [tagMap]!
}

type Team {
  id: ID!
  teamNumber: Int!
  Build: Build!
  Status: Status
  ProvisionedNetworks: [ProvisionedNetwork]!
  Plan: Plan!
}

type User {
  id: ID!
  hclId: ID!
  name: String!
  uuid: String!
  email: String!
  Tag: [Tag]!
  Environments: [Environment]!
}

type LaForgePageInfo {
  total: Int!
  nextOffset: Int!
}

type AgentStatusBatch {
  agentStatuses: [AgentStatus]!
  pageInfo: LaForgePageInfo!
}

type StatusBatch {
  statuses: [Status]!
  pageInfo: LaForgePageInfo!
}

type PlanCounts {
  planning: Int!
  awaiting: Int!
  parentAwaiting: Int!
  inProgress: Int!
  failed: Int!
  complete: Int!
  tainted: Int!
  undefined: Int!
  toDelete: Int!
  deleteInProgress: Int!
  deleted: Int!
  toRebuild: Int!
  cancelled: Int!
}

# TODO: Can use on INPUT_FIELD_DEFINITION if wanna have auth on a per variable level
directive @hasRole(roles: [RoleLevel!]!) on FIELD_DEFINITION

type Query {
  environments: [Environment] @hasRole(roles: [ADMIN, USER])
  environment(envUUID: String!): Environment @hasRole(roles: [ADMIN, USER])
  provisionedHost(proHostUUID: String!): ProvisionedHost
    @hasRole(roles: [ADMIN, USER])
  provisionedNetwork(proNetUUID: String!): ProvisionedNetwork
    @hasRole(roles: [ADMIN, USER])
  provisionedStep(proStepUUID: String!): ProvisioningStep
    @hasRole(roles: [ADMIN, USER])
  plan(planUUID: String!): Plan @hasRole(roles: [ADMIN, USER])
  getBuilds: [Build] @hasRole(roles: [ADMIN, USER])
  build(buildUUID: String!): Build @hasRole(roles: [ADMIN, USER])
  getBuildCommits(envUUID: String!): [BuildCommit]
    @hasRole(roles: [ADMIN, USER])
  getBuildCommit(buildCommitUUID: String!): BuildCommit
    @hasRole(roles: [ADMIN, USER])
  status(statusUUID: String!): Status @hasRole(roles: [ADMIN, USER])
  agentStatus(clientId: String!): AgentStatus @hasRole(roles: [ADMIN, USER])
  getServerTasks: [ServerTask] @hasRole(roles: [ADMIN, USER])
  currentUser: AuthUser @hasRole(roles: [ADMIN, USER])
  getUserList: [AuthUser] @hasRole(roles: [ADMIN])
  getCurrentUserTasks: [ServerTask] @hasRole(roles: [ADMIN, USER])
  getAgentTasks(proStepUUID: String!): [AgentTask]
    @hasRole(roles: [ADMIN, USER])
  listAgentStatuses(buildUUID: String!): [AgentStatus]
    @hasRole(roles: [ADMIN, USER])
  listBuildStatuses(buildUUID: String!): [Status] @hasRole(roles: [ADMIN, USER])
  getAllAgentStatus(
    buildUUID: String!
    count: Int!
    offset: Int!
  ): AgentStatusBatch @hasRole(roles: [ADMIN, USER])
  getAllPlanStatus(buildUUID: String!, count: Int!, offset: Int!): StatusBatch
    @hasRole(roles: [ADMIN, USER])
  getPlanStatusCounts(buildUUID: String!): PlanCounts!
    @hasRole(roles: [ADMIN, USER])
  viewServerTaskLogs(taskID: String!): String! @hasRole(roles: [ADMIN, USER])
  viewAgentTask(taskID: String!): AgentTask! @hasRole(roles: [ADMIN, USER])
  serverTasks(taskUUIDs: [String]!): [ServerTask] @hasRole(roles: [ADMIN, USER])
}

type Mutation {
  loadEnvironment(envFilePath: String!): [Environment]
    @hasRole(roles: [ADMIN, USER])
  createBuild(envUUID: String!, renderFiles: Boolean! = true): Build
    @hasRole(roles: [ADMIN, USER])
  deleteUser(userUUID: String!): Boolean! @hasRole(roles: [ADMIN, USER])
  executePlan(buildUUID: String!): Build @hasRole(roles: [ADMIN, USER])
  deleteBuild(buildUUID: String!): String! @hasRole(roles: [ADMIN, USER]) # returns the build commit uuid of delete commit
  createTask(
    proHostUUID: String!
    command: AgentCommand!
    args: String!
  ): Boolean! @hasRole(roles: [ADMIN, USER])
  dumpBuild(buildUUID: String!): String! @hasRole(roles: [ADMIN, USER])
  rebuild(rootPlans: [String]!): Boolean! @hasRole(roles: [ADMIN, USER])
  approveCommit(commitUUID: String!): Boolean! @hasRole(roles: [ADMIN, USER])
  cancelCommit(commitUUID: String!): Boolean! @hasRole(roles: [ADMIN, USER])

  # createAdhoc(rootPlans: [AdhocPlan]!): Boolean!

  createAgentTasks(
    hostHCLID: String!
    command: AgentCommand!
    buildUUID: String!
    args: [String!]!
    teams: [Int!]!
  ): [AgentTask]! @hasRole(roles: [ADMIN, USER])

  createBatchAgentTasks(
    proHostUUIDs: [String!]!
    command: AgentCommand!
    args: [String!]!
  ): [AgentTask]! @hasRole(roles: [ADMIN, USER])

  createEnviromentFromRepo(
    repoURL: String!
    branchName: String! = "master"
    envFilePath: String!
  ): [Environment]! @hasRole(roles: [ADMIN, USER])

  updateEnviromentViaPull(envUUID: String!): [Environment]!
    @hasRole(roles: [ADMIN, USER])

  cancelBuild(buildUUID: String!): Boolean! @hasRole(roles: [ADMIN, USER])

  # User Info
  modifySelfPassword(currentPassword: String!, newPassword: String!): Boolean!
    @hasRole(roles: [ADMIN, USER])
  modifySelfUserInfo(
    firstName: String
    lastName: String
    email: String
    phone: String
    company: String
    occupation: String
  ): AuthUser @hasRole(roles: [ADMIN, USER])

  # User Admin Stuff
  createUser(
    username: String!
    password: String!
    role: RoleLevel!
    provider: ProviderType!
  ): AuthUser @hasRole(roles: [ADMIN])
  modifyAdminUserInfo(
    userID: String!
    username: String
    firstName: String
    lastName: String
    email: String
    phone: String
    company: String
    occupation: String
    role: RoleLevel
    provider: ProviderType
  ): AuthUser @hasRole(roles: [ADMIN])
  modifyAdminPassword(userID: String!, newPassword: String!): Boolean!
    @hasRole(roles: [ADMIN])

  nukeBackend: [intMap]! @hasRole(roles: [ADMIN])
}

type Subscription {
  updatedAgentStatus: AgentStatus! @hasRole(roles: [ADMIN, USER])
  updatedStatus: Status! @hasRole(roles: [ADMIN, USER])
  updatedServerTask: ServerTask! @hasRole(roles: [ADMIN, USER])
  updatedBuild: Build! @hasRole(roles: [ADMIN, USER])
  updatedCommit: BuildCommit! @hasRole(roles: [ADMIN, USER])
  updatedAgentTask: AgentTask! @hasRole(roles: [ADMIN, USER])
  streamServerTaskLog(taskID: String!): String! @hasRole(roles: [ADMIN, USER])
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_hasRole_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []model.RoleLevel
	if tmp, ok := rawArgs["roles"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roles"))
		arg0, err = ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["roles"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_approveCommit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["commitUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commitUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["commitUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cancelBuild_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["buildUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cancelCommit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["commitUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commitUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["commitUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createAgentTasks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["hostHCLID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostHCLID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hostHCLID"] = arg0
	var arg1 model.AgentCommand
	if tmp, ok := rawArgs["command"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("command"))
		arg1, err = ec.unmarshalNAgentCommand2githubcomgen0cidelaforgegraphqlgraphmodelAgentCommand(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["command"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["buildUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildUUID"))
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildUUID"] = arg2
	var arg3 []string
	if tmp, ok := rawArgs["args"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("args"))
		arg3, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["args"] = arg3
	var arg4 []int
	if tmp, ok := rawArgs["teams"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teams"))
		arg4, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["teams"] = arg4
	return args, nil
}

func (ec *executionContext) field_Mutation_createBatchAgentTasks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["proHostUUIDs"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proHostUUIDs"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["proHostUUIDs"] = arg0
	var arg1 model.AgentCommand
	if tmp, ok := rawArgs["command"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("command"))
		arg1, err = ec.unmarshalNAgentCommand2githubcomgen0cidelaforgegraphqlgraphmodelAgentCommand(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["command"] = arg1
	var arg2 []string
	if tmp, ok := rawArgs["args"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("args"))
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["args"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_createBuild_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["envUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("envUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["envUUID"] = arg0
	var arg1 bool
	if tmp, ok := rawArgs["renderFiles"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("renderFiles"))
		arg1, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["renderFiles"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createEnviromentFromRepo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["repoURL"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoURL"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["repoURL"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["branchName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("branchName"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["branchName"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["envFilePath"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("envFilePath"))
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["envFilePath"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_createTask_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["proHostUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proHostUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["proHostUUID"] = arg0
	var arg1 model.AgentCommand
	if tmp, ok := rawArgs["command"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("command"))
		arg1, err = ec.unmarshalNAgentCommand2githubcomgen0cidelaforgegraphqlgraphmodelAgentCommand(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["command"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["args"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("args"))
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["args"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_createUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["username"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["username"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["password"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["password"] = arg1
	var arg2 model.RoleLevel
	if tmp, ok := rawArgs["role"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
		arg2, err = ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["role"] = arg2
	var arg3 model.ProviderType
	if tmp, ok := rawArgs["provider"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("provider"))
		arg3, err = ec.unmarshalNProviderType2githubcomgen0cidelaforgegraphqlgraphmodelProviderType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["provider"] = arg3
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteBuild_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["buildUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_dumpBuild_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["buildUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_executePlan_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["buildUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_loadEnvironment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["envFilePath"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("envFilePath"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["envFilePath"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_modifyAdminPassword_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["newPassword"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newPassword"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["newPassword"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_modifyAdminUserInfo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userID"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["username"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["username"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["firstName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firstName"))
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["firstName"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["lastName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastName"))
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["lastName"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["email"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["email"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["phone"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("phone"))
		arg5, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["phone"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["company"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("company"))
		arg6, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["company"] = arg6
	var arg7 *string
	if tmp, ok := rawArgs["occupation"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("occupation"))
		arg7, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["occupation"] = arg7
	var arg8 *model.RoleLevel
	if tmp, ok := rawArgs["role"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
		arg8, err = ec.unmarshalORoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["role"] = arg8
	var arg9 *model.ProviderType
	if tmp, ok := rawArgs["provider"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("provider"))
		arg9, err = ec.unmarshalOProviderType2githubcomgen0cidelaforgegraphqlgraphmodelProviderType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["provider"] = arg9
	return args, nil
}

func (ec *executionContext) field_Mutation_modifySelfPassword_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["currentPassword"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currentPassword"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["currentPassword"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["newPassword"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newPassword"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["newPassword"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_modifySelfUserInfo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["firstName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firstName"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["firstName"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["lastName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastName"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["lastName"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["email"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["email"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["phone"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("phone"))
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["phone"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["company"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("company"))
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["company"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["occupation"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("occupation"))
		arg5, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["occupation"] = arg5
	return args, nil
}

func (ec *executionContext) field_Mutation_rebuild_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*string
	if tmp, ok := rawArgs["rootPlans"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rootPlans"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["rootPlans"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateEnviromentViaPull_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["envUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("envUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["envUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_agentStatus_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["clientId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_build_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["buildUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_environment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["envUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("envUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["envUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getAgentTasks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["proStepUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proStepUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["proStepUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getAllAgentStatus_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["buildUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildUUID"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["count"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("count"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["count"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg2, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_getAllPlanStatus_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["buildUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildUUID"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["count"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("count"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["count"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg2, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_getBuildCommit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["buildCommitUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildCommitUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildCommitUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getBuildCommits_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["envUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("envUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["envUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getPlanStatusCounts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["buildUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_listAgentStatuses_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["buildUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_listBuildStatuses_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["buildUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_plan_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["planUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("planUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["planUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_provisionedHost_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["proHostUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proHostUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["proHostUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_provisionedNetwork_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["proNetUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proNetUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["proNetUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_provisionedStep_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["proStepUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proStepUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["proStepUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_serverTasks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*string
	if tmp, ok := rawArgs["taskUUIDs"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskUUIDs"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskUUIDs"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_status_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["statusUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["statusUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_viewAgentTask_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_viewServerTaskLogs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_streamServerTaskLog_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskID"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AdhocPlan_id(ctx context.Context, field graphql.CollectedField, obj *ent.AdhocPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdhocPlan_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AdhocPlan().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdhocPlan_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdhocPlan",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdhocPlan_NextAdhocPlans(ctx context.Context, field graphql.CollectedField, obj *ent.AdhocPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdhocPlan_NextAdhocPlans(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextAdhocPlans(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.AdhocPlan)
	fc.Result = res
	return ec.marshalOAdhocPlan2githubcomgen0cidelaforgeentAdhocPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdhocPlan_NextAdhocPlans(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdhocPlan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AdhocPlan_id(ctx, field)
			case "NextAdhocPlans":
				return ec.fieldContext_AdhocPlan_NextAdhocPlans(ctx, field)
			case "PrevAdhocPlans":
				return ec.fieldContext_AdhocPlan_PrevAdhocPlans(ctx, field)
			case "Build":
				return ec.fieldContext_AdhocPlan_Build(ctx, field)
			case "Status":
				return ec.fieldContext_AdhocPlan_Status(ctx, field)
			case "AgentTask":
				return ec.fieldContext_AdhocPlan_AgentTask(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdhocPlan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdhocPlan_PrevAdhocPlans(ctx context.Context, field graphql.CollectedField, obj *ent.AdhocPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdhocPlan_PrevAdhocPlans(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrevAdhocPlans(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.AdhocPlan)
	fc.Result = res
	return ec.marshalOAdhocPlan2githubcomgen0cidelaforgeentAdhocPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdhocPlan_PrevAdhocPlans(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdhocPlan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AdhocPlan_id(ctx, field)
			case "NextAdhocPlans":
				return ec.fieldContext_AdhocPlan_NextAdhocPlans(ctx, field)
			case "PrevAdhocPlans":
				return ec.fieldContext_AdhocPlan_PrevAdhocPlans(ctx, field)
			case "Build":
				return ec.fieldContext_AdhocPlan_Build(ctx, field)
			case "Status":
				return ec.fieldContext_AdhocPlan_Status(ctx, field)
			case "AgentTask":
				return ec.fieldContext_AdhocPlan_AgentTask(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdhocPlan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdhocPlan_Build(ctx context.Context, field graphql.CollectedField, obj *ent.AdhocPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdhocPlan_Build(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Build(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Build)
	fc.Result = res
	return ec.marshalNBuild2githubcomgen0cidelaforgeentBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdhocPlan_Build(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdhocPlan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdhocPlan_Status(ctx context.Context, field graphql.CollectedField, obj *ent.AdhocPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdhocPlan_Status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Status)
	fc.Result = res
	return ec.marshalNStatus2githubcomgen0cidelaforgeentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdhocPlan_Status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdhocPlan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdhocPlan_AgentTask(ctx context.Context, field graphql.CollectedField, obj *ent.AdhocPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdhocPlan_AgentTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentTask(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.AgentTask)
	fc.Result = res
	return ec.marshalNAgentTask2githubcomgen0cidelaforgeentAgentTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdhocPlan_AgentTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdhocPlan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AgentTask_id(ctx, field)
			case "args":
				return ec.fieldContext_AgentTask_args(ctx, field)
			case "command":
				return ec.fieldContext_AgentTask_command(ctx, field)
			case "number":
				return ec.fieldContext_AgentTask_number(ctx, field)
			case "output":
				return ec.fieldContext_AgentTask_output(ctx, field)
			case "state":
				return ec.fieldContext_AgentTask_state(ctx, field)
			case "errorMessage":
				return ec.fieldContext_AgentTask_errorMessage(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_AgentTask_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_AgentTask_ProvisioningScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentTask_ProvisionedHost(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_AgentTask_AdhocPlans(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_clientId(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_clientId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_clientId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_hostname(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_hostname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hostname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_hostname(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_upTime(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_upTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_upTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_bootTime(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_bootTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BootTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_bootTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_numProcs(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_numProcs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumProcs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_numProcs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_OS(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_OS(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Os, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_OS(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_hostID(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_hostID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_hostID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_load1(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_load1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Load1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_load1(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_load5(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_load5(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Load5, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_load5(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_load15(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_load15(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Load15, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_load15(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_totalMem(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_totalMem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalMem, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_totalMem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_freeMem(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_freeMem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FreeMem, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_freeMem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_usedMem(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_usedMem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UsedMem, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_usedMem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_timestamp(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_ProvisionedHost(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_ProvisionedHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedHost(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedHost)
	fc.Result = res
	return ec.marshalOProvisionedHost2githubcomgen0cidelaforgeentProvisionedHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_ProvisionedHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedHost_id(ctx, field)
			case "subnetIp":
				return ec.fieldContext_ProvisionedHost_subnetIp(ctx, field)
			case "addonType":
				return ec.fieldContext_ProvisionedHost_addonType(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedHost_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedHost_Status(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_ProvisionedHost_ProvisionedNetwork(ctx, field)
			case "Host":
				return ec.fieldContext_ProvisionedHost_Host(ctx, field)
			case "EndStepPlan":
				return ec.fieldContext_ProvisionedHost_EndStepPlan(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedHost_Build(ctx, field)
			case "ProvisioningSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningSteps(ctx, field)
			case "ProvisioningScheduledSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningScheduledSteps(ctx, field)
			case "AgentStatus":
				return ec.fieldContext_ProvisionedHost_AgentStatus(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisionedHost_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedHost_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisionedHost_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedHost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_ProvisionedNetwork(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_ProvisionedNetwork(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedNetwork(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedNetwork)
	fc.Result = res
	return ec.marshalOProvisionedNetwork2githubcomgen0cidelaforgeentProvisionedNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_ProvisionedNetwork(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedNetwork_id(ctx, field)
			case "name":
				return ec.fieldContext_ProvisionedNetwork_name(ctx, field)
			case "cidr":
				return ec.fieldContext_ProvisionedNetwork_cidr(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedNetwork_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedNetwork_Status(ctx, field)
			case "Network":
				return ec.fieldContext_ProvisionedNetwork_Network(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedNetwork_Build(ctx, field)
			case "Team":
				return ec.fieldContext_ProvisionedNetwork_Team(ctx, field)
			case "ProvisionedHosts":
				return ec.fieldContext_ProvisionedNetwork_ProvisionedHosts(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedNetwork_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedNetwork", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_Build(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_Build(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Build(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Build)
	fc.Result = res
	return ec.marshalOBuild2githubcomgen0cidelaforgeentBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_Build(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatusBatch_agentStatuses(ctx context.Context, field graphql.CollectedField, obj *model.AgentStatusBatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatusBatch_agentStatuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentStatuses, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.AgentStatus)
	fc.Result = res
	return ec.marshalNAgentStatus2githubcomgen0cidelaforgeentAgentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatusBatch_agentStatuses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatusBatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "clientId":
				return ec.fieldContext_AgentStatus_clientId(ctx, field)
			case "hostname":
				return ec.fieldContext_AgentStatus_hostname(ctx, field)
			case "upTime":
				return ec.fieldContext_AgentStatus_upTime(ctx, field)
			case "bootTime":
				return ec.fieldContext_AgentStatus_bootTime(ctx, field)
			case "numProcs":
				return ec.fieldContext_AgentStatus_numProcs(ctx, field)
			case "OS":
				return ec.fieldContext_AgentStatus_OS(ctx, field)
			case "hostID":
				return ec.fieldContext_AgentStatus_hostID(ctx, field)
			case "load1":
				return ec.fieldContext_AgentStatus_load1(ctx, field)
			case "load5":
				return ec.fieldContext_AgentStatus_load5(ctx, field)
			case "load15":
				return ec.fieldContext_AgentStatus_load15(ctx, field)
			case "totalMem":
				return ec.fieldContext_AgentStatus_totalMem(ctx, field)
			case "freeMem":
				return ec.fieldContext_AgentStatus_freeMem(ctx, field)
			case "usedMem":
				return ec.fieldContext_AgentStatus_usedMem(ctx, field)
			case "timestamp":
				return ec.fieldContext_AgentStatus_timestamp(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentStatus_ProvisionedHost(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_AgentStatus_ProvisionedNetwork(ctx, field)
			case "Build":
				return ec.fieldContext_AgentStatus_Build(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatusBatch_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.AgentStatusBatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatusBatch_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.LaForgePageInfo)
	fc.Result = res
	return ec.marshalNLaForgePageInfo2githubcomgen0cidelaforgegraphqlgraphmodelLaForgePageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatusBatch_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatusBatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_LaForgePageInfo_total(ctx, field)
			case "nextOffset":
				return ec.fieldContext_LaForgePageInfo_nextOffset(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LaForgePageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentTask_id(ctx context.Context, field graphql.CollectedField, obj *ent.AgentTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentTask_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AgentTask().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentTask_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentTask_args(ctx context.Context, field graphql.CollectedField, obj *ent.AgentTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentTask_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentTask_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentTask_command(ctx context.Context, field graphql.CollectedField, obj *ent.AgentTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentTask_command(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AgentTask().Command(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AgentCommand)
	fc.Result = res
	return ec.marshalNAgentCommand2githubcomgen0cidelaforgegraphqlgraphmodelAgentCommand(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentTask_command(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AgentCommand does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentTask_number(ctx context.Context, field graphql.CollectedField, obj *ent.AgentTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentTask_number(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Number, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentTask_number(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentTask_output(ctx context.Context, field graphql.CollectedField, obj *ent.AgentTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentTask_output(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Output, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentTask_output(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentTask_state(ctx context.Context, field graphql.CollectedField, obj *ent.AgentTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentTask_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AgentTask().State(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AgentTaskState)
	fc.Result = res
	return ec.marshalNAgentTaskState2githubcomgen0cidelaforgegraphqlgraphmodelAgentTaskState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentTask_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AgentTaskState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentTask_errorMessage(ctx context.Context, field graphql.CollectedField, obj *ent.AgentTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentTask_errorMessage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorMessage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentTask_errorMessage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentTask_ProvisioningStep(ctx context.Context, field graphql.CollectedField, obj *ent.AgentTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentTask_ProvisioningStep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisioningStep(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisioningStep)
	fc.Result = res
	return ec.marshalOProvisioningStep2githubcomgen0cidelaforgeentProvisioningStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentTask_ProvisioningStep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisioningStep_id(ctx, field)
			case "type":
				return ec.fieldContext_ProvisioningStep_type(ctx, field)
			case "stepNumber":
				return ec.fieldContext_ProvisioningStep_stepNumber(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisioningStep_Status(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_ProvisioningStep_ProvisionedHost(ctx, field)
			case "Script":
				return ec.fieldContext_ProvisioningStep_Script(ctx, field)
			case "Command":
				return ec.fieldContext_ProvisioningStep_Command(ctx, field)
			case "DNSRecord":
				return ec.fieldContext_ProvisioningStep_DNSRecord(ctx, field)
			case "FileDelete":
				return ec.fieldContext_ProvisioningStep_FileDelete(ctx, field)
			case "FileDownload":
				return ec.fieldContext_ProvisioningStep_FileDownload(ctx, field)
			case "FileExtract":
				return ec.fieldContext_ProvisioningStep_FileExtract(ctx, field)
			case "Ansible":
				return ec.fieldContext_ProvisioningStep_Ansible(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisioningStep_Plan(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisioningStep_AgentTasks(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisioningStep_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisioningStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentTask_ProvisioningScheduledStep(ctx context.Context, field graphql.CollectedField, obj *ent.AgentTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentTask_ProvisioningScheduledStep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisioningScheduledStep(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisioningScheduledStep)
	fc.Result = res
	return ec.marshalOProvisioningScheduledStep2githubcomgen0cidelaforgeentProvisioningScheduledStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentTask_ProvisioningScheduledStep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisioningScheduledStep_id(ctx, field)
			case "type":
				return ec.fieldContext_ProvisioningScheduledStep_type(ctx, field)
			case "runTime":
				return ec.fieldContext_ProvisioningScheduledStep_runTime(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisioningScheduledStep_Status(ctx, field)
			case "ScheduledStep":
				return ec.fieldContext_ProvisioningScheduledStep_ScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_ProvisioningScheduledStep_ProvisionedHost(ctx, field)
			case "Script":
				return ec.fieldContext_ProvisioningScheduledStep_Script(ctx, field)
			case "Command":
				return ec.fieldContext_ProvisioningScheduledStep_Command(ctx, field)
			case "DNSRecord":
				return ec.fieldContext_ProvisioningScheduledStep_DNSRecord(ctx, field)
			case "FileDelete":
				return ec.fieldContext_ProvisioningScheduledStep_FileDelete(ctx, field)
			case "FileDownload":
				return ec.fieldContext_ProvisioningScheduledStep_FileDownload(ctx, field)
			case "FileExtract":
				return ec.fieldContext_ProvisioningScheduledStep_FileExtract(ctx, field)
			case "Ansible":
				return ec.fieldContext_ProvisioningScheduledStep_Ansible(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisioningScheduledStep_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisioningScheduledStep_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisioningScheduledStep_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisioningScheduledStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentTask_ProvisionedHost(ctx context.Context, field graphql.CollectedField, obj *ent.AgentTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentTask_ProvisionedHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedHost(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedHost)
	fc.Result = res
	return ec.marshalNProvisionedHost2githubcomgen0cidelaforgeentProvisionedHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentTask_ProvisionedHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedHost_id(ctx, field)
			case "subnetIp":
				return ec.fieldContext_ProvisionedHost_subnetIp(ctx, field)
			case "addonType":
				return ec.fieldContext_ProvisionedHost_addonType(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedHost_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedHost_Status(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_ProvisionedHost_ProvisionedNetwork(ctx, field)
			case "Host":
				return ec.fieldContext_ProvisionedHost_Host(ctx, field)
			case "EndStepPlan":
				return ec.fieldContext_ProvisionedHost_EndStepPlan(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedHost_Build(ctx, field)
			case "ProvisioningSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningSteps(ctx, field)
			case "ProvisioningScheduledSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningScheduledSteps(ctx, field)
			case "AgentStatus":
				return ec.fieldContext_ProvisionedHost_AgentStatus(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisionedHost_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedHost_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisionedHost_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedHost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentTask_AdhocPlans(ctx context.Context, field graphql.CollectedField, obj *ent.AgentTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentTask_AdhocPlans(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdhocPlans(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.AdhocPlan)
	fc.Result = res
	return ec.marshalOAdhocPlan2githubcomgen0cidelaforgeentAdhocPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentTask_AdhocPlans(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AdhocPlan_id(ctx, field)
			case "NextAdhocPlans":
				return ec.fieldContext_AdhocPlan_NextAdhocPlans(ctx, field)
			case "PrevAdhocPlans":
				return ec.fieldContext_AdhocPlan_PrevAdhocPlans(ctx, field)
			case "Build":
				return ec.fieldContext_AdhocPlan_Build(ctx, field)
			case "Status":
				return ec.fieldContext_AdhocPlan_Status(ctx, field)
			case "AgentTask":
				return ec.fieldContext_AdhocPlan_AgentTask(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdhocPlan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ansible_id(ctx context.Context, field graphql.CollectedField, obj *ent.Ansible) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ansible_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Ansible().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ansible_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ansible",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ansible_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.Ansible) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ansible_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ansible_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ansible",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ansible_name(ctx context.Context, field graphql.CollectedField, obj *ent.Ansible) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ansible_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ansible_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ansible",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ansible_description(ctx context.Context, field graphql.CollectedField, obj *ent.Ansible) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ansible_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ansible_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ansible",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ansible_source(ctx context.Context, field graphql.CollectedField, obj *ent.Ansible) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ansible_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ansible_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ansible",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ansible_playbookName(ctx context.Context, field graphql.CollectedField, obj *ent.Ansible) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ansible_playbookName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlaybookName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ansible_playbookName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ansible",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ansible_method(ctx context.Context, field graphql.CollectedField, obj *ent.Ansible) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ansible_method(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Ansible().Method(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AnsibleMethod)
	fc.Result = res
	return ec.marshalNAnsibleMethod2githubcomgen0cidelaforgegraphqlgraphmodelAnsibleMethod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ansible_method(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ansible",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AnsibleMethod does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ansible_inventory(ctx context.Context, field graphql.CollectedField, obj *ent.Ansible) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ansible_inventory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Inventory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ansible_inventory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ansible",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ansible_absPath(ctx context.Context, field graphql.CollectedField, obj *ent.Ansible) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ansible_absPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AbsPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ansible_absPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ansible",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ansible_tags(ctx context.Context, field graphql.CollectedField, obj *ent.Ansible) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ansible_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Ansible().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalOtagMap2githubcomgen0cidelaforgegraphqlgraphmodelTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ansible_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ansible",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ansible_Users(ctx context.Context, field graphql.CollectedField, obj *ent.Ansible) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ansible_Users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.User)
	fc.Result = res
	return ec.marshalOUser2githubcomgen0cidelaforgeentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ansible_Users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ansible",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "hclId":
				return ec.fieldContext_User_hclId(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "uuid":
				return ec.fieldContext_User_uuid(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "Tag":
				return ec.fieldContext_User_Tag(ctx, field)
			case "Environments":
				return ec.fieldContext_User_Environments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ansible_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.Ansible) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ansible_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalOEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ansible_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ansible",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_id(ctx context.Context, field graphql.CollectedField, obj *ent.AuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AuthUser().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_username(ctx context.Context, field graphql.CollectedField, obj *ent.AuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_username(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_firstName(ctx context.Context, field graphql.CollectedField, obj *ent.AuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_firstName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FirstName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_firstName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_lastName(ctx context.Context, field graphql.CollectedField, obj *ent.AuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_lastName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_lastName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_email(ctx context.Context, field graphql.CollectedField, obj *ent.AuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_phone(ctx context.Context, field graphql.CollectedField, obj *ent.AuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_phone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_phone(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_company(ctx context.Context, field graphql.CollectedField, obj *ent.AuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_company(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Company, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_company(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_occupation(ctx context.Context, field graphql.CollectedField, obj *ent.AuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_occupation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Occupation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_occupation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_publicKey(ctx context.Context, field graphql.CollectedField, obj *ent.AuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_publicKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AuthUser().PublicKey(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_publicKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_role(ctx context.Context, field graphql.CollectedField, obj *ent.AuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AuthUser().Role(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.RoleLevel)
	fc.Result = res
	return ec.marshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_role(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RoleLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_provider(ctx context.Context, field graphql.CollectedField, obj *ent.AuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_provider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AuthUser().Provider(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ProviderType)
	fc.Result = res
	return ec.marshalNProviderType2githubcomgen0cidelaforgegraphqlgraphmodelProviderType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_provider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProviderType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_ServerTasks(ctx context.Context, field graphql.CollectedField, obj *ent.AuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_ServerTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServerTasks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ServerTask)
	fc.Result = res
	return ec.marshalOServerTask2githubcomgen0cidelaforgeentServerTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_ServerTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServerTask_id(ctx, field)
			case "type":
				return ec.fieldContext_ServerTask_type(ctx, field)
			case "startTime":
				return ec.fieldContext_ServerTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ServerTask_endTime(ctx, field)
			case "errors":
				return ec.fieldContext_ServerTask_errors(ctx, field)
			case "logFilePath":
				return ec.fieldContext_ServerTask_logFilePath(ctx, field)
			case "AuthUser":
				return ec.fieldContext_ServerTask_AuthUser(ctx, field)
			case "Status":
				return ec.fieldContext_ServerTask_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_ServerTask_Environment(ctx, field)
			case "Build":
				return ec.fieldContext_ServerTask_Build(ctx, field)
			case "BuildCommit":
				return ec.fieldContext_ServerTask_BuildCommit(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ServerTask_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServerTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_id(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Build().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_revision(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_revision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_environmentRevision(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_environmentRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_environmentRevision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_completedPlan(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_completedPlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompletedPlan, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_completedPlan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_Status(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_Status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Status)
	fc.Result = res
	return ec.marshalNStatus2githubcomgen0cidelaforgeentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_Status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_Competition(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_Competition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Competition(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Competition)
	fc.Result = res
	return ec.marshalNCompetition2githubcomgen0cidelaforgeentCompetition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_Competition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Competition_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Competition_hclId(ctx, field)
			case "rootPassword":
				return ec.fieldContext_Competition_rootPassword(ctx, field)
			case "startTime":
				return ec.fieldContext_Competition_startTime(ctx, field)
			case "stopTime":
				return ec.fieldContext_Competition_stopTime(ctx, field)
			case "config":
				return ec.fieldContext_Competition_config(ctx, field)
			case "tags":
				return ec.fieldContext_Competition_tags(ctx, field)
			case "DNS":
				return ec.fieldContext_Competition_DNS(ctx, field)
			case "Environment":
				return ec.fieldContext_Competition_Environment(ctx, field)
			case "Builds":
				return ec.fieldContext_Competition_Builds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Competition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_LatestBuildCommit(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_LatestBuildCommit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestBuildCommit(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.BuildCommit)
	fc.Result = res
	return ec.marshalOBuildCommit2githubcomgen0cidelaforgeentBuildCommit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_LatestBuildCommit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BuildCommit_id(ctx, field)
			case "type":
				return ec.fieldContext_BuildCommit_type(ctx, field)
			case "revision":
				return ec.fieldContext_BuildCommit_revision(ctx, field)
			case "state":
				return ec.fieldContext_BuildCommit_state(ctx, field)
			case "createdAt":
				return ec.fieldContext_BuildCommit_createdAt(ctx, field)
			case "Build":
				return ec.fieldContext_BuildCommit_Build(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_BuildCommit_ServerTasks(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_BuildCommit_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildCommit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_RepoCommit(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_RepoCommit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoCommit(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.RepoCommit)
	fc.Result = res
	return ec.marshalNRepoCommit2githubcomgen0cidelaforgeentRepoCommit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_RepoCommit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RepoCommit_id(ctx, field)
			case "revision":
				return ec.fieldContext_RepoCommit_revision(ctx, field)
			case "hash":
				return ec.fieldContext_RepoCommit_hash(ctx, field)
			case "author":
				return ec.fieldContext_RepoCommit_author(ctx, field)
			case "committer":
				return ec.fieldContext_RepoCommit_committer(ctx, field)
			case "pgpSignature":
				return ec.fieldContext_RepoCommit_pgpSignature(ctx, field)
			case "message":
				return ec.fieldContext_RepoCommit_message(ctx, field)
			case "treeHash":
				return ec.fieldContext_RepoCommit_treeHash(ctx, field)
			case "parentHashes":
				return ec.fieldContext_RepoCommit_parentHashes(ctx, field)
			case "Repository":
				return ec.fieldContext_RepoCommit_Repository(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoCommit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_ProvisionedNetworks(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedNetworks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ProvisionedNetwork)
	fc.Result = res
	return ec.marshalNProvisionedNetwork2githubcomgen0cidelaforgeentProvisionedNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_ProvisionedNetworks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedNetwork_id(ctx, field)
			case "name":
				return ec.fieldContext_ProvisionedNetwork_name(ctx, field)
			case "cidr":
				return ec.fieldContext_ProvisionedNetwork_cidr(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedNetwork_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedNetwork_Status(ctx, field)
			case "Network":
				return ec.fieldContext_ProvisionedNetwork_Network(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedNetwork_Build(ctx, field)
			case "Team":
				return ec.fieldContext_ProvisionedNetwork_Team(ctx, field)
			case "ProvisionedHosts":
				return ec.fieldContext_ProvisionedNetwork_ProvisionedHosts(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedNetwork_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedNetwork", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_Teams(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_Teams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Teams(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Team)
	fc.Result = res
	return ec.marshalNTeam2githubcomgen0cidelaforgeentTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_Teams(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "teamNumber":
				return ec.fieldContext_Team_teamNumber(ctx, field)
			case "Build":
				return ec.fieldContext_Team_Build(ctx, field)
			case "Status":
				return ec.fieldContext_Team_Status(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Team_ProvisionedNetworks(ctx, field)
			case "Plan":
				return ec.fieldContext_Team_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_Plans(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_Plans(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plans(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Plan)
	fc.Result = res
	return ec.marshalNPlan2githubcomgen0cidelaforgeentPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_Plans(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Plan_id(ctx, field)
			case "stepNumber":
				return ec.fieldContext_Plan_stepNumber(ctx, field)
			case "type":
				return ec.fieldContext_Plan_type(ctx, field)
			case "NextPlans":
				return ec.fieldContext_Plan_NextPlans(ctx, field)
			case "PrevPlans":
				return ec.fieldContext_Plan_PrevPlans(ctx, field)
			case "Build":
				return ec.fieldContext_Plan_Build(ctx, field)
			case "Team":
				return ec.fieldContext_Plan_Team(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Plan_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Plan_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
			case "Status":
				return ec.fieldContext_Plan_Status(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_Plan_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Plan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_BuildCommits(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_BuildCommits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildCommits(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.BuildCommit)
	fc.Result = res
	return ec.marshalNBuildCommit2githubcomgen0cidelaforgeentBuildCommit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_BuildCommits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BuildCommit_id(ctx, field)
			case "type":
				return ec.fieldContext_BuildCommit_type(ctx, field)
			case "revision":
				return ec.fieldContext_BuildCommit_revision(ctx, field)
			case "state":
				return ec.fieldContext_BuildCommit_state(ctx, field)
			case "createdAt":
				return ec.fieldContext_BuildCommit_createdAt(ctx, field)
			case "Build":
				return ec.fieldContext_BuildCommit_Build(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_BuildCommit_ServerTasks(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_BuildCommit_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildCommit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_AdhocPlans(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_AdhocPlans(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdhocPlans(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.AdhocPlan)
	fc.Result = res
	return ec.marshalNAdhocPlan2githubcomgen0cidelaforgeentAdhocPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_AdhocPlans(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AdhocPlan_id(ctx, field)
			case "NextAdhocPlans":
				return ec.fieldContext_AdhocPlan_NextAdhocPlans(ctx, field)
			case "PrevAdhocPlans":
				return ec.fieldContext_AdhocPlan_PrevAdhocPlans(ctx, field)
			case "Build":
				return ec.fieldContext_AdhocPlan_Build(ctx, field)
			case "Status":
				return ec.fieldContext_AdhocPlan_Status(ctx, field)
			case "AgentTask":
				return ec.fieldContext_AdhocPlan_AgentTask(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdhocPlan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_AgentStatuses(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_AgentStatuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentStatuses(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.AgentStatus)
	fc.Result = res
	return ec.marshalNAgentStatus2githubcomgen0cidelaforgeentAgentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_AgentStatuses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "clientId":
				return ec.fieldContext_AgentStatus_clientId(ctx, field)
			case "hostname":
				return ec.fieldContext_AgentStatus_hostname(ctx, field)
			case "upTime":
				return ec.fieldContext_AgentStatus_upTime(ctx, field)
			case "bootTime":
				return ec.fieldContext_AgentStatus_bootTime(ctx, field)
			case "numProcs":
				return ec.fieldContext_AgentStatus_numProcs(ctx, field)
			case "OS":
				return ec.fieldContext_AgentStatus_OS(ctx, field)
			case "hostID":
				return ec.fieldContext_AgentStatus_hostID(ctx, field)
			case "load1":
				return ec.fieldContext_AgentStatus_load1(ctx, field)
			case "load5":
				return ec.fieldContext_AgentStatus_load5(ctx, field)
			case "load15":
				return ec.fieldContext_AgentStatus_load15(ctx, field)
			case "totalMem":
				return ec.fieldContext_AgentStatus_totalMem(ctx, field)
			case "freeMem":
				return ec.fieldContext_AgentStatus_freeMem(ctx, field)
			case "usedMem":
				return ec.fieldContext_AgentStatus_usedMem(ctx, field)
			case "timestamp":
				return ec.fieldContext_AgentStatus_timestamp(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentStatus_ProvisionedHost(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_AgentStatus_ProvisionedNetwork(ctx, field)
			case "Build":
				return ec.fieldContext_AgentStatus_Build(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_ServerTasks(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_ServerTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServerTasks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ServerTask)
	fc.Result = res
	return ec.marshalNServerTask2githubcomgen0cidelaforgeentServerTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_ServerTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServerTask_id(ctx, field)
			case "type":
				return ec.fieldContext_ServerTask_type(ctx, field)
			case "startTime":
				return ec.fieldContext_ServerTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ServerTask_endTime(ctx, field)
			case "errors":
				return ec.fieldContext_ServerTask_errors(ctx, field)
			case "logFilePath":
				return ec.fieldContext_ServerTask_logFilePath(ctx, field)
			case "AuthUser":
				return ec.fieldContext_ServerTask_AuthUser(ctx, field)
			case "Status":
				return ec.fieldContext_ServerTask_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_ServerTask_Environment(ctx, field)
			case "Build":
				return ec.fieldContext_ServerTask_Build(ctx, field)
			case "BuildCommit":
				return ec.fieldContext_ServerTask_BuildCommit(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ServerTask_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServerTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCommit_id(ctx context.Context, field graphql.CollectedField, obj *ent.BuildCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCommit_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BuildCommit().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCommit_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCommit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCommit_type(ctx context.Context, field graphql.CollectedField, obj *ent.BuildCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCommit_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BuildCommit().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.BuildCommitType)
	fc.Result = res
	return ec.marshalNBuildCommitType2githubcomgen0cidelaforgegraphqlgraphmodelBuildCommitType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCommit_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCommit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BuildCommitType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCommit_revision(ctx context.Context, field graphql.CollectedField, obj *ent.BuildCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCommit_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCommit_revision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCommit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCommit_state(ctx context.Context, field graphql.CollectedField, obj *ent.BuildCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCommit_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BuildCommit().State(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.BuildCommitState)
	fc.Result = res
	return ec.marshalNBuildCommitState2githubcomgen0cidelaforgegraphqlgraphmodelBuildCommitState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCommit_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCommit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BuildCommitState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCommit_createdAt(ctx context.Context, field graphql.CollectedField, obj *ent.BuildCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCommit_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCommit_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCommit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCommit_Build(ctx context.Context, field graphql.CollectedField, obj *ent.BuildCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCommit_Build(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Build(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Build)
	fc.Result = res
	return ec.marshalNBuild2githubcomgen0cidelaforgeentBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCommit_Build(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCommit",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCommit_ServerTasks(ctx context.Context, field graphql.CollectedField, obj *ent.BuildCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCommit_ServerTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServerTasks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ServerTask)
	fc.Result = res
	return ec.marshalNServerTask2githubcomgen0cidelaforgeentServerTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCommit_ServerTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCommit",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServerTask_id(ctx, field)
			case "type":
				return ec.fieldContext_ServerTask_type(ctx, field)
			case "startTime":
				return ec.fieldContext_ServerTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ServerTask_endTime(ctx, field)
			case "errors":
				return ec.fieldContext_ServerTask_errors(ctx, field)
			case "logFilePath":
				return ec.fieldContext_ServerTask_logFilePath(ctx, field)
			case "AuthUser":
				return ec.fieldContext_ServerTask_AuthUser(ctx, field)
			case "Status":
				return ec.fieldContext_ServerTask_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_ServerTask_Environment(ctx, field)
			case "Build":
				return ec.fieldContext_ServerTask_Build(ctx, field)
			case "BuildCommit":
				return ec.fieldContext_ServerTask_BuildCommit(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ServerTask_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServerTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCommit_PlanDiffs(ctx context.Context, field graphql.CollectedField, obj *ent.BuildCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCommit_PlanDiffs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlanDiffs(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.PlanDiff)
	fc.Result = res
	return ec.marshalNPlanDiff2githubcomgen0cidelaforgeentPlanDiff(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCommit_PlanDiffs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCommit",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PlanDiff_id(ctx, field)
			case "revision":
				return ec.fieldContext_PlanDiff_revision(ctx, field)
			case "newState":
				return ec.fieldContext_PlanDiff_newState(ctx, field)
			case "BuildCommit":
				return ec.fieldContext_PlanDiff_BuildCommit(ctx, field)
			case "Plan":
				return ec.fieldContext_PlanDiff_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlanDiff", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_id(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Command().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_name(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_description(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_program(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_program(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Program, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_program(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_args(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_ignoreErrors(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_ignoreErrors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IgnoreErrors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_ignoreErrors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_disabled(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_disabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_cooldown(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_cooldown(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cooldown, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_cooldown(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_timeout(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_timeout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timeout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_timeout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_vars(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Command().Vars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.VarsMap)
	fc.Result = res
	return ec.marshalOvarsMap2githubcomgen0cidelaforgegraphqlgraphmodelVarsMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_vars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_varsMap_key(ctx, field)
			case "value":
				return ec.fieldContext_varsMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type varsMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_tags(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Command().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalOtagMap2githubcomgen0cidelaforgegraphqlgraphmodelTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_Users(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_Users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.User)
	fc.Result = res
	return ec.marshalNUser2githubcomgen0cidelaforgeentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_Users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "hclId":
				return ec.fieldContext_User_hclId(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "uuid":
				return ec.fieldContext_User_uuid(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "Tag":
				return ec.fieldContext_User_Tag(ctx, field)
			case "Environments":
				return ec.fieldContext_User_Environments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Competition_id(ctx context.Context, field graphql.CollectedField, obj *ent.Competition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Competition_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Competition().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Competition_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Competition",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Competition_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.Competition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Competition_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Competition_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Competition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Competition_rootPassword(ctx context.Context, field graphql.CollectedField, obj *ent.Competition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Competition_rootPassword(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RootPassword, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Competition_rootPassword(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Competition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Competition_startTime(ctx context.Context, field graphql.CollectedField, obj *ent.Competition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Competition_startTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Competition_startTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Competition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Competition_stopTime(ctx context.Context, field graphql.CollectedField, obj *ent.Competition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Competition_stopTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Competition_stopTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Competition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Competition_config(ctx context.Context, field graphql.CollectedField, obj *ent.Competition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Competition_config(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Competition().Config(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ConfigMap)
	fc.Result = res
	return ec.marshalOconfigMap2githubcomgen0cidelaforgegraphqlgraphmodelConfigMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Competition_config(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Competition",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_configMap_key(ctx, field)
			case "value":
				return ec.fieldContext_configMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type configMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Competition_tags(ctx context.Context, field graphql.CollectedField, obj *ent.Competition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Competition_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Competition().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalOtagMap2githubcomgen0cidelaforgegraphqlgraphmodelTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Competition_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Competition",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Competition_DNS(ctx context.Context, field graphql.CollectedField, obj *ent.Competition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Competition_DNS(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DNS(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.DNS)
	fc.Result = res
	return ec.marshalNDNS2githubcomgen0cidelaforgeentDNS(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Competition_DNS(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Competition",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DNS_id(ctx, field)
			case "hclId":
				return ec.fieldContext_DNS_hclId(ctx, field)
			case "type":
				return ec.fieldContext_DNS_type(ctx, field)
			case "rootDomain":
				return ec.fieldContext_DNS_rootDomain(ctx, field)
			case "dnsServers":
				return ec.fieldContext_DNS_dnsServers(ctx, field)
			case "ntpServers":
				return ec.fieldContext_DNS_ntpServers(ctx, field)
			case "config":
				return ec.fieldContext_DNS_config(ctx, field)
			case "Environments":
				return ec.fieldContext_DNS_Environments(ctx, field)
			case "Competitions":
				return ec.fieldContext_DNS_Competitions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DNS", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Competition_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.Competition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Competition_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Competition_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Competition",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Competition_Builds(ctx context.Context, field graphql.CollectedField, obj *ent.Competition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Competition_Builds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Builds(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Build)
	fc.Result = res
	return ec.marshalNBuild2githubcomgen0cidelaforgeentBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Competition_Builds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Competition",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNS_id(ctx context.Context, field graphql.CollectedField, obj *ent.DNS) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNS_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DNS().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNS_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNS",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNS_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.DNS) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNS_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNS_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNS",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNS_type(ctx context.Context, field graphql.CollectedField, obj *ent.DNS) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNS_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNS_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNS",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNS_rootDomain(ctx context.Context, field graphql.CollectedField, obj *ent.DNS) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNS_rootDomain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RootDomain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNS_rootDomain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNS",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNS_dnsServers(ctx context.Context, field graphql.CollectedField, obj *ent.DNS) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNS_dnsServers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DNSServers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNS_dnsServers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNS",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNS_ntpServers(ctx context.Context, field graphql.CollectedField, obj *ent.DNS) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNS_ntpServers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NtpServers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNS_ntpServers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNS",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNS_config(ctx context.Context, field graphql.CollectedField, obj *ent.DNS) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNS_config(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DNS().Config(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ConfigMap)
	fc.Result = res
	return ec.marshalOconfigMap2githubcomgen0cidelaforgegraphqlgraphmodelConfigMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNS_config(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNS",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_configMap_key(ctx, field)
			case "value":
				return ec.fieldContext_configMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type configMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNS_Environments(ctx context.Context, field graphql.CollectedField, obj *ent.DNS) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNS_Environments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environments(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNS_Environments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNS",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNS_Competitions(ctx context.Context, field graphql.CollectedField, obj *ent.DNS) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNS_Competitions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Competitions(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Competition)
	fc.Result = res
	return ec.marshalNCompetition2githubcomgen0cidelaforgeentCompetition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNS_Competitions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNS",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Competition_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Competition_hclId(ctx, field)
			case "rootPassword":
				return ec.fieldContext_Competition_rootPassword(ctx, field)
			case "startTime":
				return ec.fieldContext_Competition_startTime(ctx, field)
			case "stopTime":
				return ec.fieldContext_Competition_stopTime(ctx, field)
			case "config":
				return ec.fieldContext_Competition_config(ctx, field)
			case "tags":
				return ec.fieldContext_Competition_tags(ctx, field)
			case "DNS":
				return ec.fieldContext_Competition_DNS(ctx, field)
			case "Environment":
				return ec.fieldContext_Competition_Environment(ctx, field)
			case "Builds":
				return ec.fieldContext_Competition_Builds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Competition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNSRecord_id(ctx context.Context, field graphql.CollectedField, obj *ent.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNSRecord_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DNSRecord().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNSRecord_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNSRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNSRecord_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNSRecord_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNSRecord_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNSRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNSRecord_name(ctx context.Context, field graphql.CollectedField, obj *ent.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNSRecord_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNSRecord_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNSRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNSRecord_values(ctx context.Context, field graphql.CollectedField, obj *ent.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNSRecord_values(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Values, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNSRecord_values(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNSRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNSRecord_type(ctx context.Context, field graphql.CollectedField, obj *ent.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNSRecord_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNSRecord_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNSRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNSRecord_zone(ctx context.Context, field graphql.CollectedField, obj *ent.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNSRecord_zone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Zone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNSRecord_zone(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNSRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNSRecord_vars(ctx context.Context, field graphql.CollectedField, obj *ent.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNSRecord_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DNSRecord().Vars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.VarsMap)
	fc.Result = res
	return ec.marshalNvarsMap2githubcomgen0cidelaforgegraphqlgraphmodelVarsMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNSRecord_vars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNSRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_varsMap_key(ctx, field)
			case "value":
				return ec.fieldContext_varsMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type varsMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNSRecord_disabled(ctx context.Context, field graphql.CollectedField, obj *ent.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNSRecord_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNSRecord_disabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNSRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNSRecord_tags(ctx context.Context, field graphql.CollectedField, obj *ent.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNSRecord_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DNSRecord().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalNtagMap2githubcomgen0cidelaforgegraphqlgraphmodelTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNSRecord_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNSRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNSRecord_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNSRecord_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNSRecord_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNSRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Disk_id(ctx context.Context, field graphql.CollectedField, obj *ent.Disk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Disk_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Disk().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Disk_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Disk",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Disk_size(ctx context.Context, field graphql.CollectedField, obj *ent.Disk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Disk_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Disk_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Disk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Disk_Host(ctx context.Context, field graphql.CollectedField, obj *ent.Disk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Disk_Host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Host(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Host)
	fc.Result = res
	return ec.marshalNHost2githubcomgen0cidelaforgeentHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Disk_Host(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Disk",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Host_hclId(ctx, field)
			case "hostname":
				return ec.fieldContext_Host_hostname(ctx, field)
			case "description":
				return ec.fieldContext_Host_description(ctx, field)
			case "OS":
				return ec.fieldContext_Host_OS(ctx, field)
			case "lastOctet":
				return ec.fieldContext_Host_lastOctet(ctx, field)
			case "instanceSize":
				return ec.fieldContext_Host_instanceSize(ctx, field)
			case "allowMacChanges":
				return ec.fieldContext_Host_allowMacChanges(ctx, field)
			case "exposedTcpPorts":
				return ec.fieldContext_Host_exposedTcpPorts(ctx, field)
			case "exposedUdpPorts":
				return ec.fieldContext_Host_exposedUdpPorts(ctx, field)
			case "overridePassword":
				return ec.fieldContext_Host_overridePassword(ctx, field)
			case "vars":
				return ec.fieldContext_Host_vars(ctx, field)
			case "userGroups":
				return ec.fieldContext_Host_userGroups(ctx, field)
			case "provisionSteps":
				return ec.fieldContext_Host_provisionSteps(ctx, field)
			case "tags":
				return ec.fieldContext_Host_tags(ctx, field)
			case "Disk":
				return ec.fieldContext_Host_Disk(ctx, field)
			case "Users":
				return ec.fieldContext_Host_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Host_Environment(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Host_IncludedNetworks(ctx, field)
			case "DependOnHostDependencies":
				return ec.fieldContext_Host_DependOnHostDependencies(ctx, field)
			case "RequiredByHostDependencies":
				return ec.fieldContext_Host_RequiredByHostDependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_id(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Environment().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_competitionId(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_competitionId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompetitionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_competitionId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_name(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_description(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_builder(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_builder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Builder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_builder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_teamCount(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_teamCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_teamCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_revision(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_revision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_adminCidrs(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_adminCidrs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdminCidrs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_adminCidrs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_exposedVdiPorts(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExposedVdiPorts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_exposedVdiPorts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_config(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_config(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Environment().Config(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ConfigMap)
	fc.Result = res
	return ec.marshalOconfigMap2githubcomgen0cidelaforgegraphqlgraphmodelConfigMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_config(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_configMap_key(ctx, field)
			case "value":
				return ec.fieldContext_configMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type configMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_tags(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Environment().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalOtagMap2githubcomgen0cidelaforgegraphqlgraphmodelTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_Users(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_Users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.User)
	fc.Result = res
	return ec.marshalNUser2githubcomgen0cidelaforgeentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_Users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "hclId":
				return ec.fieldContext_User_hclId(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "uuid":
				return ec.fieldContext_User_uuid(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "Tag":
				return ec.fieldContext_User_Tag(ctx, field)
			case "Environments":
				return ec.fieldContext_User_Environments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_Hosts(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_Hosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hosts(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Host)
	fc.Result = res
	return ec.marshalNHost2githubcomgen0cidelaforgeentHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_Hosts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Host_hclId(ctx, field)
			case "hostname":
				return ec.fieldContext_Host_hostname(ctx, field)
			case "description":
				return ec.fieldContext_Host_description(ctx, field)
			case "OS":
				return ec.fieldContext_Host_OS(ctx, field)
			case "lastOctet":
				return ec.fieldContext_Host_lastOctet(ctx, field)
			case "instanceSize":
				return ec.fieldContext_Host_instanceSize(ctx, field)
			case "allowMacChanges":
				return ec.fieldContext_Host_allowMacChanges(ctx, field)
			case "exposedTcpPorts":
				return ec.fieldContext_Host_exposedTcpPorts(ctx, field)
			case "exposedUdpPorts":
				return ec.fieldContext_Host_exposedUdpPorts(ctx, field)
			case "overridePassword":
				return ec.fieldContext_Host_overridePassword(ctx, field)
			case "vars":
				return ec.fieldContext_Host_vars(ctx, field)
			case "userGroups":
				return ec.fieldContext_Host_userGroups(ctx, field)
			case "provisionSteps":
				return ec.fieldContext_Host_provisionSteps(ctx, field)
			case "tags":
				return ec.fieldContext_Host_tags(ctx, field)
			case "Disk":
				return ec.fieldContext_Host_Disk(ctx, field)
			case "Users":
				return ec.fieldContext_Host_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Host_Environment(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Host_IncludedNetworks(ctx, field)
			case "DependOnHostDependencies":
				return ec.fieldContext_Host_DependOnHostDependencies(ctx, field)
			case "RequiredByHostDependencies":
				return ec.fieldContext_Host_RequiredByHostDependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_Competitions(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_Competitions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Competitions(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Competition)
	fc.Result = res
	return ec.marshalNCompetition2githubcomgen0cidelaforgeentCompetition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_Competitions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Competition_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Competition_hclId(ctx, field)
			case "rootPassword":
				return ec.fieldContext_Competition_rootPassword(ctx, field)
			case "startTime":
				return ec.fieldContext_Competition_startTime(ctx, field)
			case "stopTime":
				return ec.fieldContext_Competition_stopTime(ctx, field)
			case "config":
				return ec.fieldContext_Competition_config(ctx, field)
			case "tags":
				return ec.fieldContext_Competition_tags(ctx, field)
			case "DNS":
				return ec.fieldContext_Competition_DNS(ctx, field)
			case "Environment":
				return ec.fieldContext_Competition_Environment(ctx, field)
			case "Builds":
				return ec.fieldContext_Competition_Builds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Competition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_Identities(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_Identities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Identities(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Identity)
	fc.Result = res
	return ec.marshalNIdentity2githubcomgen0cidelaforgeentIdentity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_Identities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Identity_id(ctx, field)
			case "hclid":
				return ec.fieldContext_Identity_hclid(ctx, field)
			case "firstName":
				return ec.fieldContext_Identity_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_Identity_lastName(ctx, field)
			case "email":
				return ec.fieldContext_Identity_email(ctx, field)
			case "password":
				return ec.fieldContext_Identity_password(ctx, field)
			case "description":
				return ec.fieldContext_Identity_description(ctx, field)
			case "avatarFile":
				return ec.fieldContext_Identity_avatarFile(ctx, field)
			case "vars":
				return ec.fieldContext_Identity_vars(ctx, field)
			case "tags":
				return ec.fieldContext_Identity_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_Identity_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Identity", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_Commands(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_Commands(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Commands(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Command)
	fc.Result = res
	return ec.marshalNCommand2githubcomgen0cidelaforgeentCommand(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_Commands(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Command_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Command_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Command_name(ctx, field)
			case "description":
				return ec.fieldContext_Command_description(ctx, field)
			case "program":
				return ec.fieldContext_Command_program(ctx, field)
			case "args":
				return ec.fieldContext_Command_args(ctx, field)
			case "ignoreErrors":
				return ec.fieldContext_Command_ignoreErrors(ctx, field)
			case "disabled":
				return ec.fieldContext_Command_disabled(ctx, field)
			case "cooldown":
				return ec.fieldContext_Command_cooldown(ctx, field)
			case "timeout":
				return ec.fieldContext_Command_timeout(ctx, field)
			case "vars":
				return ec.fieldContext_Command_vars(ctx, field)
			case "tags":
				return ec.fieldContext_Command_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Command_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Command_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Command", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_Scripts(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_Scripts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Scripts(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Script)
	fc.Result = res
	return ec.marshalNScript2githubcomgen0cidelaforgeentScript(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_Scripts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Script_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Script_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Script_name(ctx, field)
			case "language":
				return ec.fieldContext_Script_language(ctx, field)
			case "description":
				return ec.fieldContext_Script_description(ctx, field)
			case "source":
				return ec.fieldContext_Script_source(ctx, field)
			case "sourceType":
				return ec.fieldContext_Script_sourceType(ctx, field)
			case "cooldown":
				return ec.fieldContext_Script_cooldown(ctx, field)
			case "timeout":
				return ec.fieldContext_Script_timeout(ctx, field)
			case "ignoreErrors":
				return ec.fieldContext_Script_ignoreErrors(ctx, field)
			case "args":
				return ec.fieldContext_Script_args(ctx, field)
			case "disabled":
				return ec.fieldContext_Script_disabled(ctx, field)
			case "vars":
				return ec.fieldContext_Script_vars(ctx, field)
			case "absPath":
				return ec.fieldContext_Script_absPath(ctx, field)
			case "tags":
				return ec.fieldContext_Script_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Script_Users(ctx, field)
			case "Findings":
				return ec.fieldContext_Script_Findings(ctx, field)
			case "Environment":
				return ec.fieldContext_Script_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Script", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_FileDownloads(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_FileDownloads(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileDownloads(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.FileDownload)
	fc.Result = res
	return ec.marshalNFileDownload2githubcomgen0cidelaforgeentFileDownload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_FileDownloads(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FileDownload_id(ctx, field)
			case "hclId":
				return ec.fieldContext_FileDownload_hclId(ctx, field)
			case "sourceType":
				return ec.fieldContext_FileDownload_sourceType(ctx, field)
			case "source":
				return ec.fieldContext_FileDownload_source(ctx, field)
			case "destination":
				return ec.fieldContext_FileDownload_destination(ctx, field)
			case "template":
				return ec.fieldContext_FileDownload_template(ctx, field)
			case "perms":
				return ec.fieldContext_FileDownload_perms(ctx, field)
			case "disabled":
				return ec.fieldContext_FileDownload_disabled(ctx, field)
			case "md5":
				return ec.fieldContext_FileDownload_md5(ctx, field)
			case "absPath":
				return ec.fieldContext_FileDownload_absPath(ctx, field)
			case "tags":
				return ec.fieldContext_FileDownload_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_FileDownload_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileDownload", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_FileDeletes(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_FileDeletes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileDeletes(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.FileDelete)
	fc.Result = res
	return ec.marshalNFileDelete2githubcomgen0cidelaforgeentFileDelete(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_FileDeletes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FileDelete_id(ctx, field)
			case "hclId":
				return ec.fieldContext_FileDelete_hclId(ctx, field)
			case "path":
				return ec.fieldContext_FileDelete_path(ctx, field)
			case "tags":
				return ec.fieldContext_FileDelete_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_FileDelete_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileDelete", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_FileExtracts(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_FileExtracts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileExtracts(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.FileExtract)
	fc.Result = res
	return ec.marshalNFileExtract2githubcomgen0cidelaforgeentFileExtract(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_FileExtracts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FileExtract_id(ctx, field)
			case "hclId":
				return ec.fieldContext_FileExtract_hclId(ctx, field)
			case "source":
				return ec.fieldContext_FileExtract_source(ctx, field)
			case "destination":
				return ec.fieldContext_FileExtract_destination(ctx, field)
			case "type":
				return ec.fieldContext_FileExtract_type(ctx, field)
			case "tags":
				return ec.fieldContext_FileExtract_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_FileExtract_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileExtract", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_IncludedNetworks(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_IncludedNetworks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IncludedNetworks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.IncludedNetwork)
	fc.Result = res
	return ec.marshalNIncludedNetwork2githubcomgen0cidelaforgeentIncludedNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_IncludedNetworks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IncludedNetwork_id(ctx, field)
			case "name":
				return ec.fieldContext_IncludedNetwork_name(ctx, field)
			case "includedHosts":
				return ec.fieldContext_IncludedNetwork_includedHosts(ctx, field)
			case "Tags":
				return ec.fieldContext_IncludedNetwork_Tags(ctx, field)
			case "Hosts":
				return ec.fieldContext_IncludedNetwork_Hosts(ctx, field)
			case "Network":
				return ec.fieldContext_IncludedNetwork_Network(ctx, field)
			case "Environments":
				return ec.fieldContext_IncludedNetwork_Environments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IncludedNetwork", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_Findings(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_Findings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Findings(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Finding)
	fc.Result = res
	return ec.marshalNFinding2githubcomgen0cidelaforgeentFinding(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_Findings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Finding_id(ctx, field)
			case "name":
				return ec.fieldContext_Finding_name(ctx, field)
			case "description":
				return ec.fieldContext_Finding_description(ctx, field)
			case "severity":
				return ec.fieldContext_Finding_severity(ctx, field)
			case "difficulty":
				return ec.fieldContext_Finding_difficulty(ctx, field)
			case "tags":
				return ec.fieldContext_Finding_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Finding_Users(ctx, field)
			case "Host":
				return ec.fieldContext_Finding_Host(ctx, field)
			case "Script":
				return ec.fieldContext_Finding_Script(ctx, field)
			case "Environment":
				return ec.fieldContext_Finding_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Finding", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_DNSRecords(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_DNSRecords(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DNSRecords(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.DNSRecord)
	fc.Result = res
	return ec.marshalNDNSRecord2githubcomgen0cidelaforgeentDNSRecord(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_DNSRecords(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DNSRecord_id(ctx, field)
			case "hclId":
				return ec.fieldContext_DNSRecord_hclId(ctx, field)
			case "name":
				return ec.fieldContext_DNSRecord_name(ctx, field)
			case "values":
				return ec.fieldContext_DNSRecord_values(ctx, field)
			case "type":
				return ec.fieldContext_DNSRecord_type(ctx, field)
			case "zone":
				return ec.fieldContext_DNSRecord_zone(ctx, field)
			case "vars":
				return ec.fieldContext_DNSRecord_vars(ctx, field)
			case "disabled":
				return ec.fieldContext_DNSRecord_disabled(ctx, field)
			case "tags":
				return ec.fieldContext_DNSRecord_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_DNSRecord_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DNSRecord", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_DNS(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_DNS(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DNS(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.DNS)
	fc.Result = res
	return ec.marshalNDNS2githubcomgen0cidelaforgeentDNS(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_DNS(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DNS_id(ctx, field)
			case "hclId":
				return ec.fieldContext_DNS_hclId(ctx, field)
			case "type":
				return ec.fieldContext_DNS_type(ctx, field)
			case "rootDomain":
				return ec.fieldContext_DNS_rootDomain(ctx, field)
			case "dnsServers":
				return ec.fieldContext_DNS_dnsServers(ctx, field)
			case "ntpServers":
				return ec.fieldContext_DNS_ntpServers(ctx, field)
			case "config":
				return ec.fieldContext_DNS_config(ctx, field)
			case "Environments":
				return ec.fieldContext_DNS_Environments(ctx, field)
			case "Competitions":
				return ec.fieldContext_DNS_Competitions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DNS", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_Networks(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_Networks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Networks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Network)
	fc.Result = res
	return ec.marshalNNetwork2githubcomgen0cidelaforgeentNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_Networks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Network_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Network_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Network_name(ctx, field)
			case "cidr":
				return ec.fieldContext_Network_cidr(ctx, field)
			case "vdiVisible":
				return ec.fieldContext_Network_vdiVisible(ctx, field)
			case "vars":
				return ec.fieldContext_Network_vars(ctx, field)
			case "tags":
				return ec.fieldContext_Network_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_Network_Environment(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Network_HostDependencies(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Network_IncludedNetworks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Network", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_HostDependencies(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_HostDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostDependencies(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.HostDependency)
	fc.Result = res
	return ec.marshalNHostDependency2githubcomgen0cidelaforgeentHostDependency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_HostDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_HostDependency_id(ctx, field)
			case "hostId":
				return ec.fieldContext_HostDependency_hostId(ctx, field)
			case "networkId":
				return ec.fieldContext_HostDependency_networkId(ctx, field)
			case "RequiredBy":
				return ec.fieldContext_HostDependency_RequiredBy(ctx, field)
			case "DependOnHost":
				return ec.fieldContext_HostDependency_DependOnHost(ctx, field)
			case "DependOnNetwork":
				return ec.fieldContext_HostDependency_DependOnNetwork(ctx, field)
			case "Environment":
				return ec.fieldContext_HostDependency_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostDependency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_Ansibles(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_Ansibles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ansibles(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Ansible)
	fc.Result = res
	return ec.marshalNAnsible2githubcomgen0cidelaforgeentAnsible(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_Ansibles(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Ansible_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Ansible_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Ansible_name(ctx, field)
			case "description":
				return ec.fieldContext_Ansible_description(ctx, field)
			case "source":
				return ec.fieldContext_Ansible_source(ctx, field)
			case "playbookName":
				return ec.fieldContext_Ansible_playbookName(ctx, field)
			case "method":
				return ec.fieldContext_Ansible_method(ctx, field)
			case "inventory":
				return ec.fieldContext_Ansible_inventory(ctx, field)
			case "absPath":
				return ec.fieldContext_Ansible_absPath(ctx, field)
			case "tags":
				return ec.fieldContext_Ansible_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Ansible_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Ansible_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Ansible", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_ScheduledSteps(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_ScheduledSteps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScheduledSteps(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ScheduledStep)
	fc.Result = res
	return ec.marshalNScheduledStep2githubcomgen0cidelaforgeentScheduledStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_ScheduledSteps(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ScheduledStep_id(ctx, field)
			case "hclId":
				return ec.fieldContext_ScheduledStep_hclId(ctx, field)
			case "name":
				return ec.fieldContext_ScheduledStep_name(ctx, field)
			case "description":
				return ec.fieldContext_ScheduledStep_description(ctx, field)
			case "step":
				return ec.fieldContext_ScheduledStep_step(ctx, field)
			case "type":
				return ec.fieldContext_ScheduledStep_type(ctx, field)
			case "schedule":
				return ec.fieldContext_ScheduledStep_schedule(ctx, field)
			case "runAt":
				return ec.fieldContext_ScheduledStep_runAt(ctx, field)
			case "Environment":
				return ec.fieldContext_ScheduledStep_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ScheduledStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_Builds(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_Builds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Builds(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Build)
	fc.Result = res
	return ec.marshalNBuild2githubcomgen0cidelaforgeentBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_Builds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_Repositories(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_Repositories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repositories(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Repository)
	fc.Result = res
	return ec.marshalNRepository2githubcomgen0cidelaforgeentRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_Repositories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Repository_id(ctx, field)
			case "repoUrl":
				return ec.fieldContext_Repository_repoUrl(ctx, field)
			case "branchName":
				return ec.fieldContext_Repository_branchName(ctx, field)
			case "environmentFilepath":
				return ec.fieldContext_Repository_environmentFilepath(ctx, field)
			case "Environments":
				return ec.fieldContext_Repository_Environments(ctx, field)
			case "RepoCommits":
				return ec.fieldContext_Repository_RepoCommits(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Repository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_ServerTasks(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_ServerTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServerTasks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ServerTask)
	fc.Result = res
	return ec.marshalNServerTask2githubcomgen0cidelaforgeentServerTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_ServerTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServerTask_id(ctx, field)
			case "type":
				return ec.fieldContext_ServerTask_type(ctx, field)
			case "startTime":
				return ec.fieldContext_ServerTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ServerTask_endTime(ctx, field)
			case "errors":
				return ec.fieldContext_ServerTask_errors(ctx, field)
			case "logFilePath":
				return ec.fieldContext_ServerTask_logFilePath(ctx, field)
			case "AuthUser":
				return ec.fieldContext_ServerTask_AuthUser(ctx, field)
			case "Status":
				return ec.fieldContext_ServerTask_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_ServerTask_Environment(ctx, field)
			case "Build":
				return ec.fieldContext_ServerTask_Build(ctx, field)
			case "BuildCommit":
				return ec.fieldContext_ServerTask_BuildCommit(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ServerTask_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServerTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDelete_id(ctx context.Context, field graphql.CollectedField, obj *ent.FileDelete) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDelete_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FileDelete().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDelete_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDelete",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDelete_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.FileDelete) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDelete_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDelete_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDelete",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDelete_path(ctx context.Context, field graphql.CollectedField, obj *ent.FileDelete) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDelete_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDelete_path(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDelete",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDelete_tags(ctx context.Context, field graphql.CollectedField, obj *ent.FileDelete) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDelete_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FileDelete().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalNtagMap2githubcomgen0cidelaforgegraphqlgraphmodelTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDelete_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDelete",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDelete_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.FileDelete) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDelete_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDelete_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDelete",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDownload_id(ctx context.Context, field graphql.CollectedField, obj *ent.FileDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDownload_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FileDownload().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDownload_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDownload",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDownload_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.FileDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDownload_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDownload_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDownload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDownload_sourceType(ctx context.Context, field graphql.CollectedField, obj *ent.FileDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDownload_sourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDownload_sourceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDownload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDownload_source(ctx context.Context, field graphql.CollectedField, obj *ent.FileDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDownload_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDownload_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDownload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDownload_destination(ctx context.Context, field graphql.CollectedField, obj *ent.FileDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDownload_destination(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Destination, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDownload_destination(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDownload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDownload_template(ctx context.Context, field graphql.CollectedField, obj *ent.FileDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDownload_template(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Template, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDownload_template(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDownload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDownload_perms(ctx context.Context, field graphql.CollectedField, obj *ent.FileDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDownload_perms(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Perms, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDownload_perms(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDownload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDownload_disabled(ctx context.Context, field graphql.CollectedField, obj *ent.FileDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDownload_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDownload_disabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDownload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDownload_md5(ctx context.Context, field graphql.CollectedField, obj *ent.FileDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDownload_md5(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Md5, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDownload_md5(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDownload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDownload_absPath(ctx context.Context, field graphql.CollectedField, obj *ent.FileDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDownload_absPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AbsPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDownload_absPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDownload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDownload_tags(ctx context.Context, field graphql.CollectedField, obj *ent.FileDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDownload_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FileDownload().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalNtagMap2githubcomgen0cidelaforgegraphqlgraphmodelTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDownload_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDownload",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDownload_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.FileDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDownload_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDownload_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDownload",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileExtract_id(ctx context.Context, field graphql.CollectedField, obj *ent.FileExtract) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileExtract_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FileExtract().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileExtract_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileExtract",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileExtract_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.FileExtract) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileExtract_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileExtract_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileExtract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileExtract_source(ctx context.Context, field graphql.CollectedField, obj *ent.FileExtract) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileExtract_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileExtract_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileExtract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileExtract_destination(ctx context.Context, field graphql.CollectedField, obj *ent.FileExtract) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileExtract_destination(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Destination, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileExtract_destination(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileExtract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileExtract_type(ctx context.Context, field graphql.CollectedField, obj *ent.FileExtract) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileExtract_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileExtract_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileExtract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileExtract_tags(ctx context.Context, field graphql.CollectedField, obj *ent.FileExtract) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileExtract_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FileExtract().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalNtagMap2githubcomgen0cidelaforgegraphqlgraphmodelTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileExtract_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileExtract",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileExtract_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.FileExtract) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileExtract_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileExtract_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileExtract",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Finding_id(ctx context.Context, field graphql.CollectedField, obj *ent.Finding) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Finding_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Finding().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Finding_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Finding",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Finding_name(ctx context.Context, field graphql.CollectedField, obj *ent.Finding) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Finding_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Finding_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Finding",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Finding_description(ctx context.Context, field graphql.CollectedField, obj *ent.Finding) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Finding_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Finding_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Finding",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Finding_severity(ctx context.Context, field graphql.CollectedField, obj *ent.Finding) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Finding_severity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Finding().Severity(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.FindingSeverity)
	fc.Result = res
	return ec.marshalNFindingSeverity2githubcomgen0cidelaforgegraphqlgraphmodelFindingSeverity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Finding_severity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Finding",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FindingSeverity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Finding_difficulty(ctx context.Context, field graphql.CollectedField, obj *ent.Finding) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Finding_difficulty(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Finding().Difficulty(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.FindingDifficulty)
	fc.Result = res
	return ec.marshalNFindingDifficulty2githubcomgen0cidelaforgegraphqlgraphmodelFindingDifficulty(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Finding_difficulty(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Finding",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FindingDifficulty does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Finding_tags(ctx context.Context, field graphql.CollectedField, obj *ent.Finding) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Finding_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Finding().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalNtagMap2githubcomgen0cidelaforgegraphqlgraphmodelTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Finding_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Finding",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Finding_Users(ctx context.Context, field graphql.CollectedField, obj *ent.Finding) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Finding_Users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.User)
	fc.Result = res
	return ec.marshalNUser2githubcomgen0cidelaforgeentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Finding_Users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Finding",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "hclId":
				return ec.fieldContext_User_hclId(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "uuid":
				return ec.fieldContext_User_uuid(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "Tag":
				return ec.fieldContext_User_Tag(ctx, field)
			case "Environments":
				return ec.fieldContext_User_Environments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Finding_Host(ctx context.Context, field graphql.CollectedField, obj *ent.Finding) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Finding_Host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Host(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Host)
	fc.Result = res
	return ec.marshalOHost2githubcomgen0cidelaforgeentHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Finding_Host(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Finding",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Host_hclId(ctx, field)
			case "hostname":
				return ec.fieldContext_Host_hostname(ctx, field)
			case "description":
				return ec.fieldContext_Host_description(ctx, field)
			case "OS":
				return ec.fieldContext_Host_OS(ctx, field)
			case "lastOctet":
				return ec.fieldContext_Host_lastOctet(ctx, field)
			case "instanceSize":
				return ec.fieldContext_Host_instanceSize(ctx, field)
			case "allowMacChanges":
				return ec.fieldContext_Host_allowMacChanges(ctx, field)
			case "exposedTcpPorts":
				return ec.fieldContext_Host_exposedTcpPorts(ctx, field)
			case "exposedUdpPorts":
				return ec.fieldContext_Host_exposedUdpPorts(ctx, field)
			case "overridePassword":
				return ec.fieldContext_Host_overridePassword(ctx, field)
			case "vars":
				return ec.fieldContext_Host_vars(ctx, field)
			case "userGroups":
				return ec.fieldContext_Host_userGroups(ctx, field)
			case "provisionSteps":
				return ec.fieldContext_Host_provisionSteps(ctx, field)
			case "tags":
				return ec.fieldContext_Host_tags(ctx, field)
			case "Disk":
				return ec.fieldContext_Host_Disk(ctx, field)
			case "Users":
				return ec.fieldContext_Host_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Host_Environment(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Host_IncludedNetworks(ctx, field)
			case "DependOnHostDependencies":
				return ec.fieldContext_Host_DependOnHostDependencies(ctx, field)
			case "RequiredByHostDependencies":
				return ec.fieldContext_Host_RequiredByHostDependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Finding_Script(ctx context.Context, field graphql.CollectedField, obj *ent.Finding) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Finding_Script(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Script(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Script)
	fc.Result = res
	return ec.marshalOScript2githubcomgen0cidelaforgeentScript(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Finding_Script(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Finding",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Script_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Script_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Script_name(ctx, field)
			case "language":
				return ec.fieldContext_Script_language(ctx, field)
			case "description":
				return ec.fieldContext_Script_description(ctx, field)
			case "source":
				return ec.fieldContext_Script_source(ctx, field)
			case "sourceType":
				return ec.fieldContext_Script_sourceType(ctx, field)
			case "cooldown":
				return ec.fieldContext_Script_cooldown(ctx, field)
			case "timeout":
				return ec.fieldContext_Script_timeout(ctx, field)
			case "ignoreErrors":
				return ec.fieldContext_Script_ignoreErrors(ctx, field)
			case "args":
				return ec.fieldContext_Script_args(ctx, field)
			case "disabled":
				return ec.fieldContext_Script_disabled(ctx, field)
			case "vars":
				return ec.fieldContext_Script_vars(ctx, field)
			case "absPath":
				return ec.fieldContext_Script_absPath(ctx, field)
			case "tags":
				return ec.fieldContext_Script_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Script_Users(ctx, field)
			case "Findings":
				return ec.fieldContext_Script_Findings(ctx, field)
			case "Environment":
				return ec.fieldContext_Script_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Script", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Finding_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.Finding) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Finding_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalOEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Finding_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Finding",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GinFileMiddleware_id(ctx context.Context, field graphql.CollectedField, obj *ent.GinFileMiddleware) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GinFileMiddleware_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GinFileMiddleware().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GinFileMiddleware_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GinFileMiddleware",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GinFileMiddleware_urlId(ctx context.Context, field graphql.CollectedField, obj *ent.GinFileMiddleware) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GinFileMiddleware_urlId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URLID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GinFileMiddleware_urlId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GinFileMiddleware",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GinFileMiddleware_filePath(ctx context.Context, field graphql.CollectedField, obj *ent.GinFileMiddleware) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GinFileMiddleware_filePath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FilePath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GinFileMiddleware_filePath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GinFileMiddleware",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GinFileMiddleware_accessed(ctx context.Context, field graphql.CollectedField, obj *ent.GinFileMiddleware) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GinFileMiddleware_accessed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Accessed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GinFileMiddleware_accessed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GinFileMiddleware",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GinFileMiddleware_ProvisionedHost(ctx context.Context, field graphql.CollectedField, obj *ent.GinFileMiddleware) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GinFileMiddleware_ProvisionedHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedHost(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedHost)
	fc.Result = res
	return ec.marshalOProvisionedHost2githubcomgen0cidelaforgeentProvisionedHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GinFileMiddleware_ProvisionedHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GinFileMiddleware",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedHost_id(ctx, field)
			case "subnetIp":
				return ec.fieldContext_ProvisionedHost_subnetIp(ctx, field)
			case "addonType":
				return ec.fieldContext_ProvisionedHost_addonType(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedHost_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedHost_Status(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_ProvisionedHost_ProvisionedNetwork(ctx, field)
			case "Host":
				return ec.fieldContext_ProvisionedHost_Host(ctx, field)
			case "EndStepPlan":
				return ec.fieldContext_ProvisionedHost_EndStepPlan(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedHost_Build(ctx, field)
			case "ProvisioningSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningSteps(ctx, field)
			case "ProvisioningScheduledSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningScheduledSteps(ctx, field)
			case "AgentStatus":
				return ec.fieldContext_ProvisionedHost_AgentStatus(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisionedHost_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedHost_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisionedHost_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedHost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GinFileMiddleware_ProvisioningStep(ctx context.Context, field graphql.CollectedField, obj *ent.GinFileMiddleware) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GinFileMiddleware_ProvisioningStep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisioningStep(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisioningStep)
	fc.Result = res
	return ec.marshalOProvisioningStep2githubcomgen0cidelaforgeentProvisioningStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GinFileMiddleware_ProvisioningStep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GinFileMiddleware",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisioningStep_id(ctx, field)
			case "type":
				return ec.fieldContext_ProvisioningStep_type(ctx, field)
			case "stepNumber":
				return ec.fieldContext_ProvisioningStep_stepNumber(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisioningStep_Status(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_ProvisioningStep_ProvisionedHost(ctx, field)
			case "Script":
				return ec.fieldContext_ProvisioningStep_Script(ctx, field)
			case "Command":
				return ec.fieldContext_ProvisioningStep_Command(ctx, field)
			case "DNSRecord":
				return ec.fieldContext_ProvisioningStep_DNSRecord(ctx, field)
			case "FileDelete":
				return ec.fieldContext_ProvisioningStep_FileDelete(ctx, field)
			case "FileDownload":
				return ec.fieldContext_ProvisioningStep_FileDownload(ctx, field)
			case "FileExtract":
				return ec.fieldContext_ProvisioningStep_FileExtract(ctx, field)
			case "Ansible":
				return ec.fieldContext_ProvisioningStep_Ansible(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisioningStep_Plan(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisioningStep_AgentTasks(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisioningStep_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisioningStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GinFileMiddleware_ProvisioningScheduledStep(ctx context.Context, field graphql.CollectedField, obj *ent.GinFileMiddleware) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GinFileMiddleware_ProvisioningScheduledStep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisioningScheduledStep(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisioningScheduledStep)
	fc.Result = res
	return ec.marshalOProvisioningScheduledStep2githubcomgen0cidelaforgeentProvisioningScheduledStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GinFileMiddleware_ProvisioningScheduledStep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GinFileMiddleware",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisioningScheduledStep_id(ctx, field)
			case "type":
				return ec.fieldContext_ProvisioningScheduledStep_type(ctx, field)
			case "runTime":
				return ec.fieldContext_ProvisioningScheduledStep_runTime(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisioningScheduledStep_Status(ctx, field)
			case "ScheduledStep":
				return ec.fieldContext_ProvisioningScheduledStep_ScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_ProvisioningScheduledStep_ProvisionedHost(ctx, field)
			case "Script":
				return ec.fieldContext_ProvisioningScheduledStep_Script(ctx, field)
			case "Command":
				return ec.fieldContext_ProvisioningScheduledStep_Command(ctx, field)
			case "DNSRecord":
				return ec.fieldContext_ProvisioningScheduledStep_DNSRecord(ctx, field)
			case "FileDelete":
				return ec.fieldContext_ProvisioningScheduledStep_FileDelete(ctx, field)
			case "FileDownload":
				return ec.fieldContext_ProvisioningScheduledStep_FileDownload(ctx, field)
			case "FileExtract":
				return ec.fieldContext_ProvisioningScheduledStep_FileExtract(ctx, field)
			case "Ansible":
				return ec.fieldContext_ProvisioningScheduledStep_Ansible(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisioningScheduledStep_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisioningScheduledStep_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisioningScheduledStep_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisioningScheduledStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_id(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_hostname(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_hostname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hostname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_hostname(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_description(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_OS(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_OS(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_OS(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_lastOctet(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_lastOctet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastOctet, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_lastOctet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_instanceSize(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_instanceSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InstanceSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_instanceSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_allowMacChanges(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_allowMacChanges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllowMACChanges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_allowMacChanges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_exposedTcpPorts(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_exposedTcpPorts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExposedTCPPorts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_exposedTcpPorts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_exposedUdpPorts(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_exposedUdpPorts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExposedUDPPorts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_exposedUdpPorts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_overridePassword(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_overridePassword(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OverridePassword, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_overridePassword(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_vars(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().Vars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.VarsMap)
	fc.Result = res
	return ec.marshalOvarsMap2githubcomgen0cidelaforgegraphqlgraphmodelVarsMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_vars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_varsMap_key(ctx, field)
			case "value":
				return ec.fieldContext_varsMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type varsMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_userGroups(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_userGroups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserGroups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_userGroups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_provisionSteps(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_provisionSteps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionSteps, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_provisionSteps(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_tags(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalNtagMap2githubcomgen0cidelaforgegraphqlgraphmodelTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_Disk(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_Disk(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disk(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Disk)
	fc.Result = res
	return ec.marshalNDisk2githubcomgen0cidelaforgeentDisk(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_Disk(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Disk_id(ctx, field)
			case "size":
				return ec.fieldContext_Disk_size(ctx, field)
			case "Host":
				return ec.fieldContext_Disk_Host(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Disk", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_Users(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_Users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.User)
	fc.Result = res
	return ec.marshalNUser2githubcomgen0cidelaforgeentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_Users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "hclId":
				return ec.fieldContext_User_hclId(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "uuid":
				return ec.fieldContext_User_uuid(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "Tag":
				return ec.fieldContext_User_Tag(ctx, field)
			case "Environments":
				return ec.fieldContext_User_Environments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_IncludedNetworks(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_IncludedNetworks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IncludedNetworks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.IncludedNetwork)
	fc.Result = res
	return ec.marshalNIncludedNetwork2githubcomgen0cidelaforgeentIncludedNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_IncludedNetworks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IncludedNetwork_id(ctx, field)
			case "name":
				return ec.fieldContext_IncludedNetwork_name(ctx, field)
			case "includedHosts":
				return ec.fieldContext_IncludedNetwork_includedHosts(ctx, field)
			case "Tags":
				return ec.fieldContext_IncludedNetwork_Tags(ctx, field)
			case "Hosts":
				return ec.fieldContext_IncludedNetwork_Hosts(ctx, field)
			case "Network":
				return ec.fieldContext_IncludedNetwork_Network(ctx, field)
			case "Environments":
				return ec.fieldContext_IncludedNetwork_Environments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IncludedNetwork", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_DependOnHostDependencies(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_DependOnHostDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DependOnHostDependencies(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.HostDependency)
	fc.Result = res
	return ec.marshalNHostDependency2githubcomgen0cidelaforgeentHostDependency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_DependOnHostDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_HostDependency_id(ctx, field)
			case "hostId":
				return ec.fieldContext_HostDependency_hostId(ctx, field)
			case "networkId":
				return ec.fieldContext_HostDependency_networkId(ctx, field)
			case "RequiredBy":
				return ec.fieldContext_HostDependency_RequiredBy(ctx, field)
			case "DependOnHost":
				return ec.fieldContext_HostDependency_DependOnHost(ctx, field)
			case "DependOnNetwork":
				return ec.fieldContext_HostDependency_DependOnNetwork(ctx, field)
			case "Environment":
				return ec.fieldContext_HostDependency_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostDependency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_RequiredByHostDependencies(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_RequiredByHostDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiredByHostDependencies(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.HostDependency)
	fc.Result = res
	return ec.marshalNHostDependency2githubcomgen0cidelaforgeentHostDependency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_RequiredByHostDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_HostDependency_id(ctx, field)
			case "hostId":
				return ec.fieldContext_HostDependency_hostId(ctx, field)
			case "networkId":
				return ec.fieldContext_HostDependency_networkId(ctx, field)
			case "RequiredBy":
				return ec.fieldContext_HostDependency_RequiredBy(ctx, field)
			case "DependOnHost":
				return ec.fieldContext_HostDependency_DependOnHost(ctx, field)
			case "DependOnNetwork":
				return ec.fieldContext_HostDependency_DependOnNetwork(ctx, field)
			case "Environment":
				return ec.fieldContext_HostDependency_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostDependency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostDependency_id(ctx context.Context, field graphql.CollectedField, obj *ent.HostDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostDependency_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.HostDependency().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostDependency_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostDependency",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostDependency_hostId(ctx context.Context, field graphql.CollectedField, obj *ent.HostDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostDependency_hostId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostDependency_hostId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostDependency_networkId(ctx context.Context, field graphql.CollectedField, obj *ent.HostDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostDependency_networkId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NetworkID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostDependency_networkId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostDependency_RequiredBy(ctx context.Context, field graphql.CollectedField, obj *ent.HostDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostDependency_RequiredBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiredBy(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Host)
	fc.Result = res
	return ec.marshalOHost2githubcomgen0cidelaforgeentHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostDependency_RequiredBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostDependency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Host_hclId(ctx, field)
			case "hostname":
				return ec.fieldContext_Host_hostname(ctx, field)
			case "description":
				return ec.fieldContext_Host_description(ctx, field)
			case "OS":
				return ec.fieldContext_Host_OS(ctx, field)
			case "lastOctet":
				return ec.fieldContext_Host_lastOctet(ctx, field)
			case "instanceSize":
				return ec.fieldContext_Host_instanceSize(ctx, field)
			case "allowMacChanges":
				return ec.fieldContext_Host_allowMacChanges(ctx, field)
			case "exposedTcpPorts":
				return ec.fieldContext_Host_exposedTcpPorts(ctx, field)
			case "exposedUdpPorts":
				return ec.fieldContext_Host_exposedUdpPorts(ctx, field)
			case "overridePassword":
				return ec.fieldContext_Host_overridePassword(ctx, field)
			case "vars":
				return ec.fieldContext_Host_vars(ctx, field)
			case "userGroups":
				return ec.fieldContext_Host_userGroups(ctx, field)
			case "provisionSteps":
				return ec.fieldContext_Host_provisionSteps(ctx, field)
			case "tags":
				return ec.fieldContext_Host_tags(ctx, field)
			case "Disk":
				return ec.fieldContext_Host_Disk(ctx, field)
			case "Users":
				return ec.fieldContext_Host_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Host_Environment(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Host_IncludedNetworks(ctx, field)
			case "DependOnHostDependencies":
				return ec.fieldContext_Host_DependOnHostDependencies(ctx, field)
			case "RequiredByHostDependencies":
				return ec.fieldContext_Host_RequiredByHostDependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostDependency_DependOnHost(ctx context.Context, field graphql.CollectedField, obj *ent.HostDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostDependency_DependOnHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DependOnHost(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Host)
	fc.Result = res
	return ec.marshalOHost2githubcomgen0cidelaforgeentHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostDependency_DependOnHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostDependency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Host_hclId(ctx, field)
			case "hostname":
				return ec.fieldContext_Host_hostname(ctx, field)
			case "description":
				return ec.fieldContext_Host_description(ctx, field)
			case "OS":
				return ec.fieldContext_Host_OS(ctx, field)
			case "lastOctet":
				return ec.fieldContext_Host_lastOctet(ctx, field)
			case "instanceSize":
				return ec.fieldContext_Host_instanceSize(ctx, field)
			case "allowMacChanges":
				return ec.fieldContext_Host_allowMacChanges(ctx, field)
			case "exposedTcpPorts":
				return ec.fieldContext_Host_exposedTcpPorts(ctx, field)
			case "exposedUdpPorts":
				return ec.fieldContext_Host_exposedUdpPorts(ctx, field)
			case "overridePassword":
				return ec.fieldContext_Host_overridePassword(ctx, field)
			case "vars":
				return ec.fieldContext_Host_vars(ctx, field)
			case "userGroups":
				return ec.fieldContext_Host_userGroups(ctx, field)
			case "provisionSteps":
				return ec.fieldContext_Host_provisionSteps(ctx, field)
			case "tags":
				return ec.fieldContext_Host_tags(ctx, field)
			case "Disk":
				return ec.fieldContext_Host_Disk(ctx, field)
			case "Users":
				return ec.fieldContext_Host_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Host_Environment(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Host_IncludedNetworks(ctx, field)
			case "DependOnHostDependencies":
				return ec.fieldContext_Host_DependOnHostDependencies(ctx, field)
			case "RequiredByHostDependencies":
				return ec.fieldContext_Host_RequiredByHostDependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostDependency_DependOnNetwork(ctx context.Context, field graphql.CollectedField, obj *ent.HostDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostDependency_DependOnNetwork(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DependOnNetwork(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Network)
	fc.Result = res
	return ec.marshalONetwork2githubcomgen0cidelaforgeentNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostDependency_DependOnNetwork(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostDependency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Network_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Network_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Network_name(ctx, field)
			case "cidr":
				return ec.fieldContext_Network_cidr(ctx, field)
			case "vdiVisible":
				return ec.fieldContext_Network_vdiVisible(ctx, field)
			case "vars":
				return ec.fieldContext_Network_vars(ctx, field)
			case "tags":
				return ec.fieldContext_Network_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_Network_Environment(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Network_HostDependencies(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Network_IncludedNetworks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Network", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostDependency_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.HostDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostDependency_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalOEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostDependency_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostDependency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identity_id(ctx context.Context, field graphql.CollectedField, obj *ent.Identity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identity_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Identity().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identity_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identity_hclid(ctx context.Context, field graphql.CollectedField, obj *ent.Identity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identity_hclid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identity_hclid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identity_firstName(ctx context.Context, field graphql.CollectedField, obj *ent.Identity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identity_firstName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FirstName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identity_firstName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identity_lastName(ctx context.Context, field graphql.CollectedField, obj *ent.Identity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identity_lastName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identity_lastName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identity_email(ctx context.Context, field graphql.CollectedField, obj *ent.Identity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identity_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identity_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identity_password(ctx context.Context, field graphql.CollectedField, obj *ent.Identity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identity_password(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Password, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identity_password(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identity_description(ctx context.Context, field graphql.CollectedField, obj *ent.Identity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identity_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identity_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identity_avatarFile(ctx context.Context, field graphql.CollectedField, obj *ent.Identity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identity_avatarFile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvatarFile, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identity_avatarFile(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identity_vars(ctx context.Context, field graphql.CollectedField, obj *ent.Identity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identity_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Identity().Vars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.VarsMap)
	fc.Result = res
	return ec.marshalNvarsMap2githubcomgen0cidelaforgegraphqlgraphmodelVarsMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identity_vars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_varsMap_key(ctx, field)
			case "value":
				return ec.fieldContext_varsMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type varsMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identity_tags(ctx context.Context, field graphql.CollectedField, obj *ent.Identity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identity_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Identity().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalNtagMap2githubcomgen0cidelaforgegraphqlgraphmodelTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identity_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identity_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.Identity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identity_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identity_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identity",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IncludedNetwork_id(ctx context.Context, field graphql.CollectedField, obj *ent.IncludedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IncludedNetwork_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.IncludedNetwork().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IncludedNetwork_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IncludedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IncludedNetwork_name(ctx context.Context, field graphql.CollectedField, obj *ent.IncludedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IncludedNetwork_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IncludedNetwork_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IncludedNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IncludedNetwork_includedHosts(ctx context.Context, field graphql.CollectedField, obj *ent.IncludedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IncludedNetwork_includedHosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IncludedHosts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IncludedNetwork_includedHosts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IncludedNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IncludedNetwork_Tags(ctx context.Context, field graphql.CollectedField, obj *ent.IncludedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IncludedNetwork_Tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Tag)
	fc.Result = res
	return ec.marshalNTag2githubcomgen0cidelaforgeentTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IncludedNetwork_Tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IncludedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "uuid":
				return ec.fieldContext_Tag_uuid(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "description":
				return ec.fieldContext_Tag_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IncludedNetwork_Hosts(ctx context.Context, field graphql.CollectedField, obj *ent.IncludedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IncludedNetwork_Hosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hosts(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Host)
	fc.Result = res
	return ec.marshalNHost2githubcomgen0cidelaforgeentHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IncludedNetwork_Hosts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IncludedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Host_hclId(ctx, field)
			case "hostname":
				return ec.fieldContext_Host_hostname(ctx, field)
			case "description":
				return ec.fieldContext_Host_description(ctx, field)
			case "OS":
				return ec.fieldContext_Host_OS(ctx, field)
			case "lastOctet":
				return ec.fieldContext_Host_lastOctet(ctx, field)
			case "instanceSize":
				return ec.fieldContext_Host_instanceSize(ctx, field)
			case "allowMacChanges":
				return ec.fieldContext_Host_allowMacChanges(ctx, field)
			case "exposedTcpPorts":
				return ec.fieldContext_Host_exposedTcpPorts(ctx, field)
			case "exposedUdpPorts":
				return ec.fieldContext_Host_exposedUdpPorts(ctx, field)
			case "overridePassword":
				return ec.fieldContext_Host_overridePassword(ctx, field)
			case "vars":
				return ec.fieldContext_Host_vars(ctx, field)
			case "userGroups":
				return ec.fieldContext_Host_userGroups(ctx, field)
			case "provisionSteps":
				return ec.fieldContext_Host_provisionSteps(ctx, field)
			case "tags":
				return ec.fieldContext_Host_tags(ctx, field)
			case "Disk":
				return ec.fieldContext_Host_Disk(ctx, field)
			case "Users":
				return ec.fieldContext_Host_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Host_Environment(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Host_IncludedNetworks(ctx, field)
			case "DependOnHostDependencies":
				return ec.fieldContext_Host_DependOnHostDependencies(ctx, field)
			case "RequiredByHostDependencies":
				return ec.fieldContext_Host_RequiredByHostDependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IncludedNetwork_Network(ctx context.Context, field graphql.CollectedField, obj *ent.IncludedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IncludedNetwork_Network(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Network(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Network)
	fc.Result = res
	return ec.marshalONetwork2githubcomgen0cidelaforgeentNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IncludedNetwork_Network(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IncludedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Network_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Network_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Network_name(ctx, field)
			case "cidr":
				return ec.fieldContext_Network_cidr(ctx, field)
			case "vdiVisible":
				return ec.fieldContext_Network_vdiVisible(ctx, field)
			case "vars":
				return ec.fieldContext_Network_vars(ctx, field)
			case "tags":
				return ec.fieldContext_Network_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_Network_Environment(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Network_HostDependencies(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Network_IncludedNetworks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Network", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IncludedNetwork_Environments(ctx context.Context, field graphql.CollectedField, obj *ent.IncludedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IncludedNetwork_Environments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environments(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IncludedNetwork_Environments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IncludedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LaForgePageInfo_total(ctx context.Context, field graphql.CollectedField, obj *model.LaForgePageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LaForgePageInfo_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LaForgePageInfo_total(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LaForgePageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LaForgePageInfo_nextOffset(ctx context.Context, field graphql.CollectedField, obj *model.LaForgePageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LaForgePageInfo_nextOffset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextOffset, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LaForgePageInfo_nextOffset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LaForgePageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_loadEnvironment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_loadEnvironment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().LoadEnvironment(rctx, fc.Args["envFilePath"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.Environment); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.Environment`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Environment)
	fc.Result = res
	return ec.marshalOEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_loadEnvironment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_loadEnvironment_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createBuild(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createBuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateBuild(rctx, fc.Args["envUUID"].(string), fc.Args["renderFiles"].(bool))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.Build); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.Build`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Build)
	fc.Result = res
	return ec.marshalOBuild2githubcomgen0cidelaforgeentBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createBuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createBuild_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteUser(rctx, fc.Args["userUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_executePlan(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_executePlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ExecutePlan(rctx, fc.Args["buildUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.Build); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.Build`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Build)
	fc.Result = res
	return ec.marshalOBuild2githubcomgen0cidelaforgeentBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_executePlan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_executePlan_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteBuild(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteBuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteBuild(rctx, fc.Args["buildUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteBuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteBuild_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateTask(rctx, fc.Args["proHostUUID"].(string), fc.Args["command"].(model.AgentCommand), fc.Args["args"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_dumpBuild(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_dumpBuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DumpBuild(rctx, fc.Args["buildUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_dumpBuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_dumpBuild_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_rebuild(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_rebuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().Rebuild(rctx, fc.Args["rootPlans"].([]*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_rebuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_rebuild_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_approveCommit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_approveCommit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ApproveCommit(rctx, fc.Args["commitUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_approveCommit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_approveCommit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelCommit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cancelCommit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CancelCommit(rctx, fc.Args["commitUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cancelCommit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelCommit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createAgentTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createAgentTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateAgentTasks(rctx, fc.Args["hostHCLID"].(string), fc.Args["command"].(model.AgentCommand), fc.Args["buildUUID"].(string), fc.Args["args"].([]string), fc.Args["teams"].([]int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.AgentTask); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.AgentTask`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.AgentTask)
	fc.Result = res
	return ec.marshalNAgentTask2githubcomgen0cidelaforgeentAgentTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createAgentTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AgentTask_id(ctx, field)
			case "args":
				return ec.fieldContext_AgentTask_args(ctx, field)
			case "command":
				return ec.fieldContext_AgentTask_command(ctx, field)
			case "number":
				return ec.fieldContext_AgentTask_number(ctx, field)
			case "output":
				return ec.fieldContext_AgentTask_output(ctx, field)
			case "state":
				return ec.fieldContext_AgentTask_state(ctx, field)
			case "errorMessage":
				return ec.fieldContext_AgentTask_errorMessage(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_AgentTask_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_AgentTask_ProvisioningScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentTask_ProvisionedHost(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_AgentTask_AdhocPlans(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentTask", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createAgentTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createBatchAgentTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createBatchAgentTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateBatchAgentTasks(rctx, fc.Args["proHostUUIDs"].([]string), fc.Args["command"].(model.AgentCommand), fc.Args["args"].([]string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.AgentTask); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.AgentTask`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.AgentTask)
	fc.Result = res
	return ec.marshalNAgentTask2githubcomgen0cidelaforgeentAgentTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createBatchAgentTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AgentTask_id(ctx, field)
			case "args":
				return ec.fieldContext_AgentTask_args(ctx, field)
			case "command":
				return ec.fieldContext_AgentTask_command(ctx, field)
			case "number":
				return ec.fieldContext_AgentTask_number(ctx, field)
			case "output":
				return ec.fieldContext_AgentTask_output(ctx, field)
			case "state":
				return ec.fieldContext_AgentTask_state(ctx, field)
			case "errorMessage":
				return ec.fieldContext_AgentTask_errorMessage(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_AgentTask_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_AgentTask_ProvisioningScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentTask_ProvisionedHost(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_AgentTask_AdhocPlans(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentTask", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createBatchAgentTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createEnviromentFromRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createEnviromentFromRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateEnviromentFromRepo(rctx, fc.Args["repoURL"].(string), fc.Args["branchName"].(string), fc.Args["envFilePath"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.Environment); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.Environment`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createEnviromentFromRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createEnviromentFromRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateEnviromentViaPull(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateEnviromentViaPull(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateEnviromentViaPull(rctx, fc.Args["envUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.Environment); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.Environment`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateEnviromentViaPull(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateEnviromentViaPull_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelBuild(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cancelBuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CancelBuild(rctx, fc.Args["buildUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cancelBuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelBuild_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_modifySelfPassword(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_modifySelfPassword(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ModifySelfPassword(rctx, fc.Args["currentPassword"].(string), fc.Args["newPassword"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_modifySelfPassword(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_modifySelfPassword_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_modifySelfUserInfo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_modifySelfUserInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ModifySelfUserInfo(rctx, fc.Args["firstName"].(*string), fc.Args["lastName"].(*string), fc.Args["email"].(*string), fc.Args["phone"].(*string), fc.Args["company"].(*string), fc.Args["occupation"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.AuthUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.AuthUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.AuthUser)
	fc.Result = res
	return ec.marshalOAuthUser2githubcomgen0cidelaforgeentAuthUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_modifySelfUserInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AuthUser_id(ctx, field)
			case "username":
				return ec.fieldContext_AuthUser_username(ctx, field)
			case "firstName":
				return ec.fieldContext_AuthUser_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_AuthUser_lastName(ctx, field)
			case "email":
				return ec.fieldContext_AuthUser_email(ctx, field)
			case "phone":
				return ec.fieldContext_AuthUser_phone(ctx, field)
			case "company":
				return ec.fieldContext_AuthUser_company(ctx, field)
			case "occupation":
				return ec.fieldContext_AuthUser_occupation(ctx, field)
			case "publicKey":
				return ec.fieldContext_AuthUser_publicKey(ctx, field)
			case "role":
				return ec.fieldContext_AuthUser_role(ctx, field)
			case "provider":
				return ec.fieldContext_AuthUser_provider(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_AuthUser_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthUser", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_modifySelfUserInfo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateUser(rctx, fc.Args["username"].(string), fc.Args["password"].(string), fc.Args["role"].(model.RoleLevel), fc.Args["provider"].(model.ProviderType))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.AuthUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.AuthUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.AuthUser)
	fc.Result = res
	return ec.marshalOAuthUser2githubcomgen0cidelaforgeentAuthUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AuthUser_id(ctx, field)
			case "username":
				return ec.fieldContext_AuthUser_username(ctx, field)
			case "firstName":
				return ec.fieldContext_AuthUser_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_AuthUser_lastName(ctx, field)
			case "email":
				return ec.fieldContext_AuthUser_email(ctx, field)
			case "phone":
				return ec.fieldContext_AuthUser_phone(ctx, field)
			case "company":
				return ec.fieldContext_AuthUser_company(ctx, field)
			case "occupation":
				return ec.fieldContext_AuthUser_occupation(ctx, field)
			case "publicKey":
				return ec.fieldContext_AuthUser_publicKey(ctx, field)
			case "role":
				return ec.fieldContext_AuthUser_role(ctx, field)
			case "provider":
				return ec.fieldContext_AuthUser_provider(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_AuthUser_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthUser", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_modifyAdminUserInfo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_modifyAdminUserInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ModifyAdminUserInfo(rctx, fc.Args["userID"].(string), fc.Args["username"].(*string), fc.Args["firstName"].(*string), fc.Args["lastName"].(*string), fc.Args["email"].(*string), fc.Args["phone"].(*string), fc.Args["company"].(*string), fc.Args["occupation"].(*string), fc.Args["role"].(*model.RoleLevel), fc.Args["provider"].(*model.ProviderType))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.AuthUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.AuthUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.AuthUser)
	fc.Result = res
	return ec.marshalOAuthUser2githubcomgen0cidelaforgeentAuthUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_modifyAdminUserInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AuthUser_id(ctx, field)
			case "username":
				return ec.fieldContext_AuthUser_username(ctx, field)
			case "firstName":
				return ec.fieldContext_AuthUser_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_AuthUser_lastName(ctx, field)
			case "email":
				return ec.fieldContext_AuthUser_email(ctx, field)
			case "phone":
				return ec.fieldContext_AuthUser_phone(ctx, field)
			case "company":
				return ec.fieldContext_AuthUser_company(ctx, field)
			case "occupation":
				return ec.fieldContext_AuthUser_occupation(ctx, field)
			case "publicKey":
				return ec.fieldContext_AuthUser_publicKey(ctx, field)
			case "role":
				return ec.fieldContext_AuthUser_role(ctx, field)
			case "provider":
				return ec.fieldContext_AuthUser_provider(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_AuthUser_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthUser", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_modifyAdminUserInfo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_modifyAdminPassword(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_modifyAdminPassword(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ModifyAdminPassword(rctx, fc.Args["userID"].(string), fc.Args["newPassword"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_modifyAdminPassword(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_modifyAdminPassword_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_nukeBackend(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_nukeBackend(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().NukeBackend(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.IntMap); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/graphql/graph/model.IntMap`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.IntMap)
	fc.Result = res
	return ec.marshalNintMap2githubcomgen0cidelaforgegraphqlgraphmodelIntMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_nukeBackend(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_intMap_key(ctx, field)
			case "value":
				return ec.fieldContext_intMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type intMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Network_id(ctx context.Context, field graphql.CollectedField, obj *ent.Network) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Network_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Network().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Network_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Network",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Network_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.Network) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Network_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Network_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Network",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Network_name(ctx context.Context, field graphql.CollectedField, obj *ent.Network) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Network_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Network_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Network",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Network_cidr(ctx context.Context, field graphql.CollectedField, obj *ent.Network) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Network_cidr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cidr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Network_cidr(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Network",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Network_vdiVisible(ctx context.Context, field graphql.CollectedField, obj *ent.Network) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Network_vdiVisible(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VdiVisible, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Network_vdiVisible(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Network",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Network_vars(ctx context.Context, field graphql.CollectedField, obj *ent.Network) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Network_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Network().Vars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.VarsMap)
	fc.Result = res
	return ec.marshalOvarsMap2githubcomgen0cidelaforgegraphqlgraphmodelVarsMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Network_vars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Network",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_varsMap_key(ctx, field)
			case "value":
				return ec.fieldContext_varsMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type varsMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Network_tags(ctx context.Context, field graphql.CollectedField, obj *ent.Network) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Network_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Network().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalNtagMap2githubcomgen0cidelaforgegraphqlgraphmodelTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Network_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Network",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Network_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.Network) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Network_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Network_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Network",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Network_HostDependencies(ctx context.Context, field graphql.CollectedField, obj *ent.Network) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Network_HostDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostDependencies(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.HostDependency)
	fc.Result = res
	return ec.marshalNHostDependency2githubcomgen0cidelaforgeentHostDependency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Network_HostDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Network",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_HostDependency_id(ctx, field)
			case "hostId":
				return ec.fieldContext_HostDependency_hostId(ctx, field)
			case "networkId":
				return ec.fieldContext_HostDependency_networkId(ctx, field)
			case "RequiredBy":
				return ec.fieldContext_HostDependency_RequiredBy(ctx, field)
			case "DependOnHost":
				return ec.fieldContext_HostDependency_DependOnHost(ctx, field)
			case "DependOnNetwork":
				return ec.fieldContext_HostDependency_DependOnNetwork(ctx, field)
			case "Environment":
				return ec.fieldContext_HostDependency_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostDependency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Network_IncludedNetworks(ctx context.Context, field graphql.CollectedField, obj *ent.Network) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Network_IncludedNetworks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IncludedNetworks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.IncludedNetwork)
	fc.Result = res
	return ec.marshalNIncludedNetwork2githubcomgen0cidelaforgeentIncludedNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Network_IncludedNetworks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Network",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IncludedNetwork_id(ctx, field)
			case "name":
				return ec.fieldContext_IncludedNetwork_name(ctx, field)
			case "includedHosts":
				return ec.fieldContext_IncludedNetwork_includedHosts(ctx, field)
			case "Tags":
				return ec.fieldContext_IncludedNetwork_Tags(ctx, field)
			case "Hosts":
				return ec.fieldContext_IncludedNetwork_Hosts(ctx, field)
			case "Network":
				return ec.fieldContext_IncludedNetwork_Network(ctx, field)
			case "Environments":
				return ec.fieldContext_IncludedNetwork_Environments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IncludedNetwork", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_id(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Plan().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_stepNumber(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_stepNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StepNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_stepNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_type(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Plan().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.PlanType)
	fc.Result = res
	return ec.marshalNPlanType2githubcomgen0cidelaforgegraphqlgraphmodelPlanType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PlanType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_NextPlans(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_NextPlans(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextPlans(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Plan)
	fc.Result = res
	return ec.marshalNPlan2githubcomgen0cidelaforgeentPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_NextPlans(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Plan_id(ctx, field)
			case "stepNumber":
				return ec.fieldContext_Plan_stepNumber(ctx, field)
			case "type":
				return ec.fieldContext_Plan_type(ctx, field)
			case "NextPlans":
				return ec.fieldContext_Plan_NextPlans(ctx, field)
			case "PrevPlans":
				return ec.fieldContext_Plan_PrevPlans(ctx, field)
			case "Build":
				return ec.fieldContext_Plan_Build(ctx, field)
			case "Team":
				return ec.fieldContext_Plan_Team(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Plan_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Plan_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
			case "Status":
				return ec.fieldContext_Plan_Status(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_Plan_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Plan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_PrevPlans(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_PrevPlans(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrevPlans(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Plan)
	fc.Result = res
	return ec.marshalNPlan2githubcomgen0cidelaforgeentPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_PrevPlans(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Plan_id(ctx, field)
			case "stepNumber":
				return ec.fieldContext_Plan_stepNumber(ctx, field)
			case "type":
				return ec.fieldContext_Plan_type(ctx, field)
			case "NextPlans":
				return ec.fieldContext_Plan_NextPlans(ctx, field)
			case "PrevPlans":
				return ec.fieldContext_Plan_PrevPlans(ctx, field)
			case "Build":
				return ec.fieldContext_Plan_Build(ctx, field)
			case "Team":
				return ec.fieldContext_Plan_Team(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Plan_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Plan_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
			case "Status":
				return ec.fieldContext_Plan_Status(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_Plan_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Plan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_Build(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_Build(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Build(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Build)
	fc.Result = res
	return ec.marshalOBuild2githubcomgen0cidelaforgeentBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_Build(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_Team(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_Team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Team(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Team)
	fc.Result = res
	return ec.marshalOTeam2githubcomgen0cidelaforgeentTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_Team(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "teamNumber":
				return ec.fieldContext_Team_teamNumber(ctx, field)
			case "Build":
				return ec.fieldContext_Team_Build(ctx, field)
			case "Status":
				return ec.fieldContext_Team_Status(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Team_ProvisionedNetworks(ctx, field)
			case "Plan":
				return ec.fieldContext_Team_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_ProvisionedNetwork(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedNetwork(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedNetwork)
	fc.Result = res
	return ec.marshalOProvisionedNetwork2githubcomgen0cidelaforgeentProvisionedNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_ProvisionedNetwork(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedNetwork_id(ctx, field)
			case "name":
				return ec.fieldContext_ProvisionedNetwork_name(ctx, field)
			case "cidr":
				return ec.fieldContext_ProvisionedNetwork_cidr(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedNetwork_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedNetwork_Status(ctx, field)
			case "Network":
				return ec.fieldContext_ProvisionedNetwork_Network(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedNetwork_Build(ctx, field)
			case "Team":
				return ec.fieldContext_ProvisionedNetwork_Team(ctx, field)
			case "ProvisionedHosts":
				return ec.fieldContext_ProvisionedNetwork_ProvisionedHosts(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedNetwork_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedNetwork", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_ProvisionedHost(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_ProvisionedHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedHost(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedHost)
	fc.Result = res
	return ec.marshalOProvisionedHost2githubcomgen0cidelaforgeentProvisionedHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_ProvisionedHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedHost_id(ctx, field)
			case "subnetIp":
				return ec.fieldContext_ProvisionedHost_subnetIp(ctx, field)
			case "addonType":
				return ec.fieldContext_ProvisionedHost_addonType(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedHost_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedHost_Status(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_ProvisionedHost_ProvisionedNetwork(ctx, field)
			case "Host":
				return ec.fieldContext_ProvisionedHost_Host(ctx, field)
			case "EndStepPlan":
				return ec.fieldContext_ProvisionedHost_EndStepPlan(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedHost_Build(ctx, field)
			case "ProvisioningSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningSteps(ctx, field)
			case "ProvisioningScheduledSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningScheduledSteps(ctx, field)
			case "AgentStatus":
				return ec.fieldContext_ProvisionedHost_AgentStatus(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisionedHost_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedHost_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisionedHost_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedHost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_ProvisioningStep(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_ProvisioningStep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisioningStep(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisioningStep)
	fc.Result = res
	return ec.marshalOProvisioningStep2githubcomgen0cidelaforgeentProvisioningStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_ProvisioningStep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisioningStep_id(ctx, field)
			case "type":
				return ec.fieldContext_ProvisioningStep_type(ctx, field)
			case "stepNumber":
				return ec.fieldContext_ProvisioningStep_stepNumber(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisioningStep_Status(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_ProvisioningStep_ProvisionedHost(ctx, field)
			case "Script":
				return ec.fieldContext_ProvisioningStep_Script(ctx, field)
			case "Command":
				return ec.fieldContext_ProvisioningStep_Command(ctx, field)
			case "DNSRecord":
				return ec.fieldContext_ProvisioningStep_DNSRecord(ctx, field)
			case "FileDelete":
				return ec.fieldContext_ProvisioningStep_FileDelete(ctx, field)
			case "FileDownload":
				return ec.fieldContext_ProvisioningStep_FileDownload(ctx, field)
			case "FileExtract":
				return ec.fieldContext_ProvisioningStep_FileExtract(ctx, field)
			case "Ansible":
				return ec.fieldContext_ProvisioningStep_Ansible(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisioningStep_Plan(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisioningStep_AgentTasks(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisioningStep_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisioningStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_ProvisioningScheduledStep(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisioningScheduledStep(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisioningScheduledStep)
	fc.Result = res
	return ec.marshalOProvisioningScheduledStep2githubcomgen0cidelaforgeentProvisioningScheduledStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_ProvisioningScheduledStep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisioningScheduledStep_id(ctx, field)
			case "type":
				return ec.fieldContext_ProvisioningScheduledStep_type(ctx, field)
			case "runTime":
				return ec.fieldContext_ProvisioningScheduledStep_runTime(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisioningScheduledStep_Status(ctx, field)
			case "ScheduledStep":
				return ec.fieldContext_ProvisioningScheduledStep_ScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_ProvisioningScheduledStep_ProvisionedHost(ctx, field)
			case "Script":
				return ec.fieldContext_ProvisioningScheduledStep_Script(ctx, field)
			case "Command":
				return ec.fieldContext_ProvisioningScheduledStep_Command(ctx, field)
			case "DNSRecord":
				return ec.fieldContext_ProvisioningScheduledStep_DNSRecord(ctx, field)
			case "FileDelete":
				return ec.fieldContext_ProvisioningScheduledStep_FileDelete(ctx, field)
			case "FileDownload":
				return ec.fieldContext_ProvisioningScheduledStep_FileDownload(ctx, field)
			case "FileExtract":
				return ec.fieldContext_ProvisioningScheduledStep_FileExtract(ctx, field)
			case "Ansible":
				return ec.fieldContext_ProvisioningScheduledStep_Ansible(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisioningScheduledStep_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisioningScheduledStep_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisioningScheduledStep_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisioningScheduledStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_Status(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_Status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Status)
	fc.Result = res
	return ec.marshalNStatus2githubcomgen0cidelaforgeentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_Status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_PlanDiffs(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_PlanDiffs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlanDiffs(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.PlanDiff)
	fc.Result = res
	return ec.marshalNPlanDiff2githubcomgen0cidelaforgeentPlanDiff(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_PlanDiffs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PlanDiff_id(ctx, field)
			case "revision":
				return ec.fieldContext_PlanDiff_revision(ctx, field)
			case "newState":
				return ec.fieldContext_PlanDiff_newState(ctx, field)
			case "BuildCommit":
				return ec.fieldContext_PlanDiff_BuildCommit(ctx, field)
			case "Plan":
				return ec.fieldContext_PlanDiff_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlanDiff", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_planning(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_planning(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Planning, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_planning(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_awaiting(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_awaiting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Awaiting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_awaiting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_parentAwaiting(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_parentAwaiting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentAwaiting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_parentAwaiting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_inProgress(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_inProgress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InProgress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_inProgress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_failed(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_failed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Failed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_failed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_complete(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_complete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Complete, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_complete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_tainted(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_tainted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tainted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_tainted(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_undefined(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_undefined(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Undefined, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_undefined(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_toDelete(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_toDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToDelete, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_toDelete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_deleteInProgress(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_deleteInProgress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeleteInProgress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_deleteInProgress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_deleted(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_deleted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deleted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_deleted(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_toRebuild(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_toRebuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToRebuild, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_toRebuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_cancelled(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_cancelled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cancelled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_cancelled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanDiff_id(ctx context.Context, field graphql.CollectedField, obj *ent.PlanDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanDiff_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PlanDiff().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanDiff_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanDiff",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanDiff_revision(ctx context.Context, field graphql.CollectedField, obj *ent.PlanDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanDiff_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanDiff_revision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanDiff_newState(ctx context.Context, field graphql.CollectedField, obj *ent.PlanDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanDiff_newState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PlanDiff().NewState(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ProvisionStatus)
	fc.Result = res
	return ec.marshalNProvisionStatus2githubcomgen0cidelaforgegraphqlgraphmodelProvisionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanDiff_newState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanDiff",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProvisionStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanDiff_BuildCommit(ctx context.Context, field graphql.CollectedField, obj *ent.PlanDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanDiff_BuildCommit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildCommit(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.BuildCommit)
	fc.Result = res
	return ec.marshalNBuildCommit2githubcomgen0cidelaforgeentBuildCommit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanDiff_BuildCommit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanDiff",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BuildCommit_id(ctx, field)
			case "type":
				return ec.fieldContext_BuildCommit_type(ctx, field)
			case "revision":
				return ec.fieldContext_BuildCommit_revision(ctx, field)
			case "state":
				return ec.fieldContext_BuildCommit_state(ctx, field)
			case "createdAt":
				return ec.fieldContext_BuildCommit_createdAt(ctx, field)
			case "Build":
				return ec.fieldContext_BuildCommit_Build(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_BuildCommit_ServerTasks(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_BuildCommit_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildCommit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanDiff_Plan(ctx context.Context, field graphql.CollectedField, obj *ent.PlanDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanDiff_Plan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plan(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Plan)
	fc.Result = res
	return ec.marshalNPlan2githubcomgen0cidelaforgeentPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanDiff_Plan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanDiff",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Plan_id(ctx, field)
			case "stepNumber":
				return ec.fieldContext_Plan_stepNumber(ctx, field)
			case "type":
				return ec.fieldContext_Plan_type(ctx, field)
			case "NextPlans":
				return ec.fieldContext_Plan_NextPlans(ctx, field)
			case "PrevPlans":
				return ec.fieldContext_Plan_PrevPlans(ctx, field)
			case "Build":
				return ec.fieldContext_Plan_Build(ctx, field)
			case "Team":
				return ec.fieldContext_Plan_Team(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Plan_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Plan_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
			case "Status":
				return ec.fieldContext_Plan_Status(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_Plan_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Plan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_id(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProvisionedHost().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_subnetIp(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_subnetIp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubnetIP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_subnetIp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_addonType(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_addonType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProvisionedHost().AddonType(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ProvisionedHostAddonType)
	fc.Result = res
	return ec.marshalOProvisionedHostAddonType2githubcomgen0cidelaforgegraphqlgraphmodelProvisionedHostAddonType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_addonType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProvisionedHostAddonType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_vars(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProvisionedHost().Vars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.VarsMap)
	fc.Result = res
	return ec.marshalOvarsMap2githubcomgen0cidelaforgegraphqlgraphmodelVarsMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_vars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_varsMap_key(ctx, field)
			case "value":
				return ec.fieldContext_varsMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type varsMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_Status(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_Status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Status)
	fc.Result = res
	return ec.marshalNStatus2githubcomgen0cidelaforgeentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_Status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_ProvisionedNetwork(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_ProvisionedNetwork(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedNetwork(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedNetwork)
	fc.Result = res
	return ec.marshalNProvisionedNetwork2githubcomgen0cidelaforgeentProvisionedNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_ProvisionedNetwork(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedNetwork_id(ctx, field)
			case "name":
				return ec.fieldContext_ProvisionedNetwork_name(ctx, field)
			case "cidr":
				return ec.fieldContext_ProvisionedNetwork_cidr(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedNetwork_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedNetwork_Status(ctx, field)
			case "Network":
				return ec.fieldContext_ProvisionedNetwork_Network(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedNetwork_Build(ctx, field)
			case "Team":
				return ec.fieldContext_ProvisionedNetwork_Team(ctx, field)
			case "ProvisionedHosts":
				return ec.fieldContext_ProvisionedNetwork_ProvisionedHosts(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedNetwork_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedNetwork", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_Host(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_Host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Host(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Host)
	fc.Result = res
	return ec.marshalNHost2githubcomgen0cidelaforgeentHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_Host(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Host_hclId(ctx, field)
			case "hostname":
				return ec.fieldContext_Host_hostname(ctx, field)
			case "description":
				return ec.fieldContext_Host_description(ctx, field)
			case "OS":
				return ec.fieldContext_Host_OS(ctx, field)
			case "lastOctet":
				return ec.fieldContext_Host_lastOctet(ctx, field)
			case "instanceSize":
				return ec.fieldContext_Host_instanceSize(ctx, field)
			case "allowMacChanges":
				return ec.fieldContext_Host_allowMacChanges(ctx, field)
			case "exposedTcpPorts":
				return ec.fieldContext_Host_exposedTcpPorts(ctx, field)
			case "exposedUdpPorts":
				return ec.fieldContext_Host_exposedUdpPorts(ctx, field)
			case "overridePassword":
				return ec.fieldContext_Host_overridePassword(ctx, field)
			case "vars":
				return ec.fieldContext_Host_vars(ctx, field)
			case "userGroups":
				return ec.fieldContext_Host_userGroups(ctx, field)
			case "provisionSteps":
				return ec.fieldContext_Host_provisionSteps(ctx, field)
			case "tags":
				return ec.fieldContext_Host_tags(ctx, field)
			case "Disk":
				return ec.fieldContext_Host_Disk(ctx, field)
			case "Users":
				return ec.fieldContext_Host_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Host_Environment(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Host_IncludedNetworks(ctx, field)
			case "DependOnHostDependencies":
				return ec.fieldContext_Host_DependOnHostDependencies(ctx, field)
			case "RequiredByHostDependencies":
				return ec.fieldContext_Host_RequiredByHostDependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_EndStepPlan(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_EndStepPlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndStepPlan(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Plan)
	fc.Result = res
	return ec.marshalOPlan2githubcomgen0cidelaforgeentPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_EndStepPlan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Plan_id(ctx, field)
			case "stepNumber":
				return ec.fieldContext_Plan_stepNumber(ctx, field)
			case "type":
				return ec.fieldContext_Plan_type(ctx, field)
			case "NextPlans":
				return ec.fieldContext_Plan_NextPlans(ctx, field)
			case "PrevPlans":
				return ec.fieldContext_Plan_PrevPlans(ctx, field)
			case "Build":
				return ec.fieldContext_Plan_Build(ctx, field)
			case "Team":
				return ec.fieldContext_Plan_Team(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Plan_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Plan_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
			case "Status":
				return ec.fieldContext_Plan_Status(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_Plan_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Plan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_Build(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_Build(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Build(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Build)
	fc.Result = res
	return ec.marshalNBuild2githubcomgen0cidelaforgeentBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_Build(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_ProvisioningSteps(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_ProvisioningSteps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisioningSteps(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ProvisioningStep)
	fc.Result = res
	return ec.marshalNProvisioningStep2githubcomgen0cidelaforgeentProvisioningStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_ProvisioningSteps(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisioningStep_id(ctx, field)
			case "type":
				return ec.fieldContext_ProvisioningStep_type(ctx, field)
			case "stepNumber":
				return ec.fieldContext_ProvisioningStep_stepNumber(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisioningStep_Status(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_ProvisioningStep_ProvisionedHost(ctx, field)
			case "Script":
				return ec.fieldContext_ProvisioningStep_Script(ctx, field)
			case "Command":
				return ec.fieldContext_ProvisioningStep_Command(ctx, field)
			case "DNSRecord":
				return ec.fieldContext_ProvisioningStep_DNSRecord(ctx, field)
			case "FileDelete":
				return ec.fieldContext_ProvisioningStep_FileDelete(ctx, field)
			case "FileDownload":
				return ec.fieldContext_ProvisioningStep_FileDownload(ctx, field)
			case "FileExtract":
				return ec.fieldContext_ProvisioningStep_FileExtract(ctx, field)
			case "Ansible":
				return ec.fieldContext_ProvisioningStep_Ansible(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisioningStep_Plan(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisioningStep_AgentTasks(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisioningStep_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisioningStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_ProvisioningScheduledSteps(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_ProvisioningScheduledSteps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisioningScheduledSteps(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ProvisioningScheduledStep)
	fc.Result = res
	return ec.marshalNProvisioningScheduledStep2githubcomgen0cidelaforgeentProvisioningScheduledStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_ProvisioningScheduledSteps(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisioningScheduledStep_id(ctx, field)
			case "type":
				return ec.fieldContext_ProvisioningScheduledStep_type(ctx, field)
			case "runTime":
				return ec.fieldContext_ProvisioningScheduledStep_runTime(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisioningScheduledStep_Status(ctx, field)
			case "ScheduledStep":
				return ec.fieldContext_ProvisioningScheduledStep_ScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_ProvisioningScheduledStep_ProvisionedHost(ctx, field)
			case "Script":
				return ec.fieldContext_ProvisioningScheduledStep_Script(ctx, field)
			case "Command":
				return ec.fieldContext_ProvisioningScheduledStep_Command(ctx, field)
			case "DNSRecord":
				return ec.fieldContext_ProvisioningScheduledStep_DNSRecord(ctx, field)
			case "FileDelete":
				return ec.fieldContext_ProvisioningScheduledStep_FileDelete(ctx, field)
			case "FileDownload":
				return ec.fieldContext_ProvisioningScheduledStep_FileDownload(ctx, field)
			case "FileExtract":
				return ec.fieldContext_ProvisioningScheduledStep_FileExtract(ctx, field)
			case "Ansible":
				return ec.fieldContext_ProvisioningScheduledStep_Ansible(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisioningScheduledStep_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisioningScheduledStep_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisioningScheduledStep_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisioningScheduledStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_AgentStatus(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_AgentStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentStatuses(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.AgentStatus)
	fc.Result = res
	return ec.marshalOAgentStatus2githubcomgen0cidelaforgeentAgentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_AgentStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "clientId":
				return ec.fieldContext_AgentStatus_clientId(ctx, field)
			case "hostname":
				return ec.fieldContext_AgentStatus_hostname(ctx, field)
			case "upTime":
				return ec.fieldContext_AgentStatus_upTime(ctx, field)
			case "bootTime":
				return ec.fieldContext_AgentStatus_bootTime(ctx, field)
			case "numProcs":
				return ec.fieldContext_AgentStatus_numProcs(ctx, field)
			case "OS":
				return ec.fieldContext_AgentStatus_OS(ctx, field)
			case "hostID":
				return ec.fieldContext_AgentStatus_hostID(ctx, field)
			case "load1":
				return ec.fieldContext_AgentStatus_load1(ctx, field)
			case "load5":
				return ec.fieldContext_AgentStatus_load5(ctx, field)
			case "load15":
				return ec.fieldContext_AgentStatus_load15(ctx, field)
			case "totalMem":
				return ec.fieldContext_AgentStatus_totalMem(ctx, field)
			case "freeMem":
				return ec.fieldContext_AgentStatus_freeMem(ctx, field)
			case "usedMem":
				return ec.fieldContext_AgentStatus_usedMem(ctx, field)
			case "timestamp":
				return ec.fieldContext_AgentStatus_timestamp(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentStatus_ProvisionedHost(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_AgentStatus_ProvisionedNetwork(ctx, field)
			case "Build":
				return ec.fieldContext_AgentStatus_Build(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_AgentTasks(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_AgentTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentTasks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.AgentTask)
	fc.Result = res
	return ec.marshalNAgentTask2githubcomgen0cidelaforgeentAgentTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_AgentTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AgentTask_id(ctx, field)
			case "args":
				return ec.fieldContext_AgentTask_args(ctx, field)
			case "command":
				return ec.fieldContext_AgentTask_command(ctx, field)
			case "number":
				return ec.fieldContext_AgentTask_number(ctx, field)
			case "output":
				return ec.fieldContext_AgentTask_output(ctx, field)
			case "state":
				return ec.fieldContext_AgentTask_state(ctx, field)
			case "errorMessage":
				return ec.fieldContext_AgentTask_errorMessage(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_AgentTask_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_AgentTask_ProvisioningScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentTask_ProvisionedHost(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_AgentTask_AdhocPlans(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_Plan(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_Plan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plan(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Plan)
	fc.Result = res
	return ec.marshalNPlan2githubcomgen0cidelaforgeentPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_Plan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Plan_id(ctx, field)
			case "stepNumber":
				return ec.fieldContext_Plan_stepNumber(ctx, field)
			case "type":
				return ec.fieldContext_Plan_type(ctx, field)
			case "NextPlans":
				return ec.fieldContext_Plan_NextPlans(ctx, field)
			case "PrevPlans":
				return ec.fieldContext_Plan_PrevPlans(ctx, field)
			case "Build":
				return ec.fieldContext_Plan_Build(ctx, field)
			case "Team":
				return ec.fieldContext_Plan_Team(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Plan_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Plan_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
			case "Status":
				return ec.fieldContext_Plan_Status(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_Plan_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Plan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_GinFileMiddleware(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_GinFileMiddleware(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GinFileMiddleware(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.GinFileMiddleware)
	fc.Result = res
	return ec.marshalOGinFileMiddleware2githubcomgen0cidelaforgeentGinFileMiddleware(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_GinFileMiddleware(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GinFileMiddleware_id(ctx, field)
			case "urlId":
				return ec.fieldContext_GinFileMiddleware_urlId(ctx, field)
			case "filePath":
				return ec.fieldContext_GinFileMiddleware_filePath(ctx, field)
			case "accessed":
				return ec.fieldContext_GinFileMiddleware_accessed(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_GinFileMiddleware_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_GinFileMiddleware_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_GinFileMiddleware_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GinFileMiddleware", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedNetwork_id(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedNetwork_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProvisionedNetwork().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedNetwork_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedNetwork_name(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedNetwork_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedNetwork_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedNetwork_cidr(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedNetwork_cidr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cidr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedNetwork_cidr(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedNetwork_vars(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedNetwork_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProvisionedNetwork().Vars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.VarsMap)
	fc.Result = res
	return ec.marshalOvarsMap2githubcomgen0cidelaforgegraphqlgraphmodelVarsMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedNetwork_vars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_varsMap_key(ctx, field)
			case "value":
				return ec.fieldContext_varsMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type varsMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedNetwork_Status(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedNetwork_Status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Status)
	fc.Result = res
	return ec.marshalOStatus2githubcomgen0cidelaforgeentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedNetwork_Status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedNetwork_Network(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedNetwork_Network(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Network(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Network)
	fc.Result = res
	return ec.marshalONetwork2githubcomgen0cidelaforgeentNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedNetwork_Network(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Network_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Network_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Network_name(ctx, field)
			case "cidr":
				return ec.fieldContext_Network_cidr(ctx, field)
			case "vdiVisible":
				return ec.fieldContext_Network_vdiVisible(ctx, field)
			case "vars":
				return ec.fieldContext_Network_vars(ctx, field)
			case "tags":
				return ec.fieldContext_Network_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_Network_Environment(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Network_HostDependencies(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Network_IncludedNetworks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Network", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedNetwork_Build(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedNetwork_Build(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Build(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Build)
	fc.Result = res
	return ec.marshalOBuild2githubcomgen0cidelaforgeentBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedNetwork_Build(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedNetwork_Team(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedNetwork_Team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Team(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Team)
	fc.Result = res
	return ec.marshalOTeam2githubcomgen0cidelaforgeentTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedNetwork_Team(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "teamNumber":
				return ec.fieldContext_Team_teamNumber(ctx, field)
			case "Build":
				return ec.fieldContext_Team_Build(ctx, field)
			case "Status":
				return ec.fieldContext_Team_Status(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Team_ProvisionedNetworks(ctx, field)
			case "Plan":
				return ec.fieldContext_Team_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedNetwork_ProvisionedHosts(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedNetwork_ProvisionedHosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedHosts(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ProvisionedHost)
	fc.Result = res
	return ec.marshalNProvisionedHost2githubcomgen0cidelaforgeentProvisionedHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedNetwork_ProvisionedHosts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedHost_id(ctx, field)
			case "subnetIp":
				return ec.fieldContext_ProvisionedHost_subnetIp(ctx, field)
			case "addonType":
				return ec.fieldContext_ProvisionedHost_addonType(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedHost_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedHost_Status(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_ProvisionedHost_ProvisionedNetwork(ctx, field)
			case "Host":
				return ec.fieldContext_ProvisionedHost_Host(ctx, field)
			case "EndStepPlan":
				return ec.fieldContext_ProvisionedHost_EndStepPlan(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedHost_Build(ctx, field)
			case "ProvisioningSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningSteps(ctx, field)
			case "ProvisioningScheduledSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningScheduledSteps(ctx, field)
			case "AgentStatus":
				return ec.fieldContext_ProvisionedHost_AgentStatus(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisionedHost_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedHost_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisionedHost_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedHost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedNetwork_Plan(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedNetwork_Plan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plan(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Plan)
	fc.Result = res
	return ec.marshalOPlan2githubcomgen0cidelaforgeentPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedNetwork_Plan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Plan_id(ctx, field)
			case "stepNumber":
				return ec.fieldContext_Plan_stepNumber(ctx, field)
			case "type":
				return ec.fieldContext_Plan_type(ctx, field)
			case "NextPlans":
				return ec.fieldContext_Plan_NextPlans(ctx, field)
			case "PrevPlans":
				return ec.fieldContext_Plan_PrevPlans(ctx, field)
			case "Build":
				return ec.fieldContext_Plan_Build(ctx, field)
			case "Team":
				return ec.fieldContext_Plan_Team(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Plan_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Plan_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
			case "Status":
				return ec.fieldContext_Plan_Status(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_Plan_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Plan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_id(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProvisioningScheduledStep().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_type(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProvisioningScheduledStep().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ProvisioningScheduledStepType)
	fc.Result = res
	return ec.marshalNProvisioningScheduledStepType2githubcomgen0cidelaforgegraphqlgraphmodelProvisioningScheduledStepType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProvisioningScheduledStepType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_runTime(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_runTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RunTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_runTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_Status(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_Status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Status)
	fc.Result = res
	return ec.marshalOStatus2githubcomgen0cidelaforgeentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_Status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_ScheduledStep(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_ScheduledStep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScheduledStep(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ScheduledStep)
	fc.Result = res
	return ec.marshalNScheduledStep2githubcomgen0cidelaforgeentScheduledStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_ScheduledStep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ScheduledStep_id(ctx, field)
			case "hclId":
				return ec.fieldContext_ScheduledStep_hclId(ctx, field)
			case "name":
				return ec.fieldContext_ScheduledStep_name(ctx, field)
			case "description":
				return ec.fieldContext_ScheduledStep_description(ctx, field)
			case "step":
				return ec.fieldContext_ScheduledStep_step(ctx, field)
			case "type":
				return ec.fieldContext_ScheduledStep_type(ctx, field)
			case "schedule":
				return ec.fieldContext_ScheduledStep_schedule(ctx, field)
			case "runAt":
				return ec.fieldContext_ScheduledStep_runAt(ctx, field)
			case "Environment":
				return ec.fieldContext_ScheduledStep_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ScheduledStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_ProvisionedHost(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_ProvisionedHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedHost(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedHost)
	fc.Result = res
	return ec.marshalNProvisionedHost2githubcomgen0cidelaforgeentProvisionedHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_ProvisionedHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedHost_id(ctx, field)
			case "subnetIp":
				return ec.fieldContext_ProvisionedHost_subnetIp(ctx, field)
			case "addonType":
				return ec.fieldContext_ProvisionedHost_addonType(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedHost_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedHost_Status(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_ProvisionedHost_ProvisionedNetwork(ctx, field)
			case "Host":
				return ec.fieldContext_ProvisionedHost_Host(ctx, field)
			case "EndStepPlan":
				return ec.fieldContext_ProvisionedHost_EndStepPlan(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedHost_Build(ctx, field)
			case "ProvisioningSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningSteps(ctx, field)
			case "ProvisioningScheduledSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningScheduledSteps(ctx, field)
			case "AgentStatus":
				return ec.fieldContext_ProvisionedHost_AgentStatus(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisionedHost_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedHost_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisionedHost_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedHost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_Script(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_Script(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Script(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Script)
	fc.Result = res
	return ec.marshalOScript2githubcomgen0cidelaforgeentScript(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_Script(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Script_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Script_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Script_name(ctx, field)
			case "language":
				return ec.fieldContext_Script_language(ctx, field)
			case "description":
				return ec.fieldContext_Script_description(ctx, field)
			case "source":
				return ec.fieldContext_Script_source(ctx, field)
			case "sourceType":
				return ec.fieldContext_Script_sourceType(ctx, field)
			case "cooldown":
				return ec.fieldContext_Script_cooldown(ctx, field)
			case "timeout":
				return ec.fieldContext_Script_timeout(ctx, field)
			case "ignoreErrors":
				return ec.fieldContext_Script_ignoreErrors(ctx, field)
			case "args":
				return ec.fieldContext_Script_args(ctx, field)
			case "disabled":
				return ec.fieldContext_Script_disabled(ctx, field)
			case "vars":
				return ec.fieldContext_Script_vars(ctx, field)
			case "absPath":
				return ec.fieldContext_Script_absPath(ctx, field)
			case "tags":
				return ec.fieldContext_Script_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Script_Users(ctx, field)
			case "Findings":
				return ec.fieldContext_Script_Findings(ctx, field)
			case "Environment":
				return ec.fieldContext_Script_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Script", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_Command(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_Command(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Command(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Command)
	fc.Result = res
	return ec.marshalOCommand2githubcomgen0cidelaforgeentCommand(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_Command(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Command_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Command_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Command_name(ctx, field)
			case "description":
				return ec.fieldContext_Command_description(ctx, field)
			case "program":
				return ec.fieldContext_Command_program(ctx, field)
			case "args":
				return ec.fieldContext_Command_args(ctx, field)
			case "ignoreErrors":
				return ec.fieldContext_Command_ignoreErrors(ctx, field)
			case "disabled":
				return ec.fieldContext_Command_disabled(ctx, field)
			case "cooldown":
				return ec.fieldContext_Command_cooldown(ctx, field)
			case "timeout":
				return ec.fieldContext_Command_timeout(ctx, field)
			case "vars":
				return ec.fieldContext_Command_vars(ctx, field)
			case "tags":
				return ec.fieldContext_Command_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Command_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Command_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Command", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_DNSRecord(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_DNSRecord(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DNSRecord(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.DNSRecord)
	fc.Result = res
	return ec.marshalODNSRecord2githubcomgen0cidelaforgeentDNSRecord(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_DNSRecord(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DNSRecord_id(ctx, field)
			case "hclId":
				return ec.fieldContext_DNSRecord_hclId(ctx, field)
			case "name":
				return ec.fieldContext_DNSRecord_name(ctx, field)
			case "values":
				return ec.fieldContext_DNSRecord_values(ctx, field)
			case "type":
				return ec.fieldContext_DNSRecord_type(ctx, field)
			case "zone":
				return ec.fieldContext_DNSRecord_zone(ctx, field)
			case "vars":
				return ec.fieldContext_DNSRecord_vars(ctx, field)
			case "disabled":
				return ec.fieldContext_DNSRecord_disabled(ctx, field)
			case "tags":
				return ec.fieldContext_DNSRecord_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_DNSRecord_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DNSRecord", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_FileDelete(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_FileDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileDelete(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.FileDelete)
	fc.Result = res
	return ec.marshalOFileDelete2githubcomgen0cidelaforgeentFileDelete(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_FileDelete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FileDelete_id(ctx, field)
			case "hclId":
				return ec.fieldContext_FileDelete_hclId(ctx, field)
			case "path":
				return ec.fieldContext_FileDelete_path(ctx, field)
			case "tags":
				return ec.fieldContext_FileDelete_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_FileDelete_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileDelete", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_FileDownload(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_FileDownload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileDownload(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.FileDownload)
	fc.Result = res
	return ec.marshalOFileDownload2githubcomgen0cidelaforgeentFileDownload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_FileDownload(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FileDownload_id(ctx, field)
			case "hclId":
				return ec.fieldContext_FileDownload_hclId(ctx, field)
			case "sourceType":
				return ec.fieldContext_FileDownload_sourceType(ctx, field)
			case "source":
				return ec.fieldContext_FileDownload_source(ctx, field)
			case "destination":
				return ec.fieldContext_FileDownload_destination(ctx, field)
			case "template":
				return ec.fieldContext_FileDownload_template(ctx, field)
			case "perms":
				return ec.fieldContext_FileDownload_perms(ctx, field)
			case "disabled":
				return ec.fieldContext_FileDownload_disabled(ctx, field)
			case "md5":
				return ec.fieldContext_FileDownload_md5(ctx, field)
			case "absPath":
				return ec.fieldContext_FileDownload_absPath(ctx, field)
			case "tags":
				return ec.fieldContext_FileDownload_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_FileDownload_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileDownload", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_FileExtract(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_FileExtract(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileExtract(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.FileExtract)
	fc.Result = res
	return ec.marshalOFileExtract2githubcomgen0cidelaforgeentFileExtract(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_FileExtract(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FileExtract_id(ctx, field)
			case "hclId":
				return ec.fieldContext_FileExtract_hclId(ctx, field)
			case "source":
				return ec.fieldContext_FileExtract_source(ctx, field)
			case "destination":
				return ec.fieldContext_FileExtract_destination(ctx, field)
			case "type":
				return ec.fieldContext_FileExtract_type(ctx, field)
			case "tags":
				return ec.fieldContext_FileExtract_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_FileExtract_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileExtract", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_Ansible(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_Ansible(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ansible(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Ansible)
	fc.Result = res
	return ec.marshalOAnsible2githubcomgen0cidelaforgeentAnsible(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_Ansible(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Ansible_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Ansible_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Ansible_name(ctx, field)
			case "description":
				return ec.fieldContext_Ansible_description(ctx, field)
			case "source":
				return ec.fieldContext_Ansible_source(ctx, field)
			case "playbookName":
				return ec.fieldContext_Ansible_playbookName(ctx, field)
			case "method":
				return ec.fieldContext_Ansible_method(ctx, field)
			case "inventory":
				return ec.fieldContext_Ansible_inventory(ctx, field)
			case "absPath":
				return ec.fieldContext_Ansible_absPath(ctx, field)
			case "tags":
				return ec.fieldContext_Ansible_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Ansible_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Ansible_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Ansible", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_AgentTasks(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_AgentTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentTasks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.AgentTask)
	fc.Result = res
	return ec.marshalNAgentTask2githubcomgen0cidelaforgeentAgentTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_AgentTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AgentTask_id(ctx, field)
			case "args":
				return ec.fieldContext_AgentTask_args(ctx, field)
			case "command":
				return ec.fieldContext_AgentTask_command(ctx, field)
			case "number":
				return ec.fieldContext_AgentTask_number(ctx, field)
			case "output":
				return ec.fieldContext_AgentTask_output(ctx, field)
			case "state":
				return ec.fieldContext_AgentTask_state(ctx, field)
			case "errorMessage":
				return ec.fieldContext_AgentTask_errorMessage(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_AgentTask_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_AgentTask_ProvisioningScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentTask_ProvisionedHost(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_AgentTask_AdhocPlans(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_Plan(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_Plan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plan(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Plan)
	fc.Result = res
	return ec.marshalOPlan2githubcomgen0cidelaforgeentPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_Plan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Plan_id(ctx, field)
			case "stepNumber":
				return ec.fieldContext_Plan_stepNumber(ctx, field)
			case "type":
				return ec.fieldContext_Plan_type(ctx, field)
			case "NextPlans":
				return ec.fieldContext_Plan_NextPlans(ctx, field)
			case "PrevPlans":
				return ec.fieldContext_Plan_PrevPlans(ctx, field)
			case "Build":
				return ec.fieldContext_Plan_Build(ctx, field)
			case "Team":
				return ec.fieldContext_Plan_Team(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Plan_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Plan_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
			case "Status":
				return ec.fieldContext_Plan_Status(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_Plan_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Plan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_GinFileMiddleware(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_GinFileMiddleware(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GinFileMiddleware(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.GinFileMiddleware)
	fc.Result = res
	return ec.marshalOGinFileMiddleware2githubcomgen0cidelaforgeentGinFileMiddleware(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_GinFileMiddleware(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GinFileMiddleware_id(ctx, field)
			case "urlId":
				return ec.fieldContext_GinFileMiddleware_urlId(ctx, field)
			case "filePath":
				return ec.fieldContext_GinFileMiddleware_filePath(ctx, field)
			case "accessed":
				return ec.fieldContext_GinFileMiddleware_accessed(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_GinFileMiddleware_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_GinFileMiddleware_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_GinFileMiddleware_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GinFileMiddleware", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_id(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProvisioningStep().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_type(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProvisioningStep().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ProvisioningStepType)
	fc.Result = res
	return ec.marshalNProvisioningStepType2githubcomgen0cidelaforgegraphqlgraphmodelProvisioningStepType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProvisioningStepType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_stepNumber(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_stepNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StepNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_stepNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_Status(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_Status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Status)
	fc.Result = res
	return ec.marshalOStatus2githubcomgen0cidelaforgeentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_Status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_ProvisionedHost(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_ProvisionedHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedHost(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedHost)
	fc.Result = res
	return ec.marshalNProvisionedHost2githubcomgen0cidelaforgeentProvisionedHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_ProvisionedHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedHost_id(ctx, field)
			case "subnetIp":
				return ec.fieldContext_ProvisionedHost_subnetIp(ctx, field)
			case "addonType":
				return ec.fieldContext_ProvisionedHost_addonType(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedHost_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedHost_Status(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_ProvisionedHost_ProvisionedNetwork(ctx, field)
			case "Host":
				return ec.fieldContext_ProvisionedHost_Host(ctx, field)
			case "EndStepPlan":
				return ec.fieldContext_ProvisionedHost_EndStepPlan(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedHost_Build(ctx, field)
			case "ProvisioningSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningSteps(ctx, field)
			case "ProvisioningScheduledSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningScheduledSteps(ctx, field)
			case "AgentStatus":
				return ec.fieldContext_ProvisionedHost_AgentStatus(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisionedHost_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedHost_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisionedHost_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedHost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_Script(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_Script(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Script(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Script)
	fc.Result = res
	return ec.marshalOScript2githubcomgen0cidelaforgeentScript(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_Script(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Script_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Script_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Script_name(ctx, field)
			case "language":
				return ec.fieldContext_Script_language(ctx, field)
			case "description":
				return ec.fieldContext_Script_description(ctx, field)
			case "source":
				return ec.fieldContext_Script_source(ctx, field)
			case "sourceType":
				return ec.fieldContext_Script_sourceType(ctx, field)
			case "cooldown":
				return ec.fieldContext_Script_cooldown(ctx, field)
			case "timeout":
				return ec.fieldContext_Script_timeout(ctx, field)
			case "ignoreErrors":
				return ec.fieldContext_Script_ignoreErrors(ctx, field)
			case "args":
				return ec.fieldContext_Script_args(ctx, field)
			case "disabled":
				return ec.fieldContext_Script_disabled(ctx, field)
			case "vars":
				return ec.fieldContext_Script_vars(ctx, field)
			case "absPath":
				return ec.fieldContext_Script_absPath(ctx, field)
			case "tags":
				return ec.fieldContext_Script_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Script_Users(ctx, field)
			case "Findings":
				return ec.fieldContext_Script_Findings(ctx, field)
			case "Environment":
				return ec.fieldContext_Script_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Script", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_Command(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_Command(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Command(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Command)
	fc.Result = res
	return ec.marshalOCommand2githubcomgen0cidelaforgeentCommand(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_Command(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Command_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Command_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Command_name(ctx, field)
			case "description":
				return ec.fieldContext_Command_description(ctx, field)
			case "program":
				return ec.fieldContext_Command_program(ctx, field)
			case "args":
				return ec.fieldContext_Command_args(ctx, field)
			case "ignoreErrors":
				return ec.fieldContext_Command_ignoreErrors(ctx, field)
			case "disabled":
				return ec.fieldContext_Command_disabled(ctx, field)
			case "cooldown":
				return ec.fieldContext_Command_cooldown(ctx, field)
			case "timeout":
				return ec.fieldContext_Command_timeout(ctx, field)
			case "vars":
				return ec.fieldContext_Command_vars(ctx, field)
			case "tags":
				return ec.fieldContext_Command_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Command_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Command_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Command", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_DNSRecord(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_DNSRecord(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DNSRecord(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.DNSRecord)
	fc.Result = res
	return ec.marshalODNSRecord2githubcomgen0cidelaforgeentDNSRecord(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_DNSRecord(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DNSRecord_id(ctx, field)
			case "hclId":
				return ec.fieldContext_DNSRecord_hclId(ctx, field)
			case "name":
				return ec.fieldContext_DNSRecord_name(ctx, field)
			case "values":
				return ec.fieldContext_DNSRecord_values(ctx, field)
			case "type":
				return ec.fieldContext_DNSRecord_type(ctx, field)
			case "zone":
				return ec.fieldContext_DNSRecord_zone(ctx, field)
			case "vars":
				return ec.fieldContext_DNSRecord_vars(ctx, field)
			case "disabled":
				return ec.fieldContext_DNSRecord_disabled(ctx, field)
			case "tags":
				return ec.fieldContext_DNSRecord_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_DNSRecord_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DNSRecord", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_FileDelete(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_FileDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileDelete(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.FileDelete)
	fc.Result = res
	return ec.marshalOFileDelete2githubcomgen0cidelaforgeentFileDelete(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_FileDelete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FileDelete_id(ctx, field)
			case "hclId":
				return ec.fieldContext_FileDelete_hclId(ctx, field)
			case "path":
				return ec.fieldContext_FileDelete_path(ctx, field)
			case "tags":
				return ec.fieldContext_FileDelete_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_FileDelete_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileDelete", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_FileDownload(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_FileDownload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileDownload(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.FileDownload)
	fc.Result = res
	return ec.marshalOFileDownload2githubcomgen0cidelaforgeentFileDownload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_FileDownload(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FileDownload_id(ctx, field)
			case "hclId":
				return ec.fieldContext_FileDownload_hclId(ctx, field)
			case "sourceType":
				return ec.fieldContext_FileDownload_sourceType(ctx, field)
			case "source":
				return ec.fieldContext_FileDownload_source(ctx, field)
			case "destination":
				return ec.fieldContext_FileDownload_destination(ctx, field)
			case "template":
				return ec.fieldContext_FileDownload_template(ctx, field)
			case "perms":
				return ec.fieldContext_FileDownload_perms(ctx, field)
			case "disabled":
				return ec.fieldContext_FileDownload_disabled(ctx, field)
			case "md5":
				return ec.fieldContext_FileDownload_md5(ctx, field)
			case "absPath":
				return ec.fieldContext_FileDownload_absPath(ctx, field)
			case "tags":
				return ec.fieldContext_FileDownload_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_FileDownload_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileDownload", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_FileExtract(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_FileExtract(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileExtract(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.FileExtract)
	fc.Result = res
	return ec.marshalOFileExtract2githubcomgen0cidelaforgeentFileExtract(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_FileExtract(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FileExtract_id(ctx, field)
			case "hclId":
				return ec.fieldContext_FileExtract_hclId(ctx, field)
			case "source":
				return ec.fieldContext_FileExtract_source(ctx, field)
			case "destination":
				return ec.fieldContext_FileExtract_destination(ctx, field)
			case "type":
				return ec.fieldContext_FileExtract_type(ctx, field)
			case "tags":
				return ec.fieldContext_FileExtract_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_FileExtract_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileExtract", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_Ansible(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_Ansible(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ansible(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Ansible)
	fc.Result = res
	return ec.marshalOAnsible2githubcomgen0cidelaforgeentAnsible(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_Ansible(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Ansible_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Ansible_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Ansible_name(ctx, field)
			case "description":
				return ec.fieldContext_Ansible_description(ctx, field)
			case "source":
				return ec.fieldContext_Ansible_source(ctx, field)
			case "playbookName":
				return ec.fieldContext_Ansible_playbookName(ctx, field)
			case "method":
				return ec.fieldContext_Ansible_method(ctx, field)
			case "inventory":
				return ec.fieldContext_Ansible_inventory(ctx, field)
			case "absPath":
				return ec.fieldContext_Ansible_absPath(ctx, field)
			case "tags":
				return ec.fieldContext_Ansible_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Ansible_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Ansible_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Ansible", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_Plan(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_Plan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plan(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Plan)
	fc.Result = res
	return ec.marshalOPlan2githubcomgen0cidelaforgeentPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_Plan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Plan_id(ctx, field)
			case "stepNumber":
				return ec.fieldContext_Plan_stepNumber(ctx, field)
			case "type":
				return ec.fieldContext_Plan_type(ctx, field)
			case "NextPlans":
				return ec.fieldContext_Plan_NextPlans(ctx, field)
			case "PrevPlans":
				return ec.fieldContext_Plan_PrevPlans(ctx, field)
			case "Build":
				return ec.fieldContext_Plan_Build(ctx, field)
			case "Team":
				return ec.fieldContext_Plan_Team(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Plan_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Plan_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
			case "Status":
				return ec.fieldContext_Plan_Status(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_Plan_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Plan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_AgentTasks(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_AgentTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentTasks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.AgentTask)
	fc.Result = res
	return ec.marshalNAgentTask2githubcomgen0cidelaforgeentAgentTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_AgentTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AgentTask_id(ctx, field)
			case "args":
				return ec.fieldContext_AgentTask_args(ctx, field)
			case "command":
				return ec.fieldContext_AgentTask_command(ctx, field)
			case "number":
				return ec.fieldContext_AgentTask_number(ctx, field)
			case "output":
				return ec.fieldContext_AgentTask_output(ctx, field)
			case "state":
				return ec.fieldContext_AgentTask_state(ctx, field)
			case "errorMessage":
				return ec.fieldContext_AgentTask_errorMessage(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_AgentTask_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_AgentTask_ProvisioningScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentTask_ProvisionedHost(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_AgentTask_AdhocPlans(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_GinFileMiddleware(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_GinFileMiddleware(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GinFileMiddleware(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.GinFileMiddleware)
	fc.Result = res
	return ec.marshalOGinFileMiddleware2githubcomgen0cidelaforgeentGinFileMiddleware(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_GinFileMiddleware(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GinFileMiddleware_id(ctx, field)
			case "urlId":
				return ec.fieldContext_GinFileMiddleware_urlId(ctx, field)
			case "filePath":
				return ec.fieldContext_GinFileMiddleware_filePath(ctx, field)
			case "accessed":
				return ec.fieldContext_GinFileMiddleware_accessed(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_GinFileMiddleware_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_GinFileMiddleware_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_GinFileMiddleware_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GinFileMiddleware", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_environments(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_environments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Environments(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.Environment); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.Environment`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Environment)
	fc.Result = res
	return ec.marshalOEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_environments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_environment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Environment(rctx, fc.Args["envUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.Environment); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.Environment`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalOEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_environment_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_provisionedHost(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_provisionedHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ProvisionedHost(rctx, fc.Args["proHostUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.ProvisionedHost); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.ProvisionedHost`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedHost)
	fc.Result = res
	return ec.marshalOProvisionedHost2githubcomgen0cidelaforgeentProvisionedHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_provisionedHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedHost_id(ctx, field)
			case "subnetIp":
				return ec.fieldContext_ProvisionedHost_subnetIp(ctx, field)
			case "addonType":
				return ec.fieldContext_ProvisionedHost_addonType(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedHost_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedHost_Status(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_ProvisionedHost_ProvisionedNetwork(ctx, field)
			case "Host":
				return ec.fieldContext_ProvisionedHost_Host(ctx, field)
			case "EndStepPlan":
				return ec.fieldContext_ProvisionedHost_EndStepPlan(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedHost_Build(ctx, field)
			case "ProvisioningSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningSteps(ctx, field)
			case "ProvisioningScheduledSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningScheduledSteps(ctx, field)
			case "AgentStatus":
				return ec.fieldContext_ProvisionedHost_AgentStatus(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisionedHost_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedHost_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisionedHost_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedHost", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_provisionedHost_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_provisionedNetwork(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_provisionedNetwork(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ProvisionedNetwork(rctx, fc.Args["proNetUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.ProvisionedNetwork); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.ProvisionedNetwork`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedNetwork)
	fc.Result = res
	return ec.marshalOProvisionedNetwork2githubcomgen0cidelaforgeentProvisionedNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_provisionedNetwork(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedNetwork_id(ctx, field)
			case "name":
				return ec.fieldContext_ProvisionedNetwork_name(ctx, field)
			case "cidr":
				return ec.fieldContext_ProvisionedNetwork_cidr(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedNetwork_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedNetwork_Status(ctx, field)
			case "Network":
				return ec.fieldContext_ProvisionedNetwork_Network(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedNetwork_Build(ctx, field)
			case "Team":
				return ec.fieldContext_ProvisionedNetwork_Team(ctx, field)
			case "ProvisionedHosts":
				return ec.fieldContext_ProvisionedNetwork_ProvisionedHosts(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedNetwork_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedNetwork", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_provisionedNetwork_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_provisionedStep(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_provisionedStep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ProvisionedStep(rctx, fc.Args["proStepUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.ProvisioningStep); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.ProvisioningStep`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisioningStep)
	fc.Result = res
	return ec.marshalOProvisioningStep2githubcomgen0cidelaforgeentProvisioningStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_provisionedStep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisioningStep_id(ctx, field)
			case "type":
				return ec.fieldContext_ProvisioningStep_type(ctx, field)
			case "stepNumber":
				return ec.fieldContext_ProvisioningStep_stepNumber(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisioningStep_Status(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_ProvisioningStep_ProvisionedHost(ctx, field)
			case "Script":
				return ec.fieldContext_ProvisioningStep_Script(ctx, field)
			case "Command":
				return ec.fieldContext_ProvisioningStep_Command(ctx, field)
			case "DNSRecord":
				return ec.fieldContext_ProvisioningStep_DNSRecord(ctx, field)
			case "FileDelete":
				return ec.fieldContext_ProvisioningStep_FileDelete(ctx, field)
			case "FileDownload":
				return ec.fieldContext_ProvisioningStep_FileDownload(ctx, field)
			case "FileExtract":
				return ec.fieldContext_ProvisioningStep_FileExtract(ctx, field)
			case "Ansible":
				return ec.fieldContext_ProvisioningStep_Ansible(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisioningStep_Plan(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisioningStep_AgentTasks(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisioningStep_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisioningStep", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_provisionedStep_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_plan(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_plan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Plan(rctx, fc.Args["planUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.Plan); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.Plan`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Plan)
	fc.Result = res
	return ec.marshalOPlan2githubcomgen0cidelaforgeentPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_plan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Plan_id(ctx, field)
			case "stepNumber":
				return ec.fieldContext_Plan_stepNumber(ctx, field)
			case "type":
				return ec.fieldContext_Plan_type(ctx, field)
			case "NextPlans":
				return ec.fieldContext_Plan_NextPlans(ctx, field)
			case "PrevPlans":
				return ec.fieldContext_Plan_PrevPlans(ctx, field)
			case "Build":
				return ec.fieldContext_Plan_Build(ctx, field)
			case "Team":
				return ec.fieldContext_Plan_Team(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Plan_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Plan_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
			case "Status":
				return ec.fieldContext_Plan_Status(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_Plan_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Plan", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_plan_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_getBuilds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getBuilds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetBuilds(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.Build); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.Build`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Build)
	fc.Result = res
	return ec.marshalOBuild2githubcomgen0cidelaforgeentBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getBuilds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_build(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_build(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Build(rctx, fc.Args["buildUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.Build); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.Build`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Build)
	fc.Result = res
	return ec.marshalOBuild2githubcomgen0cidelaforgeentBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_build(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_build_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_getBuildCommits(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getBuildCommits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetBuildCommits(rctx, fc.Args["envUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.BuildCommit); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.BuildCommit`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.BuildCommit)
	fc.Result = res
	return ec.marshalOBuildCommit2githubcomgen0cidelaforgeentBuildCommit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getBuildCommits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BuildCommit_id(ctx, field)
			case "type":
				return ec.fieldContext_BuildCommit_type(ctx, field)
			case "revision":
				return ec.fieldContext_BuildCommit_revision(ctx, field)
			case "state":
				return ec.fieldContext_BuildCommit_state(ctx, field)
			case "createdAt":
				return ec.fieldContext_BuildCommit_createdAt(ctx, field)
			case "Build":
				return ec.fieldContext_BuildCommit_Build(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_BuildCommit_ServerTasks(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_BuildCommit_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildCommit", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getBuildCommits_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_getBuildCommit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getBuildCommit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetBuildCommit(rctx, fc.Args["buildCommitUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.BuildCommit); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.BuildCommit`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.BuildCommit)
	fc.Result = res
	return ec.marshalOBuildCommit2githubcomgen0cidelaforgeentBuildCommit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getBuildCommit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BuildCommit_id(ctx, field)
			case "type":
				return ec.fieldContext_BuildCommit_type(ctx, field)
			case "revision":
				return ec.fieldContext_BuildCommit_revision(ctx, field)
			case "state":
				return ec.fieldContext_BuildCommit_state(ctx, field)
			case "createdAt":
				return ec.fieldContext_BuildCommit_createdAt(ctx, field)
			case "Build":
				return ec.fieldContext_BuildCommit_Build(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_BuildCommit_ServerTasks(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_BuildCommit_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildCommit", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getBuildCommit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_status(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Status(rctx, fc.Args["statusUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.Status); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.Status`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Status)
	fc.Result = res
	return ec.marshalOStatus2githubcomgen0cidelaforgeentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_status_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_agentStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_agentStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().AgentStatus(rctx, fc.Args["clientId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.AgentStatus); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.AgentStatus`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.AgentStatus)
	fc.Result = res
	return ec.marshalOAgentStatus2githubcomgen0cidelaforgeentAgentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_agentStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "clientId":
				return ec.fieldContext_AgentStatus_clientId(ctx, field)
			case "hostname":
				return ec.fieldContext_AgentStatus_hostname(ctx, field)
			case "upTime":
				return ec.fieldContext_AgentStatus_upTime(ctx, field)
			case "bootTime":
				return ec.fieldContext_AgentStatus_bootTime(ctx, field)
			case "numProcs":
				return ec.fieldContext_AgentStatus_numProcs(ctx, field)
			case "OS":
				return ec.fieldContext_AgentStatus_OS(ctx, field)
			case "hostID":
				return ec.fieldContext_AgentStatus_hostID(ctx, field)
			case "load1":
				return ec.fieldContext_AgentStatus_load1(ctx, field)
			case "load5":
				return ec.fieldContext_AgentStatus_load5(ctx, field)
			case "load15":
				return ec.fieldContext_AgentStatus_load15(ctx, field)
			case "totalMem":
				return ec.fieldContext_AgentStatus_totalMem(ctx, field)
			case "freeMem":
				return ec.fieldContext_AgentStatus_freeMem(ctx, field)
			case "usedMem":
				return ec.fieldContext_AgentStatus_usedMem(ctx, field)
			case "timestamp":
				return ec.fieldContext_AgentStatus_timestamp(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentStatus_ProvisionedHost(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_AgentStatus_ProvisionedNetwork(ctx, field)
			case "Build":
				return ec.fieldContext_AgentStatus_Build(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentStatus", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_agentStatus_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_getServerTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getServerTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetServerTasks(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.ServerTask); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.ServerTask`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ServerTask)
	fc.Result = res
	return ec.marshalOServerTask2githubcomgen0cidelaforgeentServerTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getServerTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServerTask_id(ctx, field)
			case "type":
				return ec.fieldContext_ServerTask_type(ctx, field)
			case "startTime":
				return ec.fieldContext_ServerTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ServerTask_endTime(ctx, field)
			case "errors":
				return ec.fieldContext_ServerTask_errors(ctx, field)
			case "logFilePath":
				return ec.fieldContext_ServerTask_logFilePath(ctx, field)
			case "AuthUser":
				return ec.fieldContext_ServerTask_AuthUser(ctx, field)
			case "Status":
				return ec.fieldContext_ServerTask_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_ServerTask_Environment(ctx, field)
			case "Build":
				return ec.fieldContext_ServerTask_Build(ctx, field)
			case "BuildCommit":
				return ec.fieldContext_ServerTask_BuildCommit(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ServerTask_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServerTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_currentUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_currentUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CurrentUser(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.AuthUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.AuthUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.AuthUser)
	fc.Result = res
	return ec.marshalOAuthUser2githubcomgen0cidelaforgeentAuthUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_currentUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AuthUser_id(ctx, field)
			case "username":
				return ec.fieldContext_AuthUser_username(ctx, field)
			case "firstName":
				return ec.fieldContext_AuthUser_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_AuthUser_lastName(ctx, field)
			case "email":
				return ec.fieldContext_AuthUser_email(ctx, field)
			case "phone":
				return ec.fieldContext_AuthUser_phone(ctx, field)
			case "company":
				return ec.fieldContext_AuthUser_company(ctx, field)
			case "occupation":
				return ec.fieldContext_AuthUser_occupation(ctx, field)
			case "publicKey":
				return ec.fieldContext_AuthUser_publicKey(ctx, field)
			case "role":
				return ec.fieldContext_AuthUser_role(ctx, field)
			case "provider":
				return ec.fieldContext_AuthUser_provider(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_AuthUser_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getUserList(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getUserList(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetUserList(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.AuthUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.AuthUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.AuthUser)
	fc.Result = res
	return ec.marshalOAuthUser2githubcomgen0cidelaforgeentAuthUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getUserList(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AuthUser_id(ctx, field)
			case "username":
				return ec.fieldContext_AuthUser_username(ctx, field)
			case "firstName":
				return ec.fieldContext_AuthUser_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_AuthUser_lastName(ctx, field)
			case "email":
				return ec.fieldContext_AuthUser_email(ctx, field)
			case "phone":
				return ec.fieldContext_AuthUser_phone(ctx, field)
			case "company":
				return ec.fieldContext_AuthUser_company(ctx, field)
			case "occupation":
				return ec.fieldContext_AuthUser_occupation(ctx, field)
			case "publicKey":
				return ec.fieldContext_AuthUser_publicKey(ctx, field)
			case "role":
				return ec.fieldContext_AuthUser_role(ctx, field)
			case "provider":
				return ec.fieldContext_AuthUser_provider(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_AuthUser_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getCurrentUserTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getCurrentUserTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetCurrentUserTasks(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.ServerTask); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.ServerTask`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ServerTask)
	fc.Result = res
	return ec.marshalOServerTask2githubcomgen0cidelaforgeentServerTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getCurrentUserTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServerTask_id(ctx, field)
			case "type":
				return ec.fieldContext_ServerTask_type(ctx, field)
			case "startTime":
				return ec.fieldContext_ServerTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ServerTask_endTime(ctx, field)
			case "errors":
				return ec.fieldContext_ServerTask_errors(ctx, field)
			case "logFilePath":
				return ec.fieldContext_ServerTask_logFilePath(ctx, field)
			case "AuthUser":
				return ec.fieldContext_ServerTask_AuthUser(ctx, field)
			case "Status":
				return ec.fieldContext_ServerTask_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_ServerTask_Environment(ctx, field)
			case "Build":
				return ec.fieldContext_ServerTask_Build(ctx, field)
			case "BuildCommit":
				return ec.fieldContext_ServerTask_BuildCommit(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ServerTask_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServerTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getAgentTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getAgentTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetAgentTasks(rctx, fc.Args["proStepUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.AgentTask); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.AgentTask`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.AgentTask)
	fc.Result = res
	return ec.marshalOAgentTask2githubcomgen0cidelaforgeentAgentTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getAgentTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AgentTask_id(ctx, field)
			case "args":
				return ec.fieldContext_AgentTask_args(ctx, field)
			case "command":
				return ec.fieldContext_AgentTask_command(ctx, field)
			case "number":
				return ec.fieldContext_AgentTask_number(ctx, field)
			case "output":
				return ec.fieldContext_AgentTask_output(ctx, field)
			case "state":
				return ec.fieldContext_AgentTask_state(ctx, field)
			case "errorMessage":
				return ec.fieldContext_AgentTask_errorMessage(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_AgentTask_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_AgentTask_ProvisioningScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentTask_ProvisionedHost(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_AgentTask_AdhocPlans(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentTask", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getAgentTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_listAgentStatuses(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_listAgentStatuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListAgentStatuses(rctx, fc.Args["buildUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.AgentStatus); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.AgentStatus`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.AgentStatus)
	fc.Result = res
	return ec.marshalOAgentStatus2githubcomgen0cidelaforgeentAgentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_listAgentStatuses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "clientId":
				return ec.fieldContext_AgentStatus_clientId(ctx, field)
			case "hostname":
				return ec.fieldContext_AgentStatus_hostname(ctx, field)
			case "upTime":
				return ec.fieldContext_AgentStatus_upTime(ctx, field)
			case "bootTime":
				return ec.fieldContext_AgentStatus_bootTime(ctx, field)
			case "numProcs":
				return ec.fieldContext_AgentStatus_numProcs(ctx, field)
			case "OS":
				return ec.fieldContext_AgentStatus_OS(ctx, field)
			case "hostID":
				return ec.fieldContext_AgentStatus_hostID(ctx, field)
			case "load1":
				return ec.fieldContext_AgentStatus_load1(ctx, field)
			case "load5":
				return ec.fieldContext_AgentStatus_load5(ctx, field)
			case "load15":
				return ec.fieldContext_AgentStatus_load15(ctx, field)
			case "totalMem":
				return ec.fieldContext_AgentStatus_totalMem(ctx, field)
			case "freeMem":
				return ec.fieldContext_AgentStatus_freeMem(ctx, field)
			case "usedMem":
				return ec.fieldContext_AgentStatus_usedMem(ctx, field)
			case "timestamp":
				return ec.fieldContext_AgentStatus_timestamp(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentStatus_ProvisionedHost(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_AgentStatus_ProvisionedNetwork(ctx, field)
			case "Build":
				return ec.fieldContext_AgentStatus_Build(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentStatus", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_listAgentStatuses_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_listBuildStatuses(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_listBuildStatuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListBuildStatuses(rctx, fc.Args["buildUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.Status); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.Status`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Status)
	fc.Result = res
	return ec.marshalOStatus2githubcomgen0cidelaforgeentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_listBuildStatuses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_listBuildStatuses_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_getAllAgentStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getAllAgentStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetAllAgentStatus(rctx, fc.Args["buildUUID"].(string), fc.Args["count"].(int), fc.Args["offset"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.AgentStatusBatch); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/graphql/graph/model.AgentStatusBatch`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AgentStatusBatch)
	fc.Result = res
	return ec.marshalOAgentStatusBatch2githubcomgen0cidelaforgegraphqlgraphmodelAgentStatusBatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getAllAgentStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "agentStatuses":
				return ec.fieldContext_AgentStatusBatch_agentStatuses(ctx, field)
			case "pageInfo":
				return ec.fieldContext_AgentStatusBatch_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentStatusBatch", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getAllAgentStatus_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_getAllPlanStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getAllPlanStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetAllPlanStatus(rctx, fc.Args["buildUUID"].(string), fc.Args["count"].(int), fc.Args["offset"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.StatusBatch); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/graphql/graph/model.StatusBatch`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.StatusBatch)
	fc.Result = res
	return ec.marshalOStatusBatch2githubcomgen0cidelaforgegraphqlgraphmodelStatusBatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getAllPlanStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "statuses":
				return ec.fieldContext_StatusBatch_statuses(ctx, field)
			case "pageInfo":
				return ec.fieldContext_StatusBatch_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StatusBatch", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getAllPlanStatus_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_getPlanStatusCounts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getPlanStatusCounts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetPlanStatusCounts(rctx, fc.Args["buildUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.PlanCounts); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/graphql/graph/model.PlanCounts`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PlanCounts)
	fc.Result = res
	return ec.marshalNPlanCounts2githubcomgen0cidelaforgegraphqlgraphmodelPlanCounts(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getPlanStatusCounts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "planning":
				return ec.fieldContext_PlanCounts_planning(ctx, field)
			case "awaiting":
				return ec.fieldContext_PlanCounts_awaiting(ctx, field)
			case "parentAwaiting":
				return ec.fieldContext_PlanCounts_parentAwaiting(ctx, field)
			case "inProgress":
				return ec.fieldContext_PlanCounts_inProgress(ctx, field)
			case "failed":
				return ec.fieldContext_PlanCounts_failed(ctx, field)
			case "complete":
				return ec.fieldContext_PlanCounts_complete(ctx, field)
			case "tainted":
				return ec.fieldContext_PlanCounts_tainted(ctx, field)
			case "undefined":
				return ec.fieldContext_PlanCounts_undefined(ctx, field)
			case "toDelete":
				return ec.fieldContext_PlanCounts_toDelete(ctx, field)
			case "deleteInProgress":
				return ec.fieldContext_PlanCounts_deleteInProgress(ctx, field)
			case "deleted":
				return ec.fieldContext_PlanCounts_deleted(ctx, field)
			case "toRebuild":
				return ec.fieldContext_PlanCounts_toRebuild(ctx, field)
			case "cancelled":
				return ec.fieldContext_PlanCounts_cancelled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlanCounts", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getPlanStatusCounts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_viewServerTaskLogs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_viewServerTaskLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ViewServerTaskLogs(rctx, fc.Args["taskID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_viewServerTaskLogs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_viewServerTaskLogs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_viewAgentTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_viewAgentTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ViewAgentTask(rctx, fc.Args["taskID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.AgentTask); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.AgentTask`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.AgentTask)
	fc.Result = res
	return ec.marshalNAgentTask2githubcomgen0cidelaforgeentAgentTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_viewAgentTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AgentTask_id(ctx, field)
			case "args":
				return ec.fieldContext_AgentTask_args(ctx, field)
			case "command":
				return ec.fieldContext_AgentTask_command(ctx, field)
			case "number":
				return ec.fieldContext_AgentTask_number(ctx, field)
			case "output":
				return ec.fieldContext_AgentTask_output(ctx, field)
			case "state":
				return ec.fieldContext_AgentTask_state(ctx, field)
			case "errorMessage":
				return ec.fieldContext_AgentTask_errorMessage(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_AgentTask_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_AgentTask_ProvisioningScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentTask_ProvisionedHost(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_AgentTask_AdhocPlans(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentTask", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_viewAgentTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_serverTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_serverTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ServerTasks(rctx, fc.Args["taskUUIDs"].([]*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.ServerTask); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.ServerTask`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ServerTask)
	fc.Result = res
	return ec.marshalOServerTask2githubcomgen0cidelaforgeentServerTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_serverTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServerTask_id(ctx, field)
			case "type":
				return ec.fieldContext_ServerTask_type(ctx, field)
			case "startTime":
				return ec.fieldContext_ServerTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ServerTask_endTime(ctx, field)
			case "errors":
				return ec.fieldContext_ServerTask_errors(ctx, field)
			case "logFilePath":
				return ec.fieldContext_ServerTask_logFilePath(ctx, field)
			case "AuthUser":
				return ec.fieldContext_ServerTask_AuthUser(ctx, field)
			case "Status":
				return ec.fieldContext_ServerTask_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_ServerTask_Environment(ctx, field)
			case "Build":
				return ec.fieldContext_ServerTask_Build(ctx, field)
			case "BuildCommit":
				return ec.fieldContext_ServerTask_BuildCommit(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ServerTask_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServerTask", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_serverTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommit_id(ctx context.Context, field graphql.CollectedField, obj *ent.RepoCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommit_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RepoCommit().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommit_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommit_revision(ctx context.Context, field graphql.CollectedField, obj *ent.RepoCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommit_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommit_revision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommit_hash(ctx context.Context, field graphql.CollectedField, obj *ent.RepoCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommit_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommit_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommit_author(ctx context.Context, field graphql.CollectedField, obj *ent.RepoCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommit_author(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RepoCommit().Author(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommit_author(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommit_committer(ctx context.Context, field graphql.CollectedField, obj *ent.RepoCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommit_committer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RepoCommit().Committer(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommit_committer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommit_pgpSignature(ctx context.Context, field graphql.CollectedField, obj *ent.RepoCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommit_pgpSignature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PgpSignature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommit_pgpSignature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommit_message(ctx context.Context, field graphql.CollectedField, obj *ent.RepoCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommit_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommit_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommit_treeHash(ctx context.Context, field graphql.CollectedField, obj *ent.RepoCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommit_treeHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TreeHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommit_treeHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommit_parentHashes(ctx context.Context, field graphql.CollectedField, obj *ent.RepoCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommit_parentHashes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentHashes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommit_parentHashes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommit_Repository(ctx context.Context, field graphql.CollectedField, obj *ent.RepoCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommit_Repository(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repository(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Repository)
	fc.Result = res
	return ec.marshalNRepository2githubcomgen0cidelaforgeentRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommit_Repository(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommit",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Repository_id(ctx, field)
			case "repoUrl":
				return ec.fieldContext_Repository_repoUrl(ctx, field)
			case "branchName":
				return ec.fieldContext_Repository_branchName(ctx, field)
			case "environmentFilepath":
				return ec.fieldContext_Repository_environmentFilepath(ctx, field)
			case "Environments":
				return ec.fieldContext_Repository_Environments(ctx, field)
			case "RepoCommits":
				return ec.fieldContext_Repository_RepoCommits(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Repository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_id(ctx context.Context, field graphql.CollectedField, obj *ent.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_repoUrl(ctx context.Context, field graphql.CollectedField, obj *ent.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_repoUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_repoUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_branchName(ctx context.Context, field graphql.CollectedField, obj *ent.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_branchName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BranchName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_branchName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_environmentFilepath(ctx context.Context, field graphql.CollectedField, obj *ent.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_environmentFilepath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().EnvironmentFilepath(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_environmentFilepath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_Environments(ctx context.Context, field graphql.CollectedField, obj *ent.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_Environments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environments(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_Environments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_RepoCommits(ctx context.Context, field graphql.CollectedField, obj *ent.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_RepoCommits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoCommits(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.RepoCommit)
	fc.Result = res
	return ec.marshalNRepoCommit2githubcomgen0cidelaforgeentRepoCommit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_RepoCommits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RepoCommit_id(ctx, field)
			case "revision":
				return ec.fieldContext_RepoCommit_revision(ctx, field)
			case "hash":
				return ec.fieldContext_RepoCommit_hash(ctx, field)
			case "author":
				return ec.fieldContext_RepoCommit_author(ctx, field)
			case "committer":
				return ec.fieldContext_RepoCommit_committer(ctx, field)
			case "pgpSignature":
				return ec.fieldContext_RepoCommit_pgpSignature(ctx, field)
			case "message":
				return ec.fieldContext_RepoCommit_message(ctx, field)
			case "treeHash":
				return ec.fieldContext_RepoCommit_treeHash(ctx, field)
			case "parentHashes":
				return ec.fieldContext_RepoCommit_parentHashes(ctx, field)
			case "Repository":
				return ec.fieldContext_RepoCommit_Repository(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoCommit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScheduledStep_id(ctx context.Context, field graphql.CollectedField, obj *ent.ScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScheduledStep_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ScheduledStep().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScheduledStep_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScheduledStep_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.ScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScheduledStep_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScheduledStep_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScheduledStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScheduledStep_name(ctx context.Context, field graphql.CollectedField, obj *ent.ScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScheduledStep_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScheduledStep_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScheduledStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScheduledStep_description(ctx context.Context, field graphql.CollectedField, obj *ent.ScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScheduledStep_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScheduledStep_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScheduledStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScheduledStep_step(ctx context.Context, field graphql.CollectedField, obj *ent.ScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScheduledStep_step(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Step, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScheduledStep_step(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScheduledStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScheduledStep_type(ctx context.Context, field graphql.CollectedField, obj *ent.ScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScheduledStep_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ScheduledStep().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ScheduledStepType)
	fc.Result = res
	return ec.marshalNScheduledStepType2githubcomgen0cidelaforgegraphqlgraphmodelScheduledStepType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScheduledStep_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ScheduledStepType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScheduledStep_schedule(ctx context.Context, field graphql.CollectedField, obj *ent.ScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScheduledStep_schedule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Schedule, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScheduledStep_schedule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScheduledStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScheduledStep_runAt(ctx context.Context, field graphql.CollectedField, obj *ent.ScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScheduledStep_runAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RunAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScheduledStep_runAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScheduledStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScheduledStep_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.ScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScheduledStep_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalOEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScheduledStep_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_id(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Script().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_name(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_language(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_language(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Language, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_language(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_description(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_source(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_sourceType(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_sourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_sourceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_cooldown(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_cooldown(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cooldown, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_cooldown(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_timeout(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_timeout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timeout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_timeout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_ignoreErrors(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_ignoreErrors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IgnoreErrors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_ignoreErrors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_args(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_disabled(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_disabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_vars(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Script().Vars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.VarsMap)
	fc.Result = res
	return ec.marshalOvarsMap2githubcomgen0cidelaforgegraphqlgraphmodelVarsMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_vars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_varsMap_key(ctx, field)
			case "value":
				return ec.fieldContext_varsMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type varsMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_absPath(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_absPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AbsPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_absPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_tags(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Script().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalOtagMap2githubcomgen0cidelaforgegraphqlgraphmodelTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_Users(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_Users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.User)
	fc.Result = res
	return ec.marshalNUser2githubcomgen0cidelaforgeentUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_Users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "hclId":
				return ec.fieldContext_User_hclId(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "uuid":
				return ec.fieldContext_User_uuid(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "Tag":
				return ec.fieldContext_User_Tag(ctx, field)
			case "Environments":
				return ec.fieldContext_User_Environments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_Findings(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_Findings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Findings(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Finding)
	fc.Result = res
	return ec.marshalNFinding2githubcomgen0cidelaforgeentFinding(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_Findings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Finding_id(ctx, field)
			case "name":
				return ec.fieldContext_Finding_name(ctx, field)
			case "description":
				return ec.fieldContext_Finding_description(ctx, field)
			case "severity":
				return ec.fieldContext_Finding_severity(ctx, field)
			case "difficulty":
				return ec.fieldContext_Finding_difficulty(ctx, field)
			case "tags":
				return ec.fieldContext_Finding_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Finding_Users(ctx, field)
			case "Host":
				return ec.fieldContext_Finding_Host(ctx, field)
			case "Script":
				return ec.fieldContext_Finding_Script(ctx, field)
			case "Environment":
				return ec.fieldContext_Finding_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Finding", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerTask_id(ctx context.Context, field graphql.CollectedField, obj *ent.ServerTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerTask_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServerTask().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerTask_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerTask_type(ctx context.Context, field graphql.CollectedField, obj *ent.ServerTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerTask_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServerTask().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ServerTaskType)
	fc.Result = res
	return ec.marshalNServerTaskType2githubcomgen0cidelaforgegraphqlgraphmodelServerTaskType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerTask_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ServerTaskType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerTask_startTime(ctx context.Context, field graphql.CollectedField, obj *ent.ServerTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerTask_startTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerTask_startTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerTask_endTime(ctx context.Context, field graphql.CollectedField, obj *ent.ServerTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerTask_endTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerTask_endTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerTask_errors(ctx context.Context, field graphql.CollectedField, obj *ent.ServerTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerTask_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerTask_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerTask_logFilePath(ctx context.Context, field graphql.CollectedField, obj *ent.ServerTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerTask_logFilePath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LogFilePath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerTask_logFilePath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerTask_AuthUser(ctx context.Context, field graphql.CollectedField, obj *ent.ServerTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerTask_AuthUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthUser(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.AuthUser)
	fc.Result = res
	return ec.marshalNAuthUser2githubcomgen0cidelaforgeentAuthUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerTask_AuthUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AuthUser_id(ctx, field)
			case "username":
				return ec.fieldContext_AuthUser_username(ctx, field)
			case "firstName":
				return ec.fieldContext_AuthUser_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_AuthUser_lastName(ctx, field)
			case "email":
				return ec.fieldContext_AuthUser_email(ctx, field)
			case "phone":
				return ec.fieldContext_AuthUser_phone(ctx, field)
			case "company":
				return ec.fieldContext_AuthUser_company(ctx, field)
			case "occupation":
				return ec.fieldContext_AuthUser_occupation(ctx, field)
			case "publicKey":
				return ec.fieldContext_AuthUser_publicKey(ctx, field)
			case "role":
				return ec.fieldContext_AuthUser_role(ctx, field)
			case "provider":
				return ec.fieldContext_AuthUser_provider(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_AuthUser_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerTask_Status(ctx context.Context, field graphql.CollectedField, obj *ent.ServerTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerTask_Status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Status)
	fc.Result = res
	return ec.marshalNStatus2githubcomgen0cidelaforgeentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerTask_Status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerTask_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.ServerTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerTask_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalOEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerTask_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerTask_Build(ctx context.Context, field graphql.CollectedField, obj *ent.ServerTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerTask_Build(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Build(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Build)
	fc.Result = res
	return ec.marshalOBuild2githubcomgen0cidelaforgeentBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerTask_Build(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerTask_BuildCommit(ctx context.Context, field graphql.CollectedField, obj *ent.ServerTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerTask_BuildCommit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildCommit(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.BuildCommit)
	fc.Result = res
	return ec.marshalOBuildCommit2githubcomgen0cidelaforgeentBuildCommit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerTask_BuildCommit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BuildCommit_id(ctx, field)
			case "type":
				return ec.fieldContext_BuildCommit_type(ctx, field)
			case "revision":
				return ec.fieldContext_BuildCommit_revision(ctx, field)
			case "state":
				return ec.fieldContext_BuildCommit_state(ctx, field)
			case "createdAt":
				return ec.fieldContext_BuildCommit_createdAt(ctx, field)
			case "Build":
				return ec.fieldContext_BuildCommit_Build(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_BuildCommit_ServerTasks(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_BuildCommit_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildCommit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerTask_GinFileMiddleware(ctx context.Context, field graphql.CollectedField, obj *ent.ServerTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerTask_GinFileMiddleware(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GinFileMiddleware(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.GinFileMiddleware)
	fc.Result = res
	return ec.marshalNGinFileMiddleware2githubcomgen0cidelaforgeentGinFileMiddleware(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerTask_GinFileMiddleware(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GinFileMiddleware_id(ctx, field)
			case "urlId":
				return ec.fieldContext_GinFileMiddleware_urlId(ctx, field)
			case "filePath":
				return ec.fieldContext_GinFileMiddleware_filePath(ctx, field)
			case "accessed":
				return ec.fieldContext_GinFileMiddleware_accessed(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_GinFileMiddleware_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_GinFileMiddleware_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_GinFileMiddleware_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GinFileMiddleware", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_id(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Status().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_state(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Status().State(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ProvisionStatus)
	fc.Result = res
	return ec.marshalNProvisionStatus2githubcomgen0cidelaforgegraphqlgraphmodelProvisionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProvisionStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_statusFor(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_statusFor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Status().StatusFor(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ProvisionStatusFor)
	fc.Result = res
	return ec.marshalNProvisionStatusFor2githubcomgen0cidelaforgegraphqlgraphmodelProvisionStatusFor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_statusFor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProvisionStatusFor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_startedAt(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_startedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Status().StartedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_startedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_endedAt(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_endedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Status().EndedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_endedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_failed(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_failed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Failed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_failed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_completed(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_completed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Completed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_completed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_error(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_Build(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_Build(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Build(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Build)
	fc.Result = res
	return ec.marshalOBuild2githubcomgen0cidelaforgeentBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_Build(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_ProvisionedNetwork(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedNetwork(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedNetwork)
	fc.Result = res
	return ec.marshalOProvisionedNetwork2githubcomgen0cidelaforgeentProvisionedNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_ProvisionedNetwork(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedNetwork_id(ctx, field)
			case "name":
				return ec.fieldContext_ProvisionedNetwork_name(ctx, field)
			case "cidr":
				return ec.fieldContext_ProvisionedNetwork_cidr(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedNetwork_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedNetwork_Status(ctx, field)
			case "Network":
				return ec.fieldContext_ProvisionedNetwork_Network(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedNetwork_Build(ctx, field)
			case "Team":
				return ec.fieldContext_ProvisionedNetwork_Team(ctx, field)
			case "ProvisionedHosts":
				return ec.fieldContext_ProvisionedNetwork_ProvisionedHosts(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedNetwork_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedNetwork", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_ProvisionedHost(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_ProvisionedHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedHost(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedHost)
	fc.Result = res
	return ec.marshalOProvisionedHost2githubcomgen0cidelaforgeentProvisionedHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_ProvisionedHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedHost_id(ctx, field)
			case "subnetIp":
				return ec.fieldContext_ProvisionedHost_subnetIp(ctx, field)
			case "addonType":
				return ec.fieldContext_ProvisionedHost_addonType(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedHost_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedHost_Status(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_ProvisionedHost_ProvisionedNetwork(ctx, field)
			case "Host":
				return ec.fieldContext_ProvisionedHost_Host(ctx, field)
			case "EndStepPlan":
				return ec.fieldContext_ProvisionedHost_EndStepPlan(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedHost_Build(ctx, field)
			case "ProvisioningSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningSteps(ctx, field)
			case "ProvisioningScheduledSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningScheduledSteps(ctx, field)
			case "AgentStatus":
				return ec.fieldContext_ProvisionedHost_AgentStatus(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisionedHost_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedHost_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisionedHost_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedHost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_ProvisioningStep(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_ProvisioningStep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisioningStep(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisioningStep)
	fc.Result = res
	return ec.marshalOProvisioningStep2githubcomgen0cidelaforgeentProvisioningStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_ProvisioningStep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisioningStep_id(ctx, field)
			case "type":
				return ec.fieldContext_ProvisioningStep_type(ctx, field)
			case "stepNumber":
				return ec.fieldContext_ProvisioningStep_stepNumber(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisioningStep_Status(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_ProvisioningStep_ProvisionedHost(ctx, field)
			case "Script":
				return ec.fieldContext_ProvisioningStep_Script(ctx, field)
			case "Command":
				return ec.fieldContext_ProvisioningStep_Command(ctx, field)
			case "DNSRecord":
				return ec.fieldContext_ProvisioningStep_DNSRecord(ctx, field)
			case "FileDelete":
				return ec.fieldContext_ProvisioningStep_FileDelete(ctx, field)
			case "FileDownload":
				return ec.fieldContext_ProvisioningStep_FileDownload(ctx, field)
			case "FileExtract":
				return ec.fieldContext_ProvisioningStep_FileExtract(ctx, field)
			case "Ansible":
				return ec.fieldContext_ProvisioningStep_Ansible(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisioningStep_Plan(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisioningStep_AgentTasks(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisioningStep_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisioningStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_Team(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_Team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Team(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Team)
	fc.Result = res
	return ec.marshalOTeam2githubcomgen0cidelaforgeentTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_Team(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "teamNumber":
				return ec.fieldContext_Team_teamNumber(ctx, field)
			case "Build":
				return ec.fieldContext_Team_Build(ctx, field)
			case "Status":
				return ec.fieldContext_Team_Status(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Team_ProvisionedNetworks(ctx, field)
			case "Plan":
				return ec.fieldContext_Team_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_Plan(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_Plan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plan(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Plan)
	fc.Result = res
	return ec.marshalOPlan2githubcomgen0cidelaforgeentPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_Plan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Plan_id(ctx, field)
			case "stepNumber":
				return ec.fieldContext_Plan_stepNumber(ctx, field)
			case "type":
				return ec.fieldContext_Plan_type(ctx, field)
			case "NextPlans":
				return ec.fieldContext_Plan_NextPlans(ctx, field)
			case "PrevPlans":
				return ec.fieldContext_Plan_PrevPlans(ctx, field)
			case "Build":
				return ec.fieldContext_Plan_Build(ctx, field)
			case "Team":
				return ec.fieldContext_Plan_Team(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Plan_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Plan_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
			case "Status":
				return ec.fieldContext_Plan_Status(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_Plan_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Plan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_ServerTask(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_ServerTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServerTask(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ServerTask)
	fc.Result = res
	return ec.marshalOServerTask2githubcomgen0cidelaforgeentServerTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_ServerTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServerTask_id(ctx, field)
			case "type":
				return ec.fieldContext_ServerTask_type(ctx, field)
			case "startTime":
				return ec.fieldContext_ServerTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ServerTask_endTime(ctx, field)
			case "errors":
				return ec.fieldContext_ServerTask_errors(ctx, field)
			case "logFilePath":
				return ec.fieldContext_ServerTask_logFilePath(ctx, field)
			case "AuthUser":
				return ec.fieldContext_ServerTask_AuthUser(ctx, field)
			case "Status":
				return ec.fieldContext_ServerTask_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_ServerTask_Environment(ctx, field)
			case "Build":
				return ec.fieldContext_ServerTask_Build(ctx, field)
			case "BuildCommit":
				return ec.fieldContext_ServerTask_BuildCommit(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ServerTask_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServerTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_AdhocPlan(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_AdhocPlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdhocPlan(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.AdhocPlan)
	fc.Result = res
	return ec.marshalOAdhocPlan2githubcomgen0cidelaforgeentAdhocPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_AdhocPlan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AdhocPlan_id(ctx, field)
			case "NextAdhocPlans":
				return ec.fieldContext_AdhocPlan_NextAdhocPlans(ctx, field)
			case "PrevAdhocPlans":
				return ec.fieldContext_AdhocPlan_PrevAdhocPlans(ctx, field)
			case "Build":
				return ec.fieldContext_AdhocPlan_Build(ctx, field)
			case "Status":
				return ec.fieldContext_AdhocPlan_Status(ctx, field)
			case "AgentTask":
				return ec.fieldContext_AdhocPlan_AgentTask(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdhocPlan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_ProvisioningScheduledStep(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisioningScheduledStep(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisioningScheduledStep)
	fc.Result = res
	return ec.marshalOProvisioningScheduledStep2githubcomgen0cidelaforgeentProvisioningScheduledStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_ProvisioningScheduledStep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisioningScheduledStep_id(ctx, field)
			case "type":
				return ec.fieldContext_ProvisioningScheduledStep_type(ctx, field)
			case "runTime":
				return ec.fieldContext_ProvisioningScheduledStep_runTime(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisioningScheduledStep_Status(ctx, field)
			case "ScheduledStep":
				return ec.fieldContext_ProvisioningScheduledStep_ScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_ProvisioningScheduledStep_ProvisionedHost(ctx, field)
			case "Script":
				return ec.fieldContext_ProvisioningScheduledStep_Script(ctx, field)
			case "Command":
				return ec.fieldContext_ProvisioningScheduledStep_Command(ctx, field)
			case "DNSRecord":
				return ec.fieldContext_ProvisioningScheduledStep_DNSRecord(ctx, field)
			case "FileDelete":
				return ec.fieldContext_ProvisioningScheduledStep_FileDelete(ctx, field)
			case "FileDownload":
				return ec.fieldContext_ProvisioningScheduledStep_FileDownload(ctx, field)
			case "FileExtract":
				return ec.fieldContext_ProvisioningScheduledStep_FileExtract(ctx, field)
			case "Ansible":
				return ec.fieldContext_ProvisioningScheduledStep_Ansible(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisioningScheduledStep_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisioningScheduledStep_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisioningScheduledStep_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisioningScheduledStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StatusBatch_statuses(ctx context.Context, field graphql.CollectedField, obj *model.StatusBatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StatusBatch_statuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Statuses, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Status)
	fc.Result = res
	return ec.marshalNStatus2githubcomgen0cidelaforgeentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StatusBatch_statuses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StatusBatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StatusBatch_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.StatusBatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StatusBatch_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.LaForgePageInfo)
	fc.Result = res
	return ec.marshalNLaForgePageInfo2githubcomgen0cidelaforgegraphqlgraphmodelLaForgePageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StatusBatch_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StatusBatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_LaForgePageInfo_total(ctx, field)
			case "nextOffset":
				return ec.fieldContext_LaForgePageInfo_nextOffset(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LaForgePageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_updatedAgentStatus(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_updatedAgentStatus(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().UpdatedAgentStatus(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *ent.AgentStatus); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/gen0cide/laforge/ent.AgentStatus`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *ent.AgentStatus):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNAgentStatus2githubcomgen0cidelaforgeentAgentStatus(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_updatedAgentStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "clientId":
				return ec.fieldContext_AgentStatus_clientId(ctx, field)
			case "hostname":
				return ec.fieldContext_AgentStatus_hostname(ctx, field)
			case "upTime":
				return ec.fieldContext_AgentStatus_upTime(ctx, field)
			case "bootTime":
				return ec.fieldContext_AgentStatus_bootTime(ctx, field)
			case "numProcs":
				return ec.fieldContext_AgentStatus_numProcs(ctx, field)
			case "OS":
				return ec.fieldContext_AgentStatus_OS(ctx, field)
			case "hostID":
				return ec.fieldContext_AgentStatus_hostID(ctx, field)
			case "load1":
				return ec.fieldContext_AgentStatus_load1(ctx, field)
			case "load5":
				return ec.fieldContext_AgentStatus_load5(ctx, field)
			case "load15":
				return ec.fieldContext_AgentStatus_load15(ctx, field)
			case "totalMem":
				return ec.fieldContext_AgentStatus_totalMem(ctx, field)
			case "freeMem":
				return ec.fieldContext_AgentStatus_freeMem(ctx, field)
			case "usedMem":
				return ec.fieldContext_AgentStatus_usedMem(ctx, field)
			case "timestamp":
				return ec.fieldContext_AgentStatus_timestamp(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentStatus_ProvisionedHost(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_AgentStatus_ProvisionedNetwork(ctx, field)
			case "Build":
				return ec.fieldContext_AgentStatus_Build(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_updatedStatus(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_updatedStatus(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().UpdatedStatus(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *ent.Status); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/gen0cide/laforge/ent.Status`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *ent.Status):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNStatus2githubcomgen0cidelaforgeentStatus(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_updatedStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_updatedServerTask(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_updatedServerTask(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().UpdatedServerTask(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *ent.ServerTask); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/gen0cide/laforge/ent.ServerTask`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *ent.ServerTask):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNServerTask2githubcomgen0cidelaforgeentServerTask(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_updatedServerTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServerTask_id(ctx, field)
			case "type":
				return ec.fieldContext_ServerTask_type(ctx, field)
			case "startTime":
				return ec.fieldContext_ServerTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ServerTask_endTime(ctx, field)
			case "errors":
				return ec.fieldContext_ServerTask_errors(ctx, field)
			case "logFilePath":
				return ec.fieldContext_ServerTask_logFilePath(ctx, field)
			case "AuthUser":
				return ec.fieldContext_ServerTask_AuthUser(ctx, field)
			case "Status":
				return ec.fieldContext_ServerTask_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_ServerTask_Environment(ctx, field)
			case "Build":
				return ec.fieldContext_ServerTask_Build(ctx, field)
			case "BuildCommit":
				return ec.fieldContext_ServerTask_BuildCommit(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ServerTask_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServerTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_updatedBuild(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_updatedBuild(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().UpdatedBuild(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *ent.Build); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/gen0cide/laforge/ent.Build`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *ent.Build):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNBuild2githubcomgen0cidelaforgeentBuild(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_updatedBuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_updatedCommit(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_updatedCommit(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().UpdatedCommit(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *ent.BuildCommit); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/gen0cide/laforge/ent.BuildCommit`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *ent.BuildCommit):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNBuildCommit2githubcomgen0cidelaforgeentBuildCommit(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_updatedCommit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BuildCommit_id(ctx, field)
			case "type":
				return ec.fieldContext_BuildCommit_type(ctx, field)
			case "revision":
				return ec.fieldContext_BuildCommit_revision(ctx, field)
			case "state":
				return ec.fieldContext_BuildCommit_state(ctx, field)
			case "createdAt":
				return ec.fieldContext_BuildCommit_createdAt(ctx, field)
			case "Build":
				return ec.fieldContext_BuildCommit_Build(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_BuildCommit_ServerTasks(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_BuildCommit_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildCommit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_updatedAgentTask(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_updatedAgentTask(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().UpdatedAgentTask(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *ent.AgentTask); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/gen0cide/laforge/ent.AgentTask`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *ent.AgentTask):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNAgentTask2githubcomgen0cidelaforgeentAgentTask(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_updatedAgentTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AgentTask_id(ctx, field)
			case "args":
				return ec.fieldContext_AgentTask_args(ctx, field)
			case "command":
				return ec.fieldContext_AgentTask_command(ctx, field)
			case "number":
				return ec.fieldContext_AgentTask_number(ctx, field)
			case "output":
				return ec.fieldContext_AgentTask_output(ctx, field)
			case "state":
				return ec.fieldContext_AgentTask_state(ctx, field)
			case "errorMessage":
				return ec.fieldContext_AgentTask_errorMessage(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_AgentTask_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_AgentTask_ProvisioningScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentTask_ProvisionedHost(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_AgentTask_AdhocPlans(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_streamServerTaskLog(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_streamServerTaskLog(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().StreamServerTaskLog(rctx, fc.Args["taskID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan string):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNString2string(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_streamServerTaskLog(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_streamServerTaskLog_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Tag_id(ctx context.Context, field graphql.CollectedField, obj *ent.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Tag().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_uuid(ctx context.Context, field graphql.CollectedField, obj *ent.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_uuid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Tag().UUID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_uuid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_name(ctx context.Context, field graphql.CollectedField, obj *ent.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_description(ctx context.Context, field graphql.CollectedField, obj *ent.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Tag().Description(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalNtagMap2githubcomgen0cidelaforgegraphqlgraphmodelTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_id(ctx context.Context, field graphql.CollectedField, obj *ent.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_teamNumber(ctx context.Context, field graphql.CollectedField, obj *ent.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_teamNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_teamNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_Build(ctx context.Context, field graphql.CollectedField, obj *ent.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_Build(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Build(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Build)
	fc.Result = res
	return ec.marshalNBuild2githubcomgen0cidelaforgeentBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_Build(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_Status(ctx context.Context, field graphql.CollectedField, obj *ent.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_Status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Status)
	fc.Result = res
	return ec.marshalOStatus2githubcomgen0cidelaforgeentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_Status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_ProvisionedNetworks(ctx context.Context, field graphql.CollectedField, obj *ent.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_ProvisionedNetworks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedNetworks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ProvisionedNetwork)
	fc.Result = res
	return ec.marshalNProvisionedNetwork2githubcomgen0cidelaforgeentProvisionedNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_ProvisionedNetworks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedNetwork_id(ctx, field)
			case "name":
				return ec.fieldContext_ProvisionedNetwork_name(ctx, field)
			case "cidr":
				return ec.fieldContext_ProvisionedNetwork_cidr(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedNetwork_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedNetwork_Status(ctx, field)
			case "Network":
				return ec.fieldContext_ProvisionedNetwork_Network(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedNetwork_Build(ctx, field)
			case "Team":
				return ec.fieldContext_ProvisionedNetwork_Team(ctx, field)
			case "ProvisionedHosts":
				return ec.fieldContext_ProvisionedNetwork_ProvisionedHosts(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedNetwork_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedNetwork", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_Plan(ctx context.Context, field graphql.CollectedField, obj *ent.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_Plan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plan(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Plan)
	fc.Result = res
	return ec.marshalNPlan2githubcomgen0cidelaforgeentPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_Plan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Plan_id(ctx, field)
			case "stepNumber":
				return ec.fieldContext_Plan_stepNumber(ctx, field)
			case "type":
				return ec.fieldContext_Plan_type(ctx, field)
			case "NextPlans":
				return ec.fieldContext_Plan_NextPlans(ctx, field)
			case "PrevPlans":
				return ec.fieldContext_Plan_PrevPlans(ctx, field)
			case "Build":
				return ec.fieldContext_Plan_Build(ctx, field)
			case "Team":
				return ec.fieldContext_Plan_Team(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Plan_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Plan_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
			case "Status":
				return ec.fieldContext_Plan_Status(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_Plan_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Plan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_uuid(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_uuid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UUID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_uuid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_Tag(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_Tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tag(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Tag)
	fc.Result = res
	return ec.marshalNTag2githubcomgen0cidelaforgeentTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_Tag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "uuid":
				return ec.fieldContext_Tag_uuid(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "description":
				return ec.fieldContext_Tag_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_Environments(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_Environments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environments(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_Environments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _configMap_key(ctx context.Context, field graphql.CollectedField, obj *model.ConfigMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_configMap_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_configMap_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "configMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _configMap_value(ctx context.Context, field graphql.CollectedField, obj *model.ConfigMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_configMap_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_configMap_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "configMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _intMap_key(ctx context.Context, field graphql.CollectedField, obj *model.IntMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_intMap_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_intMap_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "intMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _intMap_value(ctx context.Context, field graphql.CollectedField, obj *model.IntMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_intMap_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_intMap_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "intMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _tagMap_key(ctx context.Context, field graphql.CollectedField, obj *model.TagMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_tagMap_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_tagMap_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "tagMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _tagMap_value(ctx context.Context, field graphql.CollectedField, obj *model.TagMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_tagMap_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_tagMap_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "tagMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _varsMap_key(ctx context.Context, field graphql.CollectedField, obj *model.VarsMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_varsMap_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_varsMap_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "varsMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _varsMap_value(ctx context.Context, field graphql.CollectedField, obj *model.VarsMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_varsMap_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_varsMap_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "varsMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var adhocPlanImplementors = []string{"AdhocPlan"}

func (ec *executionContext) _AdhocPlan(ctx context.Context, sel ast.SelectionSet, obj *ent.AdhocPlan) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adhocPlanImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdhocPlan")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AdhocPlan_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "NextAdhocPlans":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AdhocPlan_NextAdhocPlans(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "PrevAdhocPlans":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AdhocPlan_PrevAdhocPlans(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Build":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AdhocPlan_Build(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AdhocPlan_Status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "AgentTask":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AdhocPlan_AgentTask(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var agentStatusImplementors = []string{"AgentStatus"}

func (ec *executionContext) _AgentStatus(ctx context.Context, sel ast.SelectionSet, obj *ent.AgentStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, agentStatusImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AgentStatus")
		case "clientId":

			out.Values[i] = ec._AgentStatus_clientId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "hostname":

			out.Values[i] = ec._AgentStatus_hostname(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "upTime":

			out.Values[i] = ec._AgentStatus_upTime(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "bootTime":

			out.Values[i] = ec._AgentStatus_bootTime(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "numProcs":

			out.Values[i] = ec._AgentStatus_numProcs(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "OS":

			out.Values[i] = ec._AgentStatus_OS(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "hostID":

			out.Values[i] = ec._AgentStatus_hostID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "load1":

			out.Values[i] = ec._AgentStatus_load1(ctx, field, obj)

		case "load5":

			out.Values[i] = ec._AgentStatus_load5(ctx, field, obj)

		case "load15":

			out.Values[i] = ec._AgentStatus_load15(ctx, field, obj)

		case "totalMem":

			out.Values[i] = ec._AgentStatus_totalMem(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "freeMem":

			out.Values[i] = ec._AgentStatus_freeMem(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "usedMem":

			out.Values[i] = ec._AgentStatus_usedMem(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "timestamp":

			out.Values[i] = ec._AgentStatus_timestamp(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "ProvisionedHost":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AgentStatus_ProvisionedHost(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisionedNetwork":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AgentStatus_ProvisionedNetwork(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Build":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AgentStatus_Build(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var agentStatusBatchImplementors = []string{"AgentStatusBatch"}

func (ec *executionContext) _AgentStatusBatch(ctx context.Context, sel ast.SelectionSet, obj *model.AgentStatusBatch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, agentStatusBatchImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AgentStatusBatch")
		case "agentStatuses":

			out.Values[i] = ec._AgentStatusBatch_agentStatuses(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pageInfo":

			out.Values[i] = ec._AgentStatusBatch_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var agentTaskImplementors = []string{"AgentTask"}

func (ec *executionContext) _AgentTask(ctx context.Context, sel ast.SelectionSet, obj *ent.AgentTask) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, agentTaskImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AgentTask")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AgentTask_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "args":

			out.Values[i] = ec._AgentTask_args(ctx, field, obj)

		case "command":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AgentTask_command(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "number":

			out.Values[i] = ec._AgentTask_number(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "output":

			out.Values[i] = ec._AgentTask_output(ctx, field, obj)

		case "state":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AgentTask_state(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "errorMessage":

			out.Values[i] = ec._AgentTask_errorMessage(ctx, field, obj)

		case "ProvisioningStep":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AgentTask_ProvisioningStep(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisioningScheduledStep":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AgentTask_ProvisioningScheduledStep(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisionedHost":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AgentTask_ProvisionedHost(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "AdhocPlans":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AgentTask_AdhocPlans(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var ansibleImplementors = []string{"Ansible"}

func (ec *executionContext) _Ansible(ctx context.Context, sel ast.SelectionSet, obj *ent.Ansible) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ansibleImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Ansible")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Ansible_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._Ansible_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Ansible_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":

			out.Values[i] = ec._Ansible_description(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "source":

			out.Values[i] = ec._Ansible_source(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "playbookName":

			out.Values[i] = ec._Ansible_playbookName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "method":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Ansible_method(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "inventory":

			out.Values[i] = ec._Ansible_inventory(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "absPath":

			out.Values[i] = ec._Ansible_absPath(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Ansible_tags(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Users":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Ansible_Users(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Ansible_Environment(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var authUserImplementors = []string{"AuthUser"}

func (ec *executionContext) _AuthUser(ctx context.Context, sel ast.SelectionSet, obj *ent.AuthUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, authUserImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuthUser")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AuthUser_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "username":

			out.Values[i] = ec._AuthUser_username(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "firstName":

			out.Values[i] = ec._AuthUser_firstName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "lastName":

			out.Values[i] = ec._AuthUser_lastName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "email":

			out.Values[i] = ec._AuthUser_email(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "phone":

			out.Values[i] = ec._AuthUser_phone(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "company":

			out.Values[i] = ec._AuthUser_company(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "occupation":

			out.Values[i] = ec._AuthUser_occupation(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "publicKey":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AuthUser_publicKey(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "role":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AuthUser_role(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "provider":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AuthUser_provider(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ServerTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AuthUser_ServerTasks(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var buildImplementors = []string{"Build"}

func (ec *executionContext) _Build(ctx context.Context, sel ast.SelectionSet, obj *ent.Build) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Build")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "revision":

			out.Values[i] = ec._Build_revision(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "environmentRevision":

			out.Values[i] = ec._Build_environmentRevision(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "completedPlan":

			out.Values[i] = ec._Build_completedPlan(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_Status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_Environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Competition":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_Competition(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "LatestBuildCommit":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_LatestBuildCommit(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "RepoCommit":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_RepoCommit(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisionedNetworks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_ProvisionedNetworks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Teams":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_Teams(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Plans":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_Plans(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "BuildCommits":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_BuildCommits(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "AdhocPlans":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_AdhocPlans(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "AgentStatuses":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_AgentStatuses(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ServerTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_ServerTasks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var buildCommitImplementors = []string{"BuildCommit"}

func (ec *executionContext) _BuildCommit(ctx context.Context, sel ast.SelectionSet, obj *ent.BuildCommit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildCommitImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildCommit")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BuildCommit_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "type":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BuildCommit_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "revision":

			out.Values[i] = ec._BuildCommit_revision(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "state":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BuildCommit_state(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "createdAt":

			out.Values[i] = ec._BuildCommit_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Build":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BuildCommit_Build(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ServerTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BuildCommit_ServerTasks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "PlanDiffs":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BuildCommit_PlanDiffs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var commandImplementors = []string{"Command"}

func (ec *executionContext) _Command(ctx context.Context, sel ast.SelectionSet, obj *ent.Command) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, commandImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Command")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Command_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._Command_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Command_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":

			out.Values[i] = ec._Command_description(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "program":

			out.Values[i] = ec._Command_program(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "args":

			out.Values[i] = ec._Command_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "ignoreErrors":

			out.Values[i] = ec._Command_ignoreErrors(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "disabled":

			out.Values[i] = ec._Command_disabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "cooldown":

			out.Values[i] = ec._Command_cooldown(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "timeout":

			out.Values[i] = ec._Command_timeout(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "vars":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Command_vars(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Command_tags(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Users":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Command_Users(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Command_Environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var competitionImplementors = []string{"Competition"}

func (ec *executionContext) _Competition(ctx context.Context, sel ast.SelectionSet, obj *ent.Competition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, competitionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Competition")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Competition_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._Competition_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "rootPassword":

			out.Values[i] = ec._Competition_rootPassword(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "startTime":

			out.Values[i] = ec._Competition_startTime(ctx, field, obj)

		case "stopTime":

			out.Values[i] = ec._Competition_stopTime(ctx, field, obj)

		case "config":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Competition_config(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Competition_tags(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "DNS":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Competition_DNS(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Competition_Environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Builds":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Competition_Builds(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var dNSImplementors = []string{"DNS"}

func (ec *executionContext) _DNS(ctx context.Context, sel ast.SelectionSet, obj *ent.DNS) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dNSImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DNS")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DNS_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._DNS_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":

			out.Values[i] = ec._DNS_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "rootDomain":

			out.Values[i] = ec._DNS_rootDomain(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "dnsServers":

			out.Values[i] = ec._DNS_dnsServers(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "ntpServers":

			out.Values[i] = ec._DNS_ntpServers(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "config":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DNS_config(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environments":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DNS_Environments(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Competitions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DNS_Competitions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var dNSRecordImplementors = []string{"DNSRecord"}

func (ec *executionContext) _DNSRecord(ctx context.Context, sel ast.SelectionSet, obj *ent.DNSRecord) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dNSRecordImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DNSRecord")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DNSRecord_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._DNSRecord_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._DNSRecord_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "values":

			out.Values[i] = ec._DNSRecord_values(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":

			out.Values[i] = ec._DNSRecord_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "zone":

			out.Values[i] = ec._DNSRecord_zone(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "vars":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DNSRecord_vars(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "disabled":

			out.Values[i] = ec._DNSRecord_disabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DNSRecord_tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DNSRecord_Environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var diskImplementors = []string{"Disk"}

func (ec *executionContext) _Disk(ctx context.Context, sel ast.SelectionSet, obj *ent.Disk) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, diskImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Disk")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Disk_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "size":

			out.Values[i] = ec._Disk_size(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Host":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Disk_Host(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var environmentImplementors = []string{"Environment"}

func (ec *executionContext) _Environment(ctx context.Context, sel ast.SelectionSet, obj *ent.Environment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, environmentImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Environment")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._Environment_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "competitionId":

			out.Values[i] = ec._Environment_competitionId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Environment_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":

			out.Values[i] = ec._Environment_description(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "builder":

			out.Values[i] = ec._Environment_builder(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "teamCount":

			out.Values[i] = ec._Environment_teamCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "revision":

			out.Values[i] = ec._Environment_revision(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adminCidrs":

			out.Values[i] = ec._Environment_adminCidrs(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "exposedVdiPorts":

			out.Values[i] = ec._Environment_exposedVdiPorts(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "config":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_config(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_tags(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Users":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_Users(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Hosts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_Hosts(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Competitions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_Competitions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Identities":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_Identities(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Commands":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_Commands(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Scripts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_Scripts(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "FileDownloads":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_FileDownloads(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "FileDeletes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_FileDeletes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "FileExtracts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_FileExtracts(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "IncludedNetworks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_IncludedNetworks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Findings":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_Findings(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "DNSRecords":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_DNSRecords(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "DNS":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_DNS(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Networks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_Networks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "HostDependencies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_HostDependencies(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Ansibles":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_Ansibles(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ScheduledSteps":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_ScheduledSteps(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Builds":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_Builds(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Repositories":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_Repositories(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ServerTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_ServerTasks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var fileDeleteImplementors = []string{"FileDelete"}

func (ec *executionContext) _FileDelete(ctx context.Context, sel ast.SelectionSet, obj *ent.FileDelete) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fileDeleteImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FileDelete")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FileDelete_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._FileDelete_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "path":

			out.Values[i] = ec._FileDelete_path(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FileDelete_tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FileDelete_Environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var fileDownloadImplementors = []string{"FileDownload"}

func (ec *executionContext) _FileDownload(ctx context.Context, sel ast.SelectionSet, obj *ent.FileDownload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fileDownloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FileDownload")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FileDownload_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._FileDownload_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "sourceType":

			out.Values[i] = ec._FileDownload_sourceType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "source":

			out.Values[i] = ec._FileDownload_source(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "destination":

			out.Values[i] = ec._FileDownload_destination(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "template":

			out.Values[i] = ec._FileDownload_template(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "perms":

			out.Values[i] = ec._FileDownload_perms(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "disabled":

			out.Values[i] = ec._FileDownload_disabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "md5":

			out.Values[i] = ec._FileDownload_md5(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "absPath":

			out.Values[i] = ec._FileDownload_absPath(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FileDownload_tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FileDownload_Environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var fileExtractImplementors = []string{"FileExtract"}

func (ec *executionContext) _FileExtract(ctx context.Context, sel ast.SelectionSet, obj *ent.FileExtract) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fileExtractImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FileExtract")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FileExtract_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._FileExtract_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "source":

			out.Values[i] = ec._FileExtract_source(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "destination":

			out.Values[i] = ec._FileExtract_destination(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":

			out.Values[i] = ec._FileExtract_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FileExtract_tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FileExtract_Environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var findingImplementors = []string{"Finding"}

func (ec *executionContext) _Finding(ctx context.Context, sel ast.SelectionSet, obj *ent.Finding) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, findingImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Finding")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Finding_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "name":

			out.Values[i] = ec._Finding_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":

			out.Values[i] = ec._Finding_description(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "severity":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Finding_severity(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "difficulty":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Finding_difficulty(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Finding_tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Users":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Finding_Users(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Host":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Finding_Host(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Script":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Finding_Script(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Finding_Environment(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var ginFileMiddlewareImplementors = []string{"GinFileMiddleware"}

func (ec *executionContext) _GinFileMiddleware(ctx context.Context, sel ast.SelectionSet, obj *ent.GinFileMiddleware) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ginFileMiddlewareImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GinFileMiddleware")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GinFileMiddleware_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "urlId":

			out.Values[i] = ec._GinFileMiddleware_urlId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "filePath":

			out.Values[i] = ec._GinFileMiddleware_filePath(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "accessed":

			out.Values[i] = ec._GinFileMiddleware_accessed(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "ProvisionedHost":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GinFileMiddleware_ProvisionedHost(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisioningStep":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GinFileMiddleware_ProvisioningStep(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisioningScheduledStep":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GinFileMiddleware_ProvisioningScheduledStep(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var hostImplementors = []string{"Host"}

func (ec *executionContext) _Host(ctx context.Context, sel ast.SelectionSet, obj *ent.Host) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Host")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._Host_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "hostname":

			out.Values[i] = ec._Host_hostname(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":

			out.Values[i] = ec._Host_description(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "OS":

			out.Values[i] = ec._Host_OS(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "lastOctet":

			out.Values[i] = ec._Host_lastOctet(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "instanceSize":

			out.Values[i] = ec._Host_instanceSize(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "allowMacChanges":

			out.Values[i] = ec._Host_allowMacChanges(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "exposedTcpPorts":

			out.Values[i] = ec._Host_exposedTcpPorts(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "exposedUdpPorts":

			out.Values[i] = ec._Host_exposedUdpPorts(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "overridePassword":

			out.Values[i] = ec._Host_overridePassword(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "vars":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_vars(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "userGroups":

			out.Values[i] = ec._Host_userGroups(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "provisionSteps":

			out.Values[i] = ec._Host_provisionSteps(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Disk":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_Disk(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Users":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_Users(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_Environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "IncludedNetworks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_IncludedNetworks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "DependOnHostDependencies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_DependOnHostDependencies(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "RequiredByHostDependencies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_RequiredByHostDependencies(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var hostDependencyImplementors = []string{"HostDependency"}

func (ec *executionContext) _HostDependency(ctx context.Context, sel ast.SelectionSet, obj *ent.HostDependency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostDependencyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostDependency")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._HostDependency_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hostId":

			out.Values[i] = ec._HostDependency_hostId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "networkId":

			out.Values[i] = ec._HostDependency_networkId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "RequiredBy":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._HostDependency_RequiredBy(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "DependOnHost":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._HostDependency_DependOnHost(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "DependOnNetwork":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._HostDependency_DependOnNetwork(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._HostDependency_Environment(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var identityImplementors = []string{"Identity"}

func (ec *executionContext) _Identity(ctx context.Context, sel ast.SelectionSet, obj *ent.Identity) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, identityImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Identity")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Identity_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclid":

			out.Values[i] = ec._Identity_hclid(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "firstName":

			out.Values[i] = ec._Identity_firstName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "lastName":

			out.Values[i] = ec._Identity_lastName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "email":

			out.Values[i] = ec._Identity_email(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "password":

			out.Values[i] = ec._Identity_password(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":

			out.Values[i] = ec._Identity_description(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "avatarFile":

			out.Values[i] = ec._Identity_avatarFile(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "vars":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Identity_vars(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Identity_tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Identity_Environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var includedNetworkImplementors = []string{"IncludedNetwork"}

func (ec *executionContext) _IncludedNetwork(ctx context.Context, sel ast.SelectionSet, obj *ent.IncludedNetwork) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, includedNetworkImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IncludedNetwork")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IncludedNetwork_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "name":

			out.Values[i] = ec._IncludedNetwork_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "includedHosts":

			out.Values[i] = ec._IncludedNetwork_includedHosts(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IncludedNetwork_Tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Hosts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IncludedNetwork_Hosts(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Network":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IncludedNetwork_Network(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environments":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IncludedNetwork_Environments(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var laForgePageInfoImplementors = []string{"LaForgePageInfo"}

func (ec *executionContext) _LaForgePageInfo(ctx context.Context, sel ast.SelectionSet, obj *model.LaForgePageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, laForgePageInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LaForgePageInfo")
		case "total":

			out.Values[i] = ec._LaForgePageInfo_total(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "nextOffset":

			out.Values[i] = ec._LaForgePageInfo_nextOffset(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "loadEnvironment":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_loadEnvironment(ctx, field)
			})

		case "createBuild":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createBuild(ctx, field)
			})

		case "deleteUser":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteUser(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "executePlan":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_executePlan(ctx, field)
			})

		case "deleteBuild":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteBuild(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createTask":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createTask(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dumpBuild":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_dumpBuild(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rebuild":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_rebuild(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "approveCommit":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_approveCommit(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cancelCommit":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelCommit(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createAgentTasks":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createAgentTasks(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createBatchAgentTasks":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createBatchAgentTasks(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createEnviromentFromRepo":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createEnviromentFromRepo(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateEnviromentViaPull":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateEnviromentViaPull(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cancelBuild":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelBuild(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "modifySelfPassword":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_modifySelfPassword(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "modifySelfUserInfo":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_modifySelfUserInfo(ctx, field)
			})

		case "createUser":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createUser(ctx, field)
			})

		case "modifyAdminUserInfo":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_modifyAdminUserInfo(ctx, field)
			})

		case "modifyAdminPassword":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_modifyAdminPassword(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "nukeBackend":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_nukeBackend(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var networkImplementors = []string{"Network"}

func (ec *executionContext) _Network(ctx context.Context, sel ast.SelectionSet, obj *ent.Network) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, networkImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Network")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Network_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._Network_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Network_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "cidr":

			out.Values[i] = ec._Network_cidr(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "vdiVisible":

			out.Values[i] = ec._Network_vdiVisible(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "vars":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Network_vars(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Network_tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Network_Environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "HostDependencies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Network_HostDependencies(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "IncludedNetworks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Network_IncludedNetworks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var planImplementors = []string{"Plan"}

func (ec *executionContext) _Plan(ctx context.Context, sel ast.SelectionSet, obj *ent.Plan) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, planImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Plan")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Plan_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "stepNumber":

			out.Values[i] = ec._Plan_stepNumber(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Plan_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "NextPlans":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Plan_NextPlans(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "PrevPlans":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Plan_PrevPlans(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Build":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Plan_Build(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Team":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Plan_Team(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisionedNetwork":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Plan_ProvisionedNetwork(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisionedHost":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Plan_ProvisionedHost(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisioningStep":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Plan_ProvisioningStep(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisioningScheduledStep":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Plan_ProvisioningScheduledStep(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Plan_Status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "PlanDiffs":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Plan_PlanDiffs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var planCountsImplementors = []string{"PlanCounts"}

func (ec *executionContext) _PlanCounts(ctx context.Context, sel ast.SelectionSet, obj *model.PlanCounts) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, planCountsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlanCounts")
		case "planning":

			out.Values[i] = ec._PlanCounts_planning(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "awaiting":

			out.Values[i] = ec._PlanCounts_awaiting(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "parentAwaiting":

			out.Values[i] = ec._PlanCounts_parentAwaiting(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "inProgress":

			out.Values[i] = ec._PlanCounts_inProgress(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "failed":

			out.Values[i] = ec._PlanCounts_failed(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "complete":

			out.Values[i] = ec._PlanCounts_complete(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tainted":

			out.Values[i] = ec._PlanCounts_tainted(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "undefined":

			out.Values[i] = ec._PlanCounts_undefined(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "toDelete":

			out.Values[i] = ec._PlanCounts_toDelete(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteInProgress":

			out.Values[i] = ec._PlanCounts_deleteInProgress(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleted":

			out.Values[i] = ec._PlanCounts_deleted(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "toRebuild":

			out.Values[i] = ec._PlanCounts_toRebuild(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cancelled":

			out.Values[i] = ec._PlanCounts_cancelled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var planDiffImplementors = []string{"PlanDiff"}

func (ec *executionContext) _PlanDiff(ctx context.Context, sel ast.SelectionSet, obj *ent.PlanDiff) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, planDiffImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlanDiff")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PlanDiff_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "revision":

			out.Values[i] = ec._PlanDiff_revision(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "newState":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PlanDiff_newState(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "BuildCommit":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PlanDiff_BuildCommit(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Plan":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PlanDiff_Plan(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var provisionedHostImplementors = []string{"ProvisionedHost"}

func (ec *executionContext) _ProvisionedHost(ctx context.Context, sel ast.SelectionSet, obj *ent.ProvisionedHost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, provisionedHostImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProvisionedHost")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "subnetIp":

			out.Values[i] = ec._ProvisionedHost_subnetIp(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "addonType":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_addonType(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "vars":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_vars(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_Status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisionedNetwork":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_ProvisionedNetwork(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Host":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_Host(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "EndStepPlan":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_EndStepPlan(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Build":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_Build(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisioningSteps":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_ProvisioningSteps(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisioningScheduledSteps":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_ProvisioningScheduledSteps(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "AgentStatus":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_AgentStatus(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "AgentTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_AgentTasks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Plan":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_Plan(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "GinFileMiddleware":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_GinFileMiddleware(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var provisionedNetworkImplementors = []string{"ProvisionedNetwork"}

func (ec *executionContext) _ProvisionedNetwork(ctx context.Context, sel ast.SelectionSet, obj *ent.ProvisionedNetwork) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, provisionedNetworkImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProvisionedNetwork")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedNetwork_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "name":

			out.Values[i] = ec._ProvisionedNetwork_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "cidr":

			out.Values[i] = ec._ProvisionedNetwork_cidr(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "vars":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedNetwork_vars(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedNetwork_Status(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Network":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedNetwork_Network(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Build":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedNetwork_Build(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Team":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedNetwork_Team(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisionedHosts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedNetwork_ProvisionedHosts(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Plan":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedNetwork_Plan(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var provisioningScheduledStepImplementors = []string{"ProvisioningScheduledStep"}

func (ec *executionContext) _ProvisioningScheduledStep(ctx context.Context, sel ast.SelectionSet, obj *ent.ProvisioningScheduledStep) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, provisioningScheduledStepImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProvisioningScheduledStep")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "type":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "runTime":

			out.Values[i] = ec._ProvisioningScheduledStep_runTime(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_Status(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ScheduledStep":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_ScheduledStep(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisionedHost":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_ProvisionedHost(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Script":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_Script(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Command":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_Command(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "DNSRecord":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_DNSRecord(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "FileDelete":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_FileDelete(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "FileDownload":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_FileDownload(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "FileExtract":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_FileExtract(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Ansible":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_Ansible(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "AgentTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_AgentTasks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Plan":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_Plan(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "GinFileMiddleware":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_GinFileMiddleware(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var provisioningStepImplementors = []string{"ProvisioningStep"}

func (ec *executionContext) _ProvisioningStep(ctx context.Context, sel ast.SelectionSet, obj *ent.ProvisioningStep) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, provisioningStepImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProvisioningStep")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "type":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "stepNumber":

			out.Values[i] = ec._ProvisioningStep_stepNumber(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_Status(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisionedHost":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_ProvisionedHost(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Script":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_Script(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Command":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_Command(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "DNSRecord":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_DNSRecord(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "FileDelete":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_FileDelete(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "FileDownload":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_FileDownload(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "FileExtract":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_FileExtract(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Ansible":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_Ansible(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Plan":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_Plan(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "AgentTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_AgentTasks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "GinFileMiddleware":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_GinFileMiddleware(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "environments":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_environments(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_environment(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "provisionedHost":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_provisionedHost(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "provisionedNetwork":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_provisionedNetwork(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "provisionedStep":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_provisionedStep(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "plan":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_plan(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getBuilds":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getBuilds(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "build":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_build(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getBuildCommits":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getBuildCommits(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getBuildCommit":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getBuildCommit(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_status(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "agentStatus":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_agentStatus(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getServerTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getServerTasks(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "currentUser":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_currentUser(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getUserList":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getUserList(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getCurrentUserTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getCurrentUserTasks(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getAgentTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getAgentTasks(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "listAgentStatuses":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listAgentStatuses(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "listBuildStatuses":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listBuildStatuses(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getAllAgentStatus":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getAllAgentStatus(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getAllPlanStatus":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getAllPlanStatus(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getPlanStatusCounts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getPlanStatusCounts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "viewServerTaskLogs":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_viewServerTaskLogs(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "viewAgentTask":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_viewAgentTask(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "serverTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_serverTasks(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoCommitImplementors = []string{"RepoCommit"}

func (ec *executionContext) _RepoCommit(ctx context.Context, sel ast.SelectionSet, obj *ent.RepoCommit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoCommitImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoCommit")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoCommit_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "revision":

			out.Values[i] = ec._RepoCommit_revision(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "hash":

			out.Values[i] = ec._RepoCommit_hash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "author":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoCommit_author(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "committer":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoCommit_committer(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "pgpSignature":

			out.Values[i] = ec._RepoCommit_pgpSignature(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "message":

			out.Values[i] = ec._RepoCommit_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "treeHash":

			out.Values[i] = ec._RepoCommit_treeHash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "parentHashes":

			out.Values[i] = ec._RepoCommit_parentHashes(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Repository":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoCommit_Repository(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repositoryImplementors = []string{"Repository"}

func (ec *executionContext) _Repository(ctx context.Context, sel ast.SelectionSet, obj *ent.Repository) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repositoryImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Repository")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "repoUrl":

			out.Values[i] = ec._Repository_repoUrl(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "branchName":

			out.Values[i] = ec._Repository_branchName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "environmentFilepath":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_environmentFilepath(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environments":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_Environments(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "RepoCommits":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_RepoCommits(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var scheduledStepImplementors = []string{"ScheduledStep"}

func (ec *executionContext) _ScheduledStep(ctx context.Context, sel ast.SelectionSet, obj *ent.ScheduledStep) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, scheduledStepImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ScheduledStep")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ScheduledStep_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._ScheduledStep_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._ScheduledStep_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":

			out.Values[i] = ec._ScheduledStep_description(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "step":

			out.Values[i] = ec._ScheduledStep_step(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ScheduledStep_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "schedule":

			out.Values[i] = ec._ScheduledStep_schedule(ctx, field, obj)

		case "runAt":

			out.Values[i] = ec._ScheduledStep_runAt(ctx, field, obj)

		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ScheduledStep_Environment(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var scriptImplementors = []string{"Script"}

func (ec *executionContext) _Script(ctx context.Context, sel ast.SelectionSet, obj *ent.Script) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, scriptImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Script")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Script_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._Script_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Script_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "language":

			out.Values[i] = ec._Script_language(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":

			out.Values[i] = ec._Script_description(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "source":

			out.Values[i] = ec._Script_source(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "sourceType":

			out.Values[i] = ec._Script_sourceType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "cooldown":

			out.Values[i] = ec._Script_cooldown(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "timeout":

			out.Values[i] = ec._Script_timeout(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "ignoreErrors":

			out.Values[i] = ec._Script_ignoreErrors(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "args":

			out.Values[i] = ec._Script_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "disabled":

			out.Values[i] = ec._Script_disabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "vars":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Script_vars(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "absPath":

			out.Values[i] = ec._Script_absPath(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Script_tags(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Users":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Script_Users(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Findings":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Script_Findings(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Script_Environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var serverTaskImplementors = []string{"ServerTask"}

func (ec *executionContext) _ServerTask(ctx context.Context, sel ast.SelectionSet, obj *ent.ServerTask) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serverTaskImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServerTask")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ServerTask_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "type":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ServerTask_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "startTime":

			out.Values[i] = ec._ServerTask_startTime(ctx, field, obj)

		case "endTime":

			out.Values[i] = ec._ServerTask_endTime(ctx, field, obj)

		case "errors":

			out.Values[i] = ec._ServerTask_errors(ctx, field, obj)

		case "logFilePath":

			out.Values[i] = ec._ServerTask_logFilePath(ctx, field, obj)

		case "AuthUser":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ServerTask_AuthUser(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ServerTask_Status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ServerTask_Environment(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Build":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ServerTask_Build(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "BuildCommit":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ServerTask_BuildCommit(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "GinFileMiddleware":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ServerTask_GinFileMiddleware(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var statusImplementors = []string{"Status"}

func (ec *executionContext) _Status(ctx context.Context, sel ast.SelectionSet, obj *ent.Status) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, statusImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Status")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "state":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_state(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "statusFor":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_statusFor(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "startedAt":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_startedAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "endedAt":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_endedAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "failed":

			out.Values[i] = ec._Status_failed(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "completed":

			out.Values[i] = ec._Status_completed(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "error":

			out.Values[i] = ec._Status_error(ctx, field, obj)

		case "Build":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_Build(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisionedNetwork":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_ProvisionedNetwork(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisionedHost":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_ProvisionedHost(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisioningStep":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_ProvisioningStep(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Team":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_Team(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Plan":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_Plan(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ServerTask":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_ServerTask(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "AdhocPlan":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_AdhocPlan(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisioningScheduledStep":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_ProvisioningScheduledStep(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var statusBatchImplementors = []string{"StatusBatch"}

func (ec *executionContext) _StatusBatch(ctx context.Context, sel ast.SelectionSet, obj *model.StatusBatch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, statusBatchImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StatusBatch")
		case "statuses":

			out.Values[i] = ec._StatusBatch_statuses(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pageInfo":

			out.Values[i] = ec._StatusBatch_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "updatedAgentStatus":
		return ec._Subscription_updatedAgentStatus(ctx, fields[0])
	case "updatedStatus":
		return ec._Subscription_updatedStatus(ctx, fields[0])
	case "updatedServerTask":
		return ec._Subscription_updatedServerTask(ctx, fields[0])
	case "updatedBuild":
		return ec._Subscription_updatedBuild(ctx, fields[0])
	case "updatedCommit":
		return ec._Subscription_updatedCommit(ctx, fields[0])
	case "updatedAgentTask":
		return ec._Subscription_updatedAgentTask(ctx, fields[0])
	case "streamServerTaskLog":
		return ec._Subscription_streamServerTaskLog(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var tagImplementors = []string{"Tag"}

func (ec *executionContext) _Tag(ctx context.Context, sel ast.SelectionSet, obj *ent.Tag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Tag")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Tag_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "uuid":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Tag_uuid(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "name":

			out.Values[i] = ec._Tag_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Tag_description(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var teamImplementors = []string{"Team"}

func (ec *executionContext) _Team(ctx context.Context, sel ast.SelectionSet, obj *ent.Team) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Team")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "teamNumber":

			out.Values[i] = ec._Team_teamNumber(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Build":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_Build(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_Status(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisionedNetworks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_ProvisionedNetworks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Plan":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_Plan(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *ent.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._User_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._User_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "uuid":

			out.Values[i] = ec._User_uuid(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "email":

			out.Values[i] = ec._User_email(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Tag":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_Tag(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environments":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_Environments(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":

			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":

			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":

			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":

			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":

			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":

			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":

			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":

			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":

			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":

			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":

			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":

			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":

			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":

			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":

			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":

			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":

			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":

			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":

			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":

			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":

			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":

			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":

			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":

			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":

			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":

			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var configMapImplementors = []string{"configMap"}

func (ec *executionContext) _configMap(ctx context.Context, sel ast.SelectionSet, obj *model.ConfigMap) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, configMapImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("configMap")
		case "key":

			out.Values[i] = ec._configMap_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":

			out.Values[i] = ec._configMap_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var intMapImplementors = []string{"intMap"}

func (ec *executionContext) _intMap(ctx context.Context, sel ast.SelectionSet, obj *model.IntMap) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, intMapImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("intMap")
		case "key":

			out.Values[i] = ec._intMap_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":

			out.Values[i] = ec._intMap_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tagMapImplementors = []string{"tagMap"}

func (ec *executionContext) _tagMap(ctx context.Context, sel ast.SelectionSet, obj *model.TagMap) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagMapImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("tagMap")
		case "key":

			out.Values[i] = ec._tagMap_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":

			out.Values[i] = ec._tagMap_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var varsMapImplementors = []string{"varsMap"}

func (ec *executionContext) _varsMap(ctx context.Context, sel ast.SelectionSet, obj *model.VarsMap) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, varsMapImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("varsMap")
		case "key":

			out.Values[i] = ec._varsMap_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":

			out.Values[i] = ec._varsMap_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAdhocPlan2githubcomgen0cidelaforgeentAdhocPlan(ctx context.Context, sel ast.SelectionSet, v []*ent.AdhocPlan) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAdhocPlan2githubcomgen0cidelaforgeentAdhocPlan(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNAgentCommand2githubcomgen0cidelaforgegraphqlgraphmodelAgentCommand(ctx context.Context, v interface{}) (model.AgentCommand, error) {
	var res model.AgentCommand
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAgentCommand2githubcomgen0cidelaforgegraphqlgraphmodelAgentCommand(ctx context.Context, sel ast.SelectionSet, v model.AgentCommand) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNAgentStatus2githubcomgen0cidelaforgeentAgentStatus(ctx context.Context, sel ast.SelectionSet, v ent.AgentStatus) graphql.Marshaler {
	return ec._AgentStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalNAgentStatus2githubcomgen0cidelaforgeentAgentStatus(ctx context.Context, sel ast.SelectionSet, v []*ent.AgentStatus) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAgentStatus2githubcomgen0cidelaforgeentAgentStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNAgentStatus2githubcomgen0cidelaforgeentAgentStatus(ctx context.Context, sel ast.SelectionSet, v *ent.AgentStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AgentStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNAgentTask2githubcomgen0cidelaforgeentAgentTask(ctx context.Context, sel ast.SelectionSet, v ent.AgentTask) graphql.Marshaler {
	return ec._AgentTask(ctx, sel, &v)
}

func (ec *executionContext) marshalNAgentTask2githubcomgen0cidelaforgeentAgentTask(ctx context.Context, sel ast.SelectionSet, v []*ent.AgentTask) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAgentTask2githubcomgen0cidelaforgeentAgentTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNAgentTask2githubcomgen0cidelaforgeentAgentTask(ctx context.Context, sel ast.SelectionSet, v *ent.AgentTask) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AgentTask(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAgentTaskState2githubcomgen0cidelaforgegraphqlgraphmodelAgentTaskState(ctx context.Context, v interface{}) (model.AgentTaskState, error) {
	var res model.AgentTaskState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAgentTaskState2githubcomgen0cidelaforgegraphqlgraphmodelAgentTaskState(ctx context.Context, sel ast.SelectionSet, v model.AgentTaskState) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNAnsible2githubcomgen0cidelaforgeentAnsible(ctx context.Context, sel ast.SelectionSet, v []*ent.Ansible) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAnsible2githubcomgen0cidelaforgeentAnsible(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNAnsibleMethod2githubcomgen0cidelaforgegraphqlgraphmodelAnsibleMethod(ctx context.Context, v interface{}) (model.AnsibleMethod, error) {
	var res model.AnsibleMethod
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAnsibleMethod2githubcomgen0cidelaforgegraphqlgraphmodelAnsibleMethod(ctx context.Context, sel ast.SelectionSet, v model.AnsibleMethod) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNAuthUser2githubcomgen0cidelaforgeentAuthUser(ctx context.Context, sel ast.SelectionSet, v *ent.AuthUser) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AuthUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNBuild2githubcomgen0cidelaforgeentBuild(ctx context.Context, sel ast.SelectionSet, v ent.Build) graphql.Marshaler {
	return ec._Build(ctx, sel, &v)
}

func (ec *executionContext) marshalNBuild2githubcomgen0cidelaforgeentBuild(ctx context.Context, sel ast.SelectionSet, v []*ent.Build) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOBuild2githubcomgen0cidelaforgeentBuild(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNBuild2githubcomgen0cidelaforgeentBuild(ctx context.Context, sel ast.SelectionSet, v *ent.Build) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Build(ctx, sel, v)
}

func (ec *executionContext) marshalNBuildCommit2githubcomgen0cidelaforgeentBuildCommit(ctx context.Context, sel ast.SelectionSet, v ent.BuildCommit) graphql.Marshaler {
	return ec._BuildCommit(ctx, sel, &v)
}

func (ec *executionContext) marshalNBuildCommit2githubcomgen0cidelaforgeentBuildCommit(ctx context.Context, sel ast.SelectionSet, v []*ent.BuildCommit) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOBuildCommit2githubcomgen0cidelaforgeentBuildCommit(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNBuildCommit2githubcomgen0cidelaforgeentBuildCommit(ctx context.Context, sel ast.SelectionSet, v *ent.BuildCommit) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BuildCommit(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBuildCommitState2githubcomgen0cidelaforgegraphqlgraphmodelBuildCommitState(ctx context.Context, v interface{}) (model.BuildCommitState, error) {
	var res model.BuildCommitState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBuildCommitState2githubcomgen0cidelaforgegraphqlgraphmodelBuildCommitState(ctx context.Context, sel ast.SelectionSet, v model.BuildCommitState) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBuildCommitType2githubcomgen0cidelaforgegraphqlgraphmodelBuildCommitType(ctx context.Context, v interface{}) (model.BuildCommitType, error) {
	var res model.BuildCommitType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBuildCommitType2githubcomgen0cidelaforgegraphqlgraphmodelBuildCommitType(ctx context.Context, sel ast.SelectionSet, v model.BuildCommitType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCommand2githubcomgen0cidelaforgeentCommand(ctx context.Context, sel ast.SelectionSet, v []*ent.Command) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCommand2githubcomgen0cidelaforgeentCommand(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNCompetition2githubcomgen0cidelaforgeentCompetition(ctx context.Context, sel ast.SelectionSet, v []*ent.Competition) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCompetition2githubcomgen0cidelaforgeentCompetition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNCompetition2githubcomgen0cidelaforgeentCompetition(ctx context.Context, sel ast.SelectionSet, v *ent.Competition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Competition(ctx, sel, v)
}

func (ec *executionContext) marshalNDNS2githubcomgen0cidelaforgeentDNS(ctx context.Context, sel ast.SelectionSet, v []*ent.DNS) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODNS2githubcomgen0cidelaforgeentDNS(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNDNSRecord2githubcomgen0cidelaforgeentDNSRecord(ctx context.Context, sel ast.SelectionSet, v []*ent.DNSRecord) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODNSRecord2githubcomgen0cidelaforgeentDNSRecord(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNDisk2githubcomgen0cidelaforgeentDisk(ctx context.Context, sel ast.SelectionSet, v *ent.Disk) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Disk(ctx, sel, v)
}

func (ec *executionContext) marshalNEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx context.Context, sel ast.SelectionSet, v []*ent.Environment) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx context.Context, sel ast.SelectionSet, v *ent.Environment) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Environment(ctx, sel, v)
}

func (ec *executionContext) marshalNFileDelete2githubcomgen0cidelaforgeentFileDelete(ctx context.Context, sel ast.SelectionSet, v []*ent.FileDelete) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOFileDelete2githubcomgen0cidelaforgeentFileDelete(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNFileDownload2githubcomgen0cidelaforgeentFileDownload(ctx context.Context, sel ast.SelectionSet, v []*ent.FileDownload) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOFileDownload2githubcomgen0cidelaforgeentFileDownload(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNFileExtract2githubcomgen0cidelaforgeentFileExtract(ctx context.Context, sel ast.SelectionSet, v []*ent.FileExtract) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOFileExtract2githubcomgen0cidelaforgeentFileExtract(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNFinding2githubcomgen0cidelaforgeentFinding(ctx context.Context, sel ast.SelectionSet, v []*ent.Finding) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOFinding2githubcomgen0cidelaforgeentFinding(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNFindingDifficulty2githubcomgen0cidelaforgegraphqlgraphmodelFindingDifficulty(ctx context.Context, v interface{}) (model.FindingDifficulty, error) {
	var res model.FindingDifficulty
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFindingDifficulty2githubcomgen0cidelaforgegraphqlgraphmodelFindingDifficulty(ctx context.Context, sel ast.SelectionSet, v model.FindingDifficulty) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFindingSeverity2githubcomgen0cidelaforgegraphqlgraphmodelFindingSeverity(ctx context.Context, v interface{}) (model.FindingSeverity, error) {
	var res model.FindingSeverity
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFindingSeverity2githubcomgen0cidelaforgegraphqlgraphmodelFindingSeverity(ctx context.Context, sel ast.SelectionSet, v model.FindingSeverity) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGinFileMiddleware2githubcomgen0cidelaforgeentGinFileMiddleware(ctx context.Context, sel ast.SelectionSet, v []*ent.GinFileMiddleware) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGinFileMiddleware2githubcomgen0cidelaforgeentGinFileMiddleware(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNHost2githubcomgen0cidelaforgeentHost(ctx context.Context, sel ast.SelectionSet, v []*ent.Host) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOHost2githubcomgen0cidelaforgeentHost(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNHost2githubcomgen0cidelaforgeentHost(ctx context.Context, sel ast.SelectionSet, v *ent.Host) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Host(ctx, sel, v)
}

func (ec *executionContext) marshalNHostDependency2githubcomgen0cidelaforgeentHostDependency(ctx context.Context, sel ast.SelectionSet, v []*ent.HostDependency) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOHostDependency2githubcomgen0cidelaforgeentHostDependency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNIdentity2githubcomgen0cidelaforgeentIdentity(ctx context.Context, sel ast.SelectionSet, v []*ent.Identity) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOIdentity2githubcomgen0cidelaforgeentIdentity(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNIncludedNetwork2githubcomgen0cidelaforgeentIncludedNetwork(ctx context.Context, sel ast.SelectionSet, v []*ent.IncludedNetwork) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOIncludedNetwork2githubcomgen0cidelaforgeentIncludedNetwork(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int64(ctx context.Context, v interface{}) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	res := graphql.MarshalInt64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) ([]int, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLaForgePageInfo2githubcomgen0cidelaforgegraphqlgraphmodelLaForgePageInfo(ctx context.Context, sel ast.SelectionSet, v *model.LaForgePageInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LaForgePageInfo(ctx, sel, v)
}

func (ec *executionContext) marshalNNetwork2githubcomgen0cidelaforgeentNetwork(ctx context.Context, sel ast.SelectionSet, v []*ent.Network) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONetwork2githubcomgen0cidelaforgeentNetwork(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNPlan2githubcomgen0cidelaforgeentPlan(ctx context.Context, sel ast.SelectionSet, v []*ent.Plan) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPlan2githubcomgen0cidelaforgeentPlan(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNPlan2githubcomgen0cidelaforgeentPlan(ctx context.Context, sel ast.SelectionSet, v *ent.Plan) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Plan(ctx, sel, v)
}

func (ec *executionContext) marshalNPlanCounts2githubcomgen0cidelaforgegraphqlgraphmodelPlanCounts(ctx context.Context, sel ast.SelectionSet, v model.PlanCounts) graphql.Marshaler {
	return ec._PlanCounts(ctx, sel, &v)
}

func (ec *executionContext) marshalNPlanCounts2githubcomgen0cidelaforgegraphqlgraphmodelPlanCounts(ctx context.Context, sel ast.SelectionSet, v *model.PlanCounts) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PlanCounts(ctx, sel, v)
}

func (ec *executionContext) marshalNPlanDiff2githubcomgen0cidelaforgeentPlanDiff(ctx context.Context, sel ast.SelectionSet, v []*ent.PlanDiff) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPlanDiff2githubcomgen0cidelaforgeentPlanDiff(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNPlanType2githubcomgen0cidelaforgegraphqlgraphmodelPlanType(ctx context.Context, v interface{}) (model.PlanType, error) {
	var res model.PlanType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPlanType2githubcomgen0cidelaforgegraphqlgraphmodelPlanType(ctx context.Context, sel ast.SelectionSet, v model.PlanType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNProviderType2githubcomgen0cidelaforgegraphqlgraphmodelProviderType(ctx context.Context, v interface{}) (model.ProviderType, error) {
	var res model.ProviderType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProviderType2githubcomgen0cidelaforgegraphqlgraphmodelProviderType(ctx context.Context, sel ast.SelectionSet, v model.ProviderType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNProvisionStatus2githubcomgen0cidelaforgegraphqlgraphmodelProvisionStatus(ctx context.Context, v interface{}) (model.ProvisionStatus, error) {
	var res model.ProvisionStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProvisionStatus2githubcomgen0cidelaforgegraphqlgraphmodelProvisionStatus(ctx context.Context, sel ast.SelectionSet, v model.ProvisionStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNProvisionStatusFor2githubcomgen0cidelaforgegraphqlgraphmodelProvisionStatusFor(ctx context.Context, v interface{}) (model.ProvisionStatusFor, error) {
	var res model.ProvisionStatusFor
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProvisionStatusFor2githubcomgen0cidelaforgegraphqlgraphmodelProvisionStatusFor(ctx context.Context, sel ast.SelectionSet, v model.ProvisionStatusFor) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNProvisionedHost2githubcomgen0cidelaforgeentProvisionedHost(ctx context.Context, sel ast.SelectionSet, v []*ent.ProvisionedHost) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOProvisionedHost2githubcomgen0cidelaforgeentProvisionedHost(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNProvisionedHost2githubcomgen0cidelaforgeentProvisionedHost(ctx context.Context, sel ast.SelectionSet, v *ent.ProvisionedHost) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProvisionedHost(ctx, sel, v)
}

func (ec *executionContext) marshalNProvisionedNetwork2githubcomgen0cidelaforgeentProvisionedNetwork(ctx context.Context, sel ast.SelectionSet, v []*ent.ProvisionedNetwork) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOProvisionedNetwork2githubcomgen0cidelaforgeentProvisionedNetwork(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNProvisionedNetwork2githubcomgen0cidelaforgeentProvisionedNetwork(ctx context.Context, sel ast.SelectionSet, v *ent.ProvisionedNetwork) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProvisionedNetwork(ctx, sel, v)
}

func (ec *executionContext) marshalNProvisioningScheduledStep2githubcomgen0cidelaforgeentProvisioningScheduledStep(ctx context.Context, sel ast.SelectionSet, v []*ent.ProvisioningScheduledStep) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOProvisioningScheduledStep2githubcomgen0cidelaforgeentProvisioningScheduledStep(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNProvisioningScheduledStepType2githubcomgen0cidelaforgegraphqlgraphmodelProvisioningScheduledStepType(ctx context.Context, v interface{}) (model.ProvisioningScheduledStepType, error) {
	var res model.ProvisioningScheduledStepType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProvisioningScheduledStepType2githubcomgen0cidelaforgegraphqlgraphmodelProvisioningScheduledStepType(ctx context.Context, sel ast.SelectionSet, v model.ProvisioningScheduledStepType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNProvisioningStep2githubcomgen0cidelaforgeentProvisioningStep(ctx context.Context, sel ast.SelectionSet, v []*ent.ProvisioningStep) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOProvisioningStep2githubcomgen0cidelaforgeentProvisioningStep(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNProvisioningStepType2githubcomgen0cidelaforgegraphqlgraphmodelProvisioningStepType(ctx context.Context, v interface{}) (model.ProvisioningStepType, error) {
	var res model.ProvisioningStepType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProvisioningStepType2githubcomgen0cidelaforgegraphqlgraphmodelProvisioningStepType(ctx context.Context, sel ast.SelectionSet, v model.ProvisioningStepType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRepoCommit2githubcomgen0cidelaforgeentRepoCommit(ctx context.Context, sel ast.SelectionSet, v []*ent.RepoCommit) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalORepoCommit2githubcomgen0cidelaforgeentRepoCommit(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNRepoCommit2githubcomgen0cidelaforgeentRepoCommit(ctx context.Context, sel ast.SelectionSet, v *ent.RepoCommit) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RepoCommit(ctx, sel, v)
}

func (ec *executionContext) marshalNRepository2githubcomgen0cidelaforgeentRepository(ctx context.Context, sel ast.SelectionSet, v []*ent.Repository) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalORepository2githubcomgen0cidelaforgeentRepository(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNRepository2githubcomgen0cidelaforgeentRepository(ctx context.Context, sel ast.SelectionSet, v *ent.Repository) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Repository(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx context.Context, v interface{}) (model.RoleLevel, error) {
	var res model.RoleLevel
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx context.Context, sel ast.SelectionSet, v model.RoleLevel) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx context.Context, v interface{}) ([]model.RoleLevel, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.RoleLevel, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx context.Context, sel ast.SelectionSet, v []model.RoleLevel) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNScheduledStep2githubcomgen0cidelaforgeentScheduledStep(ctx context.Context, sel ast.SelectionSet, v []*ent.ScheduledStep) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOScheduledStep2githubcomgen0cidelaforgeentScheduledStep(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNScheduledStep2githubcomgen0cidelaforgeentScheduledStep(ctx context.Context, sel ast.SelectionSet, v *ent.ScheduledStep) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ScheduledStep(ctx, sel, v)
}

func (ec *executionContext) unmarshalNScheduledStepType2githubcomgen0cidelaforgegraphqlgraphmodelScheduledStepType(ctx context.Context, v interface{}) (model.ScheduledStepType, error) {
	var res model.ScheduledStepType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNScheduledStepType2githubcomgen0cidelaforgegraphqlgraphmodelScheduledStepType(ctx context.Context, sel ast.SelectionSet, v model.ScheduledStepType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNScript2githubcomgen0cidelaforgeentScript(ctx context.Context, sel ast.SelectionSet, v []*ent.Script) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOScript2githubcomgen0cidelaforgeentScript(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNServerTask2githubcomgen0cidelaforgeentServerTask(ctx context.Context, sel ast.SelectionSet, v ent.ServerTask) graphql.Marshaler {
	return ec._ServerTask(ctx, sel, &v)
}

func (ec *executionContext) marshalNServerTask2githubcomgen0cidelaforgeentServerTask(ctx context.Context, sel ast.SelectionSet, v []*ent.ServerTask) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOServerTask2githubcomgen0cidelaforgeentServerTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNServerTask2githubcomgen0cidelaforgeentServerTask(ctx context.Context, sel ast.SelectionSet, v *ent.ServerTask) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ServerTask(ctx, sel, v)
}

func (ec *executionContext) unmarshalNServerTaskType2githubcomgen0cidelaforgegraphqlgraphmodelServerTaskType(ctx context.Context, v interface{}) (model.ServerTaskType, error) {
	var res model.ServerTaskType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNServerTaskType2githubcomgen0cidelaforgegraphqlgraphmodelServerTaskType(ctx context.Context, sel ast.SelectionSet, v model.ServerTaskType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNStatus2githubcomgen0cidelaforgeentStatus(ctx context.Context, sel ast.SelectionSet, v ent.Status) graphql.Marshaler {
	return ec._Status(ctx, sel, &v)
}

func (ec *executionContext) marshalNStatus2githubcomgen0cidelaforgeentStatus(ctx context.Context, sel ast.SelectionSet, v []*ent.Status) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOStatus2githubcomgen0cidelaforgeentStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNStatus2githubcomgen0cidelaforgeentStatus(ctx context.Context, sel ast.SelectionSet, v *ent.Status) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Status(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]*string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) marshalNTag2githubcomgen0cidelaforgeentTag(ctx context.Context, sel ast.SelectionSet, v []*ent.Tag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTag2githubcomgen0cidelaforgeentTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNTeam2githubcomgen0cidelaforgeentTeam(ctx context.Context, sel ast.SelectionSet, v []*ent.Team) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTeam2githubcomgen0cidelaforgeentTeam(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNUser2githubcomgen0cidelaforgeentUser(ctx context.Context, sel ast.SelectionSet, v []*ent.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUser2githubcomgen0cidelaforgeentUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNintMap2githubcomgen0cidelaforgegraphqlgraphmodelIntMap(ctx context.Context, sel ast.SelectionSet, v []*model.IntMap) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOintMap2githubcomgen0cidelaforgegraphqlgraphmodelIntMap(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNtagMap2githubcomgen0cidelaforgegraphqlgraphmodelTagMap(ctx context.Context, sel ast.SelectionSet, v []*model.TagMap) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOtagMap2githubcomgen0cidelaforgegraphqlgraphmodelTagMap(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNvarsMap2githubcomgen0cidelaforgegraphqlgraphmodelVarsMap(ctx context.Context, sel ast.SelectionSet, v []*model.VarsMap) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOvarsMap2githubcomgen0cidelaforgegraphqlgraphmodelVarsMap(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOAdhocPlan2githubcomgen0cidelaforgeentAdhocPlan(ctx context.Context, sel ast.SelectionSet, v []*ent.AdhocPlan) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAdhocPlan2githubcomgen0cidelaforgeentAdhocPlan(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOAdhocPlan2githubcomgen0cidelaforgeentAdhocPlan(ctx context.Context, sel ast.SelectionSet, v *ent.AdhocPlan) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdhocPlan(ctx, sel, v)
}

func (ec *executionContext) marshalOAgentStatus2githubcomgen0cidelaforgeentAgentStatus(ctx context.Context, sel ast.SelectionSet, v []*ent.AgentStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAgentStatus2githubcomgen0cidelaforgeentAgentStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOAgentStatus2githubcomgen0cidelaforgeentAgentStatus(ctx context.Context, sel ast.SelectionSet, v *ent.AgentStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AgentStatus(ctx, sel, v)
}

func (ec *executionContext) marshalOAgentStatusBatch2githubcomgen0cidelaforgegraphqlgraphmodelAgentStatusBatch(ctx context.Context, sel ast.SelectionSet, v *model.AgentStatusBatch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AgentStatusBatch(ctx, sel, v)
}

func (ec *executionContext) marshalOAgentTask2githubcomgen0cidelaforgeentAgentTask(ctx context.Context, sel ast.SelectionSet, v []*ent.AgentTask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAgentTask2githubcomgen0cidelaforgeentAgentTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOAgentTask2githubcomgen0cidelaforgeentAgentTask(ctx context.Context, sel ast.SelectionSet, v *ent.AgentTask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AgentTask(ctx, sel, v)
}

func (ec *executionContext) marshalOAnsible2githubcomgen0cidelaforgeentAnsible(ctx context.Context, sel ast.SelectionSet, v *ent.Ansible) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Ansible(ctx, sel, v)
}

func (ec *executionContext) marshalOAuthUser2githubcomgen0cidelaforgeentAuthUser(ctx context.Context, sel ast.SelectionSet, v []*ent.AuthUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAuthUser2githubcomgen0cidelaforgeentAuthUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOAuthUser2githubcomgen0cidelaforgeentAuthUser(ctx context.Context, sel ast.SelectionSet, v *ent.AuthUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AuthUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOBuild2githubcomgen0cidelaforgeentBuild(ctx context.Context, sel ast.SelectionSet, v []*ent.Build) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOBuild2githubcomgen0cidelaforgeentBuild(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOBuild2githubcomgen0cidelaforgeentBuild(ctx context.Context, sel ast.SelectionSet, v *ent.Build) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Build(ctx, sel, v)
}

func (ec *executionContext) marshalOBuildCommit2githubcomgen0cidelaforgeentBuildCommit(ctx context.Context, sel ast.SelectionSet, v []*ent.BuildCommit) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOBuildCommit2githubcomgen0cidelaforgeentBuildCommit(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOBuildCommit2githubcomgen0cidelaforgeentBuildCommit(ctx context.Context, sel ast.SelectionSet, v *ent.BuildCommit) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BuildCommit(ctx, sel, v)
}

func (ec *executionContext) marshalOCommand2githubcomgen0cidelaforgeentCommand(ctx context.Context, sel ast.SelectionSet, v *ent.Command) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Command(ctx, sel, v)
}

func (ec *executionContext) marshalOCompetition2githubcomgen0cidelaforgeentCompetition(ctx context.Context, sel ast.SelectionSet, v *ent.Competition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Competition(ctx, sel, v)
}

func (ec *executionContext) marshalODNS2githubcomgen0cidelaforgeentDNS(ctx context.Context, sel ast.SelectionSet, v *ent.DNS) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DNS(ctx, sel, v)
}

func (ec *executionContext) marshalODNSRecord2githubcomgen0cidelaforgeentDNSRecord(ctx context.Context, sel ast.SelectionSet, v *ent.DNSRecord) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DNSRecord(ctx, sel, v)
}

func (ec *executionContext) marshalOEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx context.Context, sel ast.SelectionSet, v []*ent.Environment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOEnvironment2githubcomgen0cidelaforgeentEnvironment(ctx context.Context, sel ast.SelectionSet, v *ent.Environment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Environment(ctx, sel, v)
}

func (ec *executionContext) marshalOFileDelete2githubcomgen0cidelaforgeentFileDelete(ctx context.Context, sel ast.SelectionSet, v *ent.FileDelete) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FileDelete(ctx, sel, v)
}

func (ec *executionContext) marshalOFileDownload2githubcomgen0cidelaforgeentFileDownload(ctx context.Context, sel ast.SelectionSet, v *ent.FileDownload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FileDownload(ctx, sel, v)
}

func (ec *executionContext) marshalOFileExtract2githubcomgen0cidelaforgeentFileExtract(ctx context.Context, sel ast.SelectionSet, v *ent.FileExtract) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FileExtract(ctx, sel, v)
}

func (ec *executionContext) marshalOFinding2githubcomgen0cidelaforgeentFinding(ctx context.Context, sel ast.SelectionSet, v *ent.Finding) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Finding(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalOGinFileMiddleware2githubcomgen0cidelaforgeentGinFileMiddleware(ctx context.Context, sel ast.SelectionSet, v *ent.GinFileMiddleware) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GinFileMiddleware(ctx, sel, v)
}

func (ec *executionContext) marshalOHost2githubcomgen0cidelaforgeentHost(ctx context.Context, sel ast.SelectionSet, v *ent.Host) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Host(ctx, sel, v)
}

func (ec *executionContext) marshalOHostDependency2githubcomgen0cidelaforgeentHostDependency(ctx context.Context, sel ast.SelectionSet, v *ent.HostDependency) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._HostDependency(ctx, sel, v)
}

func (ec *executionContext) marshalOIdentity2githubcomgen0cidelaforgeentIdentity(ctx context.Context, sel ast.SelectionSet, v *ent.Identity) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Identity(ctx, sel, v)
}

func (ec *executionContext) marshalOIncludedNetwork2githubcomgen0cidelaforgeentIncludedNetwork(ctx context.Context, sel ast.SelectionSet, v *ent.IncludedNetwork) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._IncludedNetwork(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInt2int64(ctx context.Context, v interface{}) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	res := graphql.MarshalInt64(v)
	return res
}

func (ec *executionContext) marshalONetwork2githubcomgen0cidelaforgeentNetwork(ctx context.Context, sel ast.SelectionSet, v *ent.Network) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Network(ctx, sel, v)
}

func (ec *executionContext) marshalOPlan2githubcomgen0cidelaforgeentPlan(ctx context.Context, sel ast.SelectionSet, v *ent.Plan) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Plan(ctx, sel, v)
}

func (ec *executionContext) marshalOPlanDiff2githubcomgen0cidelaforgeentPlanDiff(ctx context.Context, sel ast.SelectionSet, v *ent.PlanDiff) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PlanDiff(ctx, sel, v)
}

func (ec *executionContext) unmarshalOProviderType2githubcomgen0cidelaforgegraphqlgraphmodelProviderType(ctx context.Context, v interface{}) (*model.ProviderType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ProviderType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProviderType2githubcomgen0cidelaforgegraphqlgraphmodelProviderType(ctx context.Context, sel ast.SelectionSet, v *model.ProviderType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOProvisionedHost2githubcomgen0cidelaforgeentProvisionedHost(ctx context.Context, sel ast.SelectionSet, v *ent.ProvisionedHost) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProvisionedHost(ctx, sel, v)
}

func (ec *executionContext) unmarshalOProvisionedHostAddonType2githubcomgen0cidelaforgegraphqlgraphmodelProvisionedHostAddonType(ctx context.Context, v interface{}) (*model.ProvisionedHostAddonType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ProvisionedHostAddonType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProvisionedHostAddonType2githubcomgen0cidelaforgegraphqlgraphmodelProvisionedHostAddonType(ctx context.Context, sel ast.SelectionSet, v *model.ProvisionedHostAddonType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOProvisionedNetwork2githubcomgen0cidelaforgeentProvisionedNetwork(ctx context.Context, sel ast.SelectionSet, v *ent.ProvisionedNetwork) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProvisionedNetwork(ctx, sel, v)
}

func (ec *executionContext) marshalOProvisioningScheduledStep2githubcomgen0cidelaforgeentProvisioningScheduledStep(ctx context.Context, sel ast.SelectionSet, v *ent.ProvisioningScheduledStep) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProvisioningScheduledStep(ctx, sel, v)
}

func (ec *executionContext) marshalOProvisioningStep2githubcomgen0cidelaforgeentProvisioningStep(ctx context.Context, sel ast.SelectionSet, v *ent.ProvisioningStep) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProvisioningStep(ctx, sel, v)
}

func (ec *executionContext) marshalORepoCommit2githubcomgen0cidelaforgeentRepoCommit(ctx context.Context, sel ast.SelectionSet, v *ent.RepoCommit) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RepoCommit(ctx, sel, v)
}

func (ec *executionContext) marshalORepository2githubcomgen0cidelaforgeentRepository(ctx context.Context, sel ast.SelectionSet, v *ent.Repository) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Repository(ctx, sel, v)
}

func (ec *executionContext) unmarshalORoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx context.Context, v interface{}) (*model.RoleLevel, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.RoleLevel)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORoleLevel2githubcomgen0cidelaforgegraphqlgraphmodelRoleLevel(ctx context.Context, sel ast.SelectionSet, v *model.RoleLevel) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOScheduledStep2githubcomgen0cidelaforgeentScheduledStep(ctx context.Context, sel ast.SelectionSet, v *ent.ScheduledStep) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ScheduledStep(ctx, sel, v)
}

func (ec *executionContext) marshalOScript2githubcomgen0cidelaforgeentScript(ctx context.Context, sel ast.SelectionSet, v *ent.Script) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Script(ctx, sel, v)
}

func (ec *executionContext) marshalOServerTask2githubcomgen0cidelaforgeentServerTask(ctx context.Context, sel ast.SelectionSet, v []*ent.ServerTask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOServerTask2githubcomgen0cidelaforgeentServerTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOServerTask2githubcomgen0cidelaforgeentServerTask(ctx context.Context, sel ast.SelectionSet, v *ent.ServerTask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ServerTask(ctx, sel, v)
}

func (ec *executionContext) marshalOStatus2githubcomgen0cidelaforgeentStatus(ctx context.Context, sel ast.SelectionSet, v []*ent.Status) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOStatus2githubcomgen0cidelaforgeentStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOStatus2githubcomgen0cidelaforgeentStatus(ctx context.Context, sel ast.SelectionSet, v *ent.Status) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Status(ctx, sel, v)
}

func (ec *executionContext) marshalOStatusBatch2githubcomgen0cidelaforgegraphqlgraphmodelStatusBatch(ctx context.Context, sel ast.SelectionSet, v *model.StatusBatch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StatusBatch(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTag2githubcomgen0cidelaforgeentTag(ctx context.Context, sel ast.SelectionSet, v *ent.Tag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) marshalOTeam2githubcomgen0cidelaforgeentTeam(ctx context.Context, sel ast.SelectionSet, v *ent.Team) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Team(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	return res
}

func (ec *executionContext) marshalOUser2githubcomgen0cidelaforgeentUser(ctx context.Context, sel ast.SelectionSet, v []*ent.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUser2githubcomgen0cidelaforgeentUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOUser2githubcomgen0cidelaforgeentUser(ctx context.Context, sel ast.SelectionSet, v *ent.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) marshalOconfigMap2githubcomgen0cidelaforgegraphqlgraphmodelConfigMap(ctx context.Context, sel ast.SelectionSet, v []*model.ConfigMap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOconfigMap2githubcomgen0cidelaforgegraphqlgraphmodelConfigMap(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOconfigMap2githubcomgen0cidelaforgegraphqlgraphmodelConfigMap(ctx context.Context, sel ast.SelectionSet, v *model.ConfigMap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._configMap(ctx, sel, v)
}

func (ec *executionContext) marshalOintMap2githubcomgen0cidelaforgegraphqlgraphmodelIntMap(ctx context.Context, sel ast.SelectionSet, v *model.IntMap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._intMap(ctx, sel, v)
}

func (ec *executionContext) marshalOtagMap2githubcomgen0cidelaforgegraphqlgraphmodelTagMap(ctx context.Context, sel ast.SelectionSet, v []*model.TagMap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOtagMap2githubcomgen0cidelaforgegraphqlgraphmodelTagMap(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOtagMap2githubcomgen0cidelaforgegraphqlgraphmodelTagMap(ctx context.Context, sel ast.SelectionSet, v *model.TagMap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._tagMap(ctx, sel, v)
}

func (ec *executionContext) marshalOvarsMap2githubcomgen0cidelaforgegraphqlgraphmodelVarsMap(ctx context.Context, sel ast.SelectionSet, v []*model.VarsMap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOvarsMap2githubcomgen0cidelaforgegraphqlgraphmodelVarsMap(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOvarsMap2githubcomgen0cidelaforgegraphqlgraphmodelVarsMap(ctx context.Context, sel ast.SelectionSet, v *model.VarsMap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._varsMap(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
