// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/gen0cide/laforge/ent"
	"github.com/gen0cide/laforge/graphql/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	AdhocPlan() AdhocPlanResolver
	AgentTask() AgentTaskResolver
	Ansible() AnsibleResolver
	AuthUser() AuthUserResolver
	Build() BuildResolver
	BuildCommit() BuildCommitResolver
	Command() CommandResolver
	Competition() CompetitionResolver
	DNS() DNSResolver
	DNSRecord() DNSRecordResolver
	Disk() DiskResolver
	Environment() EnvironmentResolver
	FileDelete() FileDeleteResolver
	FileDownload() FileDownloadResolver
	FileExtract() FileExtractResolver
	Finding() FindingResolver
	GinFileMiddleware() GinFileMiddlewareResolver
	Host() HostResolver
	HostDependency() HostDependencyResolver
	Identity() IdentityResolver
	IncludedNetwork() IncludedNetworkResolver
	Mutation() MutationResolver
	Network() NetworkResolver
	Plan() PlanResolver
	PlanDiff() PlanDiffResolver
	ProvisionedHost() ProvisionedHostResolver
	ProvisionedNetwork() ProvisionedNetworkResolver
	ProvisioningScheduledStep() ProvisioningScheduledStepResolver
	ProvisioningStep() ProvisioningStepResolver
	Query() QueryResolver
	RepoCommit() RepoCommitResolver
	Repository() RepositoryResolver
	ScheduledStep() ScheduledStepResolver
	Script() ScriptResolver
	ServerTask() ServerTaskResolver
	Status() StatusResolver
	Subscription() SubscriptionResolver
	Tag() TagResolver
	Team() TeamResolver
	User() UserResolver
}

type DirectiveRoot struct {
	HasRole func(ctx context.Context, obj interface{}, next graphql.Resolver, roles []model.RoleLevel) (res interface{}, err error)
}

type ComplexityRoot struct {
	AdhocPlan struct {
		AgentTask      func(childComplexity int) int
		Build          func(childComplexity int) int
		ID             func(childComplexity int) int
		NextAdhocPlans func(childComplexity int) int
		PrevAdhocPlans func(childComplexity int) int
		Status         func(childComplexity int) int
	}

	AgentConfig struct {
		APIDownloadURL func(childComplexity int) int
		GrpcServerURI  func(childComplexity int) int
	}

	AgentStatus struct {
		BootTime           func(childComplexity int) int
		Build              func(childComplexity int) int
		ClientID           func(childComplexity int) int
		FreeMem            func(childComplexity int) int
		HostID             func(childComplexity int) int
		Hostname           func(childComplexity int) int
		Load1              func(childComplexity int) int
		Load15             func(childComplexity int) int
		Load5              func(childComplexity int) int
		NumProcs           func(childComplexity int) int
		Os                 func(childComplexity int) int
		ProvisionedHost    func(childComplexity int) int
		ProvisionedNetwork func(childComplexity int) int
		Timestamp          func(childComplexity int) int
		TotalMem           func(childComplexity int) int
		UpTime             func(childComplexity int) int
		UsedMem            func(childComplexity int) int
	}

	AgentStatusBatch struct {
		AgentStatuses func(childComplexity int) int
		PageInfo      func(childComplexity int) int
	}

	AgentTask struct {
		AdhocPlans                func(childComplexity int) int
		Args                      func(childComplexity int) int
		Command                   func(childComplexity int) int
		ErrorMessage              func(childComplexity int) int
		ID                        func(childComplexity int) int
		Number                    func(childComplexity int) int
		Output                    func(childComplexity int) int
		ProvisionedHost           func(childComplexity int) int
		ProvisioningScheduledStep func(childComplexity int) int
		ProvisioningStep          func(childComplexity int) int
		State                     func(childComplexity int) int
	}

	Ansible struct {
		AbsPath      func(childComplexity int) int
		Description  func(childComplexity int) int
		Environment  func(childComplexity int) int
		HclID        func(childComplexity int) int
		ID           func(childComplexity int) int
		Inventory    func(childComplexity int) int
		Method       func(childComplexity int) int
		Name         func(childComplexity int) int
		PlaybookName func(childComplexity int) int
		Source       func(childComplexity int) int
		Tags         func(childComplexity int) int
		Users        func(childComplexity int) int
	}

	AuthConfig struct {
		CookieTimeout func(childComplexity int) int
		GithubID      func(childComplexity int) int
	}

	AuthUser struct {
		Company     func(childComplexity int) int
		Email       func(childComplexity int) int
		FirstName   func(childComplexity int) int
		ID          func(childComplexity int) int
		LastName    func(childComplexity int) int
		Occupation  func(childComplexity int) int
		Phone       func(childComplexity int) int
		Provider    func(childComplexity int) int
		PublicKey   func(childComplexity int) int
		Role        func(childComplexity int) int
		ServerTasks func(childComplexity int) int
		Username    func(childComplexity int) int
	}

	Build struct {
		AdhocPlans          func(childComplexity int) int
		AgentStatuses       func(childComplexity int) int
		BuildCommits        func(childComplexity int) int
		Competition         func(childComplexity int) int
		CompletedPlan       func(childComplexity int) int
		Environment         func(childComplexity int) int
		EnvironmentRevision func(childComplexity int) int
		ID                  func(childComplexity int) int
		LatestBuildCommit   func(childComplexity int) int
		Plans               func(childComplexity int) int
		ProvisionedNetworks func(childComplexity int) int
		RepoCommit          func(childComplexity int) int
		Revision            func(childComplexity int) int
		ServerTasks         func(childComplexity int) int
		Status              func(childComplexity int) int
		Teams               func(childComplexity int) int
	}

	BuildCommit struct {
		Build       func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		PlanDiffs   func(childComplexity int) int
		Revision    func(childComplexity int) int
		ServerTasks func(childComplexity int) int
		State       func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	BuilderConfig struct {
		Builder    func(childComplexity int) int
		ConfigFile func(childComplexity int) int
	}

	Command struct {
		Args         func(childComplexity int) int
		Cooldown     func(childComplexity int) int
		Description  func(childComplexity int) int
		Disabled     func(childComplexity int) int
		Environment  func(childComplexity int) int
		HclID        func(childComplexity int) int
		ID           func(childComplexity int) int
		IgnoreErrors func(childComplexity int) int
		Name         func(childComplexity int) int
		Program      func(childComplexity int) int
		Tags         func(childComplexity int) int
		Timeout      func(childComplexity int) int
		Users        func(childComplexity int) int
		Vars         func(childComplexity int) int
	}

	Competition struct {
		Builds       func(childComplexity int) int
		Config       func(childComplexity int) int
		DNS          func(childComplexity int) int
		Environment  func(childComplexity int) int
		HclID        func(childComplexity int) int
		ID           func(childComplexity int) int
		RootPassword func(childComplexity int) int
		StartTime    func(childComplexity int) int
		StopTime     func(childComplexity int) int
		Tags         func(childComplexity int) int
	}

	DNS struct {
		Competitions func(childComplexity int) int
		Config       func(childComplexity int) int
		DNSServers   func(childComplexity int) int
		Environments func(childComplexity int) int
		HclID        func(childComplexity int) int
		ID           func(childComplexity int) int
		NtpServers   func(childComplexity int) int
		RootDomain   func(childComplexity int) int
		Type         func(childComplexity int) int
	}

	DNSRecord struct {
		Disabled    func(childComplexity int) int
		Environment func(childComplexity int) int
		HclID       func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Tags        func(childComplexity int) int
		Type        func(childComplexity int) int
		Values      func(childComplexity int) int
		Vars        func(childComplexity int) int
		Zone        func(childComplexity int) int
	}

	DatabaseConfig struct {
		AdminUser   func(childComplexity int) int
		PostgresURI func(childComplexity int) int
	}

	Disk struct {
		Host func(childComplexity int) int
		ID   func(childComplexity int) int
		Size func(childComplexity int) int
	}

	Environment struct {
		AdminCidrs       func(childComplexity int) int
		Ansibles         func(childComplexity int) int
		Builder          func(childComplexity int) int
		Builds           func(childComplexity int) int
		Commands         func(childComplexity int) int
		CompetitionID    func(childComplexity int) int
		Competitions     func(childComplexity int) int
		Config           func(childComplexity int) int
		DNS              func(childComplexity int) int
		DNSRecords       func(childComplexity int) int
		Description      func(childComplexity int) int
		ExposedVdiPorts  func(childComplexity int) int
		FileDeletes      func(childComplexity int) int
		FileDownloads    func(childComplexity int) int
		FileExtracts     func(childComplexity int) int
		Findings         func(childComplexity int) int
		HclID            func(childComplexity int) int
		HostDependencies func(childComplexity int) int
		Hosts            func(childComplexity int) int
		ID               func(childComplexity int) int
		Identities       func(childComplexity int) int
		IncludedNetworks func(childComplexity int) int
		Name             func(childComplexity int) int
		Networks         func(childComplexity int) int
		Repositories     func(childComplexity int) int
		Revision         func(childComplexity int) int
		ScheduledSteps   func(childComplexity int) int
		Scripts          func(childComplexity int) int
		ServerTasks      func(childComplexity int) int
		Tags             func(childComplexity int) int
		TeamCount        func(childComplexity int) int
		Users            func(childComplexity int) int
	}

	FileDelete struct {
		Environment func(childComplexity int) int
		HclID       func(childComplexity int) int
		ID          func(childComplexity int) int
		Path        func(childComplexity int) int
		Tags        func(childComplexity int) int
	}

	FileDownload struct {
		AbsPath     func(childComplexity int) int
		Destination func(childComplexity int) int
		Disabled    func(childComplexity int) int
		Environment func(childComplexity int) int
		HclID       func(childComplexity int) int
		ID          func(childComplexity int) int
		Md5         func(childComplexity int) int
		Perms       func(childComplexity int) int
		Source      func(childComplexity int) int
		SourceType  func(childComplexity int) int
		Tags        func(childComplexity int) int
		Template    func(childComplexity int) int
	}

	FileExtract struct {
		Destination func(childComplexity int) int
		Environment func(childComplexity int) int
		HclID       func(childComplexity int) int
		ID          func(childComplexity int) int
		Source      func(childComplexity int) int
		Tags        func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	Finding struct {
		Description func(childComplexity int) int
		Difficulty  func(childComplexity int) int
		Environment func(childComplexity int) int
		Host        func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Script      func(childComplexity int) int
		Severity    func(childComplexity int) int
		Tags        func(childComplexity int) int
		Users       func(childComplexity int) int
	}

	GinFileMiddleware struct {
		Accessed                  func(childComplexity int) int
		FilePath                  func(childComplexity int) int
		ID                        func(childComplexity int) int
		ProvisionedHost           func(childComplexity int) int
		ProvisioningScheduledStep func(childComplexity int) int
		ProvisioningStep          func(childComplexity int) int
		URLID                     func(childComplexity int) int
	}

	GraphqlConfig struct {
		Hostname       func(childComplexity int) int
		RedisServerURI func(childComplexity int) int
	}

	Host struct {
		AllowMACChanges            func(childComplexity int) int
		DependOnHostDependencies   func(childComplexity int) int
		Description                func(childComplexity int) int
		Disk                       func(childComplexity int) int
		Environment                func(childComplexity int) int
		ExposedTCPPorts            func(childComplexity int) int
		ExposedUDPPorts            func(childComplexity int) int
		HclID                      func(childComplexity int) int
		Hostname                   func(childComplexity int) int
		ID                         func(childComplexity int) int
		IncludedNetworks           func(childComplexity int) int
		InstanceSize               func(childComplexity int) int
		LastOctet                  func(childComplexity int) int
		OS                         func(childComplexity int) int
		OverridePassword           func(childComplexity int) int
		ProvisionSteps             func(childComplexity int) int
		RequiredByHostDependencies func(childComplexity int) int
		Tags                       func(childComplexity int) int
		UserGroups                 func(childComplexity int) int
		Users                      func(childComplexity int) int
		Vars                       func(childComplexity int) int
	}

	HostDependency struct {
		DependOnHost    func(childComplexity int) int
		DependOnNetwork func(childComplexity int) int
		Environment     func(childComplexity int) int
		HostID          func(childComplexity int) int
		ID              func(childComplexity int) int
		NetworkID       func(childComplexity int) int
		RequiredBy      func(childComplexity int) int
	}

	Identity struct {
		AvatarFile  func(childComplexity int) int
		Description func(childComplexity int) int
		Email       func(childComplexity int) int
		Environment func(childComplexity int) int
		FirstName   func(childComplexity int) int
		HclID       func(childComplexity int) int
		ID          func(childComplexity int) int
		LastName    func(childComplexity int) int
		Password    func(childComplexity int) int
		Tags        func(childComplexity int) int
		Vars        func(childComplexity int) int
	}

	IncludedNetwork struct {
		Environments  func(childComplexity int) int
		Hosts         func(childComplexity int) int
		ID            func(childComplexity int) int
		IncludedHosts func(childComplexity int) int
		Name          func(childComplexity int) int
		Network       func(childComplexity int) int
		Tags          func(childComplexity int) int
	}

	LaForgePageInfo struct {
		NextOffset func(childComplexity int) int
		Total      func(childComplexity int) int
	}

	Mutation struct {
		ApproveCommit            func(childComplexity int, commitUUID string) int
		CancelBuild              func(childComplexity int, buildUUID string) int
		CancelCommit             func(childComplexity int, commitUUID string) int
		CreateAgentTasks         func(childComplexity int, hostHclid string, command model.AgentCommand, buildUUID string, args []string, teams []int) int
		CreateBatchAgentTasks    func(childComplexity int, proHostUUIDs []string, command model.AgentCommand, args []string) int
		CreateBuild              func(childComplexity int, envUUID string, renderFiles bool) int
		CreateEnviromentFromRepo func(childComplexity int, repoURL string, branchName string, envFilePath string) int
		CreateTask               func(childComplexity int, proHostUUID string, command model.AgentCommand, args string) int
		CreateUser               func(childComplexity int, username string, password string, role model.RoleLevel, provider model.ProviderType) int
		DeleteBuild              func(childComplexity int, buildUUID string) int
		DeleteUser               func(childComplexity int, userUUID string) int
		DumpBuild                func(childComplexity int, buildUUID string) int
		ExecutePlan              func(childComplexity int, buildUUID string) int
		LoadEnvironment          func(childComplexity int, envFilePath string) int
		ModifyAdminPassword      func(childComplexity int, userID string, newPassword string) int
		ModifyAdminUserInfo      func(childComplexity int, userID string, username *string, firstName *string, lastName *string, email *string, phone *string, company *string, occupation *string, role *model.RoleLevel, provider *model.ProviderType) int
		ModifySelfPassword       func(childComplexity int, currentPassword string, newPassword string) int
		ModifySelfUserInfo       func(childComplexity int, firstName *string, lastName *string, email *string, phone *string, company *string, occupation *string) int
		NukeBackend              func(childComplexity int) int
		Rebuild                  func(childComplexity int, rootPlans []*string) int
		UpdateEnviromentViaPull  func(childComplexity int, envUUID string) int
	}

	Network struct {
		Cidr             func(childComplexity int) int
		Environment      func(childComplexity int) int
		HclID            func(childComplexity int) int
		HostDependencies func(childComplexity int) int
		ID               func(childComplexity int) int
		IncludedNetworks func(childComplexity int) int
		Name             func(childComplexity int) int
		Tags             func(childComplexity int) int
		Vars             func(childComplexity int) int
		VdiVisible       func(childComplexity int) int
	}

	Plan struct {
		Build                     func(childComplexity int) int
		ID                        func(childComplexity int) int
		NextPlans                 func(childComplexity int) int
		PlanDiffs                 func(childComplexity int) int
		PrevPlans                 func(childComplexity int) int
		ProvisionedHost           func(childComplexity int) int
		ProvisionedNetwork        func(childComplexity int) int
		ProvisioningScheduledStep func(childComplexity int) int
		ProvisioningStep          func(childComplexity int) int
		Status                    func(childComplexity int) int
		StepNumber                func(childComplexity int) int
		Team                      func(childComplexity int) int
		Type                      func(childComplexity int) int
	}

	PlanCounts struct {
		Awaiting         func(childComplexity int) int
		Cancelled        func(childComplexity int) int
		Complete         func(childComplexity int) int
		DeleteInProgress func(childComplexity int) int
		Deleted          func(childComplexity int) int
		Failed           func(childComplexity int) int
		InProgress       func(childComplexity int) int
		ParentAwaiting   func(childComplexity int) int
		Planning         func(childComplexity int) int
		Tainted          func(childComplexity int) int
		ToDelete         func(childComplexity int) int
		ToRebuild        func(childComplexity int) int
		Undefined        func(childComplexity int) int
	}

	PlanDiff struct {
		BuildCommit func(childComplexity int) int
		ID          func(childComplexity int) int
		NewState    func(childComplexity int) int
		Plan        func(childComplexity int) int
		Revision    func(childComplexity int) int
	}

	ProvisionedHost struct {
		AddonType                  func(childComplexity int) int
		AgentStatuses              func(childComplexity int) int
		AgentTasks                 func(childComplexity int) int
		Build                      func(childComplexity int) int
		EndStepPlan                func(childComplexity int) int
		GinFileMiddleware          func(childComplexity int) int
		Host                       func(childComplexity int) int
		ID                         func(childComplexity int) int
		Plan                       func(childComplexity int) int
		ProvisionedNetwork         func(childComplexity int) int
		ProvisioningScheduledSteps func(childComplexity int) int
		ProvisioningSteps          func(childComplexity int) int
		Status                     func(childComplexity int) int
		SubnetIP                   func(childComplexity int) int
		Vars                       func(childComplexity int) int
	}

	ProvisionedNetwork struct {
		Build            func(childComplexity int) int
		Cidr             func(childComplexity int) int
		ID               func(childComplexity int) int
		Name             func(childComplexity int) int
		Network          func(childComplexity int) int
		Plan             func(childComplexity int) int
		ProvisionedHosts func(childComplexity int) int
		Status           func(childComplexity int) int
		Team             func(childComplexity int) int
		Vars             func(childComplexity int) int
	}

	ProvisioningScheduledStep struct {
		AgentTasks        func(childComplexity int) int
		Ansible           func(childComplexity int) int
		Command           func(childComplexity int) int
		DNSRecord         func(childComplexity int) int
		FileDelete        func(childComplexity int) int
		FileDownload      func(childComplexity int) int
		FileExtract       func(childComplexity int) int
		GinFileMiddleware func(childComplexity int) int
		ID                func(childComplexity int) int
		Plan              func(childComplexity int) int
		ProvisionedHost   func(childComplexity int) int
		RunTime           func(childComplexity int) int
		ScheduledStep     func(childComplexity int) int
		Script            func(childComplexity int) int
		Status            func(childComplexity int) int
		Type              func(childComplexity int) int
	}

	ProvisioningStep struct {
		AgentTasks        func(childComplexity int) int
		Ansible           func(childComplexity int) int
		Command           func(childComplexity int) int
		DNSRecord         func(childComplexity int) int
		FileDelete        func(childComplexity int) int
		FileDownload      func(childComplexity int) int
		FileExtract       func(childComplexity int) int
		GinFileMiddleware func(childComplexity int) int
		ID                func(childComplexity int) int
		Plan              func(childComplexity int) int
		ProvisionedHost   func(childComplexity int) int
		Script            func(childComplexity int) int
		Status            func(childComplexity int) int
		StepNumber        func(childComplexity int) int
		Type              func(childComplexity int) int
	}

	Query struct {
		AgentStatus         func(childComplexity int, clientID string) int
		Build               func(childComplexity int, buildUUID string) int
		CurrentUser         func(childComplexity int) int
		Environment         func(childComplexity int, envUUID string) int
		Environments        func(childComplexity int) int
		GetAgentTasks       func(childComplexity int, proStepUUID *string, proSchedStepUUID *string) int
		GetAllAgentStatus   func(childComplexity int, buildUUID string, count int, offset int) int
		GetAllPlanStatus    func(childComplexity int, buildUUID string, count int, offset int) int
		GetBuildCommit      func(childComplexity int, buildCommitUUID string) int
		GetBuildCommits     func(childComplexity int, envUUID string) int
		GetBuilds           func(childComplexity int) int
		GetCurrentUserTasks func(childComplexity int) int
		GetPlanStatusCounts func(childComplexity int, buildUUID string) int
		GetServerTasks      func(childComplexity int) int
		GetUserList         func(childComplexity int) int
		ListAgentStatuses   func(childComplexity int, buildUUID string) int
		ListBuildStatuses   func(childComplexity int, buildUUID string) int
		Plan                func(childComplexity int, planUUID string) int
		ProvisionedHost     func(childComplexity int, proHostUUID string) int
		ProvisionedNetwork  func(childComplexity int, proNetUUID string) int
		ProvisionedStep     func(childComplexity int, proStepUUID string) int
		ServerConfig        func(childComplexity int) int
		ServerTasks         func(childComplexity int, taskUUIDs []*string) int
		Status              func(childComplexity int, statusUUID string) int
		ViewAgentTask       func(childComplexity int, taskID string) int
		ViewServerTaskLogs  func(childComplexity int, taskID string) int
	}

	RepoCommit struct {
		Author       func(childComplexity int) int
		Committer    func(childComplexity int) int
		Hash         func(childComplexity int) int
		ID           func(childComplexity int) int
		Message      func(childComplexity int) int
		ParentHashes func(childComplexity int) int
		PgpSignature func(childComplexity int) int
		Repository   func(childComplexity int) int
		Revision     func(childComplexity int) int
		TreeHash     func(childComplexity int) int
	}

	Repository struct {
		BranchName          func(childComplexity int) int
		EnvironmentFilepath func(childComplexity int) int
		Environments        func(childComplexity int) int
		ID                  func(childComplexity int) int
		RepoCommits         func(childComplexity int) int
		RepoURL             func(childComplexity int) int
	}

	ScheduledStep struct {
		Description func(childComplexity int) int
		Environment func(childComplexity int) int
		HclID       func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		RunAt       func(childComplexity int) int
		Schedule    func(childComplexity int) int
		Step        func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	Script struct {
		AbsPath      func(childComplexity int) int
		Args         func(childComplexity int) int
		Cooldown     func(childComplexity int) int
		Description  func(childComplexity int) int
		Disabled     func(childComplexity int) int
		Environment  func(childComplexity int) int
		Findings     func(childComplexity int) int
		HclID        func(childComplexity int) int
		ID           func(childComplexity int) int
		IgnoreErrors func(childComplexity int) int
		Language     func(childComplexity int) int
		Name         func(childComplexity int) int
		Source       func(childComplexity int) int
		SourceType   func(childComplexity int) int
		Tags         func(childComplexity int) int
		Timeout      func(childComplexity int) int
		Users        func(childComplexity int) int
		Vars         func(childComplexity int) int
	}

	ServerConfig struct {
		Agent      func(childComplexity int) int
		Auth       func(childComplexity int) int
		Builders   func(childComplexity int) int
		ConfigFile func(childComplexity int) int
		Database   func(childComplexity int) int
		Debug      func(childComplexity int) int
		GinMode    func(childComplexity int) int
		Graphql    func(childComplexity int) int
		LogFolder  func(childComplexity int) int
		UI         func(childComplexity int) int
	}

	ServerTask struct {
		AuthUser          func(childComplexity int) int
		Build             func(childComplexity int) int
		BuildCommit       func(childComplexity int) int
		EndTime           func(childComplexity int) int
		Environment       func(childComplexity int) int
		Errors            func(childComplexity int) int
		GinFileMiddleware func(childComplexity int) int
		ID                func(childComplexity int) int
		LogFilePath       func(childComplexity int) int
		StartTime         func(childComplexity int) int
		Status            func(childComplexity int) int
		Type              func(childComplexity int) int
	}

	Status struct {
		AdhocPlan                 func(childComplexity int) int
		Build                     func(childComplexity int) int
		Completed                 func(childComplexity int) int
		EndedAt                   func(childComplexity int) int
		Error                     func(childComplexity int) int
		Failed                    func(childComplexity int) int
		ID                        func(childComplexity int) int
		Plan                      func(childComplexity int) int
		ProvisionedHost           func(childComplexity int) int
		ProvisionedNetwork        func(childComplexity int) int
		ProvisioningScheduledStep func(childComplexity int) int
		ProvisioningStep          func(childComplexity int) int
		ServerTask                func(childComplexity int) int
		StartedAt                 func(childComplexity int) int
		State                     func(childComplexity int) int
		StatusFor                 func(childComplexity int) int
		Team                      func(childComplexity int) int
	}

	StatusBatch struct {
		PageInfo func(childComplexity int) int
		Statuses func(childComplexity int) int
	}

	Subscription struct {
		StreamServerTaskLog func(childComplexity int, taskID string) int
		UpdatedAgentStatus  func(childComplexity int) int
		UpdatedAgentTask    func(childComplexity int) int
		UpdatedBuild        func(childComplexity int) int
		UpdatedCommit       func(childComplexity int) int
		UpdatedServerTask   func(childComplexity int) int
		UpdatedStatus       func(childComplexity int) int
	}

	Tag struct {
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		UUID        func(childComplexity int) int
	}

	Team struct {
		Build               func(childComplexity int) int
		ID                  func(childComplexity int) int
		Plan                func(childComplexity int) int
		ProvisionedNetworks func(childComplexity int) int
		Status              func(childComplexity int) int
		TeamNumber          func(childComplexity int) int
	}

	UIConfig struct {
		AllowedOrigins func(childComplexity int) int
		HTTPSEnabled   func(childComplexity int) int
	}

	User struct {
		Email        func(childComplexity int) int
		Environments func(childComplexity int) int
		HclID        func(childComplexity int) int
		ID           func(childComplexity int) int
		Name         func(childComplexity int) int
		Tag          func(childComplexity int) int
		UUID         func(childComplexity int) int
	}

	ConfigMap struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	IntMap struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	TagMap struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	VarsMap struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}
}

type AdhocPlanResolver interface {
	ID(ctx context.Context, obj *ent.AdhocPlan) (string, error)
}
type AgentTaskResolver interface {
	ID(ctx context.Context, obj *ent.AgentTask) (string, error)

	Command(ctx context.Context, obj *ent.AgentTask) (model.AgentCommand, error)

	State(ctx context.Context, obj *ent.AgentTask) (model.AgentTaskState, error)
}
type AnsibleResolver interface {
	ID(ctx context.Context, obj *ent.Ansible) (string, error)

	Method(ctx context.Context, obj *ent.Ansible) (model.AnsibleMethod, error)

	Tags(ctx context.Context, obj *ent.Ansible) ([]*model.TagMap, error)
}
type AuthUserResolver interface {
	ID(ctx context.Context, obj *ent.AuthUser) (string, error)

	PublicKey(ctx context.Context, obj *ent.AuthUser) (string, error)
	Role(ctx context.Context, obj *ent.AuthUser) (model.RoleLevel, error)
	Provider(ctx context.Context, obj *ent.AuthUser) (model.ProviderType, error)
}
type BuildResolver interface {
	ID(ctx context.Context, obj *ent.Build) (string, error)
}
type BuildCommitResolver interface {
	ID(ctx context.Context, obj *ent.BuildCommit) (string, error)
	Type(ctx context.Context, obj *ent.BuildCommit) (model.BuildCommitType, error)

	State(ctx context.Context, obj *ent.BuildCommit) (model.BuildCommitState, error)
}
type CommandResolver interface {
	ID(ctx context.Context, obj *ent.Command) (string, error)

	Vars(ctx context.Context, obj *ent.Command) ([]*model.VarsMap, error)
	Tags(ctx context.Context, obj *ent.Command) ([]*model.TagMap, error)
}
type CompetitionResolver interface {
	ID(ctx context.Context, obj *ent.Competition) (string, error)

	Config(ctx context.Context, obj *ent.Competition) ([]*model.ConfigMap, error)
	Tags(ctx context.Context, obj *ent.Competition) ([]*model.TagMap, error)
}
type DNSResolver interface {
	ID(ctx context.Context, obj *ent.DNS) (string, error)

	Config(ctx context.Context, obj *ent.DNS) ([]*model.ConfigMap, error)
}
type DNSRecordResolver interface {
	ID(ctx context.Context, obj *ent.DNSRecord) (string, error)

	Vars(ctx context.Context, obj *ent.DNSRecord) ([]*model.VarsMap, error)

	Tags(ctx context.Context, obj *ent.DNSRecord) ([]*model.TagMap, error)
}
type DiskResolver interface {
	ID(ctx context.Context, obj *ent.Disk) (string, error)
}
type EnvironmentResolver interface {
	ID(ctx context.Context, obj *ent.Environment) (string, error)

	Config(ctx context.Context, obj *ent.Environment) ([]*model.ConfigMap, error)
	Tags(ctx context.Context, obj *ent.Environment) ([]*model.TagMap, error)
}
type FileDeleteResolver interface {
	ID(ctx context.Context, obj *ent.FileDelete) (string, error)

	Tags(ctx context.Context, obj *ent.FileDelete) ([]*model.TagMap, error)
}
type FileDownloadResolver interface {
	ID(ctx context.Context, obj *ent.FileDownload) (string, error)

	Tags(ctx context.Context, obj *ent.FileDownload) ([]*model.TagMap, error)
}
type FileExtractResolver interface {
	ID(ctx context.Context, obj *ent.FileExtract) (string, error)

	Tags(ctx context.Context, obj *ent.FileExtract) ([]*model.TagMap, error)
}
type FindingResolver interface {
	ID(ctx context.Context, obj *ent.Finding) (string, error)

	Severity(ctx context.Context, obj *ent.Finding) (model.FindingSeverity, error)
	Difficulty(ctx context.Context, obj *ent.Finding) (model.FindingDifficulty, error)
	Tags(ctx context.Context, obj *ent.Finding) ([]*model.TagMap, error)
}
type GinFileMiddlewareResolver interface {
	ID(ctx context.Context, obj *ent.GinFileMiddleware) (string, error)
}
type HostResolver interface {
	ID(ctx context.Context, obj *ent.Host) (string, error)

	Vars(ctx context.Context, obj *ent.Host) ([]*model.VarsMap, error)

	Tags(ctx context.Context, obj *ent.Host) ([]*model.TagMap, error)
}
type HostDependencyResolver interface {
	ID(ctx context.Context, obj *ent.HostDependency) (string, error)
}
type IdentityResolver interface {
	ID(ctx context.Context, obj *ent.Identity) (string, error)

	Vars(ctx context.Context, obj *ent.Identity) ([]*model.VarsMap, error)
	Tags(ctx context.Context, obj *ent.Identity) ([]*model.TagMap, error)
}
type IncludedNetworkResolver interface {
	ID(ctx context.Context, obj *ent.IncludedNetwork) (string, error)
}
type MutationResolver interface {
	LoadEnvironment(ctx context.Context, envFilePath string) ([]*ent.Environment, error)
	CreateBuild(ctx context.Context, envUUID string, renderFiles bool) (*ent.Build, error)
	DeleteUser(ctx context.Context, userUUID string) (bool, error)
	ExecutePlan(ctx context.Context, buildUUID string) (*ent.Build, error)
	DeleteBuild(ctx context.Context, buildUUID string) (string, error)
	CreateTask(ctx context.Context, proHostUUID string, command model.AgentCommand, args string) (bool, error)
	DumpBuild(ctx context.Context, buildUUID string) (string, error)
	Rebuild(ctx context.Context, rootPlans []*string) (bool, error)
	ApproveCommit(ctx context.Context, commitUUID string) (bool, error)
	CancelCommit(ctx context.Context, commitUUID string) (bool, error)
	CreateAgentTasks(ctx context.Context, hostHclid string, command model.AgentCommand, buildUUID string, args []string, teams []int) ([]*ent.AgentTask, error)
	CreateBatchAgentTasks(ctx context.Context, proHostUUIDs []string, command model.AgentCommand, args []string) ([]*ent.AgentTask, error)
	CreateEnviromentFromRepo(ctx context.Context, repoURL string, branchName string, envFilePath string) ([]*ent.Environment, error)
	UpdateEnviromentViaPull(ctx context.Context, envUUID string) ([]*ent.Environment, error)
	CancelBuild(ctx context.Context, buildUUID string) (bool, error)
	ModifySelfPassword(ctx context.Context, currentPassword string, newPassword string) (bool, error)
	ModifySelfUserInfo(ctx context.Context, firstName *string, lastName *string, email *string, phone *string, company *string, occupation *string) (*ent.AuthUser, error)
	CreateUser(ctx context.Context, username string, password string, role model.RoleLevel, provider model.ProviderType) (*ent.AuthUser, error)
	ModifyAdminUserInfo(ctx context.Context, userID string, username *string, firstName *string, lastName *string, email *string, phone *string, company *string, occupation *string, role *model.RoleLevel, provider *model.ProviderType) (*ent.AuthUser, error)
	ModifyAdminPassword(ctx context.Context, userID string, newPassword string) (bool, error)
	NukeBackend(ctx context.Context) ([]*model.IntMap, error)
}
type NetworkResolver interface {
	ID(ctx context.Context, obj *ent.Network) (string, error)

	Vars(ctx context.Context, obj *ent.Network) ([]*model.VarsMap, error)
	Tags(ctx context.Context, obj *ent.Network) ([]*model.TagMap, error)
}
type PlanResolver interface {
	ID(ctx context.Context, obj *ent.Plan) (string, error)

	Type(ctx context.Context, obj *ent.Plan) (model.PlanType, error)
}
type PlanDiffResolver interface {
	ID(ctx context.Context, obj *ent.PlanDiff) (string, error)

	NewState(ctx context.Context, obj *ent.PlanDiff) (model.ProvisionStatus, error)
}
type ProvisionedHostResolver interface {
	ID(ctx context.Context, obj *ent.ProvisionedHost) (string, error)

	AddonType(ctx context.Context, obj *ent.ProvisionedHost) (*model.ProvisionedHostAddonType, error)
	Vars(ctx context.Context, obj *ent.ProvisionedHost) ([]*model.VarsMap, error)
}
type ProvisionedNetworkResolver interface {
	ID(ctx context.Context, obj *ent.ProvisionedNetwork) (string, error)

	Vars(ctx context.Context, obj *ent.ProvisionedNetwork) ([]*model.VarsMap, error)
}
type ProvisioningScheduledStepResolver interface {
	ID(ctx context.Context, obj *ent.ProvisioningScheduledStep) (string, error)
	Type(ctx context.Context, obj *ent.ProvisioningScheduledStep) (model.ProvisioningScheduledStepType, error)
}
type ProvisioningStepResolver interface {
	ID(ctx context.Context, obj *ent.ProvisioningStep) (string, error)
	Type(ctx context.Context, obj *ent.ProvisioningStep) (model.ProvisioningStepType, error)
}
type QueryResolver interface {
	Environments(ctx context.Context) ([]*ent.Environment, error)
	Environment(ctx context.Context, envUUID string) (*ent.Environment, error)
	ProvisionedHost(ctx context.Context, proHostUUID string) (*ent.ProvisionedHost, error)
	ProvisionedNetwork(ctx context.Context, proNetUUID string) (*ent.ProvisionedNetwork, error)
	ProvisionedStep(ctx context.Context, proStepUUID string) (*ent.ProvisioningStep, error)
	Plan(ctx context.Context, planUUID string) (*ent.Plan, error)
	GetBuilds(ctx context.Context) ([]*ent.Build, error)
	Build(ctx context.Context, buildUUID string) (*ent.Build, error)
	GetBuildCommits(ctx context.Context, envUUID string) ([]*ent.BuildCommit, error)
	GetBuildCommit(ctx context.Context, buildCommitUUID string) (*ent.BuildCommit, error)
	Status(ctx context.Context, statusUUID string) (*ent.Status, error)
	AgentStatus(ctx context.Context, clientID string) (*ent.AgentStatus, error)
	GetServerTasks(ctx context.Context) ([]*ent.ServerTask, error)
	CurrentUser(ctx context.Context) (*ent.AuthUser, error)
	GetUserList(ctx context.Context) ([]*ent.AuthUser, error)
	GetCurrentUserTasks(ctx context.Context) ([]*ent.ServerTask, error)
	GetAgentTasks(ctx context.Context, proStepUUID *string, proSchedStepUUID *string) ([]*ent.AgentTask, error)
	ListAgentStatuses(ctx context.Context, buildUUID string) ([]*ent.AgentStatus, error)
	ListBuildStatuses(ctx context.Context, buildUUID string) ([]*ent.Status, error)
	GetAllAgentStatus(ctx context.Context, buildUUID string, count int, offset int) (*model.AgentStatusBatch, error)
	GetAllPlanStatus(ctx context.Context, buildUUID string, count int, offset int) (*model.StatusBatch, error)
	GetPlanStatusCounts(ctx context.Context, buildUUID string) (*model.PlanCounts, error)
	ViewServerTaskLogs(ctx context.Context, taskID string) (string, error)
	ViewAgentTask(ctx context.Context, taskID string) (*ent.AgentTask, error)
	ServerTasks(ctx context.Context, taskUUIDs []*string) ([]*ent.ServerTask, error)
	ServerConfig(ctx context.Context) (*model.ServerConfig, error)
}
type RepoCommitResolver interface {
	ID(ctx context.Context, obj *ent.RepoCommit) (string, error)

	Author(ctx context.Context, obj *ent.RepoCommit) (string, error)
	Committer(ctx context.Context, obj *ent.RepoCommit) (string, error)
}
type RepositoryResolver interface {
	ID(ctx context.Context, obj *ent.Repository) (string, error)

	EnvironmentFilepath(ctx context.Context, obj *ent.Repository) (string, error)
}
type ScheduledStepResolver interface {
	ID(ctx context.Context, obj *ent.ScheduledStep) (string, error)

	Type(ctx context.Context, obj *ent.ScheduledStep) (model.ScheduledStepType, error)
}
type ScriptResolver interface {
	ID(ctx context.Context, obj *ent.Script) (string, error)

	Vars(ctx context.Context, obj *ent.Script) ([]*model.VarsMap, error)

	Tags(ctx context.Context, obj *ent.Script) ([]*model.TagMap, error)
}
type ServerTaskResolver interface {
	ID(ctx context.Context, obj *ent.ServerTask) (string, error)
	Type(ctx context.Context, obj *ent.ServerTask) (model.ServerTaskType, error)
}
type StatusResolver interface {
	ID(ctx context.Context, obj *ent.Status) (string, error)
	State(ctx context.Context, obj *ent.Status) (model.ProvisionStatus, error)
	StatusFor(ctx context.Context, obj *ent.Status) (model.ProvisionStatusFor, error)
	StartedAt(ctx context.Context, obj *ent.Status) (string, error)
	EndedAt(ctx context.Context, obj *ent.Status) (string, error)
}
type SubscriptionResolver interface {
	UpdatedAgentStatus(ctx context.Context) (<-chan *ent.AgentStatus, error)
	UpdatedStatus(ctx context.Context) (<-chan *ent.Status, error)
	UpdatedServerTask(ctx context.Context) (<-chan *ent.ServerTask, error)
	UpdatedBuild(ctx context.Context) (<-chan *ent.Build, error)
	UpdatedCommit(ctx context.Context) (<-chan *ent.BuildCommit, error)
	UpdatedAgentTask(ctx context.Context) (<-chan *ent.AgentTask, error)
	StreamServerTaskLog(ctx context.Context, taskID string) (<-chan string, error)
}
type TagResolver interface {
	ID(ctx context.Context, obj *ent.Tag) (string, error)
	UUID(ctx context.Context, obj *ent.Tag) (string, error)

	Description(ctx context.Context, obj *ent.Tag) ([]*model.TagMap, error)
}
type TeamResolver interface {
	ID(ctx context.Context, obj *ent.Team) (string, error)
}
type UserResolver interface {
	ID(ctx context.Context, obj *ent.User) (string, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "AdhocPlan.AgentTask":
		if e.complexity.AdhocPlan.AgentTask == nil {
			break
		}

		return e.complexity.AdhocPlan.AgentTask(childComplexity), true

	case "AdhocPlan.Build":
		if e.complexity.AdhocPlan.Build == nil {
			break
		}

		return e.complexity.AdhocPlan.Build(childComplexity), true

	case "AdhocPlan.id":
		if e.complexity.AdhocPlan.ID == nil {
			break
		}

		return e.complexity.AdhocPlan.ID(childComplexity), true

	case "AdhocPlan.NextAdhocPlans":
		if e.complexity.AdhocPlan.NextAdhocPlans == nil {
			break
		}

		return e.complexity.AdhocPlan.NextAdhocPlans(childComplexity), true

	case "AdhocPlan.PrevAdhocPlans":
		if e.complexity.AdhocPlan.PrevAdhocPlans == nil {
			break
		}

		return e.complexity.AdhocPlan.PrevAdhocPlans(childComplexity), true

	case "AdhocPlan.Status":
		if e.complexity.AdhocPlan.Status == nil {
			break
		}

		return e.complexity.AdhocPlan.Status(childComplexity), true

	case "AgentConfig.ApiDownloadUrl":
		if e.complexity.AgentConfig.APIDownloadURL == nil {
			break
		}

		return e.complexity.AgentConfig.APIDownloadURL(childComplexity), true

	case "AgentConfig.GrpcServerUri":
		if e.complexity.AgentConfig.GrpcServerURI == nil {
			break
		}

		return e.complexity.AgentConfig.GrpcServerURI(childComplexity), true

	case "AgentStatus.bootTime":
		if e.complexity.AgentStatus.BootTime == nil {
			break
		}

		return e.complexity.AgentStatus.BootTime(childComplexity), true

	case "AgentStatus.Build":
		if e.complexity.AgentStatus.Build == nil {
			break
		}

		return e.complexity.AgentStatus.Build(childComplexity), true

	case "AgentStatus.clientId":
		if e.complexity.AgentStatus.ClientID == nil {
			break
		}

		return e.complexity.AgentStatus.ClientID(childComplexity), true

	case "AgentStatus.freeMem":
		if e.complexity.AgentStatus.FreeMem == nil {
			break
		}

		return e.complexity.AgentStatus.FreeMem(childComplexity), true

	case "AgentStatus.hostID":
		if e.complexity.AgentStatus.HostID == nil {
			break
		}

		return e.complexity.AgentStatus.HostID(childComplexity), true

	case "AgentStatus.hostname":
		if e.complexity.AgentStatus.Hostname == nil {
			break
		}

		return e.complexity.AgentStatus.Hostname(childComplexity), true

	case "AgentStatus.load1":
		if e.complexity.AgentStatus.Load1 == nil {
			break
		}

		return e.complexity.AgentStatus.Load1(childComplexity), true

	case "AgentStatus.load15":
		if e.complexity.AgentStatus.Load15 == nil {
			break
		}

		return e.complexity.AgentStatus.Load15(childComplexity), true

	case "AgentStatus.load5":
		if e.complexity.AgentStatus.Load5 == nil {
			break
		}

		return e.complexity.AgentStatus.Load5(childComplexity), true

	case "AgentStatus.numProcs":
		if e.complexity.AgentStatus.NumProcs == nil {
			break
		}

		return e.complexity.AgentStatus.NumProcs(childComplexity), true

	case "AgentStatus.OS":
		if e.complexity.AgentStatus.Os == nil {
			break
		}

		return e.complexity.AgentStatus.Os(childComplexity), true

	case "AgentStatus.ProvisionedHost":
		if e.complexity.AgentStatus.ProvisionedHost == nil {
			break
		}

		return e.complexity.AgentStatus.ProvisionedHost(childComplexity), true

	case "AgentStatus.ProvisionedNetwork":
		if e.complexity.AgentStatus.ProvisionedNetwork == nil {
			break
		}

		return e.complexity.AgentStatus.ProvisionedNetwork(childComplexity), true

	case "AgentStatus.timestamp":
		if e.complexity.AgentStatus.Timestamp == nil {
			break
		}

		return e.complexity.AgentStatus.Timestamp(childComplexity), true

	case "AgentStatus.totalMem":
		if e.complexity.AgentStatus.TotalMem == nil {
			break
		}

		return e.complexity.AgentStatus.TotalMem(childComplexity), true

	case "AgentStatus.upTime":
		if e.complexity.AgentStatus.UpTime == nil {
			break
		}

		return e.complexity.AgentStatus.UpTime(childComplexity), true

	case "AgentStatus.usedMem":
		if e.complexity.AgentStatus.UsedMem == nil {
			break
		}

		return e.complexity.AgentStatus.UsedMem(childComplexity), true

	case "AgentStatusBatch.agentStatuses":
		if e.complexity.AgentStatusBatch.AgentStatuses == nil {
			break
		}

		return e.complexity.AgentStatusBatch.AgentStatuses(childComplexity), true

	case "AgentStatusBatch.pageInfo":
		if e.complexity.AgentStatusBatch.PageInfo == nil {
			break
		}

		return e.complexity.AgentStatusBatch.PageInfo(childComplexity), true

	case "AgentTask.AdhocPlans":
		if e.complexity.AgentTask.AdhocPlans == nil {
			break
		}

		return e.complexity.AgentTask.AdhocPlans(childComplexity), true

	case "AgentTask.args":
		if e.complexity.AgentTask.Args == nil {
			break
		}

		return e.complexity.AgentTask.Args(childComplexity), true

	case "AgentTask.command":
		if e.complexity.AgentTask.Command == nil {
			break
		}

		return e.complexity.AgentTask.Command(childComplexity), true

	case "AgentTask.errorMessage":
		if e.complexity.AgentTask.ErrorMessage == nil {
			break
		}

		return e.complexity.AgentTask.ErrorMessage(childComplexity), true

	case "AgentTask.id":
		if e.complexity.AgentTask.ID == nil {
			break
		}

		return e.complexity.AgentTask.ID(childComplexity), true

	case "AgentTask.number":
		if e.complexity.AgentTask.Number == nil {
			break
		}

		return e.complexity.AgentTask.Number(childComplexity), true

	case "AgentTask.output":
		if e.complexity.AgentTask.Output == nil {
			break
		}

		return e.complexity.AgentTask.Output(childComplexity), true

	case "AgentTask.ProvisionedHost":
		if e.complexity.AgentTask.ProvisionedHost == nil {
			break
		}

		return e.complexity.AgentTask.ProvisionedHost(childComplexity), true

	case "AgentTask.ProvisioningScheduledStep":
		if e.complexity.AgentTask.ProvisioningScheduledStep == nil {
			break
		}

		return e.complexity.AgentTask.ProvisioningScheduledStep(childComplexity), true

	case "AgentTask.ProvisioningStep":
		if e.complexity.AgentTask.ProvisioningStep == nil {
			break
		}

		return e.complexity.AgentTask.ProvisioningStep(childComplexity), true

	case "AgentTask.state":
		if e.complexity.AgentTask.State == nil {
			break
		}

		return e.complexity.AgentTask.State(childComplexity), true

	case "Ansible.absPath":
		if e.complexity.Ansible.AbsPath == nil {
			break
		}

		return e.complexity.Ansible.AbsPath(childComplexity), true

	case "Ansible.description":
		if e.complexity.Ansible.Description == nil {
			break
		}

		return e.complexity.Ansible.Description(childComplexity), true

	case "Ansible.Environment":
		if e.complexity.Ansible.Environment == nil {
			break
		}

		return e.complexity.Ansible.Environment(childComplexity), true

	case "Ansible.hclId":
		if e.complexity.Ansible.HclID == nil {
			break
		}

		return e.complexity.Ansible.HclID(childComplexity), true

	case "Ansible.id":
		if e.complexity.Ansible.ID == nil {
			break
		}

		return e.complexity.Ansible.ID(childComplexity), true

	case "Ansible.inventory":
		if e.complexity.Ansible.Inventory == nil {
			break
		}

		return e.complexity.Ansible.Inventory(childComplexity), true

	case "Ansible.method":
		if e.complexity.Ansible.Method == nil {
			break
		}

		return e.complexity.Ansible.Method(childComplexity), true

	case "Ansible.name":
		if e.complexity.Ansible.Name == nil {
			break
		}

		return e.complexity.Ansible.Name(childComplexity), true

	case "Ansible.playbookName":
		if e.complexity.Ansible.PlaybookName == nil {
			break
		}

		return e.complexity.Ansible.PlaybookName(childComplexity), true

	case "Ansible.source":
		if e.complexity.Ansible.Source == nil {
			break
		}

		return e.complexity.Ansible.Source(childComplexity), true

	case "Ansible.tags":
		if e.complexity.Ansible.Tags == nil {
			break
		}

		return e.complexity.Ansible.Tags(childComplexity), true

	case "Ansible.Users":
		if e.complexity.Ansible.Users == nil {
			break
		}

		return e.complexity.Ansible.Users(childComplexity), true

	case "AuthConfig.CookieTimeout":
		if e.complexity.AuthConfig.CookieTimeout == nil {
			break
		}

		return e.complexity.AuthConfig.CookieTimeout(childComplexity), true

	case "AuthConfig.GithubId":
		if e.complexity.AuthConfig.GithubID == nil {
			break
		}

		return e.complexity.AuthConfig.GithubID(childComplexity), true

	case "AuthUser.company":
		if e.complexity.AuthUser.Company == nil {
			break
		}

		return e.complexity.AuthUser.Company(childComplexity), true

	case "AuthUser.email":
		if e.complexity.AuthUser.Email == nil {
			break
		}

		return e.complexity.AuthUser.Email(childComplexity), true

	case "AuthUser.firstName":
		if e.complexity.AuthUser.FirstName == nil {
			break
		}

		return e.complexity.AuthUser.FirstName(childComplexity), true

	case "AuthUser.id":
		if e.complexity.AuthUser.ID == nil {
			break
		}

		return e.complexity.AuthUser.ID(childComplexity), true

	case "AuthUser.lastName":
		if e.complexity.AuthUser.LastName == nil {
			break
		}

		return e.complexity.AuthUser.LastName(childComplexity), true

	case "AuthUser.occupation":
		if e.complexity.AuthUser.Occupation == nil {
			break
		}

		return e.complexity.AuthUser.Occupation(childComplexity), true

	case "AuthUser.phone":
		if e.complexity.AuthUser.Phone == nil {
			break
		}

		return e.complexity.AuthUser.Phone(childComplexity), true

	case "AuthUser.provider":
		if e.complexity.AuthUser.Provider == nil {
			break
		}

		return e.complexity.AuthUser.Provider(childComplexity), true

	case "AuthUser.publicKey":
		if e.complexity.AuthUser.PublicKey == nil {
			break
		}

		return e.complexity.AuthUser.PublicKey(childComplexity), true

	case "AuthUser.role":
		if e.complexity.AuthUser.Role == nil {
			break
		}

		return e.complexity.AuthUser.Role(childComplexity), true

	case "AuthUser.ServerTasks":
		if e.complexity.AuthUser.ServerTasks == nil {
			break
		}

		return e.complexity.AuthUser.ServerTasks(childComplexity), true

	case "AuthUser.username":
		if e.complexity.AuthUser.Username == nil {
			break
		}

		return e.complexity.AuthUser.Username(childComplexity), true

	case "Build.AdhocPlans":
		if e.complexity.Build.AdhocPlans == nil {
			break
		}

		return e.complexity.Build.AdhocPlans(childComplexity), true

	case "Build.AgentStatuses":
		if e.complexity.Build.AgentStatuses == nil {
			break
		}

		return e.complexity.Build.AgentStatuses(childComplexity), true

	case "Build.BuildCommits":
		if e.complexity.Build.BuildCommits == nil {
			break
		}

		return e.complexity.Build.BuildCommits(childComplexity), true

	case "Build.Competition":
		if e.complexity.Build.Competition == nil {
			break
		}

		return e.complexity.Build.Competition(childComplexity), true

	case "Build.completedPlan":
		if e.complexity.Build.CompletedPlan == nil {
			break
		}

		return e.complexity.Build.CompletedPlan(childComplexity), true

	case "Build.Environment":
		if e.complexity.Build.Environment == nil {
			break
		}

		return e.complexity.Build.Environment(childComplexity), true

	case "Build.environmentRevision":
		if e.complexity.Build.EnvironmentRevision == nil {
			break
		}

		return e.complexity.Build.EnvironmentRevision(childComplexity), true

	case "Build.id":
		if e.complexity.Build.ID == nil {
			break
		}

		return e.complexity.Build.ID(childComplexity), true

	case "Build.LatestBuildCommit":
		if e.complexity.Build.LatestBuildCommit == nil {
			break
		}

		return e.complexity.Build.LatestBuildCommit(childComplexity), true

	case "Build.Plans":
		if e.complexity.Build.Plans == nil {
			break
		}

		return e.complexity.Build.Plans(childComplexity), true

	case "Build.ProvisionedNetworks":
		if e.complexity.Build.ProvisionedNetworks == nil {
			break
		}

		return e.complexity.Build.ProvisionedNetworks(childComplexity), true

	case "Build.RepoCommit":
		if e.complexity.Build.RepoCommit == nil {
			break
		}

		return e.complexity.Build.RepoCommit(childComplexity), true

	case "Build.revision":
		if e.complexity.Build.Revision == nil {
			break
		}

		return e.complexity.Build.Revision(childComplexity), true

	case "Build.ServerTasks":
		if e.complexity.Build.ServerTasks == nil {
			break
		}

		return e.complexity.Build.ServerTasks(childComplexity), true

	case "Build.Status":
		if e.complexity.Build.Status == nil {
			break
		}

		return e.complexity.Build.Status(childComplexity), true

	case "Build.Teams":
		if e.complexity.Build.Teams == nil {
			break
		}

		return e.complexity.Build.Teams(childComplexity), true

	case "BuildCommit.Build":
		if e.complexity.BuildCommit.Build == nil {
			break
		}

		return e.complexity.BuildCommit.Build(childComplexity), true

	case "BuildCommit.createdAt":
		if e.complexity.BuildCommit.CreatedAt == nil {
			break
		}

		return e.complexity.BuildCommit.CreatedAt(childComplexity), true

	case "BuildCommit.id":
		if e.complexity.BuildCommit.ID == nil {
			break
		}

		return e.complexity.BuildCommit.ID(childComplexity), true

	case "BuildCommit.PlanDiffs":
		if e.complexity.BuildCommit.PlanDiffs == nil {
			break
		}

		return e.complexity.BuildCommit.PlanDiffs(childComplexity), true

	case "BuildCommit.revision":
		if e.complexity.BuildCommit.Revision == nil {
			break
		}

		return e.complexity.BuildCommit.Revision(childComplexity), true

	case "BuildCommit.ServerTasks":
		if e.complexity.BuildCommit.ServerTasks == nil {
			break
		}

		return e.complexity.BuildCommit.ServerTasks(childComplexity), true

	case "BuildCommit.state":
		if e.complexity.BuildCommit.State == nil {
			break
		}

		return e.complexity.BuildCommit.State(childComplexity), true

	case "BuildCommit.type":
		if e.complexity.BuildCommit.Type == nil {
			break
		}

		return e.complexity.BuildCommit.Type(childComplexity), true

	case "BuilderConfig.Builder":
		if e.complexity.BuilderConfig.Builder == nil {
			break
		}

		return e.complexity.BuilderConfig.Builder(childComplexity), true

	case "BuilderConfig.ConfigFile":
		if e.complexity.BuilderConfig.ConfigFile == nil {
			break
		}

		return e.complexity.BuilderConfig.ConfigFile(childComplexity), true

	case "Command.args":
		if e.complexity.Command.Args == nil {
			break
		}

		return e.complexity.Command.Args(childComplexity), true

	case "Command.cooldown":
		if e.complexity.Command.Cooldown == nil {
			break
		}

		return e.complexity.Command.Cooldown(childComplexity), true

	case "Command.description":
		if e.complexity.Command.Description == nil {
			break
		}

		return e.complexity.Command.Description(childComplexity), true

	case "Command.disabled":
		if e.complexity.Command.Disabled == nil {
			break
		}

		return e.complexity.Command.Disabled(childComplexity), true

	case "Command.Environment":
		if e.complexity.Command.Environment == nil {
			break
		}

		return e.complexity.Command.Environment(childComplexity), true

	case "Command.hclId":
		if e.complexity.Command.HclID == nil {
			break
		}

		return e.complexity.Command.HclID(childComplexity), true

	case "Command.id":
		if e.complexity.Command.ID == nil {
			break
		}

		return e.complexity.Command.ID(childComplexity), true

	case "Command.ignoreErrors":
		if e.complexity.Command.IgnoreErrors == nil {
			break
		}

		return e.complexity.Command.IgnoreErrors(childComplexity), true

	case "Command.name":
		if e.complexity.Command.Name == nil {
			break
		}

		return e.complexity.Command.Name(childComplexity), true

	case "Command.program":
		if e.complexity.Command.Program == nil {
			break
		}

		return e.complexity.Command.Program(childComplexity), true

	case "Command.tags":
		if e.complexity.Command.Tags == nil {
			break
		}

		return e.complexity.Command.Tags(childComplexity), true

	case "Command.timeout":
		if e.complexity.Command.Timeout == nil {
			break
		}

		return e.complexity.Command.Timeout(childComplexity), true

	case "Command.Users":
		if e.complexity.Command.Users == nil {
			break
		}

		return e.complexity.Command.Users(childComplexity), true

	case "Command.vars":
		if e.complexity.Command.Vars == nil {
			break
		}

		return e.complexity.Command.Vars(childComplexity), true

	case "Competition.Builds":
		if e.complexity.Competition.Builds == nil {
			break
		}

		return e.complexity.Competition.Builds(childComplexity), true

	case "Competition.config":
		if e.complexity.Competition.Config == nil {
			break
		}

		return e.complexity.Competition.Config(childComplexity), true

	case "Competition.DNS":
		if e.complexity.Competition.DNS == nil {
			break
		}

		return e.complexity.Competition.DNS(childComplexity), true

	case "Competition.Environment":
		if e.complexity.Competition.Environment == nil {
			break
		}

		return e.complexity.Competition.Environment(childComplexity), true

	case "Competition.hclId":
		if e.complexity.Competition.HclID == nil {
			break
		}

		return e.complexity.Competition.HclID(childComplexity), true

	case "Competition.id":
		if e.complexity.Competition.ID == nil {
			break
		}

		return e.complexity.Competition.ID(childComplexity), true

	case "Competition.rootPassword":
		if e.complexity.Competition.RootPassword == nil {
			break
		}

		return e.complexity.Competition.RootPassword(childComplexity), true

	case "Competition.startTime":
		if e.complexity.Competition.StartTime == nil {
			break
		}

		return e.complexity.Competition.StartTime(childComplexity), true

	case "Competition.stopTime":
		if e.complexity.Competition.StopTime == nil {
			break
		}

		return e.complexity.Competition.StopTime(childComplexity), true

	case "Competition.tags":
		if e.complexity.Competition.Tags == nil {
			break
		}

		return e.complexity.Competition.Tags(childComplexity), true

	case "DNS.Competitions":
		if e.complexity.DNS.Competitions == nil {
			break
		}

		return e.complexity.DNS.Competitions(childComplexity), true

	case "DNS.config":
		if e.complexity.DNS.Config == nil {
			break
		}

		return e.complexity.DNS.Config(childComplexity), true

	case "DNS.dnsServers":
		if e.complexity.DNS.DNSServers == nil {
			break
		}

		return e.complexity.DNS.DNSServers(childComplexity), true

	case "DNS.Environments":
		if e.complexity.DNS.Environments == nil {
			break
		}

		return e.complexity.DNS.Environments(childComplexity), true

	case "DNS.hclId":
		if e.complexity.DNS.HclID == nil {
			break
		}

		return e.complexity.DNS.HclID(childComplexity), true

	case "DNS.id":
		if e.complexity.DNS.ID == nil {
			break
		}

		return e.complexity.DNS.ID(childComplexity), true

	case "DNS.ntpServers":
		if e.complexity.DNS.NtpServers == nil {
			break
		}

		return e.complexity.DNS.NtpServers(childComplexity), true

	case "DNS.rootDomain":
		if e.complexity.DNS.RootDomain == nil {
			break
		}

		return e.complexity.DNS.RootDomain(childComplexity), true

	case "DNS.type":
		if e.complexity.DNS.Type == nil {
			break
		}

		return e.complexity.DNS.Type(childComplexity), true

	case "DNSRecord.disabled":
		if e.complexity.DNSRecord.Disabled == nil {
			break
		}

		return e.complexity.DNSRecord.Disabled(childComplexity), true

	case "DNSRecord.Environment":
		if e.complexity.DNSRecord.Environment == nil {
			break
		}

		return e.complexity.DNSRecord.Environment(childComplexity), true

	case "DNSRecord.hclId":
		if e.complexity.DNSRecord.HclID == nil {
			break
		}

		return e.complexity.DNSRecord.HclID(childComplexity), true

	case "DNSRecord.id":
		if e.complexity.DNSRecord.ID == nil {
			break
		}

		return e.complexity.DNSRecord.ID(childComplexity), true

	case "DNSRecord.name":
		if e.complexity.DNSRecord.Name == nil {
			break
		}

		return e.complexity.DNSRecord.Name(childComplexity), true

	case "DNSRecord.tags":
		if e.complexity.DNSRecord.Tags == nil {
			break
		}

		return e.complexity.DNSRecord.Tags(childComplexity), true

	case "DNSRecord.type":
		if e.complexity.DNSRecord.Type == nil {
			break
		}

		return e.complexity.DNSRecord.Type(childComplexity), true

	case "DNSRecord.values":
		if e.complexity.DNSRecord.Values == nil {
			break
		}

		return e.complexity.DNSRecord.Values(childComplexity), true

	case "DNSRecord.vars":
		if e.complexity.DNSRecord.Vars == nil {
			break
		}

		return e.complexity.DNSRecord.Vars(childComplexity), true

	case "DNSRecord.zone":
		if e.complexity.DNSRecord.Zone == nil {
			break
		}

		return e.complexity.DNSRecord.Zone(childComplexity), true

	case "DatabaseConfig.AdminUser":
		if e.complexity.DatabaseConfig.AdminUser == nil {
			break
		}

		return e.complexity.DatabaseConfig.AdminUser(childComplexity), true

	case "DatabaseConfig.PostgresUri":
		if e.complexity.DatabaseConfig.PostgresURI == nil {
			break
		}

		return e.complexity.DatabaseConfig.PostgresURI(childComplexity), true

	case "Disk.Host":
		if e.complexity.Disk.Host == nil {
			break
		}

		return e.complexity.Disk.Host(childComplexity), true

	case "Disk.id":
		if e.complexity.Disk.ID == nil {
			break
		}

		return e.complexity.Disk.ID(childComplexity), true

	case "Disk.size":
		if e.complexity.Disk.Size == nil {
			break
		}

		return e.complexity.Disk.Size(childComplexity), true

	case "Environment.adminCidrs":
		if e.complexity.Environment.AdminCidrs == nil {
			break
		}

		return e.complexity.Environment.AdminCidrs(childComplexity), true

	case "Environment.Ansibles":
		if e.complexity.Environment.Ansibles == nil {
			break
		}

		return e.complexity.Environment.Ansibles(childComplexity), true

	case "Environment.builder":
		if e.complexity.Environment.Builder == nil {
			break
		}

		return e.complexity.Environment.Builder(childComplexity), true

	case "Environment.Builds":
		if e.complexity.Environment.Builds == nil {
			break
		}

		return e.complexity.Environment.Builds(childComplexity), true

	case "Environment.Commands":
		if e.complexity.Environment.Commands == nil {
			break
		}

		return e.complexity.Environment.Commands(childComplexity), true

	case "Environment.competitionId":
		if e.complexity.Environment.CompetitionID == nil {
			break
		}

		return e.complexity.Environment.CompetitionID(childComplexity), true

	case "Environment.Competitions":
		if e.complexity.Environment.Competitions == nil {
			break
		}

		return e.complexity.Environment.Competitions(childComplexity), true

	case "Environment.config":
		if e.complexity.Environment.Config == nil {
			break
		}

		return e.complexity.Environment.Config(childComplexity), true

	case "Environment.DNS":
		if e.complexity.Environment.DNS == nil {
			break
		}

		return e.complexity.Environment.DNS(childComplexity), true

	case "Environment.DNSRecords":
		if e.complexity.Environment.DNSRecords == nil {
			break
		}

		return e.complexity.Environment.DNSRecords(childComplexity), true

	case "Environment.description":
		if e.complexity.Environment.Description == nil {
			break
		}

		return e.complexity.Environment.Description(childComplexity), true

	case "Environment.exposedVdiPorts":
		if e.complexity.Environment.ExposedVdiPorts == nil {
			break
		}

		return e.complexity.Environment.ExposedVdiPorts(childComplexity), true

	case "Environment.FileDeletes":
		if e.complexity.Environment.FileDeletes == nil {
			break
		}

		return e.complexity.Environment.FileDeletes(childComplexity), true

	case "Environment.FileDownloads":
		if e.complexity.Environment.FileDownloads == nil {
			break
		}

		return e.complexity.Environment.FileDownloads(childComplexity), true

	case "Environment.FileExtracts":
		if e.complexity.Environment.FileExtracts == nil {
			break
		}

		return e.complexity.Environment.FileExtracts(childComplexity), true

	case "Environment.Findings":
		if e.complexity.Environment.Findings == nil {
			break
		}

		return e.complexity.Environment.Findings(childComplexity), true

	case "Environment.hclId":
		if e.complexity.Environment.HclID == nil {
			break
		}

		return e.complexity.Environment.HclID(childComplexity), true

	case "Environment.HostDependencies":
		if e.complexity.Environment.HostDependencies == nil {
			break
		}

		return e.complexity.Environment.HostDependencies(childComplexity), true

	case "Environment.Hosts":
		if e.complexity.Environment.Hosts == nil {
			break
		}

		return e.complexity.Environment.Hosts(childComplexity), true

	case "Environment.id":
		if e.complexity.Environment.ID == nil {
			break
		}

		return e.complexity.Environment.ID(childComplexity), true

	case "Environment.Identities":
		if e.complexity.Environment.Identities == nil {
			break
		}

		return e.complexity.Environment.Identities(childComplexity), true

	case "Environment.IncludedNetworks":
		if e.complexity.Environment.IncludedNetworks == nil {
			break
		}

		return e.complexity.Environment.IncludedNetworks(childComplexity), true

	case "Environment.name":
		if e.complexity.Environment.Name == nil {
			break
		}

		return e.complexity.Environment.Name(childComplexity), true

	case "Environment.Networks":
		if e.complexity.Environment.Networks == nil {
			break
		}

		return e.complexity.Environment.Networks(childComplexity), true

	case "Environment.Repositories":
		if e.complexity.Environment.Repositories == nil {
			break
		}

		return e.complexity.Environment.Repositories(childComplexity), true

	case "Environment.revision":
		if e.complexity.Environment.Revision == nil {
			break
		}

		return e.complexity.Environment.Revision(childComplexity), true

	case "Environment.ScheduledSteps":
		if e.complexity.Environment.ScheduledSteps == nil {
			break
		}

		return e.complexity.Environment.ScheduledSteps(childComplexity), true

	case "Environment.Scripts":
		if e.complexity.Environment.Scripts == nil {
			break
		}

		return e.complexity.Environment.Scripts(childComplexity), true

	case "Environment.ServerTasks":
		if e.complexity.Environment.ServerTasks == nil {
			break
		}

		return e.complexity.Environment.ServerTasks(childComplexity), true

	case "Environment.tags":
		if e.complexity.Environment.Tags == nil {
			break
		}

		return e.complexity.Environment.Tags(childComplexity), true

	case "Environment.teamCount":
		if e.complexity.Environment.TeamCount == nil {
			break
		}

		return e.complexity.Environment.TeamCount(childComplexity), true

	case "Environment.Users":
		if e.complexity.Environment.Users == nil {
			break
		}

		return e.complexity.Environment.Users(childComplexity), true

	case "FileDelete.Environment":
		if e.complexity.FileDelete.Environment == nil {
			break
		}

		return e.complexity.FileDelete.Environment(childComplexity), true

	case "FileDelete.hclId":
		if e.complexity.FileDelete.HclID == nil {
			break
		}

		return e.complexity.FileDelete.HclID(childComplexity), true

	case "FileDelete.id":
		if e.complexity.FileDelete.ID == nil {
			break
		}

		return e.complexity.FileDelete.ID(childComplexity), true

	case "FileDelete.path":
		if e.complexity.FileDelete.Path == nil {
			break
		}

		return e.complexity.FileDelete.Path(childComplexity), true

	case "FileDelete.tags":
		if e.complexity.FileDelete.Tags == nil {
			break
		}

		return e.complexity.FileDelete.Tags(childComplexity), true

	case "FileDownload.absPath":
		if e.complexity.FileDownload.AbsPath == nil {
			break
		}

		return e.complexity.FileDownload.AbsPath(childComplexity), true

	case "FileDownload.destination":
		if e.complexity.FileDownload.Destination == nil {
			break
		}

		return e.complexity.FileDownload.Destination(childComplexity), true

	case "FileDownload.disabled":
		if e.complexity.FileDownload.Disabled == nil {
			break
		}

		return e.complexity.FileDownload.Disabled(childComplexity), true

	case "FileDownload.Environment":
		if e.complexity.FileDownload.Environment == nil {
			break
		}

		return e.complexity.FileDownload.Environment(childComplexity), true

	case "FileDownload.hclId":
		if e.complexity.FileDownload.HclID == nil {
			break
		}

		return e.complexity.FileDownload.HclID(childComplexity), true

	case "FileDownload.id":
		if e.complexity.FileDownload.ID == nil {
			break
		}

		return e.complexity.FileDownload.ID(childComplexity), true

	case "FileDownload.md5":
		if e.complexity.FileDownload.Md5 == nil {
			break
		}

		return e.complexity.FileDownload.Md5(childComplexity), true

	case "FileDownload.perms":
		if e.complexity.FileDownload.Perms == nil {
			break
		}

		return e.complexity.FileDownload.Perms(childComplexity), true

	case "FileDownload.source":
		if e.complexity.FileDownload.Source == nil {
			break
		}

		return e.complexity.FileDownload.Source(childComplexity), true

	case "FileDownload.sourceType":
		if e.complexity.FileDownload.SourceType == nil {
			break
		}

		return e.complexity.FileDownload.SourceType(childComplexity), true

	case "FileDownload.tags":
		if e.complexity.FileDownload.Tags == nil {
			break
		}

		return e.complexity.FileDownload.Tags(childComplexity), true

	case "FileDownload.template":
		if e.complexity.FileDownload.Template == nil {
			break
		}

		return e.complexity.FileDownload.Template(childComplexity), true

	case "FileExtract.destination":
		if e.complexity.FileExtract.Destination == nil {
			break
		}

		return e.complexity.FileExtract.Destination(childComplexity), true

	case "FileExtract.Environment":
		if e.complexity.FileExtract.Environment == nil {
			break
		}

		return e.complexity.FileExtract.Environment(childComplexity), true

	case "FileExtract.hclId":
		if e.complexity.FileExtract.HclID == nil {
			break
		}

		return e.complexity.FileExtract.HclID(childComplexity), true

	case "FileExtract.id":
		if e.complexity.FileExtract.ID == nil {
			break
		}

		return e.complexity.FileExtract.ID(childComplexity), true

	case "FileExtract.source":
		if e.complexity.FileExtract.Source == nil {
			break
		}

		return e.complexity.FileExtract.Source(childComplexity), true

	case "FileExtract.tags":
		if e.complexity.FileExtract.Tags == nil {
			break
		}

		return e.complexity.FileExtract.Tags(childComplexity), true

	case "FileExtract.type":
		if e.complexity.FileExtract.Type == nil {
			break
		}

		return e.complexity.FileExtract.Type(childComplexity), true

	case "Finding.description":
		if e.complexity.Finding.Description == nil {
			break
		}

		return e.complexity.Finding.Description(childComplexity), true

	case "Finding.difficulty":
		if e.complexity.Finding.Difficulty == nil {
			break
		}

		return e.complexity.Finding.Difficulty(childComplexity), true

	case "Finding.Environment":
		if e.complexity.Finding.Environment == nil {
			break
		}

		return e.complexity.Finding.Environment(childComplexity), true

	case "Finding.Host":
		if e.complexity.Finding.Host == nil {
			break
		}

		return e.complexity.Finding.Host(childComplexity), true

	case "Finding.id":
		if e.complexity.Finding.ID == nil {
			break
		}

		return e.complexity.Finding.ID(childComplexity), true

	case "Finding.name":
		if e.complexity.Finding.Name == nil {
			break
		}

		return e.complexity.Finding.Name(childComplexity), true

	case "Finding.Script":
		if e.complexity.Finding.Script == nil {
			break
		}

		return e.complexity.Finding.Script(childComplexity), true

	case "Finding.severity":
		if e.complexity.Finding.Severity == nil {
			break
		}

		return e.complexity.Finding.Severity(childComplexity), true

	case "Finding.tags":
		if e.complexity.Finding.Tags == nil {
			break
		}

		return e.complexity.Finding.Tags(childComplexity), true

	case "Finding.Users":
		if e.complexity.Finding.Users == nil {
			break
		}

		return e.complexity.Finding.Users(childComplexity), true

	case "GinFileMiddleware.accessed":
		if e.complexity.GinFileMiddleware.Accessed == nil {
			break
		}

		return e.complexity.GinFileMiddleware.Accessed(childComplexity), true

	case "GinFileMiddleware.filePath":
		if e.complexity.GinFileMiddleware.FilePath == nil {
			break
		}

		return e.complexity.GinFileMiddleware.FilePath(childComplexity), true

	case "GinFileMiddleware.id":
		if e.complexity.GinFileMiddleware.ID == nil {
			break
		}

		return e.complexity.GinFileMiddleware.ID(childComplexity), true

	case "GinFileMiddleware.ProvisionedHost":
		if e.complexity.GinFileMiddleware.ProvisionedHost == nil {
			break
		}

		return e.complexity.GinFileMiddleware.ProvisionedHost(childComplexity), true

	case "GinFileMiddleware.ProvisioningScheduledStep":
		if e.complexity.GinFileMiddleware.ProvisioningScheduledStep == nil {
			break
		}

		return e.complexity.GinFileMiddleware.ProvisioningScheduledStep(childComplexity), true

	case "GinFileMiddleware.ProvisioningStep":
		if e.complexity.GinFileMiddleware.ProvisioningStep == nil {
			break
		}

		return e.complexity.GinFileMiddleware.ProvisioningStep(childComplexity), true

	case "GinFileMiddleware.urlId":
		if e.complexity.GinFileMiddleware.URLID == nil {
			break
		}

		return e.complexity.GinFileMiddleware.URLID(childComplexity), true

	case "GraphqlConfig.Hostname":
		if e.complexity.GraphqlConfig.Hostname == nil {
			break
		}

		return e.complexity.GraphqlConfig.Hostname(childComplexity), true

	case "GraphqlConfig.RedisServerUri":
		if e.complexity.GraphqlConfig.RedisServerURI == nil {
			break
		}

		return e.complexity.GraphqlConfig.RedisServerURI(childComplexity), true

	case "Host.allowMacChanges":
		if e.complexity.Host.AllowMACChanges == nil {
			break
		}

		return e.complexity.Host.AllowMACChanges(childComplexity), true

	case "Host.DependOnHostDependencies":
		if e.complexity.Host.DependOnHostDependencies == nil {
			break
		}

		return e.complexity.Host.DependOnHostDependencies(childComplexity), true

	case "Host.description":
		if e.complexity.Host.Description == nil {
			break
		}

		return e.complexity.Host.Description(childComplexity), true

	case "Host.Disk":
		if e.complexity.Host.Disk == nil {
			break
		}

		return e.complexity.Host.Disk(childComplexity), true

	case "Host.Environment":
		if e.complexity.Host.Environment == nil {
			break
		}

		return e.complexity.Host.Environment(childComplexity), true

	case "Host.exposedTcpPorts":
		if e.complexity.Host.ExposedTCPPorts == nil {
			break
		}

		return e.complexity.Host.ExposedTCPPorts(childComplexity), true

	case "Host.exposedUdpPorts":
		if e.complexity.Host.ExposedUDPPorts == nil {
			break
		}

		return e.complexity.Host.ExposedUDPPorts(childComplexity), true

	case "Host.hclId":
		if e.complexity.Host.HclID == nil {
			break
		}

		return e.complexity.Host.HclID(childComplexity), true

	case "Host.hostname":
		if e.complexity.Host.Hostname == nil {
			break
		}

		return e.complexity.Host.Hostname(childComplexity), true

	case "Host.id":
		if e.complexity.Host.ID == nil {
			break
		}

		return e.complexity.Host.ID(childComplexity), true

	case "Host.IncludedNetworks":
		if e.complexity.Host.IncludedNetworks == nil {
			break
		}

		return e.complexity.Host.IncludedNetworks(childComplexity), true

	case "Host.instanceSize":
		if e.complexity.Host.InstanceSize == nil {
			break
		}

		return e.complexity.Host.InstanceSize(childComplexity), true

	case "Host.lastOctet":
		if e.complexity.Host.LastOctet == nil {
			break
		}

		return e.complexity.Host.LastOctet(childComplexity), true

	case "Host.OS":
		if e.complexity.Host.OS == nil {
			break
		}

		return e.complexity.Host.OS(childComplexity), true

	case "Host.overridePassword":
		if e.complexity.Host.OverridePassword == nil {
			break
		}

		return e.complexity.Host.OverridePassword(childComplexity), true

	case "Host.provisionSteps":
		if e.complexity.Host.ProvisionSteps == nil {
			break
		}

		return e.complexity.Host.ProvisionSteps(childComplexity), true

	case "Host.RequiredByHostDependencies":
		if e.complexity.Host.RequiredByHostDependencies == nil {
			break
		}

		return e.complexity.Host.RequiredByHostDependencies(childComplexity), true

	case "Host.tags":
		if e.complexity.Host.Tags == nil {
			break
		}

		return e.complexity.Host.Tags(childComplexity), true

	case "Host.userGroups":
		if e.complexity.Host.UserGroups == nil {
			break
		}

		return e.complexity.Host.UserGroups(childComplexity), true

	case "Host.Users":
		if e.complexity.Host.Users == nil {
			break
		}

		return e.complexity.Host.Users(childComplexity), true

	case "Host.vars":
		if e.complexity.Host.Vars == nil {
			break
		}

		return e.complexity.Host.Vars(childComplexity), true

	case "HostDependency.DependOnHost":
		if e.complexity.HostDependency.DependOnHost == nil {
			break
		}

		return e.complexity.HostDependency.DependOnHost(childComplexity), true

	case "HostDependency.DependOnNetwork":
		if e.complexity.HostDependency.DependOnNetwork == nil {
			break
		}

		return e.complexity.HostDependency.DependOnNetwork(childComplexity), true

	case "HostDependency.Environment":
		if e.complexity.HostDependency.Environment == nil {
			break
		}

		return e.complexity.HostDependency.Environment(childComplexity), true

	case "HostDependency.hostId":
		if e.complexity.HostDependency.HostID == nil {
			break
		}

		return e.complexity.HostDependency.HostID(childComplexity), true

	case "HostDependency.id":
		if e.complexity.HostDependency.ID == nil {
			break
		}

		return e.complexity.HostDependency.ID(childComplexity), true

	case "HostDependency.networkId":
		if e.complexity.HostDependency.NetworkID == nil {
			break
		}

		return e.complexity.HostDependency.NetworkID(childComplexity), true

	case "HostDependency.RequiredBy":
		if e.complexity.HostDependency.RequiredBy == nil {
			break
		}

		return e.complexity.HostDependency.RequiredBy(childComplexity), true

	case "Identity.avatarFile":
		if e.complexity.Identity.AvatarFile == nil {
			break
		}

		return e.complexity.Identity.AvatarFile(childComplexity), true

	case "Identity.description":
		if e.complexity.Identity.Description == nil {
			break
		}

		return e.complexity.Identity.Description(childComplexity), true

	case "Identity.email":
		if e.complexity.Identity.Email == nil {
			break
		}

		return e.complexity.Identity.Email(childComplexity), true

	case "Identity.Environment":
		if e.complexity.Identity.Environment == nil {
			break
		}

		return e.complexity.Identity.Environment(childComplexity), true

	case "Identity.firstName":
		if e.complexity.Identity.FirstName == nil {
			break
		}

		return e.complexity.Identity.FirstName(childComplexity), true

	case "Identity.hclid":
		if e.complexity.Identity.HclID == nil {
			break
		}

		return e.complexity.Identity.HclID(childComplexity), true

	case "Identity.id":
		if e.complexity.Identity.ID == nil {
			break
		}

		return e.complexity.Identity.ID(childComplexity), true

	case "Identity.lastName":
		if e.complexity.Identity.LastName == nil {
			break
		}

		return e.complexity.Identity.LastName(childComplexity), true

	case "Identity.password":
		if e.complexity.Identity.Password == nil {
			break
		}

		return e.complexity.Identity.Password(childComplexity), true

	case "Identity.tags":
		if e.complexity.Identity.Tags == nil {
			break
		}

		return e.complexity.Identity.Tags(childComplexity), true

	case "Identity.vars":
		if e.complexity.Identity.Vars == nil {
			break
		}

		return e.complexity.Identity.Vars(childComplexity), true

	case "IncludedNetwork.Environments":
		if e.complexity.IncludedNetwork.Environments == nil {
			break
		}

		return e.complexity.IncludedNetwork.Environments(childComplexity), true

	case "IncludedNetwork.Hosts":
		if e.complexity.IncludedNetwork.Hosts == nil {
			break
		}

		return e.complexity.IncludedNetwork.Hosts(childComplexity), true

	case "IncludedNetwork.id":
		if e.complexity.IncludedNetwork.ID == nil {
			break
		}

		return e.complexity.IncludedNetwork.ID(childComplexity), true

	case "IncludedNetwork.includedHosts":
		if e.complexity.IncludedNetwork.IncludedHosts == nil {
			break
		}

		return e.complexity.IncludedNetwork.IncludedHosts(childComplexity), true

	case "IncludedNetwork.name":
		if e.complexity.IncludedNetwork.Name == nil {
			break
		}

		return e.complexity.IncludedNetwork.Name(childComplexity), true

	case "IncludedNetwork.Network":
		if e.complexity.IncludedNetwork.Network == nil {
			break
		}

		return e.complexity.IncludedNetwork.Network(childComplexity), true

	case "IncludedNetwork.Tags":
		if e.complexity.IncludedNetwork.Tags == nil {
			break
		}

		return e.complexity.IncludedNetwork.Tags(childComplexity), true

	case "LaForgePageInfo.nextOffset":
		if e.complexity.LaForgePageInfo.NextOffset == nil {
			break
		}

		return e.complexity.LaForgePageInfo.NextOffset(childComplexity), true

	case "LaForgePageInfo.total":
		if e.complexity.LaForgePageInfo.Total == nil {
			break
		}

		return e.complexity.LaForgePageInfo.Total(childComplexity), true

	case "Mutation.approveCommit":
		if e.complexity.Mutation.ApproveCommit == nil {
			break
		}

		args, err := ec.field_Mutation_approveCommit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ApproveCommit(childComplexity, args["commitUUID"].(string)), true

	case "Mutation.cancelBuild":
		if e.complexity.Mutation.CancelBuild == nil {
			break
		}

		args, err := ec.field_Mutation_cancelBuild_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelBuild(childComplexity, args["buildUUID"].(string)), true

	case "Mutation.cancelCommit":
		if e.complexity.Mutation.CancelCommit == nil {
			break
		}

		args, err := ec.field_Mutation_cancelCommit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CancelCommit(childComplexity, args["commitUUID"].(string)), true

	case "Mutation.createAgentTasks":
		if e.complexity.Mutation.CreateAgentTasks == nil {
			break
		}

		args, err := ec.field_Mutation_createAgentTasks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateAgentTasks(childComplexity, args["hostHCLID"].(string), args["command"].(model.AgentCommand), args["buildUUID"].(string), args["args"].([]string), args["teams"].([]int)), true

	case "Mutation.createBatchAgentTasks":
		if e.complexity.Mutation.CreateBatchAgentTasks == nil {
			break
		}

		args, err := ec.field_Mutation_createBatchAgentTasks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateBatchAgentTasks(childComplexity, args["proHostUUIDs"].([]string), args["command"].(model.AgentCommand), args["args"].([]string)), true

	case "Mutation.createBuild":
		if e.complexity.Mutation.CreateBuild == nil {
			break
		}

		args, err := ec.field_Mutation_createBuild_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateBuild(childComplexity, args["envUUID"].(string), args["renderFiles"].(bool)), true

	case "Mutation.createEnviromentFromRepo":
		if e.complexity.Mutation.CreateEnviromentFromRepo == nil {
			break
		}

		args, err := ec.field_Mutation_createEnviromentFromRepo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateEnviromentFromRepo(childComplexity, args["repoURL"].(string), args["branchName"].(string), args["envFilePath"].(string)), true

	case "Mutation.createTask":
		if e.complexity.Mutation.CreateTask == nil {
			break
		}

		args, err := ec.field_Mutation_createTask_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTask(childComplexity, args["proHostUUID"].(string), args["command"].(model.AgentCommand), args["args"].(string)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["username"].(string), args["password"].(string), args["role"].(model.RoleLevel), args["provider"].(model.ProviderType)), true

	case "Mutation.deleteBuild":
		if e.complexity.Mutation.DeleteBuild == nil {
			break
		}

		args, err := ec.field_Mutation_deleteBuild_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteBuild(childComplexity, args["buildUUID"].(string)), true

	case "Mutation.deleteUser":
		if e.complexity.Mutation.DeleteUser == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUser(childComplexity, args["userUUID"].(string)), true

	case "Mutation.dumpBuild":
		if e.complexity.Mutation.DumpBuild == nil {
			break
		}

		args, err := ec.field_Mutation_dumpBuild_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DumpBuild(childComplexity, args["buildUUID"].(string)), true

	case "Mutation.executePlan":
		if e.complexity.Mutation.ExecutePlan == nil {
			break
		}

		args, err := ec.field_Mutation_executePlan_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ExecutePlan(childComplexity, args["buildUUID"].(string)), true

	case "Mutation.loadEnvironment":
		if e.complexity.Mutation.LoadEnvironment == nil {
			break
		}

		args, err := ec.field_Mutation_loadEnvironment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.LoadEnvironment(childComplexity, args["envFilePath"].(string)), true

	case "Mutation.modifyAdminPassword":
		if e.complexity.Mutation.ModifyAdminPassword == nil {
			break
		}

		args, err := ec.field_Mutation_modifyAdminPassword_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ModifyAdminPassword(childComplexity, args["userID"].(string), args["newPassword"].(string)), true

	case "Mutation.modifyAdminUserInfo":
		if e.complexity.Mutation.ModifyAdminUserInfo == nil {
			break
		}

		args, err := ec.field_Mutation_modifyAdminUserInfo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ModifyAdminUserInfo(childComplexity, args["userID"].(string), args["username"].(*string), args["firstName"].(*string), args["lastName"].(*string), args["email"].(*string), args["phone"].(*string), args["company"].(*string), args["occupation"].(*string), args["role"].(*model.RoleLevel), args["provider"].(*model.ProviderType)), true

	case "Mutation.modifySelfPassword":
		if e.complexity.Mutation.ModifySelfPassword == nil {
			break
		}

		args, err := ec.field_Mutation_modifySelfPassword_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ModifySelfPassword(childComplexity, args["currentPassword"].(string), args["newPassword"].(string)), true

	case "Mutation.modifySelfUserInfo":
		if e.complexity.Mutation.ModifySelfUserInfo == nil {
			break
		}

		args, err := ec.field_Mutation_modifySelfUserInfo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ModifySelfUserInfo(childComplexity, args["firstName"].(*string), args["lastName"].(*string), args["email"].(*string), args["phone"].(*string), args["company"].(*string), args["occupation"].(*string)), true

	case "Mutation.nukeBackend":
		if e.complexity.Mutation.NukeBackend == nil {
			break
		}

		return e.complexity.Mutation.NukeBackend(childComplexity), true

	case "Mutation.rebuild":
		if e.complexity.Mutation.Rebuild == nil {
			break
		}

		args, err := ec.field_Mutation_rebuild_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Rebuild(childComplexity, args["rootPlans"].([]*string)), true

	case "Mutation.updateEnviromentViaPull":
		if e.complexity.Mutation.UpdateEnviromentViaPull == nil {
			break
		}

		args, err := ec.field_Mutation_updateEnviromentViaPull_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEnviromentViaPull(childComplexity, args["envUUID"].(string)), true

	case "Network.cidr":
		if e.complexity.Network.Cidr == nil {
			break
		}

		return e.complexity.Network.Cidr(childComplexity), true

	case "Network.Environment":
		if e.complexity.Network.Environment == nil {
			break
		}

		return e.complexity.Network.Environment(childComplexity), true

	case "Network.hclId":
		if e.complexity.Network.HclID == nil {
			break
		}

		return e.complexity.Network.HclID(childComplexity), true

	case "Network.HostDependencies":
		if e.complexity.Network.HostDependencies == nil {
			break
		}

		return e.complexity.Network.HostDependencies(childComplexity), true

	case "Network.id":
		if e.complexity.Network.ID == nil {
			break
		}

		return e.complexity.Network.ID(childComplexity), true

	case "Network.IncludedNetworks":
		if e.complexity.Network.IncludedNetworks == nil {
			break
		}

		return e.complexity.Network.IncludedNetworks(childComplexity), true

	case "Network.name":
		if e.complexity.Network.Name == nil {
			break
		}

		return e.complexity.Network.Name(childComplexity), true

	case "Network.tags":
		if e.complexity.Network.Tags == nil {
			break
		}

		return e.complexity.Network.Tags(childComplexity), true

	case "Network.vars":
		if e.complexity.Network.Vars == nil {
			break
		}

		return e.complexity.Network.Vars(childComplexity), true

	case "Network.vdiVisible":
		if e.complexity.Network.VdiVisible == nil {
			break
		}

		return e.complexity.Network.VdiVisible(childComplexity), true

	case "Plan.Build":
		if e.complexity.Plan.Build == nil {
			break
		}

		return e.complexity.Plan.Build(childComplexity), true

	case "Plan.id":
		if e.complexity.Plan.ID == nil {
			break
		}

		return e.complexity.Plan.ID(childComplexity), true

	case "Plan.NextPlans":
		if e.complexity.Plan.NextPlans == nil {
			break
		}

		return e.complexity.Plan.NextPlans(childComplexity), true

	case "Plan.PlanDiffs":
		if e.complexity.Plan.PlanDiffs == nil {
			break
		}

		return e.complexity.Plan.PlanDiffs(childComplexity), true

	case "Plan.PrevPlans":
		if e.complexity.Plan.PrevPlans == nil {
			break
		}

		return e.complexity.Plan.PrevPlans(childComplexity), true

	case "Plan.ProvisionedHost":
		if e.complexity.Plan.ProvisionedHost == nil {
			break
		}

		return e.complexity.Plan.ProvisionedHost(childComplexity), true

	case "Plan.ProvisionedNetwork":
		if e.complexity.Plan.ProvisionedNetwork == nil {
			break
		}

		return e.complexity.Plan.ProvisionedNetwork(childComplexity), true

	case "Plan.ProvisioningScheduledStep":
		if e.complexity.Plan.ProvisioningScheduledStep == nil {
			break
		}

		return e.complexity.Plan.ProvisioningScheduledStep(childComplexity), true

	case "Plan.ProvisioningStep":
		if e.complexity.Plan.ProvisioningStep == nil {
			break
		}

		return e.complexity.Plan.ProvisioningStep(childComplexity), true

	case "Plan.Status":
		if e.complexity.Plan.Status == nil {
			break
		}

		return e.complexity.Plan.Status(childComplexity), true

	case "Plan.stepNumber":
		if e.complexity.Plan.StepNumber == nil {
			break
		}

		return e.complexity.Plan.StepNumber(childComplexity), true

	case "Plan.Team":
		if e.complexity.Plan.Team == nil {
			break
		}

		return e.complexity.Plan.Team(childComplexity), true

	case "Plan.type":
		if e.complexity.Plan.Type == nil {
			break
		}

		return e.complexity.Plan.Type(childComplexity), true

	case "PlanCounts.awaiting":
		if e.complexity.PlanCounts.Awaiting == nil {
			break
		}

		return e.complexity.PlanCounts.Awaiting(childComplexity), true

	case "PlanCounts.cancelled":
		if e.complexity.PlanCounts.Cancelled == nil {
			break
		}

		return e.complexity.PlanCounts.Cancelled(childComplexity), true

	case "PlanCounts.complete":
		if e.complexity.PlanCounts.Complete == nil {
			break
		}

		return e.complexity.PlanCounts.Complete(childComplexity), true

	case "PlanCounts.deleteInProgress":
		if e.complexity.PlanCounts.DeleteInProgress == nil {
			break
		}

		return e.complexity.PlanCounts.DeleteInProgress(childComplexity), true

	case "PlanCounts.deleted":
		if e.complexity.PlanCounts.Deleted == nil {
			break
		}

		return e.complexity.PlanCounts.Deleted(childComplexity), true

	case "PlanCounts.failed":
		if e.complexity.PlanCounts.Failed == nil {
			break
		}

		return e.complexity.PlanCounts.Failed(childComplexity), true

	case "PlanCounts.inProgress":
		if e.complexity.PlanCounts.InProgress == nil {
			break
		}

		return e.complexity.PlanCounts.InProgress(childComplexity), true

	case "PlanCounts.parentAwaiting":
		if e.complexity.PlanCounts.ParentAwaiting == nil {
			break
		}

		return e.complexity.PlanCounts.ParentAwaiting(childComplexity), true

	case "PlanCounts.planning":
		if e.complexity.PlanCounts.Planning == nil {
			break
		}

		return e.complexity.PlanCounts.Planning(childComplexity), true

	case "PlanCounts.tainted":
		if e.complexity.PlanCounts.Tainted == nil {
			break
		}

		return e.complexity.PlanCounts.Tainted(childComplexity), true

	case "PlanCounts.toDelete":
		if e.complexity.PlanCounts.ToDelete == nil {
			break
		}

		return e.complexity.PlanCounts.ToDelete(childComplexity), true

	case "PlanCounts.toRebuild":
		if e.complexity.PlanCounts.ToRebuild == nil {
			break
		}

		return e.complexity.PlanCounts.ToRebuild(childComplexity), true

	case "PlanCounts.undefined":
		if e.complexity.PlanCounts.Undefined == nil {
			break
		}

		return e.complexity.PlanCounts.Undefined(childComplexity), true

	case "PlanDiff.BuildCommit":
		if e.complexity.PlanDiff.BuildCommit == nil {
			break
		}

		return e.complexity.PlanDiff.BuildCommit(childComplexity), true

	case "PlanDiff.id":
		if e.complexity.PlanDiff.ID == nil {
			break
		}

		return e.complexity.PlanDiff.ID(childComplexity), true

	case "PlanDiff.newState":
		if e.complexity.PlanDiff.NewState == nil {
			break
		}

		return e.complexity.PlanDiff.NewState(childComplexity), true

	case "PlanDiff.Plan":
		if e.complexity.PlanDiff.Plan == nil {
			break
		}

		return e.complexity.PlanDiff.Plan(childComplexity), true

	case "PlanDiff.revision":
		if e.complexity.PlanDiff.Revision == nil {
			break
		}

		return e.complexity.PlanDiff.Revision(childComplexity), true

	case "ProvisionedHost.addonType":
		if e.complexity.ProvisionedHost.AddonType == nil {
			break
		}

		return e.complexity.ProvisionedHost.AddonType(childComplexity), true

	case "ProvisionedHost.AgentStatuses":
		if e.complexity.ProvisionedHost.AgentStatuses == nil {
			break
		}

		return e.complexity.ProvisionedHost.AgentStatuses(childComplexity), true

	case "ProvisionedHost.AgentTasks":
		if e.complexity.ProvisionedHost.AgentTasks == nil {
			break
		}

		return e.complexity.ProvisionedHost.AgentTasks(childComplexity), true

	case "ProvisionedHost.Build":
		if e.complexity.ProvisionedHost.Build == nil {
			break
		}

		return e.complexity.ProvisionedHost.Build(childComplexity), true

	case "ProvisionedHost.EndStepPlan":
		if e.complexity.ProvisionedHost.EndStepPlan == nil {
			break
		}

		return e.complexity.ProvisionedHost.EndStepPlan(childComplexity), true

	case "ProvisionedHost.GinFileMiddleware":
		if e.complexity.ProvisionedHost.GinFileMiddleware == nil {
			break
		}

		return e.complexity.ProvisionedHost.GinFileMiddleware(childComplexity), true

	case "ProvisionedHost.Host":
		if e.complexity.ProvisionedHost.Host == nil {
			break
		}

		return e.complexity.ProvisionedHost.Host(childComplexity), true

	case "ProvisionedHost.id":
		if e.complexity.ProvisionedHost.ID == nil {
			break
		}

		return e.complexity.ProvisionedHost.ID(childComplexity), true

	case "ProvisionedHost.Plan":
		if e.complexity.ProvisionedHost.Plan == nil {
			break
		}

		return e.complexity.ProvisionedHost.Plan(childComplexity), true

	case "ProvisionedHost.ProvisionedNetwork":
		if e.complexity.ProvisionedHost.ProvisionedNetwork == nil {
			break
		}

		return e.complexity.ProvisionedHost.ProvisionedNetwork(childComplexity), true

	case "ProvisionedHost.ProvisioningScheduledSteps":
		if e.complexity.ProvisionedHost.ProvisioningScheduledSteps == nil {
			break
		}

		return e.complexity.ProvisionedHost.ProvisioningScheduledSteps(childComplexity), true

	case "ProvisionedHost.ProvisioningSteps":
		if e.complexity.ProvisionedHost.ProvisioningSteps == nil {
			break
		}

		return e.complexity.ProvisionedHost.ProvisioningSteps(childComplexity), true

	case "ProvisionedHost.Status":
		if e.complexity.ProvisionedHost.Status == nil {
			break
		}

		return e.complexity.ProvisionedHost.Status(childComplexity), true

	case "ProvisionedHost.subnetIp":
		if e.complexity.ProvisionedHost.SubnetIP == nil {
			break
		}

		return e.complexity.ProvisionedHost.SubnetIP(childComplexity), true

	case "ProvisionedHost.vars":
		if e.complexity.ProvisionedHost.Vars == nil {
			break
		}

		return e.complexity.ProvisionedHost.Vars(childComplexity), true

	case "ProvisionedNetwork.Build":
		if e.complexity.ProvisionedNetwork.Build == nil {
			break
		}

		return e.complexity.ProvisionedNetwork.Build(childComplexity), true

	case "ProvisionedNetwork.cidr":
		if e.complexity.ProvisionedNetwork.Cidr == nil {
			break
		}

		return e.complexity.ProvisionedNetwork.Cidr(childComplexity), true

	case "ProvisionedNetwork.id":
		if e.complexity.ProvisionedNetwork.ID == nil {
			break
		}

		return e.complexity.ProvisionedNetwork.ID(childComplexity), true

	case "ProvisionedNetwork.name":
		if e.complexity.ProvisionedNetwork.Name == nil {
			break
		}

		return e.complexity.ProvisionedNetwork.Name(childComplexity), true

	case "ProvisionedNetwork.Network":
		if e.complexity.ProvisionedNetwork.Network == nil {
			break
		}

		return e.complexity.ProvisionedNetwork.Network(childComplexity), true

	case "ProvisionedNetwork.Plan":
		if e.complexity.ProvisionedNetwork.Plan == nil {
			break
		}

		return e.complexity.ProvisionedNetwork.Plan(childComplexity), true

	case "ProvisionedNetwork.ProvisionedHosts":
		if e.complexity.ProvisionedNetwork.ProvisionedHosts == nil {
			break
		}

		return e.complexity.ProvisionedNetwork.ProvisionedHosts(childComplexity), true

	case "ProvisionedNetwork.Status":
		if e.complexity.ProvisionedNetwork.Status == nil {
			break
		}

		return e.complexity.ProvisionedNetwork.Status(childComplexity), true

	case "ProvisionedNetwork.Team":
		if e.complexity.ProvisionedNetwork.Team == nil {
			break
		}

		return e.complexity.ProvisionedNetwork.Team(childComplexity), true

	case "ProvisionedNetwork.vars":
		if e.complexity.ProvisionedNetwork.Vars == nil {
			break
		}

		return e.complexity.ProvisionedNetwork.Vars(childComplexity), true

	case "ProvisioningScheduledStep.AgentTasks":
		if e.complexity.ProvisioningScheduledStep.AgentTasks == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.AgentTasks(childComplexity), true

	case "ProvisioningScheduledStep.Ansible":
		if e.complexity.ProvisioningScheduledStep.Ansible == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.Ansible(childComplexity), true

	case "ProvisioningScheduledStep.Command":
		if e.complexity.ProvisioningScheduledStep.Command == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.Command(childComplexity), true

	case "ProvisioningScheduledStep.DNSRecord":
		if e.complexity.ProvisioningScheduledStep.DNSRecord == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.DNSRecord(childComplexity), true

	case "ProvisioningScheduledStep.FileDelete":
		if e.complexity.ProvisioningScheduledStep.FileDelete == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.FileDelete(childComplexity), true

	case "ProvisioningScheduledStep.FileDownload":
		if e.complexity.ProvisioningScheduledStep.FileDownload == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.FileDownload(childComplexity), true

	case "ProvisioningScheduledStep.FileExtract":
		if e.complexity.ProvisioningScheduledStep.FileExtract == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.FileExtract(childComplexity), true

	case "ProvisioningScheduledStep.GinFileMiddleware":
		if e.complexity.ProvisioningScheduledStep.GinFileMiddleware == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.GinFileMiddleware(childComplexity), true

	case "ProvisioningScheduledStep.id":
		if e.complexity.ProvisioningScheduledStep.ID == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.ID(childComplexity), true

	case "ProvisioningScheduledStep.Plan":
		if e.complexity.ProvisioningScheduledStep.Plan == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.Plan(childComplexity), true

	case "ProvisioningScheduledStep.ProvisionedHost":
		if e.complexity.ProvisioningScheduledStep.ProvisionedHost == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.ProvisionedHost(childComplexity), true

	case "ProvisioningScheduledStep.runTime":
		if e.complexity.ProvisioningScheduledStep.RunTime == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.RunTime(childComplexity), true

	case "ProvisioningScheduledStep.ScheduledStep":
		if e.complexity.ProvisioningScheduledStep.ScheduledStep == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.ScheduledStep(childComplexity), true

	case "ProvisioningScheduledStep.Script":
		if e.complexity.ProvisioningScheduledStep.Script == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.Script(childComplexity), true

	case "ProvisioningScheduledStep.Status":
		if e.complexity.ProvisioningScheduledStep.Status == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.Status(childComplexity), true

	case "ProvisioningScheduledStep.type":
		if e.complexity.ProvisioningScheduledStep.Type == nil {
			break
		}

		return e.complexity.ProvisioningScheduledStep.Type(childComplexity), true

	case "ProvisioningStep.AgentTasks":
		if e.complexity.ProvisioningStep.AgentTasks == nil {
			break
		}

		return e.complexity.ProvisioningStep.AgentTasks(childComplexity), true

	case "ProvisioningStep.Ansible":
		if e.complexity.ProvisioningStep.Ansible == nil {
			break
		}

		return e.complexity.ProvisioningStep.Ansible(childComplexity), true

	case "ProvisioningStep.Command":
		if e.complexity.ProvisioningStep.Command == nil {
			break
		}

		return e.complexity.ProvisioningStep.Command(childComplexity), true

	case "ProvisioningStep.DNSRecord":
		if e.complexity.ProvisioningStep.DNSRecord == nil {
			break
		}

		return e.complexity.ProvisioningStep.DNSRecord(childComplexity), true

	case "ProvisioningStep.FileDelete":
		if e.complexity.ProvisioningStep.FileDelete == nil {
			break
		}

		return e.complexity.ProvisioningStep.FileDelete(childComplexity), true

	case "ProvisioningStep.FileDownload":
		if e.complexity.ProvisioningStep.FileDownload == nil {
			break
		}

		return e.complexity.ProvisioningStep.FileDownload(childComplexity), true

	case "ProvisioningStep.FileExtract":
		if e.complexity.ProvisioningStep.FileExtract == nil {
			break
		}

		return e.complexity.ProvisioningStep.FileExtract(childComplexity), true

	case "ProvisioningStep.GinFileMiddleware":
		if e.complexity.ProvisioningStep.GinFileMiddleware == nil {
			break
		}

		return e.complexity.ProvisioningStep.GinFileMiddleware(childComplexity), true

	case "ProvisioningStep.id":
		if e.complexity.ProvisioningStep.ID == nil {
			break
		}

		return e.complexity.ProvisioningStep.ID(childComplexity), true

	case "ProvisioningStep.Plan":
		if e.complexity.ProvisioningStep.Plan == nil {
			break
		}

		return e.complexity.ProvisioningStep.Plan(childComplexity), true

	case "ProvisioningStep.ProvisionedHost":
		if e.complexity.ProvisioningStep.ProvisionedHost == nil {
			break
		}

		return e.complexity.ProvisioningStep.ProvisionedHost(childComplexity), true

	case "ProvisioningStep.Script":
		if e.complexity.ProvisioningStep.Script == nil {
			break
		}

		return e.complexity.ProvisioningStep.Script(childComplexity), true

	case "ProvisioningStep.Status":
		if e.complexity.ProvisioningStep.Status == nil {
			break
		}

		return e.complexity.ProvisioningStep.Status(childComplexity), true

	case "ProvisioningStep.stepNumber":
		if e.complexity.ProvisioningStep.StepNumber == nil {
			break
		}

		return e.complexity.ProvisioningStep.StepNumber(childComplexity), true

	case "ProvisioningStep.type":
		if e.complexity.ProvisioningStep.Type == nil {
			break
		}

		return e.complexity.ProvisioningStep.Type(childComplexity), true

	case "Query.agentStatus":
		if e.complexity.Query.AgentStatus == nil {
			break
		}

		args, err := ec.field_Query_agentStatus_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AgentStatus(childComplexity, args["clientId"].(string)), true

	case "Query.build":
		if e.complexity.Query.Build == nil {
			break
		}

		args, err := ec.field_Query_build_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Build(childComplexity, args["buildUUID"].(string)), true

	case "Query.currentUser":
		if e.complexity.Query.CurrentUser == nil {
			break
		}

		return e.complexity.Query.CurrentUser(childComplexity), true

	case "Query.environment":
		if e.complexity.Query.Environment == nil {
			break
		}

		args, err := ec.field_Query_environment_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Environment(childComplexity, args["envUUID"].(string)), true

	case "Query.environments":
		if e.complexity.Query.Environments == nil {
			break
		}

		return e.complexity.Query.Environments(childComplexity), true

	case "Query.getAgentTasks":
		if e.complexity.Query.GetAgentTasks == nil {
			break
		}

		args, err := ec.field_Query_getAgentTasks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetAgentTasks(childComplexity, args["proStepUUID"].(*string), args["proSchedStepUUID"].(*string)), true

	case "Query.getAllAgentStatus":
		if e.complexity.Query.GetAllAgentStatus == nil {
			break
		}

		args, err := ec.field_Query_getAllAgentStatus_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetAllAgentStatus(childComplexity, args["buildUUID"].(string), args["count"].(int), args["offset"].(int)), true

	case "Query.getAllPlanStatus":
		if e.complexity.Query.GetAllPlanStatus == nil {
			break
		}

		args, err := ec.field_Query_getAllPlanStatus_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetAllPlanStatus(childComplexity, args["buildUUID"].(string), args["count"].(int), args["offset"].(int)), true

	case "Query.getBuildCommit":
		if e.complexity.Query.GetBuildCommit == nil {
			break
		}

		args, err := ec.field_Query_getBuildCommit_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetBuildCommit(childComplexity, args["buildCommitUUID"].(string)), true

	case "Query.getBuildCommits":
		if e.complexity.Query.GetBuildCommits == nil {
			break
		}

		args, err := ec.field_Query_getBuildCommits_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetBuildCommits(childComplexity, args["envUUID"].(string)), true

	case "Query.getBuilds":
		if e.complexity.Query.GetBuilds == nil {
			break
		}

		return e.complexity.Query.GetBuilds(childComplexity), true

	case "Query.getCurrentUserTasks":
		if e.complexity.Query.GetCurrentUserTasks == nil {
			break
		}

		return e.complexity.Query.GetCurrentUserTasks(childComplexity), true

	case "Query.getPlanStatusCounts":
		if e.complexity.Query.GetPlanStatusCounts == nil {
			break
		}

		args, err := ec.field_Query_getPlanStatusCounts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetPlanStatusCounts(childComplexity, args["buildUUID"].(string)), true

	case "Query.getServerTasks":
		if e.complexity.Query.GetServerTasks == nil {
			break
		}

		return e.complexity.Query.GetServerTasks(childComplexity), true

	case "Query.getUserList":
		if e.complexity.Query.GetUserList == nil {
			break
		}

		return e.complexity.Query.GetUserList(childComplexity), true

	case "Query.listAgentStatuses":
		if e.complexity.Query.ListAgentStatuses == nil {
			break
		}

		args, err := ec.field_Query_listAgentStatuses_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListAgentStatuses(childComplexity, args["buildUUID"].(string)), true

	case "Query.listBuildStatuses":
		if e.complexity.Query.ListBuildStatuses == nil {
			break
		}

		args, err := ec.field_Query_listBuildStatuses_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ListBuildStatuses(childComplexity, args["buildUUID"].(string)), true

	case "Query.plan":
		if e.complexity.Query.Plan == nil {
			break
		}

		args, err := ec.field_Query_plan_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Plan(childComplexity, args["planUUID"].(string)), true

	case "Query.provisionedHost":
		if e.complexity.Query.ProvisionedHost == nil {
			break
		}

		args, err := ec.field_Query_provisionedHost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ProvisionedHost(childComplexity, args["proHostUUID"].(string)), true

	case "Query.provisionedNetwork":
		if e.complexity.Query.ProvisionedNetwork == nil {
			break
		}

		args, err := ec.field_Query_provisionedNetwork_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ProvisionedNetwork(childComplexity, args["proNetUUID"].(string)), true

	case "Query.provisionedStep":
		if e.complexity.Query.ProvisionedStep == nil {
			break
		}

		args, err := ec.field_Query_provisionedStep_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ProvisionedStep(childComplexity, args["proStepUUID"].(string)), true

	case "Query.serverConfig":
		if e.complexity.Query.ServerConfig == nil {
			break
		}

		return e.complexity.Query.ServerConfig(childComplexity), true

	case "Query.serverTasks":
		if e.complexity.Query.ServerTasks == nil {
			break
		}

		args, err := ec.field_Query_serverTasks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ServerTasks(childComplexity, args["taskUUIDs"].([]*string)), true

	case "Query.status":
		if e.complexity.Query.Status == nil {
			break
		}

		args, err := ec.field_Query_status_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Status(childComplexity, args["statusUUID"].(string)), true

	case "Query.viewAgentTask":
		if e.complexity.Query.ViewAgentTask == nil {
			break
		}

		args, err := ec.field_Query_viewAgentTask_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ViewAgentTask(childComplexity, args["taskID"].(string)), true

	case "Query.viewServerTaskLogs":
		if e.complexity.Query.ViewServerTaskLogs == nil {
			break
		}

		args, err := ec.field_Query_viewServerTaskLogs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ViewServerTaskLogs(childComplexity, args["taskID"].(string)), true

	case "RepoCommit.author":
		if e.complexity.RepoCommit.Author == nil {
			break
		}

		return e.complexity.RepoCommit.Author(childComplexity), true

	case "RepoCommit.committer":
		if e.complexity.RepoCommit.Committer == nil {
			break
		}

		return e.complexity.RepoCommit.Committer(childComplexity), true

	case "RepoCommit.hash":
		if e.complexity.RepoCommit.Hash == nil {
			break
		}

		return e.complexity.RepoCommit.Hash(childComplexity), true

	case "RepoCommit.id":
		if e.complexity.RepoCommit.ID == nil {
			break
		}

		return e.complexity.RepoCommit.ID(childComplexity), true

	case "RepoCommit.message":
		if e.complexity.RepoCommit.Message == nil {
			break
		}

		return e.complexity.RepoCommit.Message(childComplexity), true

	case "RepoCommit.parentHashes":
		if e.complexity.RepoCommit.ParentHashes == nil {
			break
		}

		return e.complexity.RepoCommit.ParentHashes(childComplexity), true

	case "RepoCommit.pgpSignature":
		if e.complexity.RepoCommit.PgpSignature == nil {
			break
		}

		return e.complexity.RepoCommit.PgpSignature(childComplexity), true

	case "RepoCommit.Repository":
		if e.complexity.RepoCommit.Repository == nil {
			break
		}

		return e.complexity.RepoCommit.Repository(childComplexity), true

	case "RepoCommit.revision":
		if e.complexity.RepoCommit.Revision == nil {
			break
		}

		return e.complexity.RepoCommit.Revision(childComplexity), true

	case "RepoCommit.treeHash":
		if e.complexity.RepoCommit.TreeHash == nil {
			break
		}

		return e.complexity.RepoCommit.TreeHash(childComplexity), true

	case "Repository.branchName":
		if e.complexity.Repository.BranchName == nil {
			break
		}

		return e.complexity.Repository.BranchName(childComplexity), true

	case "Repository.environmentFilepath":
		if e.complexity.Repository.EnvironmentFilepath == nil {
			break
		}

		return e.complexity.Repository.EnvironmentFilepath(childComplexity), true

	case "Repository.Environments":
		if e.complexity.Repository.Environments == nil {
			break
		}

		return e.complexity.Repository.Environments(childComplexity), true

	case "Repository.id":
		if e.complexity.Repository.ID == nil {
			break
		}

		return e.complexity.Repository.ID(childComplexity), true

	case "Repository.RepoCommits":
		if e.complexity.Repository.RepoCommits == nil {
			break
		}

		return e.complexity.Repository.RepoCommits(childComplexity), true

	case "Repository.repoUrl":
		if e.complexity.Repository.RepoURL == nil {
			break
		}

		return e.complexity.Repository.RepoURL(childComplexity), true

	case "ScheduledStep.description":
		if e.complexity.ScheduledStep.Description == nil {
			break
		}

		return e.complexity.ScheduledStep.Description(childComplexity), true

	case "ScheduledStep.Environment":
		if e.complexity.ScheduledStep.Environment == nil {
			break
		}

		return e.complexity.ScheduledStep.Environment(childComplexity), true

	case "ScheduledStep.hclId":
		if e.complexity.ScheduledStep.HclID == nil {
			break
		}

		return e.complexity.ScheduledStep.HclID(childComplexity), true

	case "ScheduledStep.id":
		if e.complexity.ScheduledStep.ID == nil {
			break
		}

		return e.complexity.ScheduledStep.ID(childComplexity), true

	case "ScheduledStep.name":
		if e.complexity.ScheduledStep.Name == nil {
			break
		}

		return e.complexity.ScheduledStep.Name(childComplexity), true

	case "ScheduledStep.runAt":
		if e.complexity.ScheduledStep.RunAt == nil {
			break
		}

		return e.complexity.ScheduledStep.RunAt(childComplexity), true

	case "ScheduledStep.schedule":
		if e.complexity.ScheduledStep.Schedule == nil {
			break
		}

		return e.complexity.ScheduledStep.Schedule(childComplexity), true

	case "ScheduledStep.step":
		if e.complexity.ScheduledStep.Step == nil {
			break
		}

		return e.complexity.ScheduledStep.Step(childComplexity), true

	case "ScheduledStep.type":
		if e.complexity.ScheduledStep.Type == nil {
			break
		}

		return e.complexity.ScheduledStep.Type(childComplexity), true

	case "Script.absPath":
		if e.complexity.Script.AbsPath == nil {
			break
		}

		return e.complexity.Script.AbsPath(childComplexity), true

	case "Script.args":
		if e.complexity.Script.Args == nil {
			break
		}

		return e.complexity.Script.Args(childComplexity), true

	case "Script.cooldown":
		if e.complexity.Script.Cooldown == nil {
			break
		}

		return e.complexity.Script.Cooldown(childComplexity), true

	case "Script.description":
		if e.complexity.Script.Description == nil {
			break
		}

		return e.complexity.Script.Description(childComplexity), true

	case "Script.disabled":
		if e.complexity.Script.Disabled == nil {
			break
		}

		return e.complexity.Script.Disabled(childComplexity), true

	case "Script.Environment":
		if e.complexity.Script.Environment == nil {
			break
		}

		return e.complexity.Script.Environment(childComplexity), true

	case "Script.Findings":
		if e.complexity.Script.Findings == nil {
			break
		}

		return e.complexity.Script.Findings(childComplexity), true

	case "Script.hclId":
		if e.complexity.Script.HclID == nil {
			break
		}

		return e.complexity.Script.HclID(childComplexity), true

	case "Script.id":
		if e.complexity.Script.ID == nil {
			break
		}

		return e.complexity.Script.ID(childComplexity), true

	case "Script.ignoreErrors":
		if e.complexity.Script.IgnoreErrors == nil {
			break
		}

		return e.complexity.Script.IgnoreErrors(childComplexity), true

	case "Script.language":
		if e.complexity.Script.Language == nil {
			break
		}

		return e.complexity.Script.Language(childComplexity), true

	case "Script.name":
		if e.complexity.Script.Name == nil {
			break
		}

		return e.complexity.Script.Name(childComplexity), true

	case "Script.source":
		if e.complexity.Script.Source == nil {
			break
		}

		return e.complexity.Script.Source(childComplexity), true

	case "Script.sourceType":
		if e.complexity.Script.SourceType == nil {
			break
		}

		return e.complexity.Script.SourceType(childComplexity), true

	case "Script.tags":
		if e.complexity.Script.Tags == nil {
			break
		}

		return e.complexity.Script.Tags(childComplexity), true

	case "Script.timeout":
		if e.complexity.Script.Timeout == nil {
			break
		}

		return e.complexity.Script.Timeout(childComplexity), true

	case "Script.Users":
		if e.complexity.Script.Users == nil {
			break
		}

		return e.complexity.Script.Users(childComplexity), true

	case "Script.vars":
		if e.complexity.Script.Vars == nil {
			break
		}

		return e.complexity.Script.Vars(childComplexity), true

	case "ServerConfig.Agent":
		if e.complexity.ServerConfig.Agent == nil {
			break
		}

		return e.complexity.ServerConfig.Agent(childComplexity), true

	case "ServerConfig.Auth":
		if e.complexity.ServerConfig.Auth == nil {
			break
		}

		return e.complexity.ServerConfig.Auth(childComplexity), true

	case "ServerConfig.Builders":
		if e.complexity.ServerConfig.Builders == nil {
			break
		}

		return e.complexity.ServerConfig.Builders(childComplexity), true

	case "ServerConfig.ConfigFile":
		if e.complexity.ServerConfig.ConfigFile == nil {
			break
		}

		return e.complexity.ServerConfig.ConfigFile(childComplexity), true

	case "ServerConfig.Database":
		if e.complexity.ServerConfig.Database == nil {
			break
		}

		return e.complexity.ServerConfig.Database(childComplexity), true

	case "ServerConfig.Debug":
		if e.complexity.ServerConfig.Debug == nil {
			break
		}

		return e.complexity.ServerConfig.Debug(childComplexity), true

	case "ServerConfig.GinMode":
		if e.complexity.ServerConfig.GinMode == nil {
			break
		}

		return e.complexity.ServerConfig.GinMode(childComplexity), true

	case "ServerConfig.Graphql":
		if e.complexity.ServerConfig.Graphql == nil {
			break
		}

		return e.complexity.ServerConfig.Graphql(childComplexity), true

	case "ServerConfig.LogFolder":
		if e.complexity.ServerConfig.LogFolder == nil {
			break
		}

		return e.complexity.ServerConfig.LogFolder(childComplexity), true

	case "ServerConfig.UI":
		if e.complexity.ServerConfig.UI == nil {
			break
		}

		return e.complexity.ServerConfig.UI(childComplexity), true

	case "ServerTask.AuthUser":
		if e.complexity.ServerTask.AuthUser == nil {
			break
		}

		return e.complexity.ServerTask.AuthUser(childComplexity), true

	case "ServerTask.Build":
		if e.complexity.ServerTask.Build == nil {
			break
		}

		return e.complexity.ServerTask.Build(childComplexity), true

	case "ServerTask.BuildCommit":
		if e.complexity.ServerTask.BuildCommit == nil {
			break
		}

		return e.complexity.ServerTask.BuildCommit(childComplexity), true

	case "ServerTask.endTime":
		if e.complexity.ServerTask.EndTime == nil {
			break
		}

		return e.complexity.ServerTask.EndTime(childComplexity), true

	case "ServerTask.Environment":
		if e.complexity.ServerTask.Environment == nil {
			break
		}

		return e.complexity.ServerTask.Environment(childComplexity), true

	case "ServerTask.errors":
		if e.complexity.ServerTask.Errors == nil {
			break
		}

		return e.complexity.ServerTask.Errors(childComplexity), true

	case "ServerTask.GinFileMiddleware":
		if e.complexity.ServerTask.GinFileMiddleware == nil {
			break
		}

		return e.complexity.ServerTask.GinFileMiddleware(childComplexity), true

	case "ServerTask.id":
		if e.complexity.ServerTask.ID == nil {
			break
		}

		return e.complexity.ServerTask.ID(childComplexity), true

	case "ServerTask.logFilePath":
		if e.complexity.ServerTask.LogFilePath == nil {
			break
		}

		return e.complexity.ServerTask.LogFilePath(childComplexity), true

	case "ServerTask.startTime":
		if e.complexity.ServerTask.StartTime == nil {
			break
		}

		return e.complexity.ServerTask.StartTime(childComplexity), true

	case "ServerTask.Status":
		if e.complexity.ServerTask.Status == nil {
			break
		}

		return e.complexity.ServerTask.Status(childComplexity), true

	case "ServerTask.type":
		if e.complexity.ServerTask.Type == nil {
			break
		}

		return e.complexity.ServerTask.Type(childComplexity), true

	case "Status.AdhocPlan":
		if e.complexity.Status.AdhocPlan == nil {
			break
		}

		return e.complexity.Status.AdhocPlan(childComplexity), true

	case "Status.Build":
		if e.complexity.Status.Build == nil {
			break
		}

		return e.complexity.Status.Build(childComplexity), true

	case "Status.completed":
		if e.complexity.Status.Completed == nil {
			break
		}

		return e.complexity.Status.Completed(childComplexity), true

	case "Status.endedAt":
		if e.complexity.Status.EndedAt == nil {
			break
		}

		return e.complexity.Status.EndedAt(childComplexity), true

	case "Status.error":
		if e.complexity.Status.Error == nil {
			break
		}

		return e.complexity.Status.Error(childComplexity), true

	case "Status.failed":
		if e.complexity.Status.Failed == nil {
			break
		}

		return e.complexity.Status.Failed(childComplexity), true

	case "Status.id":
		if e.complexity.Status.ID == nil {
			break
		}

		return e.complexity.Status.ID(childComplexity), true

	case "Status.Plan":
		if e.complexity.Status.Plan == nil {
			break
		}

		return e.complexity.Status.Plan(childComplexity), true

	case "Status.ProvisionedHost":
		if e.complexity.Status.ProvisionedHost == nil {
			break
		}

		return e.complexity.Status.ProvisionedHost(childComplexity), true

	case "Status.ProvisionedNetwork":
		if e.complexity.Status.ProvisionedNetwork == nil {
			break
		}

		return e.complexity.Status.ProvisionedNetwork(childComplexity), true

	case "Status.ProvisioningScheduledStep":
		if e.complexity.Status.ProvisioningScheduledStep == nil {
			break
		}

		return e.complexity.Status.ProvisioningScheduledStep(childComplexity), true

	case "Status.ProvisioningStep":
		if e.complexity.Status.ProvisioningStep == nil {
			break
		}

		return e.complexity.Status.ProvisioningStep(childComplexity), true

	case "Status.ServerTask":
		if e.complexity.Status.ServerTask == nil {
			break
		}

		return e.complexity.Status.ServerTask(childComplexity), true

	case "Status.startedAt":
		if e.complexity.Status.StartedAt == nil {
			break
		}

		return e.complexity.Status.StartedAt(childComplexity), true

	case "Status.state":
		if e.complexity.Status.State == nil {
			break
		}

		return e.complexity.Status.State(childComplexity), true

	case "Status.statusFor":
		if e.complexity.Status.StatusFor == nil {
			break
		}

		return e.complexity.Status.StatusFor(childComplexity), true

	case "Status.Team":
		if e.complexity.Status.Team == nil {
			break
		}

		return e.complexity.Status.Team(childComplexity), true

	case "StatusBatch.pageInfo":
		if e.complexity.StatusBatch.PageInfo == nil {
			break
		}

		return e.complexity.StatusBatch.PageInfo(childComplexity), true

	case "StatusBatch.statuses":
		if e.complexity.StatusBatch.Statuses == nil {
			break
		}

		return e.complexity.StatusBatch.Statuses(childComplexity), true

	case "Subscription.streamServerTaskLog":
		if e.complexity.Subscription.StreamServerTaskLog == nil {
			break
		}

		args, err := ec.field_Subscription_streamServerTaskLog_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.StreamServerTaskLog(childComplexity, args["taskID"].(string)), true

	case "Subscription.updatedAgentStatus":
		if e.complexity.Subscription.UpdatedAgentStatus == nil {
			break
		}

		return e.complexity.Subscription.UpdatedAgentStatus(childComplexity), true

	case "Subscription.updatedAgentTask":
		if e.complexity.Subscription.UpdatedAgentTask == nil {
			break
		}

		return e.complexity.Subscription.UpdatedAgentTask(childComplexity), true

	case "Subscription.updatedBuild":
		if e.complexity.Subscription.UpdatedBuild == nil {
			break
		}

		return e.complexity.Subscription.UpdatedBuild(childComplexity), true

	case "Subscription.updatedCommit":
		if e.complexity.Subscription.UpdatedCommit == nil {
			break
		}

		return e.complexity.Subscription.UpdatedCommit(childComplexity), true

	case "Subscription.updatedServerTask":
		if e.complexity.Subscription.UpdatedServerTask == nil {
			break
		}

		return e.complexity.Subscription.UpdatedServerTask(childComplexity), true

	case "Subscription.updatedStatus":
		if e.complexity.Subscription.UpdatedStatus == nil {
			break
		}

		return e.complexity.Subscription.UpdatedStatus(childComplexity), true

	case "Tag.description":
		if e.complexity.Tag.Description == nil {
			break
		}

		return e.complexity.Tag.Description(childComplexity), true

	case "Tag.id":
		if e.complexity.Tag.ID == nil {
			break
		}

		return e.complexity.Tag.ID(childComplexity), true

	case "Tag.name":
		if e.complexity.Tag.Name == nil {
			break
		}

		return e.complexity.Tag.Name(childComplexity), true

	case "Tag.uuid":
		if e.complexity.Tag.UUID == nil {
			break
		}

		return e.complexity.Tag.UUID(childComplexity), true

	case "Team.Build":
		if e.complexity.Team.Build == nil {
			break
		}

		return e.complexity.Team.Build(childComplexity), true

	case "Team.id":
		if e.complexity.Team.ID == nil {
			break
		}

		return e.complexity.Team.ID(childComplexity), true

	case "Team.Plan":
		if e.complexity.Team.Plan == nil {
			break
		}

		return e.complexity.Team.Plan(childComplexity), true

	case "Team.ProvisionedNetworks":
		if e.complexity.Team.ProvisionedNetworks == nil {
			break
		}

		return e.complexity.Team.ProvisionedNetworks(childComplexity), true

	case "Team.Status":
		if e.complexity.Team.Status == nil {
			break
		}

		return e.complexity.Team.Status(childComplexity), true

	case "Team.teamNumber":
		if e.complexity.Team.TeamNumber == nil {
			break
		}

		return e.complexity.Team.TeamNumber(childComplexity), true

	case "UIConfig.AllowedOrigins":
		if e.complexity.UIConfig.AllowedOrigins == nil {
			break
		}

		return e.complexity.UIConfig.AllowedOrigins(childComplexity), true

	case "UIConfig.HttpsEnabled":
		if e.complexity.UIConfig.HTTPSEnabled == nil {
			break
		}

		return e.complexity.UIConfig.HTTPSEnabled(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.Environments":
		if e.complexity.User.Environments == nil {
			break
		}

		return e.complexity.User.Environments(childComplexity), true

	case "User.hclId":
		if e.complexity.User.HclID == nil {
			break
		}

		return e.complexity.User.HclID(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.Tag":
		if e.complexity.User.Tag == nil {
			break
		}

		return e.complexity.User.Tag(childComplexity), true

	case "User.uuid":
		if e.complexity.User.UUID == nil {
			break
		}

		return e.complexity.User.UUID(childComplexity), true

	case "configMap.key":
		if e.complexity.ConfigMap.Key == nil {
			break
		}

		return e.complexity.ConfigMap.Key(childComplexity), true

	case "configMap.value":
		if e.complexity.ConfigMap.Value == nil {
			break
		}

		return e.complexity.ConfigMap.Value(childComplexity), true

	case "intMap.key":
		if e.complexity.IntMap.Key == nil {
			break
		}

		return e.complexity.IntMap.Key(childComplexity), true

	case "intMap.value":
		if e.complexity.IntMap.Value == nil {
			break
		}

		return e.complexity.IntMap.Value(childComplexity), true

	case "tagMap.key":
		if e.complexity.TagMap.Key == nil {
			break
		}

		return e.complexity.TagMap.Key(childComplexity), true

	case "tagMap.value":
		if e.complexity.TagMap.Value == nil {
			break
		}

		return e.complexity.TagMap.Value(childComplexity), true

	case "varsMap.key":
		if e.complexity.VarsMap.Key == nil {
			break
		}

		return e.complexity.VarsMap.Key(childComplexity), true

	case "varsMap.value":
		if e.complexity.VarsMap.Value == nil {
			break
		}

		return e.complexity.VarsMap.Value(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap()
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema.graphqls", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

scalar Time
scalar Map

type varsMap {
  key: String!
  value: String!
}

type configMap {
  key: String!
  value: String!
}

type tagMap {
  key: String!
  value: String!
}

type intMap {
  key: String!
  value: Int!
}

enum FindingSeverity {
  ZeroSeverity
  LowSeverity
  MediumSeverity
  HighSeverity
  CriticalSeverity
  NullSeverity
}

enum FindingDifficulty {
  ZeroDifficulty
  NoviceDifficulty
  AdvancedDifficulty
  ExpertDifficulty
  NullDifficulty
}

enum ProvisionStatus {
  PLANNING
  AWAITING
  PARENTAWAITING
  INPROGRESS
  FAILED
  COMPLETE
  TAINTED
  UNDEFINED
  TODELETE
  DELETEINPROGRESS
  DELETED
  TOREBUILD
  CANCELLED
}

enum ProvisionStatusFor {
  Build
  Team
  Plan
  ProvisionedNetwork
  ProvisionedHost
  ProvisioningStep
  Undefined
}

enum PlanType {
  start_build
  start_team
  provision_network
  provision_host
  execute_step
  undefined
}

enum ProvisioningStepType {
  Ansible
  Script
  Command
  DNSRecord
  FileDelete
  FileDownload
  FileExtract
  Undefined
}

enum ProvisioningScheduledStepType {
  Ansible
  Script
  Command
  DNSRecord
  FileDelete
  FileDownload
  FileExtract
  Undefined
}

enum RoleLevel {
  ADMIN
  USER
  UNDEFINED
}

enum ProviderType {
  LOCAL
  GITHUB
  OPENID
  UNDEFINED
}

enum AgentCommand {
  DEFAULT
  DELETE
  REBOOT
  EXTRACT
  DOWNLOAD
  CREATEUSER
  CREATEUSERPASS
  ADDTOGROUP
  EXECUTE
  VALIDATE
  CHANGEPERMS
  APPENDFILE
}

enum AgentTaskState {
  AWAITING
  INPROGRESS
  FAILED
  COMPLETE
}

enum ServerTaskType {
  LOADENV
  CREATEBUILD
  RENDERFILES
  DELETEBUILD
  REBUILD
  EXECUTEBUILD
}

enum BuildCommitType {
  ROOT
  REBUILD
  DELETE
}

enum BuildCommitState {
  PLANNING
  INPROGRESS
  APPLIED
  CANCELLED
  APPROVED
}

enum AnsibleMethod {
  LOCAL
}

enum ProvisionedHostAddonType {
  DNS
}

enum ScheduledStepType {
  CRON
  RUNONCE
}

type AdhocPlan {
  id: ID!
  NextAdhocPlans: [AdhocPlan]
  PrevAdhocPlans: [AdhocPlan]
  Build: Build!
  Status: Status!
  AgentTask: AgentTask!
}

type AgentStatus {
  clientId: String!
  hostname: String!
  upTime: Int!
  bootTime: Int!
  numProcs: Int!
  OS: String!
  hostID: String!
  load1: Float
  load5: Float
  load15: Float
  totalMem: Int!
  freeMem: Int!
  usedMem: Int!
  timestamp: Int!
  ProvisionedHost: ProvisionedHost
  ProvisionedNetwork: ProvisionedNetwork
  Build: Build
}

type AgentTask {
  id: ID!
  args: String
  command: AgentCommand!
  number: Int!
  output: String
  state: AgentTaskState!
  errorMessage: String
  ProvisioningStep: ProvisioningStep
  ProvisioningScheduledStep: ProvisioningScheduledStep
  ProvisionedHost: ProvisionedHost!
  AdhocPlans: [AdhocPlan]
}

type Ansible {
  id: ID!
  hclId: String!
  name: String!
  description: String!
  source: String!
  playbookName: String!
  method: AnsibleMethod!
  inventory: String!
  absPath: String!
  tags: [tagMap]
  Users: [User]
  Environment: Environment
}

type AuthUser {
  id: ID!
  username: String!
  # password <- hidden
  firstName: String!
  lastName: String!
  email: String!
  phone: String!
  company: String!
  occupation: String!
  # privateKeyPath <- hidden
  publicKey: String!
  role: RoleLevel!
  provider: ProviderType!
  # Tokens <- hidden
  ServerTasks: [ServerTask]
}

type Build {
  id: ID!
  revision: Int!
  environmentRevision: Int!
  completedPlan: Boolean!
  Status: Status!
  Environment: Environment!
  Competition: Competition!
  LatestBuildCommit: BuildCommit
  RepoCommit: RepoCommit!
  ProvisionedNetworks: [ProvisionedNetwork]!
  Teams: [Team]!
  Plans: [Plan]!
  BuildCommits: [BuildCommit]!
  AdhocPlans: [AdhocPlan]!
  AgentStatuses: [AgentStatus]!
  ServerTasks: [ServerTask]!
}

type BuildCommit {
  id: ID!
  type: BuildCommitType!
  revision: Int!
  state: BuildCommitState!
  createdAt: Time!
  Build: Build!
  ServerTasks: [ServerTask]!
  PlanDiffs: [PlanDiff]!
}

type Command {
  id: ID!
  hclId: String!
  name: String!
  description: String!
  program: String!
  args: [String]!
  ignoreErrors: Boolean!
  disabled: Boolean!
  cooldown: Int!
  timeout: Int!
  vars: [varsMap]
  tags: [tagMap]
  Users: [User]!
  Environment: Environment!
}

type Competition {
  id: ID!
  hclId: String!
  rootPassword: String!
  startTime: Int
  stopTime: Int
  config: [configMap]
  tags: [tagMap]
  DNS: [DNS]!
  Environment: Environment!
  Builds: [Build]!
}

type Disk {
  id: ID!
  size: Int!
  Host: Host!
}

type DNS {
  id: ID!
  hclId: String!
  type: String!
  rootDomain: String!
  dnsServers: [String]!
  ntpServers: [String]!
  config: [configMap]
  Environments: [Environment]!
  Competitions: [Competition]!
}

type DNSRecord {
  id: ID!
  hclId: String!
  name: String!
  values: [String]!
  type: String!
  zone: String!
  vars: [varsMap]!
  disabled: Boolean!
  tags: [tagMap]!
  Environment: Environment!
}

type Environment {
  id: ID!
  hclId: String!
  competitionId: String!
  name: String!
  description: String!
  builder: String!
  teamCount: Int!
  revision: Int!
  adminCidrs: [String]!
  exposedVdiPorts: [String]!
  config: [configMap]
  tags: [tagMap]
  Users: [User]!
  Hosts: [Host]!
  Competitions: [Competition]!
  Identities: [Identity]!
  Commands: [Command]!
  Scripts: [Script]!
  FileDownloads: [FileDownload]!
  FileDeletes: [FileDelete]!
  FileExtracts: [FileExtract]!
  IncludedNetworks: [IncludedNetwork]!
  Findings: [Finding]!
  DNSRecords: [DNSRecord]!
  DNS: [DNS]!
  Networks: [Network]!
  HostDependencies: [HostDependency]!
  Ansibles: [Ansible]!
  ScheduledSteps: [ScheduledStep]!
  Builds: [Build]!
  Repositories: [Repository]!
  ServerTasks: [ServerTask]!
}

type FileDelete {
  id: ID!
  hclId: String!
  path: String!
  tags: [tagMap]!
  Environment: Environment!
}

type FileDownload {
  id: ID!
  hclId: String!
  sourceType: String!
  source: String!
  destination: String!
  template: Boolean!
  perms: String!
  disabled: Boolean!
  md5: String!
  absPath: String!
  tags: [tagMap]!
  Environment: Environment!
}

type FileExtract {
  id: ID!
  hclId: String!
  source: String!
  destination: String!
  type: String!
  tags: [tagMap]!
  Environment: Environment!
}

type Finding {
  id: ID!
  name: String!
  description: String!
  severity: FindingSeverity!
  difficulty: FindingDifficulty!
  tags: [tagMap]!
  Users: [User]!
  Host: Host
  Script: Script
  Environment: Environment
}

type GinFileMiddleware {
  id: ID!
  urlId: String!
  filePath: String!
  accessed: Boolean!
  ProvisionedHost: ProvisionedHost
  ProvisioningStep: ProvisioningStep
  ProvisioningScheduledStep: ProvisioningScheduledStep
}

type Host {
  id: ID!
  hclId: String!
  hostname: String!
  description: String!
  OS: String!
  lastOctet: Int!
  instanceSize: String!
  allowMacChanges: Boolean!
  exposedTcpPorts: [String]!
  exposedUdpPorts: [String]!
  overridePassword: String!
  vars: [varsMap]
  userGroups: [String]!
  provisionSteps: [String]!
  tags: [tagMap]!
  Disk: Disk!
  Users: [User]!
  Environment: Environment!
  IncludedNetworks: [IncludedNetwork]!
  DependOnHostDependencies: [HostDependency]!
  RequiredByHostDependencies: [HostDependency]!
}

type HostDependency {
  id: ID!
  hostId: String!
  networkId: String!
  RequiredBy: Host
  DependOnHost: Host
  DependOnNetwork: Network
  Environment: Environment
}

type Identity {
  id: ID!
  hclid: String!
  firstName: String!
  lastName: String!
  email: String!
  password: String!
  description: String!
  avatarFile: String!
  vars: [varsMap]!
  tags: [tagMap]!
  Environment: Environment!
}

type IncludedNetwork {
  id: ID!
  name: String!
  includedHosts: [String]!
  Tags: [Tag]!
  Hosts: [Host]!
  Network: Network
  Environments: [Environment]!
}

type Network {
  id: ID!
  hclId: String!
  name: String!
  cidr: String!
  vdiVisible: Boolean!
  vars: [varsMap]
  tags: [tagMap]!
  Environment: Environment!
  HostDependencies: [HostDependency]!
  IncludedNetworks: [IncludedNetwork]!
}

type Plan {
  id: ID!
  stepNumber: Int!
  type: PlanType!
  NextPlans: [Plan]!
  PrevPlans: [Plan]!
  Build: Build
  Team: Team
  ProvisionedNetwork: ProvisionedNetwork
  ProvisionedHost: ProvisionedHost
  ProvisioningStep: ProvisioningStep
  ProvisioningScheduledStep: ProvisioningScheduledStep
  Status: Status!
  PlanDiffs: [PlanDiff]!
}

type PlanDiff {
  id: ID!
  revision: Int!
  newState: ProvisionStatus!
  BuildCommit: BuildCommit!
  Plan: Plan!
}

type ProvisionedHost {
  id: ID!
  subnetIp: String!
  addonType: ProvisionedHostAddonType
  vars: [varsMap]
  Status: Status!
  ProvisionedNetwork: ProvisionedNetwork!
  Host: Host!
  EndStepPlan: Plan
  Build: Build!
  ProvisioningSteps: [ProvisioningStep]!
  ProvisioningScheduledSteps: [ProvisioningScheduledStep]!
  AgentStatuses: [AgentStatus]!
  AgentTasks: [AgentTask]!
  Plan: Plan!
  GinFileMiddleware: GinFileMiddleware
}

type ProvisionedNetwork {
  id: ID!
  name: String!
  cidr: String!
  vars: [varsMap]
  Status: Status
  Network: Network
  Build: Build
  Team: Team
  ProvisionedHosts: [ProvisionedHost]!
  Plan: Plan
}

type ProvisioningScheduledStep {
  id: ID!
  type: ProvisioningScheduledStepType!
  runTime: Time!
  Status: Status
  ScheduledStep: ScheduledStep!
  ProvisionedHost: ProvisionedHost!
  Script: Script
  Command: Command
  DNSRecord: DNSRecord
  FileDelete: FileDelete
  FileDownload: FileDownload
  FileExtract: FileExtract
  Ansible: Ansible
  AgentTasks: [AgentTask]!
  Plan: Plan
  GinFileMiddleware: GinFileMiddleware
}

type ProvisioningStep {
  id: ID!
  type: ProvisioningStepType!
  stepNumber: Int!
  Status: Status
  ProvisionedHost: ProvisionedHost!
  Script: Script
  Command: Command
  DNSRecord: DNSRecord
  FileDelete: FileDelete
  FileDownload: FileDownload
  FileExtract: FileExtract
  Ansible: Ansible
  Plan: Plan
  AgentTasks: [AgentTask]!
  GinFileMiddleware: GinFileMiddleware
}

type RepoCommit {
  id: ID!
  revision: Int!
  hash: String!
  author: String!
  committer: String!
  pgpSignature: String!
  message: String!
  treeHash: String!
  parentHashes: [String]!
  Repository: Repository!
}

type Repository {
  id: ID!
  repoUrl: String!
  branchName: String!
  environmentFilepath: String!
  Environments: [Environment]!
  RepoCommits: [RepoCommit]!
}

type ScheduledStep {
  id: ID!
  hclId: String!
  name: String!
  description: String!
  step: String!
  type: ScheduledStepType!
  schedule: String
  runAt: Int
  Environment: Environment
}

type Script {
  id: ID!
  hclId: String!
  name: String!
  language: String!
  description: String!
  source: String!
  sourceType: String!
  cooldown: Int!
  timeout: Int!
  ignoreErrors: Boolean!
  args: [String]!
  disabled: Boolean!
  vars: [varsMap]
  absPath: String!
  tags: [tagMap]
  Users: [User]!
  Findings: [Finding]!
  Environment: Environment!
}

type ServerTask {
  id: ID!
  type: ServerTaskType!
  startTime: Time
  endTime: Time
  errors: [String]
  logFilePath: String
  AuthUser: AuthUser!
  Status: Status!
  Environment: Environment
  Build: Build
  BuildCommit: BuildCommit
  GinFileMiddleware: [GinFileMiddleware]!
}

type Status {
  id: ID!
  state: ProvisionStatus!
  statusFor: ProvisionStatusFor!
  startedAt: String!
  endedAt: String!
  failed: Boolean!
  completed: Boolean!
  error: String
  Build: Build
  ProvisionedNetwork: ProvisionedNetwork
  ProvisionedHost: ProvisionedHost
  ProvisioningStep: ProvisioningStep
  Team: Team
  Plan: Plan
  ServerTask: ServerTask
  AdhocPlan: AdhocPlan
  ProvisioningScheduledStep: ProvisioningScheduledStep
}

type Tag {
  id: ID!
  uuid: ID!
  name: String!
  description: [tagMap]!
}

type Team {
  id: ID!
  teamNumber: Int!
  Build: Build!
  Status: Status
  ProvisionedNetworks: [ProvisionedNetwork]!
  Plan: Plan!
}

type User {
  id: ID!
  hclId: ID!
  name: String!
  uuid: String!
  email: String!
  Tag: [Tag]!
  Environments: [Environment]!
}

type LaForgePageInfo {
  total: Int!
  nextOffset: Int!
}

type AgentStatusBatch {
  agentStatuses: [AgentStatus]!
  pageInfo: LaForgePageInfo!
}

type StatusBatch {
  statuses: [Status]!
  pageInfo: LaForgePageInfo!
}

type PlanCounts {
  planning: Int!
  awaiting: Int!
  parentAwaiting: Int!
  inProgress: Int!
  failed: Int!
  complete: Int!
  tainted: Int!
  undefined: Int!
  toDelete: Int!
  deleteInProgress: Int!
  deleted: Int!
  toRebuild: Int!
  cancelled: Int!
}

type ServerConfig {
  ConfigFile: String!
  Debug: Boolean
  LogFolder: String!
  GinMode: String!
  Builders: Map!
  Database: DatabaseConfig
  Auth: AuthConfig
  UI: UIConfig
  Agent: AgentConfig
  Graphql: GraphqlConfig
}

type BuilderConfig {
  Builder: String!
  ConfigFile: String!
}

type DatabaseConfig {
  PostgresUri: String!
  AdminUser: String!
  # AdminPass <-- hidden
}

type AuthConfig {
  GithubId: String!
  # GithubSecret <-- hidden
  CookieTimeout: Int!
}

type UIConfig {
  HttpsEnabled: Boolean!
  AllowedOrigins: [String]!
}

type AgentConfig {
  GrpcServerUri: String!
  ApiDownloadUrl: String!
}

type GraphqlConfig {
  Hostname: String!
  RedisServerUri: String!
  # RedisPassword <-- hidden
}

# TODO: Can use on INPUT_FIELD_DEFINITION if wanna have auth on a per variable level
directive @hasRole(roles: [RoleLevel!]!) on FIELD_DEFINITION

type Query {
  environments: [Environment] @hasRole(roles: [ADMIN, USER])
  environment(envUUID: String!): Environment @hasRole(roles: [ADMIN, USER])
  provisionedHost(proHostUUID: String!): ProvisionedHost
    @hasRole(roles: [ADMIN, USER])
  provisionedNetwork(proNetUUID: String!): ProvisionedNetwork
    @hasRole(roles: [ADMIN, USER])
  provisionedStep(proStepUUID: String!): ProvisioningStep
    @hasRole(roles: [ADMIN, USER])
  plan(planUUID: String!): Plan @hasRole(roles: [ADMIN, USER])
  getBuilds: [Build] @hasRole(roles: [ADMIN, USER])
  build(buildUUID: String!): Build @hasRole(roles: [ADMIN, USER])
  getBuildCommits(envUUID: String!): [BuildCommit]
    @hasRole(roles: [ADMIN, USER])
  getBuildCommit(buildCommitUUID: String!): BuildCommit
    @hasRole(roles: [ADMIN, USER])
  status(statusUUID: String!): Status @hasRole(roles: [ADMIN, USER])
  agentStatus(clientId: String!): AgentStatus @hasRole(roles: [ADMIN, USER])
  getServerTasks: [ServerTask] @hasRole(roles: [ADMIN, USER])
  currentUser: AuthUser @hasRole(roles: [ADMIN, USER])
  getUserList: [AuthUser] @hasRole(roles: [ADMIN])
  getCurrentUserTasks: [ServerTask] @hasRole(roles: [ADMIN, USER])
  getAgentTasks(proStepUUID: String, proSchedStepUUID: String): [AgentTask]
    @hasRole(roles: [ADMIN, USER])
  listAgentStatuses(buildUUID: String!): [AgentStatus]
    @hasRole(roles: [ADMIN, USER])
  listBuildStatuses(buildUUID: String!): [Status] @hasRole(roles: [ADMIN, USER])
  getAllAgentStatus(
    buildUUID: String!
    count: Int!
    offset: Int!
  ): AgentStatusBatch @hasRole(roles: [ADMIN, USER])
  getAllPlanStatus(buildUUID: String!, count: Int!, offset: Int!): StatusBatch
    @hasRole(roles: [ADMIN, USER])
  getPlanStatusCounts(buildUUID: String!): PlanCounts!
    @hasRole(roles: [ADMIN, USER])
  viewServerTaskLogs(taskID: String!): String! @hasRole(roles: [ADMIN, USER])
  viewAgentTask(taskID: String!): AgentTask! @hasRole(roles: [ADMIN, USER])
  serverTasks(taskUUIDs: [String]!): [ServerTask] @hasRole(roles: [ADMIN, USER])
  serverConfig: ServerConfig @hasRole(roles: [ADMIN])
}

type Mutation {
  loadEnvironment(envFilePath: String!): [Environment]
    @hasRole(roles: [ADMIN, USER])
  createBuild(envUUID: String!, renderFiles: Boolean! = true): Build
    @hasRole(roles: [ADMIN, USER])
  deleteUser(userUUID: String!): Boolean! @hasRole(roles: [ADMIN, USER])
  executePlan(buildUUID: String!): Build @hasRole(roles: [ADMIN, USER])
  deleteBuild(buildUUID: String!): String! @hasRole(roles: [ADMIN, USER]) # returns the build commit uuid of delete commit
  createTask(
    proHostUUID: String!
    command: AgentCommand!
    args: String!
  ): Boolean! @hasRole(roles: [ADMIN, USER])
  dumpBuild(buildUUID: String!): String! @hasRole(roles: [ADMIN, USER])
  rebuild(rootPlans: [String]!): Boolean! @hasRole(roles: [ADMIN, USER])
  approveCommit(commitUUID: String!): Boolean! @hasRole(roles: [ADMIN, USER])
  cancelCommit(commitUUID: String!): Boolean! @hasRole(roles: [ADMIN, USER])

  # createAdhoc(rootPlans: [AdhocPlan]!): Boolean!

  createAgentTasks(
    hostHCLID: String!
    command: AgentCommand!
    buildUUID: String!
    args: [String!]!
    teams: [Int!]!
  ): [AgentTask]! @hasRole(roles: [ADMIN, USER])

  createBatchAgentTasks(
    proHostUUIDs: [String!]!
    command: AgentCommand!
    args: [String!]!
  ): [AgentTask]! @hasRole(roles: [ADMIN, USER])

  createEnviromentFromRepo(
    repoURL: String!
    branchName: String! = "master"
    envFilePath: String!
  ): [Environment]! @hasRole(roles: [ADMIN, USER])

  updateEnviromentViaPull(envUUID: String!): [Environment]!
    @hasRole(roles: [ADMIN, USER])

  cancelBuild(buildUUID: String!): Boolean! @hasRole(roles: [ADMIN, USER])

  # User Info
  modifySelfPassword(currentPassword: String!, newPassword: String!): Boolean!
    @hasRole(roles: [ADMIN, USER])
  modifySelfUserInfo(
    firstName: String
    lastName: String
    email: String
    phone: String
    company: String
    occupation: String
  ): AuthUser @hasRole(roles: [ADMIN, USER])

  # User Admin Stuff
  createUser(
    username: String!
    password: String!
    role: RoleLevel!
    provider: ProviderType!
  ): AuthUser @hasRole(roles: [ADMIN])
  modifyAdminUserInfo(
    userID: String!
    username: String
    firstName: String
    lastName: String
    email: String
    phone: String
    company: String
    occupation: String
    role: RoleLevel
    provider: ProviderType
  ): AuthUser @hasRole(roles: [ADMIN])
  modifyAdminPassword(userID: String!, newPassword: String!): Boolean!
    @hasRole(roles: [ADMIN])

  nukeBackend: [intMap]! @hasRole(roles: [ADMIN])
}

type Subscription {
  updatedAgentStatus: AgentStatus! @hasRole(roles: [ADMIN, USER])
  updatedStatus: Status! @hasRole(roles: [ADMIN, USER])
  updatedServerTask: ServerTask! @hasRole(roles: [ADMIN, USER])
  updatedBuild: Build! @hasRole(roles: [ADMIN, USER])
  updatedCommit: BuildCommit! @hasRole(roles: [ADMIN, USER])
  updatedAgentTask: AgentTask! @hasRole(roles: [ADMIN, USER])
  streamServerTaskLog(taskID: String!): String! @hasRole(roles: [ADMIN, USER])
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_hasRole_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []model.RoleLevel
	if tmp, ok := rawArgs["roles"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roles"))
		arg0, err = ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["roles"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_approveCommit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["commitUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commitUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["commitUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cancelBuild_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["buildUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_cancelCommit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["commitUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commitUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["commitUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createAgentTasks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["hostHCLID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostHCLID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hostHCLID"] = arg0
	var arg1 model.AgentCommand
	if tmp, ok := rawArgs["command"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("command"))
		arg1, err = ec.unmarshalNAgentCommand2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐAgentCommand(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["command"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["buildUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildUUID"))
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildUUID"] = arg2
	var arg3 []string
	if tmp, ok := rawArgs["args"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("args"))
		arg3, err = ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["args"] = arg3
	var arg4 []int
	if tmp, ok := rawArgs["teams"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("teams"))
		arg4, err = ec.unmarshalNInt2ᚕintᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["teams"] = arg4
	return args, nil
}

func (ec *executionContext) field_Mutation_createBatchAgentTasks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["proHostUUIDs"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proHostUUIDs"))
		arg0, err = ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["proHostUUIDs"] = arg0
	var arg1 model.AgentCommand
	if tmp, ok := rawArgs["command"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("command"))
		arg1, err = ec.unmarshalNAgentCommand2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐAgentCommand(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["command"] = arg1
	var arg2 []string
	if tmp, ok := rawArgs["args"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("args"))
		arg2, err = ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["args"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_createBuild_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["envUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("envUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["envUUID"] = arg0
	var arg1 bool
	if tmp, ok := rawArgs["renderFiles"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("renderFiles"))
		arg1, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["renderFiles"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createEnviromentFromRepo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["repoURL"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoURL"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["repoURL"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["branchName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("branchName"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["branchName"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["envFilePath"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("envFilePath"))
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["envFilePath"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_createTask_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["proHostUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proHostUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["proHostUUID"] = arg0
	var arg1 model.AgentCommand
	if tmp, ok := rawArgs["command"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("command"))
		arg1, err = ec.unmarshalNAgentCommand2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐAgentCommand(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["command"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["args"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("args"))
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["args"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_createUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["username"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["username"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["password"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["password"] = arg1
	var arg2 model.RoleLevel
	if tmp, ok := rawArgs["role"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
		arg2, err = ec.unmarshalNRoleLevel2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevel(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["role"] = arg2
	var arg3 model.ProviderType
	if tmp, ok := rawArgs["provider"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("provider"))
		arg3, err = ec.unmarshalNProviderType2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐProviderType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["provider"] = arg3
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteBuild_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["buildUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteUser_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_dumpBuild_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["buildUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_executePlan_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["buildUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_loadEnvironment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["envFilePath"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("envFilePath"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["envFilePath"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_modifyAdminPassword_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userID"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["newPassword"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newPassword"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["newPassword"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_modifyAdminUserInfo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["userID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userID"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["username"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["username"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["firstName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firstName"))
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["firstName"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["lastName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastName"))
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["lastName"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["email"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["email"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["phone"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("phone"))
		arg5, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["phone"] = arg5
	var arg6 *string
	if tmp, ok := rawArgs["company"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("company"))
		arg6, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["company"] = arg6
	var arg7 *string
	if tmp, ok := rawArgs["occupation"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("occupation"))
		arg7, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["occupation"] = arg7
	var arg8 *model.RoleLevel
	if tmp, ok := rawArgs["role"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
		arg8, err = ec.unmarshalORoleLevel2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevel(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["role"] = arg8
	var arg9 *model.ProviderType
	if tmp, ok := rawArgs["provider"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("provider"))
		arg9, err = ec.unmarshalOProviderType2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐProviderType(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["provider"] = arg9
	return args, nil
}

func (ec *executionContext) field_Mutation_modifySelfPassword_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["currentPassword"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currentPassword"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["currentPassword"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["newPassword"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newPassword"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["newPassword"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_modifySelfUserInfo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["firstName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("firstName"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["firstName"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["lastName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastName"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["lastName"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["email"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["email"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["phone"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("phone"))
		arg3, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["phone"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["company"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("company"))
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["company"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["occupation"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("occupation"))
		arg5, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["occupation"] = arg5
	return args, nil
}

func (ec *executionContext) field_Mutation_rebuild_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*string
	if tmp, ok := rawArgs["rootPlans"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rootPlans"))
		arg0, err = ec.unmarshalNString2ᚕᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["rootPlans"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateEnviromentViaPull_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["envUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("envUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["envUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_agentStatus_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["clientId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_build_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["buildUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_environment_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["envUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("envUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["envUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getAgentTasks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["proStepUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proStepUUID"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["proStepUUID"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["proSchedStepUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proSchedStepUUID"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["proSchedStepUUID"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_getAllAgentStatus_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["buildUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildUUID"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["count"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("count"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["count"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg2, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_getAllPlanStatus_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["buildUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildUUID"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["count"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("count"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["count"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg2, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_getBuildCommit_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["buildCommitUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildCommitUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildCommitUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getBuildCommits_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["envUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("envUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["envUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_getPlanStatusCounts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["buildUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_listAgentStatuses_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["buildUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_listBuildStatuses_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["buildUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_plan_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["planUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("planUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["planUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_provisionedHost_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["proHostUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proHostUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["proHostUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_provisionedNetwork_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["proNetUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proNetUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["proNetUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_provisionedStep_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["proStepUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proStepUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["proStepUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_serverTasks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []*string
	if tmp, ok := rawArgs["taskUUIDs"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskUUIDs"))
		arg0, err = ec.unmarshalNString2ᚕᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskUUIDs"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_status_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["statusUUID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statusUUID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["statusUUID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_viewAgentTask_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_viewServerTaskLogs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_streamServerTaskLog_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskID"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AdhocPlan_id(ctx context.Context, field graphql.CollectedField, obj *ent.AdhocPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdhocPlan_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AdhocPlan().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdhocPlan_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdhocPlan",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdhocPlan_NextAdhocPlans(ctx context.Context, field graphql.CollectedField, obj *ent.AdhocPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdhocPlan_NextAdhocPlans(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextAdhocPlans(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.AdhocPlan)
	fc.Result = res
	return ec.marshalOAdhocPlan2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAdhocPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdhocPlan_NextAdhocPlans(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdhocPlan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AdhocPlan_id(ctx, field)
			case "NextAdhocPlans":
				return ec.fieldContext_AdhocPlan_NextAdhocPlans(ctx, field)
			case "PrevAdhocPlans":
				return ec.fieldContext_AdhocPlan_PrevAdhocPlans(ctx, field)
			case "Build":
				return ec.fieldContext_AdhocPlan_Build(ctx, field)
			case "Status":
				return ec.fieldContext_AdhocPlan_Status(ctx, field)
			case "AgentTask":
				return ec.fieldContext_AdhocPlan_AgentTask(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdhocPlan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdhocPlan_PrevAdhocPlans(ctx context.Context, field graphql.CollectedField, obj *ent.AdhocPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdhocPlan_PrevAdhocPlans(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrevAdhocPlans(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.AdhocPlan)
	fc.Result = res
	return ec.marshalOAdhocPlan2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAdhocPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdhocPlan_PrevAdhocPlans(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdhocPlan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AdhocPlan_id(ctx, field)
			case "NextAdhocPlans":
				return ec.fieldContext_AdhocPlan_NextAdhocPlans(ctx, field)
			case "PrevAdhocPlans":
				return ec.fieldContext_AdhocPlan_PrevAdhocPlans(ctx, field)
			case "Build":
				return ec.fieldContext_AdhocPlan_Build(ctx, field)
			case "Status":
				return ec.fieldContext_AdhocPlan_Status(ctx, field)
			case "AgentTask":
				return ec.fieldContext_AdhocPlan_AgentTask(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdhocPlan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdhocPlan_Build(ctx context.Context, field graphql.CollectedField, obj *ent.AdhocPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdhocPlan_Build(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Build(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Build)
	fc.Result = res
	return ec.marshalNBuild2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdhocPlan_Build(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdhocPlan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdhocPlan_Status(ctx context.Context, field graphql.CollectedField, obj *ent.AdhocPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdhocPlan_Status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Status)
	fc.Result = res
	return ec.marshalNStatus2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdhocPlan_Status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdhocPlan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdhocPlan_AgentTask(ctx context.Context, field graphql.CollectedField, obj *ent.AdhocPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdhocPlan_AgentTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentTask(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.AgentTask)
	fc.Result = res
	return ec.marshalNAgentTask2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdhocPlan_AgentTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdhocPlan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AgentTask_id(ctx, field)
			case "args":
				return ec.fieldContext_AgentTask_args(ctx, field)
			case "command":
				return ec.fieldContext_AgentTask_command(ctx, field)
			case "number":
				return ec.fieldContext_AgentTask_number(ctx, field)
			case "output":
				return ec.fieldContext_AgentTask_output(ctx, field)
			case "state":
				return ec.fieldContext_AgentTask_state(ctx, field)
			case "errorMessage":
				return ec.fieldContext_AgentTask_errorMessage(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_AgentTask_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_AgentTask_ProvisioningScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentTask_ProvisionedHost(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_AgentTask_AdhocPlans(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentConfig_GrpcServerUri(ctx context.Context, field graphql.CollectedField, obj *model.AgentConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentConfig_GrpcServerUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GrpcServerURI, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentConfig_GrpcServerUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentConfig_ApiDownloadUrl(ctx context.Context, field graphql.CollectedField, obj *model.AgentConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentConfig_ApiDownloadUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIDownloadURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentConfig_ApiDownloadUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_clientId(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_clientId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_clientId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_hostname(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_hostname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hostname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_hostname(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_upTime(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_upTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_upTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_bootTime(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_bootTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BootTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_bootTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_numProcs(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_numProcs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumProcs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_numProcs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_OS(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_OS(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Os, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_OS(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_hostID(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_hostID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_hostID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_load1(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_load1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Load1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_load1(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_load5(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_load5(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Load5, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_load5(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_load15(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_load15(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Load15, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_load15(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_totalMem(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_totalMem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalMem, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_totalMem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_freeMem(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_freeMem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FreeMem, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_freeMem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_usedMem(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_usedMem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UsedMem, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_usedMem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_timestamp(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_ProvisionedHost(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_ProvisionedHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedHost(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedHost)
	fc.Result = res
	return ec.marshalOProvisionedHost2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisionedHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_ProvisionedHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedHost_id(ctx, field)
			case "subnetIp":
				return ec.fieldContext_ProvisionedHost_subnetIp(ctx, field)
			case "addonType":
				return ec.fieldContext_ProvisionedHost_addonType(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedHost_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedHost_Status(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_ProvisionedHost_ProvisionedNetwork(ctx, field)
			case "Host":
				return ec.fieldContext_ProvisionedHost_Host(ctx, field)
			case "EndStepPlan":
				return ec.fieldContext_ProvisionedHost_EndStepPlan(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedHost_Build(ctx, field)
			case "ProvisioningSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningSteps(ctx, field)
			case "ProvisioningScheduledSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningScheduledSteps(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_ProvisionedHost_AgentStatuses(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisionedHost_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedHost_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisionedHost_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedHost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_ProvisionedNetwork(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_ProvisionedNetwork(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedNetwork(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedNetwork)
	fc.Result = res
	return ec.marshalOProvisionedNetwork2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisionedNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_ProvisionedNetwork(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedNetwork_id(ctx, field)
			case "name":
				return ec.fieldContext_ProvisionedNetwork_name(ctx, field)
			case "cidr":
				return ec.fieldContext_ProvisionedNetwork_cidr(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedNetwork_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedNetwork_Status(ctx, field)
			case "Network":
				return ec.fieldContext_ProvisionedNetwork_Network(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedNetwork_Build(ctx, field)
			case "Team":
				return ec.fieldContext_ProvisionedNetwork_Team(ctx, field)
			case "ProvisionedHosts":
				return ec.fieldContext_ProvisionedNetwork_ProvisionedHosts(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedNetwork_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedNetwork", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatus_Build(ctx context.Context, field graphql.CollectedField, obj *ent.AgentStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatus_Build(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Build(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Build)
	fc.Result = res
	return ec.marshalOBuild2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatus_Build(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatus",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatusBatch_agentStatuses(ctx context.Context, field graphql.CollectedField, obj *model.AgentStatusBatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatusBatch_agentStatuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentStatuses, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.AgentStatus)
	fc.Result = res
	return ec.marshalNAgentStatus2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatusBatch_agentStatuses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatusBatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "clientId":
				return ec.fieldContext_AgentStatus_clientId(ctx, field)
			case "hostname":
				return ec.fieldContext_AgentStatus_hostname(ctx, field)
			case "upTime":
				return ec.fieldContext_AgentStatus_upTime(ctx, field)
			case "bootTime":
				return ec.fieldContext_AgentStatus_bootTime(ctx, field)
			case "numProcs":
				return ec.fieldContext_AgentStatus_numProcs(ctx, field)
			case "OS":
				return ec.fieldContext_AgentStatus_OS(ctx, field)
			case "hostID":
				return ec.fieldContext_AgentStatus_hostID(ctx, field)
			case "load1":
				return ec.fieldContext_AgentStatus_load1(ctx, field)
			case "load5":
				return ec.fieldContext_AgentStatus_load5(ctx, field)
			case "load15":
				return ec.fieldContext_AgentStatus_load15(ctx, field)
			case "totalMem":
				return ec.fieldContext_AgentStatus_totalMem(ctx, field)
			case "freeMem":
				return ec.fieldContext_AgentStatus_freeMem(ctx, field)
			case "usedMem":
				return ec.fieldContext_AgentStatus_usedMem(ctx, field)
			case "timestamp":
				return ec.fieldContext_AgentStatus_timestamp(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentStatus_ProvisionedHost(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_AgentStatus_ProvisionedNetwork(ctx, field)
			case "Build":
				return ec.fieldContext_AgentStatus_Build(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentStatusBatch_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.AgentStatusBatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentStatusBatch_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.LaForgePageInfo)
	fc.Result = res
	return ec.marshalNLaForgePageInfo2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐLaForgePageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentStatusBatch_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentStatusBatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_LaForgePageInfo_total(ctx, field)
			case "nextOffset":
				return ec.fieldContext_LaForgePageInfo_nextOffset(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LaForgePageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentTask_id(ctx context.Context, field graphql.CollectedField, obj *ent.AgentTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentTask_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AgentTask().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentTask_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentTask_args(ctx context.Context, field graphql.CollectedField, obj *ent.AgentTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentTask_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentTask_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentTask_command(ctx context.Context, field graphql.CollectedField, obj *ent.AgentTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentTask_command(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AgentTask().Command(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AgentCommand)
	fc.Result = res
	return ec.marshalNAgentCommand2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐAgentCommand(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentTask_command(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AgentCommand does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentTask_number(ctx context.Context, field graphql.CollectedField, obj *ent.AgentTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentTask_number(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Number, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentTask_number(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentTask_output(ctx context.Context, field graphql.CollectedField, obj *ent.AgentTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentTask_output(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Output, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentTask_output(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentTask_state(ctx context.Context, field graphql.CollectedField, obj *ent.AgentTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentTask_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AgentTask().State(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AgentTaskState)
	fc.Result = res
	return ec.marshalNAgentTaskState2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐAgentTaskState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentTask_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AgentTaskState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentTask_errorMessage(ctx context.Context, field graphql.CollectedField, obj *ent.AgentTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentTask_errorMessage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorMessage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentTask_errorMessage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentTask_ProvisioningStep(ctx context.Context, field graphql.CollectedField, obj *ent.AgentTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentTask_ProvisioningStep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisioningStep(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisioningStep)
	fc.Result = res
	return ec.marshalOProvisioningStep2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisioningStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentTask_ProvisioningStep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisioningStep_id(ctx, field)
			case "type":
				return ec.fieldContext_ProvisioningStep_type(ctx, field)
			case "stepNumber":
				return ec.fieldContext_ProvisioningStep_stepNumber(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisioningStep_Status(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_ProvisioningStep_ProvisionedHost(ctx, field)
			case "Script":
				return ec.fieldContext_ProvisioningStep_Script(ctx, field)
			case "Command":
				return ec.fieldContext_ProvisioningStep_Command(ctx, field)
			case "DNSRecord":
				return ec.fieldContext_ProvisioningStep_DNSRecord(ctx, field)
			case "FileDelete":
				return ec.fieldContext_ProvisioningStep_FileDelete(ctx, field)
			case "FileDownload":
				return ec.fieldContext_ProvisioningStep_FileDownload(ctx, field)
			case "FileExtract":
				return ec.fieldContext_ProvisioningStep_FileExtract(ctx, field)
			case "Ansible":
				return ec.fieldContext_ProvisioningStep_Ansible(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisioningStep_Plan(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisioningStep_AgentTasks(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisioningStep_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisioningStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentTask_ProvisioningScheduledStep(ctx context.Context, field graphql.CollectedField, obj *ent.AgentTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentTask_ProvisioningScheduledStep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisioningScheduledStep(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisioningScheduledStep)
	fc.Result = res
	return ec.marshalOProvisioningScheduledStep2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisioningScheduledStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentTask_ProvisioningScheduledStep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisioningScheduledStep_id(ctx, field)
			case "type":
				return ec.fieldContext_ProvisioningScheduledStep_type(ctx, field)
			case "runTime":
				return ec.fieldContext_ProvisioningScheduledStep_runTime(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisioningScheduledStep_Status(ctx, field)
			case "ScheduledStep":
				return ec.fieldContext_ProvisioningScheduledStep_ScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_ProvisioningScheduledStep_ProvisionedHost(ctx, field)
			case "Script":
				return ec.fieldContext_ProvisioningScheduledStep_Script(ctx, field)
			case "Command":
				return ec.fieldContext_ProvisioningScheduledStep_Command(ctx, field)
			case "DNSRecord":
				return ec.fieldContext_ProvisioningScheduledStep_DNSRecord(ctx, field)
			case "FileDelete":
				return ec.fieldContext_ProvisioningScheduledStep_FileDelete(ctx, field)
			case "FileDownload":
				return ec.fieldContext_ProvisioningScheduledStep_FileDownload(ctx, field)
			case "FileExtract":
				return ec.fieldContext_ProvisioningScheduledStep_FileExtract(ctx, field)
			case "Ansible":
				return ec.fieldContext_ProvisioningScheduledStep_Ansible(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisioningScheduledStep_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisioningScheduledStep_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisioningScheduledStep_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisioningScheduledStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentTask_ProvisionedHost(ctx context.Context, field graphql.CollectedField, obj *ent.AgentTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentTask_ProvisionedHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedHost(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedHost)
	fc.Result = res
	return ec.marshalNProvisionedHost2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisionedHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentTask_ProvisionedHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedHost_id(ctx, field)
			case "subnetIp":
				return ec.fieldContext_ProvisionedHost_subnetIp(ctx, field)
			case "addonType":
				return ec.fieldContext_ProvisionedHost_addonType(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedHost_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedHost_Status(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_ProvisionedHost_ProvisionedNetwork(ctx, field)
			case "Host":
				return ec.fieldContext_ProvisionedHost_Host(ctx, field)
			case "EndStepPlan":
				return ec.fieldContext_ProvisionedHost_EndStepPlan(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedHost_Build(ctx, field)
			case "ProvisioningSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningSteps(ctx, field)
			case "ProvisioningScheduledSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningScheduledSteps(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_ProvisionedHost_AgentStatuses(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisionedHost_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedHost_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisionedHost_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedHost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgentTask_AdhocPlans(ctx context.Context, field graphql.CollectedField, obj *ent.AgentTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgentTask_AdhocPlans(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdhocPlans(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.AdhocPlan)
	fc.Result = res
	return ec.marshalOAdhocPlan2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAdhocPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgentTask_AdhocPlans(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgentTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AdhocPlan_id(ctx, field)
			case "NextAdhocPlans":
				return ec.fieldContext_AdhocPlan_NextAdhocPlans(ctx, field)
			case "PrevAdhocPlans":
				return ec.fieldContext_AdhocPlan_PrevAdhocPlans(ctx, field)
			case "Build":
				return ec.fieldContext_AdhocPlan_Build(ctx, field)
			case "Status":
				return ec.fieldContext_AdhocPlan_Status(ctx, field)
			case "AgentTask":
				return ec.fieldContext_AdhocPlan_AgentTask(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdhocPlan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ansible_id(ctx context.Context, field graphql.CollectedField, obj *ent.Ansible) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ansible_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Ansible().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ansible_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ansible",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ansible_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.Ansible) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ansible_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ansible_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ansible",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ansible_name(ctx context.Context, field graphql.CollectedField, obj *ent.Ansible) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ansible_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ansible_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ansible",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ansible_description(ctx context.Context, field graphql.CollectedField, obj *ent.Ansible) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ansible_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ansible_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ansible",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ansible_source(ctx context.Context, field graphql.CollectedField, obj *ent.Ansible) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ansible_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ansible_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ansible",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ansible_playbookName(ctx context.Context, field graphql.CollectedField, obj *ent.Ansible) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ansible_playbookName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlaybookName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ansible_playbookName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ansible",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ansible_method(ctx context.Context, field graphql.CollectedField, obj *ent.Ansible) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ansible_method(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Ansible().Method(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AnsibleMethod)
	fc.Result = res
	return ec.marshalNAnsibleMethod2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐAnsibleMethod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ansible_method(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ansible",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AnsibleMethod does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ansible_inventory(ctx context.Context, field graphql.CollectedField, obj *ent.Ansible) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ansible_inventory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Inventory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ansible_inventory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ansible",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ansible_absPath(ctx context.Context, field graphql.CollectedField, obj *ent.Ansible) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ansible_absPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AbsPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ansible_absPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ansible",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ansible_tags(ctx context.Context, field graphql.CollectedField, obj *ent.Ansible) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ansible_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Ansible().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalOtagMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ansible_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ansible",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ansible_Users(ctx context.Context, field graphql.CollectedField, obj *ent.Ansible) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ansible_Users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.User)
	fc.Result = res
	return ec.marshalOUser2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ansible_Users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ansible",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "hclId":
				return ec.fieldContext_User_hclId(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "uuid":
				return ec.fieldContext_User_uuid(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "Tag":
				return ec.fieldContext_User_Tag(ctx, field)
			case "Environments":
				return ec.fieldContext_User_Environments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Ansible_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.Ansible) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Ansible_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalOEnvironment2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Ansible_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Ansible",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthConfig_GithubId(ctx context.Context, field graphql.CollectedField, obj *model.AuthConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthConfig_GithubId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthConfig_GithubId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthConfig_CookieTimeout(ctx context.Context, field graphql.CollectedField, obj *model.AuthConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthConfig_CookieTimeout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CookieTimeout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthConfig_CookieTimeout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_id(ctx context.Context, field graphql.CollectedField, obj *ent.AuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AuthUser().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_username(ctx context.Context, field graphql.CollectedField, obj *ent.AuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_username(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_firstName(ctx context.Context, field graphql.CollectedField, obj *ent.AuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_firstName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FirstName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_firstName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_lastName(ctx context.Context, field graphql.CollectedField, obj *ent.AuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_lastName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_lastName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_email(ctx context.Context, field graphql.CollectedField, obj *ent.AuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_phone(ctx context.Context, field graphql.CollectedField, obj *ent.AuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_phone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_phone(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_company(ctx context.Context, field graphql.CollectedField, obj *ent.AuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_company(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Company, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_company(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_occupation(ctx context.Context, field graphql.CollectedField, obj *ent.AuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_occupation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Occupation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_occupation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_publicKey(ctx context.Context, field graphql.CollectedField, obj *ent.AuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_publicKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AuthUser().PublicKey(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_publicKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_role(ctx context.Context, field graphql.CollectedField, obj *ent.AuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_role(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AuthUser().Role(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.RoleLevel)
	fc.Result = res
	return ec.marshalNRoleLevel2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_role(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RoleLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_provider(ctx context.Context, field graphql.CollectedField, obj *ent.AuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_provider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AuthUser().Provider(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ProviderType)
	fc.Result = res
	return ec.marshalNProviderType2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐProviderType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_provider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProviderType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_ServerTasks(ctx context.Context, field graphql.CollectedField, obj *ent.AuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_ServerTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServerTasks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ServerTask)
	fc.Result = res
	return ec.marshalOServerTask2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐServerTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_ServerTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServerTask_id(ctx, field)
			case "type":
				return ec.fieldContext_ServerTask_type(ctx, field)
			case "startTime":
				return ec.fieldContext_ServerTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ServerTask_endTime(ctx, field)
			case "errors":
				return ec.fieldContext_ServerTask_errors(ctx, field)
			case "logFilePath":
				return ec.fieldContext_ServerTask_logFilePath(ctx, field)
			case "AuthUser":
				return ec.fieldContext_ServerTask_AuthUser(ctx, field)
			case "Status":
				return ec.fieldContext_ServerTask_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_ServerTask_Environment(ctx, field)
			case "Build":
				return ec.fieldContext_ServerTask_Build(ctx, field)
			case "BuildCommit":
				return ec.fieldContext_ServerTask_BuildCommit(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ServerTask_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServerTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_id(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Build().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_revision(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_revision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_environmentRevision(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_environmentRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnvironmentRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_environmentRevision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_completedPlan(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_completedPlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompletedPlan, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_completedPlan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_Status(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_Status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Status)
	fc.Result = res
	return ec.marshalNStatus2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_Status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_Competition(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_Competition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Competition(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Competition)
	fc.Result = res
	return ec.marshalNCompetition2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐCompetition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_Competition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Competition_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Competition_hclId(ctx, field)
			case "rootPassword":
				return ec.fieldContext_Competition_rootPassword(ctx, field)
			case "startTime":
				return ec.fieldContext_Competition_startTime(ctx, field)
			case "stopTime":
				return ec.fieldContext_Competition_stopTime(ctx, field)
			case "config":
				return ec.fieldContext_Competition_config(ctx, field)
			case "tags":
				return ec.fieldContext_Competition_tags(ctx, field)
			case "DNS":
				return ec.fieldContext_Competition_DNS(ctx, field)
			case "Environment":
				return ec.fieldContext_Competition_Environment(ctx, field)
			case "Builds":
				return ec.fieldContext_Competition_Builds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Competition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_LatestBuildCommit(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_LatestBuildCommit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestBuildCommit(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.BuildCommit)
	fc.Result = res
	return ec.marshalOBuildCommit2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuildCommit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_LatestBuildCommit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BuildCommit_id(ctx, field)
			case "type":
				return ec.fieldContext_BuildCommit_type(ctx, field)
			case "revision":
				return ec.fieldContext_BuildCommit_revision(ctx, field)
			case "state":
				return ec.fieldContext_BuildCommit_state(ctx, field)
			case "createdAt":
				return ec.fieldContext_BuildCommit_createdAt(ctx, field)
			case "Build":
				return ec.fieldContext_BuildCommit_Build(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_BuildCommit_ServerTasks(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_BuildCommit_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildCommit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_RepoCommit(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_RepoCommit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoCommit(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.RepoCommit)
	fc.Result = res
	return ec.marshalNRepoCommit2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐRepoCommit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_RepoCommit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RepoCommit_id(ctx, field)
			case "revision":
				return ec.fieldContext_RepoCommit_revision(ctx, field)
			case "hash":
				return ec.fieldContext_RepoCommit_hash(ctx, field)
			case "author":
				return ec.fieldContext_RepoCommit_author(ctx, field)
			case "committer":
				return ec.fieldContext_RepoCommit_committer(ctx, field)
			case "pgpSignature":
				return ec.fieldContext_RepoCommit_pgpSignature(ctx, field)
			case "message":
				return ec.fieldContext_RepoCommit_message(ctx, field)
			case "treeHash":
				return ec.fieldContext_RepoCommit_treeHash(ctx, field)
			case "parentHashes":
				return ec.fieldContext_RepoCommit_parentHashes(ctx, field)
			case "Repository":
				return ec.fieldContext_RepoCommit_Repository(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoCommit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_ProvisionedNetworks(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedNetworks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ProvisionedNetwork)
	fc.Result = res
	return ec.marshalNProvisionedNetwork2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisionedNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_ProvisionedNetworks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedNetwork_id(ctx, field)
			case "name":
				return ec.fieldContext_ProvisionedNetwork_name(ctx, field)
			case "cidr":
				return ec.fieldContext_ProvisionedNetwork_cidr(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedNetwork_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedNetwork_Status(ctx, field)
			case "Network":
				return ec.fieldContext_ProvisionedNetwork_Network(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedNetwork_Build(ctx, field)
			case "Team":
				return ec.fieldContext_ProvisionedNetwork_Team(ctx, field)
			case "ProvisionedHosts":
				return ec.fieldContext_ProvisionedNetwork_ProvisionedHosts(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedNetwork_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedNetwork", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_Teams(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_Teams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Teams(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Team)
	fc.Result = res
	return ec.marshalNTeam2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_Teams(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "teamNumber":
				return ec.fieldContext_Team_teamNumber(ctx, field)
			case "Build":
				return ec.fieldContext_Team_Build(ctx, field)
			case "Status":
				return ec.fieldContext_Team_Status(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Team_ProvisionedNetworks(ctx, field)
			case "Plan":
				return ec.fieldContext_Team_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_Plans(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_Plans(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plans(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Plan)
	fc.Result = res
	return ec.marshalNPlan2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_Plans(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Plan_id(ctx, field)
			case "stepNumber":
				return ec.fieldContext_Plan_stepNumber(ctx, field)
			case "type":
				return ec.fieldContext_Plan_type(ctx, field)
			case "NextPlans":
				return ec.fieldContext_Plan_NextPlans(ctx, field)
			case "PrevPlans":
				return ec.fieldContext_Plan_PrevPlans(ctx, field)
			case "Build":
				return ec.fieldContext_Plan_Build(ctx, field)
			case "Team":
				return ec.fieldContext_Plan_Team(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Plan_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Plan_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
			case "Status":
				return ec.fieldContext_Plan_Status(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_Plan_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Plan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_BuildCommits(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_BuildCommits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildCommits(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.BuildCommit)
	fc.Result = res
	return ec.marshalNBuildCommit2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuildCommit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_BuildCommits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BuildCommit_id(ctx, field)
			case "type":
				return ec.fieldContext_BuildCommit_type(ctx, field)
			case "revision":
				return ec.fieldContext_BuildCommit_revision(ctx, field)
			case "state":
				return ec.fieldContext_BuildCommit_state(ctx, field)
			case "createdAt":
				return ec.fieldContext_BuildCommit_createdAt(ctx, field)
			case "Build":
				return ec.fieldContext_BuildCommit_Build(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_BuildCommit_ServerTasks(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_BuildCommit_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildCommit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_AdhocPlans(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_AdhocPlans(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdhocPlans(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.AdhocPlan)
	fc.Result = res
	return ec.marshalNAdhocPlan2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAdhocPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_AdhocPlans(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AdhocPlan_id(ctx, field)
			case "NextAdhocPlans":
				return ec.fieldContext_AdhocPlan_NextAdhocPlans(ctx, field)
			case "PrevAdhocPlans":
				return ec.fieldContext_AdhocPlan_PrevAdhocPlans(ctx, field)
			case "Build":
				return ec.fieldContext_AdhocPlan_Build(ctx, field)
			case "Status":
				return ec.fieldContext_AdhocPlan_Status(ctx, field)
			case "AgentTask":
				return ec.fieldContext_AdhocPlan_AgentTask(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdhocPlan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_AgentStatuses(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_AgentStatuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentStatuses(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.AgentStatus)
	fc.Result = res
	return ec.marshalNAgentStatus2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_AgentStatuses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "clientId":
				return ec.fieldContext_AgentStatus_clientId(ctx, field)
			case "hostname":
				return ec.fieldContext_AgentStatus_hostname(ctx, field)
			case "upTime":
				return ec.fieldContext_AgentStatus_upTime(ctx, field)
			case "bootTime":
				return ec.fieldContext_AgentStatus_bootTime(ctx, field)
			case "numProcs":
				return ec.fieldContext_AgentStatus_numProcs(ctx, field)
			case "OS":
				return ec.fieldContext_AgentStatus_OS(ctx, field)
			case "hostID":
				return ec.fieldContext_AgentStatus_hostID(ctx, field)
			case "load1":
				return ec.fieldContext_AgentStatus_load1(ctx, field)
			case "load5":
				return ec.fieldContext_AgentStatus_load5(ctx, field)
			case "load15":
				return ec.fieldContext_AgentStatus_load15(ctx, field)
			case "totalMem":
				return ec.fieldContext_AgentStatus_totalMem(ctx, field)
			case "freeMem":
				return ec.fieldContext_AgentStatus_freeMem(ctx, field)
			case "usedMem":
				return ec.fieldContext_AgentStatus_usedMem(ctx, field)
			case "timestamp":
				return ec.fieldContext_AgentStatus_timestamp(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentStatus_ProvisionedHost(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_AgentStatus_ProvisionedNetwork(ctx, field)
			case "Build":
				return ec.fieldContext_AgentStatus_Build(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_ServerTasks(ctx context.Context, field graphql.CollectedField, obj *ent.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_ServerTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServerTasks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ServerTask)
	fc.Result = res
	return ec.marshalNServerTask2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐServerTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_ServerTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServerTask_id(ctx, field)
			case "type":
				return ec.fieldContext_ServerTask_type(ctx, field)
			case "startTime":
				return ec.fieldContext_ServerTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ServerTask_endTime(ctx, field)
			case "errors":
				return ec.fieldContext_ServerTask_errors(ctx, field)
			case "logFilePath":
				return ec.fieldContext_ServerTask_logFilePath(ctx, field)
			case "AuthUser":
				return ec.fieldContext_ServerTask_AuthUser(ctx, field)
			case "Status":
				return ec.fieldContext_ServerTask_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_ServerTask_Environment(ctx, field)
			case "Build":
				return ec.fieldContext_ServerTask_Build(ctx, field)
			case "BuildCommit":
				return ec.fieldContext_ServerTask_BuildCommit(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ServerTask_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServerTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCommit_id(ctx context.Context, field graphql.CollectedField, obj *ent.BuildCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCommit_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BuildCommit().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCommit_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCommit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCommit_type(ctx context.Context, field graphql.CollectedField, obj *ent.BuildCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCommit_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BuildCommit().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.BuildCommitType)
	fc.Result = res
	return ec.marshalNBuildCommitType2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐBuildCommitType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCommit_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCommit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BuildCommitType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCommit_revision(ctx context.Context, field graphql.CollectedField, obj *ent.BuildCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCommit_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCommit_revision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCommit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCommit_state(ctx context.Context, field graphql.CollectedField, obj *ent.BuildCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCommit_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BuildCommit().State(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.BuildCommitState)
	fc.Result = res
	return ec.marshalNBuildCommitState2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐBuildCommitState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCommit_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCommit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BuildCommitState does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCommit_createdAt(ctx context.Context, field graphql.CollectedField, obj *ent.BuildCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCommit_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCommit_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCommit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCommit_Build(ctx context.Context, field graphql.CollectedField, obj *ent.BuildCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCommit_Build(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Build(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Build)
	fc.Result = res
	return ec.marshalNBuild2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCommit_Build(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCommit",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCommit_ServerTasks(ctx context.Context, field graphql.CollectedField, obj *ent.BuildCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCommit_ServerTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServerTasks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ServerTask)
	fc.Result = res
	return ec.marshalNServerTask2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐServerTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCommit_ServerTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCommit",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServerTask_id(ctx, field)
			case "type":
				return ec.fieldContext_ServerTask_type(ctx, field)
			case "startTime":
				return ec.fieldContext_ServerTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ServerTask_endTime(ctx, field)
			case "errors":
				return ec.fieldContext_ServerTask_errors(ctx, field)
			case "logFilePath":
				return ec.fieldContext_ServerTask_logFilePath(ctx, field)
			case "AuthUser":
				return ec.fieldContext_ServerTask_AuthUser(ctx, field)
			case "Status":
				return ec.fieldContext_ServerTask_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_ServerTask_Environment(ctx, field)
			case "Build":
				return ec.fieldContext_ServerTask_Build(ctx, field)
			case "BuildCommit":
				return ec.fieldContext_ServerTask_BuildCommit(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ServerTask_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServerTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildCommit_PlanDiffs(ctx context.Context, field graphql.CollectedField, obj *ent.BuildCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildCommit_PlanDiffs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlanDiffs(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.PlanDiff)
	fc.Result = res
	return ec.marshalNPlanDiff2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐPlanDiff(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildCommit_PlanDiffs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildCommit",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PlanDiff_id(ctx, field)
			case "revision":
				return ec.fieldContext_PlanDiff_revision(ctx, field)
			case "newState":
				return ec.fieldContext_PlanDiff_newState(ctx, field)
			case "BuildCommit":
				return ec.fieldContext_PlanDiff_BuildCommit(ctx, field)
			case "Plan":
				return ec.fieldContext_PlanDiff_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlanDiff", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuilderConfig_Builder(ctx context.Context, field graphql.CollectedField, obj *model.BuilderConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuilderConfig_Builder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Builder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuilderConfig_Builder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuilderConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuilderConfig_ConfigFile(ctx context.Context, field graphql.CollectedField, obj *model.BuilderConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuilderConfig_ConfigFile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfigFile, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuilderConfig_ConfigFile(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuilderConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_id(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Command().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_name(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_description(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_program(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_program(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Program, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_program(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_args(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_ignoreErrors(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_ignoreErrors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IgnoreErrors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_ignoreErrors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_disabled(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_disabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_cooldown(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_cooldown(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cooldown, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_cooldown(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_timeout(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_timeout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timeout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_timeout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_vars(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Command().Vars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.VarsMap)
	fc.Result = res
	return ec.marshalOvarsMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐVarsMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_vars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_varsMap_key(ctx, field)
			case "value":
				return ec.fieldContext_varsMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type varsMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_tags(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Command().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalOtagMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_Users(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_Users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.User)
	fc.Result = res
	return ec.marshalNUser2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_Users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "hclId":
				return ec.fieldContext_User_hclId(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "uuid":
				return ec.fieldContext_User_uuid(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "Tag":
				return ec.fieldContext_User_Tag(ctx, field)
			case "Environments":
				return ec.fieldContext_User_Environments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Command_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.Command) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Command_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Command_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Command",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Competition_id(ctx context.Context, field graphql.CollectedField, obj *ent.Competition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Competition_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Competition().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Competition_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Competition",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Competition_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.Competition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Competition_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Competition_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Competition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Competition_rootPassword(ctx context.Context, field graphql.CollectedField, obj *ent.Competition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Competition_rootPassword(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RootPassword, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Competition_rootPassword(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Competition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Competition_startTime(ctx context.Context, field graphql.CollectedField, obj *ent.Competition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Competition_startTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Competition_startTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Competition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Competition_stopTime(ctx context.Context, field graphql.CollectedField, obj *ent.Competition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Competition_stopTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Competition_stopTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Competition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Competition_config(ctx context.Context, field graphql.CollectedField, obj *ent.Competition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Competition_config(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Competition().Config(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ConfigMap)
	fc.Result = res
	return ec.marshalOconfigMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐConfigMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Competition_config(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Competition",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_configMap_key(ctx, field)
			case "value":
				return ec.fieldContext_configMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type configMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Competition_tags(ctx context.Context, field graphql.CollectedField, obj *ent.Competition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Competition_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Competition().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalOtagMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Competition_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Competition",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Competition_DNS(ctx context.Context, field graphql.CollectedField, obj *ent.Competition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Competition_DNS(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DNS(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.DNS)
	fc.Result = res
	return ec.marshalNDNS2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐDNS(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Competition_DNS(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Competition",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DNS_id(ctx, field)
			case "hclId":
				return ec.fieldContext_DNS_hclId(ctx, field)
			case "type":
				return ec.fieldContext_DNS_type(ctx, field)
			case "rootDomain":
				return ec.fieldContext_DNS_rootDomain(ctx, field)
			case "dnsServers":
				return ec.fieldContext_DNS_dnsServers(ctx, field)
			case "ntpServers":
				return ec.fieldContext_DNS_ntpServers(ctx, field)
			case "config":
				return ec.fieldContext_DNS_config(ctx, field)
			case "Environments":
				return ec.fieldContext_DNS_Environments(ctx, field)
			case "Competitions":
				return ec.fieldContext_DNS_Competitions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DNS", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Competition_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.Competition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Competition_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Competition_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Competition",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Competition_Builds(ctx context.Context, field graphql.CollectedField, obj *ent.Competition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Competition_Builds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Builds(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Build)
	fc.Result = res
	return ec.marshalNBuild2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Competition_Builds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Competition",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNS_id(ctx context.Context, field graphql.CollectedField, obj *ent.DNS) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNS_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DNS().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNS_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNS",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNS_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.DNS) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNS_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNS_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNS",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNS_type(ctx context.Context, field graphql.CollectedField, obj *ent.DNS) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNS_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNS_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNS",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNS_rootDomain(ctx context.Context, field graphql.CollectedField, obj *ent.DNS) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNS_rootDomain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RootDomain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNS_rootDomain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNS",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNS_dnsServers(ctx context.Context, field graphql.CollectedField, obj *ent.DNS) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNS_dnsServers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DNSServers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNS_dnsServers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNS",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNS_ntpServers(ctx context.Context, field graphql.CollectedField, obj *ent.DNS) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNS_ntpServers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NtpServers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNS_ntpServers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNS",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNS_config(ctx context.Context, field graphql.CollectedField, obj *ent.DNS) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNS_config(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DNS().Config(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ConfigMap)
	fc.Result = res
	return ec.marshalOconfigMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐConfigMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNS_config(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNS",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_configMap_key(ctx, field)
			case "value":
				return ec.fieldContext_configMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type configMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNS_Environments(ctx context.Context, field graphql.CollectedField, obj *ent.DNS) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNS_Environments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environments(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNS_Environments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNS",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNS_Competitions(ctx context.Context, field graphql.CollectedField, obj *ent.DNS) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNS_Competitions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Competitions(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Competition)
	fc.Result = res
	return ec.marshalNCompetition2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐCompetition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNS_Competitions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNS",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Competition_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Competition_hclId(ctx, field)
			case "rootPassword":
				return ec.fieldContext_Competition_rootPassword(ctx, field)
			case "startTime":
				return ec.fieldContext_Competition_startTime(ctx, field)
			case "stopTime":
				return ec.fieldContext_Competition_stopTime(ctx, field)
			case "config":
				return ec.fieldContext_Competition_config(ctx, field)
			case "tags":
				return ec.fieldContext_Competition_tags(ctx, field)
			case "DNS":
				return ec.fieldContext_Competition_DNS(ctx, field)
			case "Environment":
				return ec.fieldContext_Competition_Environment(ctx, field)
			case "Builds":
				return ec.fieldContext_Competition_Builds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Competition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNSRecord_id(ctx context.Context, field graphql.CollectedField, obj *ent.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNSRecord_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DNSRecord().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNSRecord_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNSRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNSRecord_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNSRecord_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNSRecord_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNSRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNSRecord_name(ctx context.Context, field graphql.CollectedField, obj *ent.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNSRecord_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNSRecord_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNSRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNSRecord_values(ctx context.Context, field graphql.CollectedField, obj *ent.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNSRecord_values(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Values, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNSRecord_values(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNSRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNSRecord_type(ctx context.Context, field graphql.CollectedField, obj *ent.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNSRecord_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNSRecord_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNSRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNSRecord_zone(ctx context.Context, field graphql.CollectedField, obj *ent.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNSRecord_zone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Zone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNSRecord_zone(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNSRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNSRecord_vars(ctx context.Context, field graphql.CollectedField, obj *ent.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNSRecord_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DNSRecord().Vars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.VarsMap)
	fc.Result = res
	return ec.marshalNvarsMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐVarsMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNSRecord_vars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNSRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_varsMap_key(ctx, field)
			case "value":
				return ec.fieldContext_varsMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type varsMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNSRecord_disabled(ctx context.Context, field graphql.CollectedField, obj *ent.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNSRecord_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNSRecord_disabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNSRecord",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNSRecord_tags(ctx context.Context, field graphql.CollectedField, obj *ent.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNSRecord_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DNSRecord().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalNtagMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNSRecord_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNSRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DNSRecord_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.DNSRecord) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DNSRecord_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DNSRecord_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DNSRecord",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DatabaseConfig_PostgresUri(ctx context.Context, field graphql.CollectedField, obj *model.DatabaseConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DatabaseConfig_PostgresUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PostgresURI, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DatabaseConfig_PostgresUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatabaseConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DatabaseConfig_AdminUser(ctx context.Context, field graphql.CollectedField, obj *model.DatabaseConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DatabaseConfig_AdminUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdminUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DatabaseConfig_AdminUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DatabaseConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Disk_id(ctx context.Context, field graphql.CollectedField, obj *ent.Disk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Disk_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Disk().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Disk_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Disk",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Disk_size(ctx context.Context, field graphql.CollectedField, obj *ent.Disk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Disk_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Disk_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Disk",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Disk_Host(ctx context.Context, field graphql.CollectedField, obj *ent.Disk) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Disk_Host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Host(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Host)
	fc.Result = res
	return ec.marshalNHost2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Disk_Host(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Disk",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Host_hclId(ctx, field)
			case "hostname":
				return ec.fieldContext_Host_hostname(ctx, field)
			case "description":
				return ec.fieldContext_Host_description(ctx, field)
			case "OS":
				return ec.fieldContext_Host_OS(ctx, field)
			case "lastOctet":
				return ec.fieldContext_Host_lastOctet(ctx, field)
			case "instanceSize":
				return ec.fieldContext_Host_instanceSize(ctx, field)
			case "allowMacChanges":
				return ec.fieldContext_Host_allowMacChanges(ctx, field)
			case "exposedTcpPorts":
				return ec.fieldContext_Host_exposedTcpPorts(ctx, field)
			case "exposedUdpPorts":
				return ec.fieldContext_Host_exposedUdpPorts(ctx, field)
			case "overridePassword":
				return ec.fieldContext_Host_overridePassword(ctx, field)
			case "vars":
				return ec.fieldContext_Host_vars(ctx, field)
			case "userGroups":
				return ec.fieldContext_Host_userGroups(ctx, field)
			case "provisionSteps":
				return ec.fieldContext_Host_provisionSteps(ctx, field)
			case "tags":
				return ec.fieldContext_Host_tags(ctx, field)
			case "Disk":
				return ec.fieldContext_Host_Disk(ctx, field)
			case "Users":
				return ec.fieldContext_Host_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Host_Environment(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Host_IncludedNetworks(ctx, field)
			case "DependOnHostDependencies":
				return ec.fieldContext_Host_DependOnHostDependencies(ctx, field)
			case "RequiredByHostDependencies":
				return ec.fieldContext_Host_RequiredByHostDependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_id(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Environment().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_competitionId(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_competitionId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompetitionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_competitionId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_name(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_description(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_builder(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_builder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Builder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_builder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_teamCount(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_teamCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_teamCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_revision(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_revision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_adminCidrs(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_adminCidrs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdminCidrs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_adminCidrs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_exposedVdiPorts(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExposedVdiPorts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_exposedVdiPorts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_config(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_config(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Environment().Config(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ConfigMap)
	fc.Result = res
	return ec.marshalOconfigMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐConfigMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_config(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_configMap_key(ctx, field)
			case "value":
				return ec.fieldContext_configMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type configMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_tags(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Environment().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalOtagMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_Users(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_Users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.User)
	fc.Result = res
	return ec.marshalNUser2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_Users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "hclId":
				return ec.fieldContext_User_hclId(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "uuid":
				return ec.fieldContext_User_uuid(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "Tag":
				return ec.fieldContext_User_Tag(ctx, field)
			case "Environments":
				return ec.fieldContext_User_Environments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_Hosts(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_Hosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hosts(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Host)
	fc.Result = res
	return ec.marshalNHost2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_Hosts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Host_hclId(ctx, field)
			case "hostname":
				return ec.fieldContext_Host_hostname(ctx, field)
			case "description":
				return ec.fieldContext_Host_description(ctx, field)
			case "OS":
				return ec.fieldContext_Host_OS(ctx, field)
			case "lastOctet":
				return ec.fieldContext_Host_lastOctet(ctx, field)
			case "instanceSize":
				return ec.fieldContext_Host_instanceSize(ctx, field)
			case "allowMacChanges":
				return ec.fieldContext_Host_allowMacChanges(ctx, field)
			case "exposedTcpPorts":
				return ec.fieldContext_Host_exposedTcpPorts(ctx, field)
			case "exposedUdpPorts":
				return ec.fieldContext_Host_exposedUdpPorts(ctx, field)
			case "overridePassword":
				return ec.fieldContext_Host_overridePassword(ctx, field)
			case "vars":
				return ec.fieldContext_Host_vars(ctx, field)
			case "userGroups":
				return ec.fieldContext_Host_userGroups(ctx, field)
			case "provisionSteps":
				return ec.fieldContext_Host_provisionSteps(ctx, field)
			case "tags":
				return ec.fieldContext_Host_tags(ctx, field)
			case "Disk":
				return ec.fieldContext_Host_Disk(ctx, field)
			case "Users":
				return ec.fieldContext_Host_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Host_Environment(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Host_IncludedNetworks(ctx, field)
			case "DependOnHostDependencies":
				return ec.fieldContext_Host_DependOnHostDependencies(ctx, field)
			case "RequiredByHostDependencies":
				return ec.fieldContext_Host_RequiredByHostDependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_Competitions(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_Competitions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Competitions(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Competition)
	fc.Result = res
	return ec.marshalNCompetition2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐCompetition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_Competitions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Competition_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Competition_hclId(ctx, field)
			case "rootPassword":
				return ec.fieldContext_Competition_rootPassword(ctx, field)
			case "startTime":
				return ec.fieldContext_Competition_startTime(ctx, field)
			case "stopTime":
				return ec.fieldContext_Competition_stopTime(ctx, field)
			case "config":
				return ec.fieldContext_Competition_config(ctx, field)
			case "tags":
				return ec.fieldContext_Competition_tags(ctx, field)
			case "DNS":
				return ec.fieldContext_Competition_DNS(ctx, field)
			case "Environment":
				return ec.fieldContext_Competition_Environment(ctx, field)
			case "Builds":
				return ec.fieldContext_Competition_Builds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Competition", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_Identities(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_Identities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Identities(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Identity)
	fc.Result = res
	return ec.marshalNIdentity2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐIdentity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_Identities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Identity_id(ctx, field)
			case "hclid":
				return ec.fieldContext_Identity_hclid(ctx, field)
			case "firstName":
				return ec.fieldContext_Identity_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_Identity_lastName(ctx, field)
			case "email":
				return ec.fieldContext_Identity_email(ctx, field)
			case "password":
				return ec.fieldContext_Identity_password(ctx, field)
			case "description":
				return ec.fieldContext_Identity_description(ctx, field)
			case "avatarFile":
				return ec.fieldContext_Identity_avatarFile(ctx, field)
			case "vars":
				return ec.fieldContext_Identity_vars(ctx, field)
			case "tags":
				return ec.fieldContext_Identity_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_Identity_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Identity", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_Commands(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_Commands(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Commands(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Command)
	fc.Result = res
	return ec.marshalNCommand2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐCommand(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_Commands(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Command_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Command_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Command_name(ctx, field)
			case "description":
				return ec.fieldContext_Command_description(ctx, field)
			case "program":
				return ec.fieldContext_Command_program(ctx, field)
			case "args":
				return ec.fieldContext_Command_args(ctx, field)
			case "ignoreErrors":
				return ec.fieldContext_Command_ignoreErrors(ctx, field)
			case "disabled":
				return ec.fieldContext_Command_disabled(ctx, field)
			case "cooldown":
				return ec.fieldContext_Command_cooldown(ctx, field)
			case "timeout":
				return ec.fieldContext_Command_timeout(ctx, field)
			case "vars":
				return ec.fieldContext_Command_vars(ctx, field)
			case "tags":
				return ec.fieldContext_Command_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Command_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Command_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Command", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_Scripts(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_Scripts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Scripts(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Script)
	fc.Result = res
	return ec.marshalNScript2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐScript(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_Scripts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Script_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Script_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Script_name(ctx, field)
			case "language":
				return ec.fieldContext_Script_language(ctx, field)
			case "description":
				return ec.fieldContext_Script_description(ctx, field)
			case "source":
				return ec.fieldContext_Script_source(ctx, field)
			case "sourceType":
				return ec.fieldContext_Script_sourceType(ctx, field)
			case "cooldown":
				return ec.fieldContext_Script_cooldown(ctx, field)
			case "timeout":
				return ec.fieldContext_Script_timeout(ctx, field)
			case "ignoreErrors":
				return ec.fieldContext_Script_ignoreErrors(ctx, field)
			case "args":
				return ec.fieldContext_Script_args(ctx, field)
			case "disabled":
				return ec.fieldContext_Script_disabled(ctx, field)
			case "vars":
				return ec.fieldContext_Script_vars(ctx, field)
			case "absPath":
				return ec.fieldContext_Script_absPath(ctx, field)
			case "tags":
				return ec.fieldContext_Script_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Script_Users(ctx, field)
			case "Findings":
				return ec.fieldContext_Script_Findings(ctx, field)
			case "Environment":
				return ec.fieldContext_Script_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Script", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_FileDownloads(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_FileDownloads(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileDownloads(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.FileDownload)
	fc.Result = res
	return ec.marshalNFileDownload2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐFileDownload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_FileDownloads(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FileDownload_id(ctx, field)
			case "hclId":
				return ec.fieldContext_FileDownload_hclId(ctx, field)
			case "sourceType":
				return ec.fieldContext_FileDownload_sourceType(ctx, field)
			case "source":
				return ec.fieldContext_FileDownload_source(ctx, field)
			case "destination":
				return ec.fieldContext_FileDownload_destination(ctx, field)
			case "template":
				return ec.fieldContext_FileDownload_template(ctx, field)
			case "perms":
				return ec.fieldContext_FileDownload_perms(ctx, field)
			case "disabled":
				return ec.fieldContext_FileDownload_disabled(ctx, field)
			case "md5":
				return ec.fieldContext_FileDownload_md5(ctx, field)
			case "absPath":
				return ec.fieldContext_FileDownload_absPath(ctx, field)
			case "tags":
				return ec.fieldContext_FileDownload_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_FileDownload_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileDownload", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_FileDeletes(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_FileDeletes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileDeletes(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.FileDelete)
	fc.Result = res
	return ec.marshalNFileDelete2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐFileDelete(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_FileDeletes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FileDelete_id(ctx, field)
			case "hclId":
				return ec.fieldContext_FileDelete_hclId(ctx, field)
			case "path":
				return ec.fieldContext_FileDelete_path(ctx, field)
			case "tags":
				return ec.fieldContext_FileDelete_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_FileDelete_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileDelete", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_FileExtracts(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_FileExtracts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileExtracts(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.FileExtract)
	fc.Result = res
	return ec.marshalNFileExtract2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐFileExtract(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_FileExtracts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FileExtract_id(ctx, field)
			case "hclId":
				return ec.fieldContext_FileExtract_hclId(ctx, field)
			case "source":
				return ec.fieldContext_FileExtract_source(ctx, field)
			case "destination":
				return ec.fieldContext_FileExtract_destination(ctx, field)
			case "type":
				return ec.fieldContext_FileExtract_type(ctx, field)
			case "tags":
				return ec.fieldContext_FileExtract_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_FileExtract_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileExtract", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_IncludedNetworks(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_IncludedNetworks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IncludedNetworks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.IncludedNetwork)
	fc.Result = res
	return ec.marshalNIncludedNetwork2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐIncludedNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_IncludedNetworks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IncludedNetwork_id(ctx, field)
			case "name":
				return ec.fieldContext_IncludedNetwork_name(ctx, field)
			case "includedHosts":
				return ec.fieldContext_IncludedNetwork_includedHosts(ctx, field)
			case "Tags":
				return ec.fieldContext_IncludedNetwork_Tags(ctx, field)
			case "Hosts":
				return ec.fieldContext_IncludedNetwork_Hosts(ctx, field)
			case "Network":
				return ec.fieldContext_IncludedNetwork_Network(ctx, field)
			case "Environments":
				return ec.fieldContext_IncludedNetwork_Environments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IncludedNetwork", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_Findings(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_Findings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Findings(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Finding)
	fc.Result = res
	return ec.marshalNFinding2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐFinding(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_Findings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Finding_id(ctx, field)
			case "name":
				return ec.fieldContext_Finding_name(ctx, field)
			case "description":
				return ec.fieldContext_Finding_description(ctx, field)
			case "severity":
				return ec.fieldContext_Finding_severity(ctx, field)
			case "difficulty":
				return ec.fieldContext_Finding_difficulty(ctx, field)
			case "tags":
				return ec.fieldContext_Finding_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Finding_Users(ctx, field)
			case "Host":
				return ec.fieldContext_Finding_Host(ctx, field)
			case "Script":
				return ec.fieldContext_Finding_Script(ctx, field)
			case "Environment":
				return ec.fieldContext_Finding_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Finding", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_DNSRecords(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_DNSRecords(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DNSRecords(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.DNSRecord)
	fc.Result = res
	return ec.marshalNDNSRecord2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐDNSRecord(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_DNSRecords(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DNSRecord_id(ctx, field)
			case "hclId":
				return ec.fieldContext_DNSRecord_hclId(ctx, field)
			case "name":
				return ec.fieldContext_DNSRecord_name(ctx, field)
			case "values":
				return ec.fieldContext_DNSRecord_values(ctx, field)
			case "type":
				return ec.fieldContext_DNSRecord_type(ctx, field)
			case "zone":
				return ec.fieldContext_DNSRecord_zone(ctx, field)
			case "vars":
				return ec.fieldContext_DNSRecord_vars(ctx, field)
			case "disabled":
				return ec.fieldContext_DNSRecord_disabled(ctx, field)
			case "tags":
				return ec.fieldContext_DNSRecord_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_DNSRecord_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DNSRecord", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_DNS(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_DNS(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DNS(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.DNS)
	fc.Result = res
	return ec.marshalNDNS2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐDNS(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_DNS(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DNS_id(ctx, field)
			case "hclId":
				return ec.fieldContext_DNS_hclId(ctx, field)
			case "type":
				return ec.fieldContext_DNS_type(ctx, field)
			case "rootDomain":
				return ec.fieldContext_DNS_rootDomain(ctx, field)
			case "dnsServers":
				return ec.fieldContext_DNS_dnsServers(ctx, field)
			case "ntpServers":
				return ec.fieldContext_DNS_ntpServers(ctx, field)
			case "config":
				return ec.fieldContext_DNS_config(ctx, field)
			case "Environments":
				return ec.fieldContext_DNS_Environments(ctx, field)
			case "Competitions":
				return ec.fieldContext_DNS_Competitions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DNS", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_Networks(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_Networks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Networks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Network)
	fc.Result = res
	return ec.marshalNNetwork2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_Networks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Network_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Network_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Network_name(ctx, field)
			case "cidr":
				return ec.fieldContext_Network_cidr(ctx, field)
			case "vdiVisible":
				return ec.fieldContext_Network_vdiVisible(ctx, field)
			case "vars":
				return ec.fieldContext_Network_vars(ctx, field)
			case "tags":
				return ec.fieldContext_Network_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_Network_Environment(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Network_HostDependencies(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Network_IncludedNetworks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Network", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_HostDependencies(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_HostDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostDependencies(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.HostDependency)
	fc.Result = res
	return ec.marshalNHostDependency2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐHostDependency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_HostDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_HostDependency_id(ctx, field)
			case "hostId":
				return ec.fieldContext_HostDependency_hostId(ctx, field)
			case "networkId":
				return ec.fieldContext_HostDependency_networkId(ctx, field)
			case "RequiredBy":
				return ec.fieldContext_HostDependency_RequiredBy(ctx, field)
			case "DependOnHost":
				return ec.fieldContext_HostDependency_DependOnHost(ctx, field)
			case "DependOnNetwork":
				return ec.fieldContext_HostDependency_DependOnNetwork(ctx, field)
			case "Environment":
				return ec.fieldContext_HostDependency_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostDependency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_Ansibles(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_Ansibles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ansibles(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Ansible)
	fc.Result = res
	return ec.marshalNAnsible2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAnsible(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_Ansibles(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Ansible_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Ansible_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Ansible_name(ctx, field)
			case "description":
				return ec.fieldContext_Ansible_description(ctx, field)
			case "source":
				return ec.fieldContext_Ansible_source(ctx, field)
			case "playbookName":
				return ec.fieldContext_Ansible_playbookName(ctx, field)
			case "method":
				return ec.fieldContext_Ansible_method(ctx, field)
			case "inventory":
				return ec.fieldContext_Ansible_inventory(ctx, field)
			case "absPath":
				return ec.fieldContext_Ansible_absPath(ctx, field)
			case "tags":
				return ec.fieldContext_Ansible_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Ansible_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Ansible_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Ansible", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_ScheduledSteps(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_ScheduledSteps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScheduledSteps(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ScheduledStep)
	fc.Result = res
	return ec.marshalNScheduledStep2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐScheduledStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_ScheduledSteps(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ScheduledStep_id(ctx, field)
			case "hclId":
				return ec.fieldContext_ScheduledStep_hclId(ctx, field)
			case "name":
				return ec.fieldContext_ScheduledStep_name(ctx, field)
			case "description":
				return ec.fieldContext_ScheduledStep_description(ctx, field)
			case "step":
				return ec.fieldContext_ScheduledStep_step(ctx, field)
			case "type":
				return ec.fieldContext_ScheduledStep_type(ctx, field)
			case "schedule":
				return ec.fieldContext_ScheduledStep_schedule(ctx, field)
			case "runAt":
				return ec.fieldContext_ScheduledStep_runAt(ctx, field)
			case "Environment":
				return ec.fieldContext_ScheduledStep_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ScheduledStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_Builds(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_Builds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Builds(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Build)
	fc.Result = res
	return ec.marshalNBuild2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_Builds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_Repositories(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_Repositories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repositories(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Repository)
	fc.Result = res
	return ec.marshalNRepository2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_Repositories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Repository_id(ctx, field)
			case "repoUrl":
				return ec.fieldContext_Repository_repoUrl(ctx, field)
			case "branchName":
				return ec.fieldContext_Repository_branchName(ctx, field)
			case "environmentFilepath":
				return ec.fieldContext_Repository_environmentFilepath(ctx, field)
			case "Environments":
				return ec.fieldContext_Repository_Environments(ctx, field)
			case "RepoCommits":
				return ec.fieldContext_Repository_RepoCommits(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Repository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Environment_ServerTasks(ctx context.Context, field graphql.CollectedField, obj *ent.Environment) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Environment_ServerTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServerTasks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ServerTask)
	fc.Result = res
	return ec.marshalNServerTask2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐServerTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Environment_ServerTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Environment",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServerTask_id(ctx, field)
			case "type":
				return ec.fieldContext_ServerTask_type(ctx, field)
			case "startTime":
				return ec.fieldContext_ServerTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ServerTask_endTime(ctx, field)
			case "errors":
				return ec.fieldContext_ServerTask_errors(ctx, field)
			case "logFilePath":
				return ec.fieldContext_ServerTask_logFilePath(ctx, field)
			case "AuthUser":
				return ec.fieldContext_ServerTask_AuthUser(ctx, field)
			case "Status":
				return ec.fieldContext_ServerTask_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_ServerTask_Environment(ctx, field)
			case "Build":
				return ec.fieldContext_ServerTask_Build(ctx, field)
			case "BuildCommit":
				return ec.fieldContext_ServerTask_BuildCommit(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ServerTask_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServerTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDelete_id(ctx context.Context, field graphql.CollectedField, obj *ent.FileDelete) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDelete_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FileDelete().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDelete_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDelete",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDelete_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.FileDelete) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDelete_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDelete_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDelete",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDelete_path(ctx context.Context, field graphql.CollectedField, obj *ent.FileDelete) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDelete_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDelete_path(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDelete",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDelete_tags(ctx context.Context, field graphql.CollectedField, obj *ent.FileDelete) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDelete_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FileDelete().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalNtagMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDelete_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDelete",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDelete_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.FileDelete) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDelete_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDelete_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDelete",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDownload_id(ctx context.Context, field graphql.CollectedField, obj *ent.FileDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDownload_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FileDownload().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDownload_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDownload",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDownload_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.FileDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDownload_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDownload_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDownload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDownload_sourceType(ctx context.Context, field graphql.CollectedField, obj *ent.FileDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDownload_sourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDownload_sourceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDownload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDownload_source(ctx context.Context, field graphql.CollectedField, obj *ent.FileDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDownload_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDownload_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDownload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDownload_destination(ctx context.Context, field graphql.CollectedField, obj *ent.FileDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDownload_destination(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Destination, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDownload_destination(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDownload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDownload_template(ctx context.Context, field graphql.CollectedField, obj *ent.FileDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDownload_template(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Template, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDownload_template(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDownload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDownload_perms(ctx context.Context, field graphql.CollectedField, obj *ent.FileDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDownload_perms(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Perms, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDownload_perms(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDownload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDownload_disabled(ctx context.Context, field graphql.CollectedField, obj *ent.FileDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDownload_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDownload_disabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDownload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDownload_md5(ctx context.Context, field graphql.CollectedField, obj *ent.FileDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDownload_md5(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Md5, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDownload_md5(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDownload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDownload_absPath(ctx context.Context, field graphql.CollectedField, obj *ent.FileDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDownload_absPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AbsPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDownload_absPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDownload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDownload_tags(ctx context.Context, field graphql.CollectedField, obj *ent.FileDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDownload_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FileDownload().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalNtagMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDownload_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDownload",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDownload_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.FileDownload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDownload_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDownload_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDownload",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileExtract_id(ctx context.Context, field graphql.CollectedField, obj *ent.FileExtract) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileExtract_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FileExtract().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileExtract_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileExtract",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileExtract_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.FileExtract) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileExtract_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileExtract_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileExtract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileExtract_source(ctx context.Context, field graphql.CollectedField, obj *ent.FileExtract) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileExtract_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileExtract_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileExtract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileExtract_destination(ctx context.Context, field graphql.CollectedField, obj *ent.FileExtract) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileExtract_destination(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Destination, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileExtract_destination(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileExtract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileExtract_type(ctx context.Context, field graphql.CollectedField, obj *ent.FileExtract) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileExtract_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileExtract_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileExtract",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileExtract_tags(ctx context.Context, field graphql.CollectedField, obj *ent.FileExtract) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileExtract_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FileExtract().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalNtagMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileExtract_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileExtract",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileExtract_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.FileExtract) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileExtract_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileExtract_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileExtract",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Finding_id(ctx context.Context, field graphql.CollectedField, obj *ent.Finding) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Finding_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Finding().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Finding_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Finding",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Finding_name(ctx context.Context, field graphql.CollectedField, obj *ent.Finding) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Finding_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Finding_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Finding",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Finding_description(ctx context.Context, field graphql.CollectedField, obj *ent.Finding) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Finding_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Finding_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Finding",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Finding_severity(ctx context.Context, field graphql.CollectedField, obj *ent.Finding) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Finding_severity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Finding().Severity(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.FindingSeverity)
	fc.Result = res
	return ec.marshalNFindingSeverity2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐFindingSeverity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Finding_severity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Finding",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FindingSeverity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Finding_difficulty(ctx context.Context, field graphql.CollectedField, obj *ent.Finding) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Finding_difficulty(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Finding().Difficulty(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.FindingDifficulty)
	fc.Result = res
	return ec.marshalNFindingDifficulty2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐFindingDifficulty(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Finding_difficulty(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Finding",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FindingDifficulty does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Finding_tags(ctx context.Context, field graphql.CollectedField, obj *ent.Finding) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Finding_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Finding().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalNtagMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Finding_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Finding",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Finding_Users(ctx context.Context, field graphql.CollectedField, obj *ent.Finding) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Finding_Users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.User)
	fc.Result = res
	return ec.marshalNUser2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Finding_Users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Finding",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "hclId":
				return ec.fieldContext_User_hclId(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "uuid":
				return ec.fieldContext_User_uuid(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "Tag":
				return ec.fieldContext_User_Tag(ctx, field)
			case "Environments":
				return ec.fieldContext_User_Environments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Finding_Host(ctx context.Context, field graphql.CollectedField, obj *ent.Finding) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Finding_Host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Host(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Host)
	fc.Result = res
	return ec.marshalOHost2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Finding_Host(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Finding",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Host_hclId(ctx, field)
			case "hostname":
				return ec.fieldContext_Host_hostname(ctx, field)
			case "description":
				return ec.fieldContext_Host_description(ctx, field)
			case "OS":
				return ec.fieldContext_Host_OS(ctx, field)
			case "lastOctet":
				return ec.fieldContext_Host_lastOctet(ctx, field)
			case "instanceSize":
				return ec.fieldContext_Host_instanceSize(ctx, field)
			case "allowMacChanges":
				return ec.fieldContext_Host_allowMacChanges(ctx, field)
			case "exposedTcpPorts":
				return ec.fieldContext_Host_exposedTcpPorts(ctx, field)
			case "exposedUdpPorts":
				return ec.fieldContext_Host_exposedUdpPorts(ctx, field)
			case "overridePassword":
				return ec.fieldContext_Host_overridePassword(ctx, field)
			case "vars":
				return ec.fieldContext_Host_vars(ctx, field)
			case "userGroups":
				return ec.fieldContext_Host_userGroups(ctx, field)
			case "provisionSteps":
				return ec.fieldContext_Host_provisionSteps(ctx, field)
			case "tags":
				return ec.fieldContext_Host_tags(ctx, field)
			case "Disk":
				return ec.fieldContext_Host_Disk(ctx, field)
			case "Users":
				return ec.fieldContext_Host_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Host_Environment(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Host_IncludedNetworks(ctx, field)
			case "DependOnHostDependencies":
				return ec.fieldContext_Host_DependOnHostDependencies(ctx, field)
			case "RequiredByHostDependencies":
				return ec.fieldContext_Host_RequiredByHostDependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Finding_Script(ctx context.Context, field graphql.CollectedField, obj *ent.Finding) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Finding_Script(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Script(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Script)
	fc.Result = res
	return ec.marshalOScript2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐScript(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Finding_Script(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Finding",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Script_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Script_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Script_name(ctx, field)
			case "language":
				return ec.fieldContext_Script_language(ctx, field)
			case "description":
				return ec.fieldContext_Script_description(ctx, field)
			case "source":
				return ec.fieldContext_Script_source(ctx, field)
			case "sourceType":
				return ec.fieldContext_Script_sourceType(ctx, field)
			case "cooldown":
				return ec.fieldContext_Script_cooldown(ctx, field)
			case "timeout":
				return ec.fieldContext_Script_timeout(ctx, field)
			case "ignoreErrors":
				return ec.fieldContext_Script_ignoreErrors(ctx, field)
			case "args":
				return ec.fieldContext_Script_args(ctx, field)
			case "disabled":
				return ec.fieldContext_Script_disabled(ctx, field)
			case "vars":
				return ec.fieldContext_Script_vars(ctx, field)
			case "absPath":
				return ec.fieldContext_Script_absPath(ctx, field)
			case "tags":
				return ec.fieldContext_Script_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Script_Users(ctx, field)
			case "Findings":
				return ec.fieldContext_Script_Findings(ctx, field)
			case "Environment":
				return ec.fieldContext_Script_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Script", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Finding_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.Finding) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Finding_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalOEnvironment2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Finding_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Finding",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GinFileMiddleware_id(ctx context.Context, field graphql.CollectedField, obj *ent.GinFileMiddleware) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GinFileMiddleware_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GinFileMiddleware().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GinFileMiddleware_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GinFileMiddleware",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GinFileMiddleware_urlId(ctx context.Context, field graphql.CollectedField, obj *ent.GinFileMiddleware) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GinFileMiddleware_urlId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URLID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GinFileMiddleware_urlId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GinFileMiddleware",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GinFileMiddleware_filePath(ctx context.Context, field graphql.CollectedField, obj *ent.GinFileMiddleware) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GinFileMiddleware_filePath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FilePath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GinFileMiddleware_filePath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GinFileMiddleware",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GinFileMiddleware_accessed(ctx context.Context, field graphql.CollectedField, obj *ent.GinFileMiddleware) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GinFileMiddleware_accessed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Accessed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GinFileMiddleware_accessed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GinFileMiddleware",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GinFileMiddleware_ProvisionedHost(ctx context.Context, field graphql.CollectedField, obj *ent.GinFileMiddleware) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GinFileMiddleware_ProvisionedHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedHost(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedHost)
	fc.Result = res
	return ec.marshalOProvisionedHost2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisionedHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GinFileMiddleware_ProvisionedHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GinFileMiddleware",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedHost_id(ctx, field)
			case "subnetIp":
				return ec.fieldContext_ProvisionedHost_subnetIp(ctx, field)
			case "addonType":
				return ec.fieldContext_ProvisionedHost_addonType(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedHost_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedHost_Status(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_ProvisionedHost_ProvisionedNetwork(ctx, field)
			case "Host":
				return ec.fieldContext_ProvisionedHost_Host(ctx, field)
			case "EndStepPlan":
				return ec.fieldContext_ProvisionedHost_EndStepPlan(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedHost_Build(ctx, field)
			case "ProvisioningSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningSteps(ctx, field)
			case "ProvisioningScheduledSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningScheduledSteps(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_ProvisionedHost_AgentStatuses(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisionedHost_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedHost_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisionedHost_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedHost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GinFileMiddleware_ProvisioningStep(ctx context.Context, field graphql.CollectedField, obj *ent.GinFileMiddleware) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GinFileMiddleware_ProvisioningStep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisioningStep(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisioningStep)
	fc.Result = res
	return ec.marshalOProvisioningStep2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisioningStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GinFileMiddleware_ProvisioningStep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GinFileMiddleware",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisioningStep_id(ctx, field)
			case "type":
				return ec.fieldContext_ProvisioningStep_type(ctx, field)
			case "stepNumber":
				return ec.fieldContext_ProvisioningStep_stepNumber(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisioningStep_Status(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_ProvisioningStep_ProvisionedHost(ctx, field)
			case "Script":
				return ec.fieldContext_ProvisioningStep_Script(ctx, field)
			case "Command":
				return ec.fieldContext_ProvisioningStep_Command(ctx, field)
			case "DNSRecord":
				return ec.fieldContext_ProvisioningStep_DNSRecord(ctx, field)
			case "FileDelete":
				return ec.fieldContext_ProvisioningStep_FileDelete(ctx, field)
			case "FileDownload":
				return ec.fieldContext_ProvisioningStep_FileDownload(ctx, field)
			case "FileExtract":
				return ec.fieldContext_ProvisioningStep_FileExtract(ctx, field)
			case "Ansible":
				return ec.fieldContext_ProvisioningStep_Ansible(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisioningStep_Plan(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisioningStep_AgentTasks(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisioningStep_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisioningStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GinFileMiddleware_ProvisioningScheduledStep(ctx context.Context, field graphql.CollectedField, obj *ent.GinFileMiddleware) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GinFileMiddleware_ProvisioningScheduledStep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisioningScheduledStep(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisioningScheduledStep)
	fc.Result = res
	return ec.marshalOProvisioningScheduledStep2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisioningScheduledStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GinFileMiddleware_ProvisioningScheduledStep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GinFileMiddleware",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisioningScheduledStep_id(ctx, field)
			case "type":
				return ec.fieldContext_ProvisioningScheduledStep_type(ctx, field)
			case "runTime":
				return ec.fieldContext_ProvisioningScheduledStep_runTime(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisioningScheduledStep_Status(ctx, field)
			case "ScheduledStep":
				return ec.fieldContext_ProvisioningScheduledStep_ScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_ProvisioningScheduledStep_ProvisionedHost(ctx, field)
			case "Script":
				return ec.fieldContext_ProvisioningScheduledStep_Script(ctx, field)
			case "Command":
				return ec.fieldContext_ProvisioningScheduledStep_Command(ctx, field)
			case "DNSRecord":
				return ec.fieldContext_ProvisioningScheduledStep_DNSRecord(ctx, field)
			case "FileDelete":
				return ec.fieldContext_ProvisioningScheduledStep_FileDelete(ctx, field)
			case "FileDownload":
				return ec.fieldContext_ProvisioningScheduledStep_FileDownload(ctx, field)
			case "FileExtract":
				return ec.fieldContext_ProvisioningScheduledStep_FileExtract(ctx, field)
			case "Ansible":
				return ec.fieldContext_ProvisioningScheduledStep_Ansible(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisioningScheduledStep_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisioningScheduledStep_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisioningScheduledStep_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisioningScheduledStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GraphqlConfig_Hostname(ctx context.Context, field graphql.CollectedField, obj *model.GraphqlConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GraphqlConfig_Hostname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hostname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GraphqlConfig_Hostname(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GraphqlConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GraphqlConfig_RedisServerUri(ctx context.Context, field graphql.CollectedField, obj *model.GraphqlConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GraphqlConfig_RedisServerUri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RedisServerURI, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GraphqlConfig_RedisServerUri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GraphqlConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_id(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_hostname(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_hostname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hostname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_hostname(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_description(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_OS(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_OS(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_OS(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_lastOctet(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_lastOctet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastOctet, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_lastOctet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_instanceSize(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_instanceSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InstanceSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_instanceSize(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_allowMacChanges(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_allowMacChanges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllowMACChanges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_allowMacChanges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_exposedTcpPorts(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_exposedTcpPorts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExposedTCPPorts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_exposedTcpPorts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_exposedUdpPorts(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_exposedUdpPorts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExposedUDPPorts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_exposedUdpPorts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_overridePassword(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_overridePassword(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OverridePassword, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_overridePassword(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_vars(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().Vars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.VarsMap)
	fc.Result = res
	return ec.marshalOvarsMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐVarsMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_vars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_varsMap_key(ctx, field)
			case "value":
				return ec.fieldContext_varsMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type varsMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_userGroups(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_userGroups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserGroups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_userGroups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_provisionSteps(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_provisionSteps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionSteps, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_provisionSteps(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_tags(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalNtagMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_Disk(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_Disk(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disk(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Disk)
	fc.Result = res
	return ec.marshalNDisk2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐDisk(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_Disk(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Disk_id(ctx, field)
			case "size":
				return ec.fieldContext_Disk_size(ctx, field)
			case "Host":
				return ec.fieldContext_Disk_Host(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Disk", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_Users(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_Users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.User)
	fc.Result = res
	return ec.marshalNUser2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_Users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "hclId":
				return ec.fieldContext_User_hclId(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "uuid":
				return ec.fieldContext_User_uuid(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "Tag":
				return ec.fieldContext_User_Tag(ctx, field)
			case "Environments":
				return ec.fieldContext_User_Environments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_IncludedNetworks(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_IncludedNetworks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IncludedNetworks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.IncludedNetwork)
	fc.Result = res
	return ec.marshalNIncludedNetwork2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐIncludedNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_IncludedNetworks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IncludedNetwork_id(ctx, field)
			case "name":
				return ec.fieldContext_IncludedNetwork_name(ctx, field)
			case "includedHosts":
				return ec.fieldContext_IncludedNetwork_includedHosts(ctx, field)
			case "Tags":
				return ec.fieldContext_IncludedNetwork_Tags(ctx, field)
			case "Hosts":
				return ec.fieldContext_IncludedNetwork_Hosts(ctx, field)
			case "Network":
				return ec.fieldContext_IncludedNetwork_Network(ctx, field)
			case "Environments":
				return ec.fieldContext_IncludedNetwork_Environments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IncludedNetwork", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_DependOnHostDependencies(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_DependOnHostDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DependOnHostDependencies(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.HostDependency)
	fc.Result = res
	return ec.marshalNHostDependency2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐHostDependency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_DependOnHostDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_HostDependency_id(ctx, field)
			case "hostId":
				return ec.fieldContext_HostDependency_hostId(ctx, field)
			case "networkId":
				return ec.fieldContext_HostDependency_networkId(ctx, field)
			case "RequiredBy":
				return ec.fieldContext_HostDependency_RequiredBy(ctx, field)
			case "DependOnHost":
				return ec.fieldContext_HostDependency_DependOnHost(ctx, field)
			case "DependOnNetwork":
				return ec.fieldContext_HostDependency_DependOnNetwork(ctx, field)
			case "Environment":
				return ec.fieldContext_HostDependency_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostDependency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_RequiredByHostDependencies(ctx context.Context, field graphql.CollectedField, obj *ent.Host) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_RequiredByHostDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiredByHostDependencies(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.HostDependency)
	fc.Result = res
	return ec.marshalNHostDependency2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐHostDependency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_RequiredByHostDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_HostDependency_id(ctx, field)
			case "hostId":
				return ec.fieldContext_HostDependency_hostId(ctx, field)
			case "networkId":
				return ec.fieldContext_HostDependency_networkId(ctx, field)
			case "RequiredBy":
				return ec.fieldContext_HostDependency_RequiredBy(ctx, field)
			case "DependOnHost":
				return ec.fieldContext_HostDependency_DependOnHost(ctx, field)
			case "DependOnNetwork":
				return ec.fieldContext_HostDependency_DependOnNetwork(ctx, field)
			case "Environment":
				return ec.fieldContext_HostDependency_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostDependency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostDependency_id(ctx context.Context, field graphql.CollectedField, obj *ent.HostDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostDependency_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.HostDependency().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostDependency_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostDependency",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostDependency_hostId(ctx context.Context, field graphql.CollectedField, obj *ent.HostDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostDependency_hostId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostDependency_hostId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostDependency_networkId(ctx context.Context, field graphql.CollectedField, obj *ent.HostDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostDependency_networkId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NetworkID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostDependency_networkId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostDependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostDependency_RequiredBy(ctx context.Context, field graphql.CollectedField, obj *ent.HostDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostDependency_RequiredBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiredBy(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Host)
	fc.Result = res
	return ec.marshalOHost2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostDependency_RequiredBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostDependency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Host_hclId(ctx, field)
			case "hostname":
				return ec.fieldContext_Host_hostname(ctx, field)
			case "description":
				return ec.fieldContext_Host_description(ctx, field)
			case "OS":
				return ec.fieldContext_Host_OS(ctx, field)
			case "lastOctet":
				return ec.fieldContext_Host_lastOctet(ctx, field)
			case "instanceSize":
				return ec.fieldContext_Host_instanceSize(ctx, field)
			case "allowMacChanges":
				return ec.fieldContext_Host_allowMacChanges(ctx, field)
			case "exposedTcpPorts":
				return ec.fieldContext_Host_exposedTcpPorts(ctx, field)
			case "exposedUdpPorts":
				return ec.fieldContext_Host_exposedUdpPorts(ctx, field)
			case "overridePassword":
				return ec.fieldContext_Host_overridePassword(ctx, field)
			case "vars":
				return ec.fieldContext_Host_vars(ctx, field)
			case "userGroups":
				return ec.fieldContext_Host_userGroups(ctx, field)
			case "provisionSteps":
				return ec.fieldContext_Host_provisionSteps(ctx, field)
			case "tags":
				return ec.fieldContext_Host_tags(ctx, field)
			case "Disk":
				return ec.fieldContext_Host_Disk(ctx, field)
			case "Users":
				return ec.fieldContext_Host_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Host_Environment(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Host_IncludedNetworks(ctx, field)
			case "DependOnHostDependencies":
				return ec.fieldContext_Host_DependOnHostDependencies(ctx, field)
			case "RequiredByHostDependencies":
				return ec.fieldContext_Host_RequiredByHostDependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostDependency_DependOnHost(ctx context.Context, field graphql.CollectedField, obj *ent.HostDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostDependency_DependOnHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DependOnHost(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Host)
	fc.Result = res
	return ec.marshalOHost2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostDependency_DependOnHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostDependency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Host_hclId(ctx, field)
			case "hostname":
				return ec.fieldContext_Host_hostname(ctx, field)
			case "description":
				return ec.fieldContext_Host_description(ctx, field)
			case "OS":
				return ec.fieldContext_Host_OS(ctx, field)
			case "lastOctet":
				return ec.fieldContext_Host_lastOctet(ctx, field)
			case "instanceSize":
				return ec.fieldContext_Host_instanceSize(ctx, field)
			case "allowMacChanges":
				return ec.fieldContext_Host_allowMacChanges(ctx, field)
			case "exposedTcpPorts":
				return ec.fieldContext_Host_exposedTcpPorts(ctx, field)
			case "exposedUdpPorts":
				return ec.fieldContext_Host_exposedUdpPorts(ctx, field)
			case "overridePassword":
				return ec.fieldContext_Host_overridePassword(ctx, field)
			case "vars":
				return ec.fieldContext_Host_vars(ctx, field)
			case "userGroups":
				return ec.fieldContext_Host_userGroups(ctx, field)
			case "provisionSteps":
				return ec.fieldContext_Host_provisionSteps(ctx, field)
			case "tags":
				return ec.fieldContext_Host_tags(ctx, field)
			case "Disk":
				return ec.fieldContext_Host_Disk(ctx, field)
			case "Users":
				return ec.fieldContext_Host_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Host_Environment(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Host_IncludedNetworks(ctx, field)
			case "DependOnHostDependencies":
				return ec.fieldContext_Host_DependOnHostDependencies(ctx, field)
			case "RequiredByHostDependencies":
				return ec.fieldContext_Host_RequiredByHostDependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostDependency_DependOnNetwork(ctx context.Context, field graphql.CollectedField, obj *ent.HostDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostDependency_DependOnNetwork(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DependOnNetwork(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Network)
	fc.Result = res
	return ec.marshalONetwork2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostDependency_DependOnNetwork(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostDependency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Network_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Network_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Network_name(ctx, field)
			case "cidr":
				return ec.fieldContext_Network_cidr(ctx, field)
			case "vdiVisible":
				return ec.fieldContext_Network_vdiVisible(ctx, field)
			case "vars":
				return ec.fieldContext_Network_vars(ctx, field)
			case "tags":
				return ec.fieldContext_Network_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_Network_Environment(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Network_HostDependencies(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Network_IncludedNetworks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Network", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostDependency_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.HostDependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostDependency_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalOEnvironment2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostDependency_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostDependency",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identity_id(ctx context.Context, field graphql.CollectedField, obj *ent.Identity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identity_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Identity().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identity_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identity_hclid(ctx context.Context, field graphql.CollectedField, obj *ent.Identity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identity_hclid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identity_hclid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identity_firstName(ctx context.Context, field graphql.CollectedField, obj *ent.Identity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identity_firstName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FirstName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identity_firstName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identity_lastName(ctx context.Context, field graphql.CollectedField, obj *ent.Identity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identity_lastName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identity_lastName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identity_email(ctx context.Context, field graphql.CollectedField, obj *ent.Identity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identity_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identity_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identity_password(ctx context.Context, field graphql.CollectedField, obj *ent.Identity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identity_password(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Password, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identity_password(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identity_description(ctx context.Context, field graphql.CollectedField, obj *ent.Identity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identity_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identity_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identity_avatarFile(ctx context.Context, field graphql.CollectedField, obj *ent.Identity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identity_avatarFile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvatarFile, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identity_avatarFile(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identity_vars(ctx context.Context, field graphql.CollectedField, obj *ent.Identity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identity_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Identity().Vars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.VarsMap)
	fc.Result = res
	return ec.marshalNvarsMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐVarsMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identity_vars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_varsMap_key(ctx, field)
			case "value":
				return ec.fieldContext_varsMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type varsMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identity_tags(ctx context.Context, field graphql.CollectedField, obj *ent.Identity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identity_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Identity().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalNtagMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identity_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identity",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Identity_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.Identity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Identity_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Identity_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Identity",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IncludedNetwork_id(ctx context.Context, field graphql.CollectedField, obj *ent.IncludedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IncludedNetwork_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.IncludedNetwork().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IncludedNetwork_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IncludedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IncludedNetwork_name(ctx context.Context, field graphql.CollectedField, obj *ent.IncludedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IncludedNetwork_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IncludedNetwork_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IncludedNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IncludedNetwork_includedHosts(ctx context.Context, field graphql.CollectedField, obj *ent.IncludedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IncludedNetwork_includedHosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IncludedHosts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IncludedNetwork_includedHosts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IncludedNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IncludedNetwork_Tags(ctx context.Context, field graphql.CollectedField, obj *ent.IncludedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IncludedNetwork_Tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Tag)
	fc.Result = res
	return ec.marshalNTag2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IncludedNetwork_Tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IncludedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "uuid":
				return ec.fieldContext_Tag_uuid(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "description":
				return ec.fieldContext_Tag_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IncludedNetwork_Hosts(ctx context.Context, field graphql.CollectedField, obj *ent.IncludedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IncludedNetwork_Hosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hosts(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Host)
	fc.Result = res
	return ec.marshalNHost2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IncludedNetwork_Hosts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IncludedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Host_hclId(ctx, field)
			case "hostname":
				return ec.fieldContext_Host_hostname(ctx, field)
			case "description":
				return ec.fieldContext_Host_description(ctx, field)
			case "OS":
				return ec.fieldContext_Host_OS(ctx, field)
			case "lastOctet":
				return ec.fieldContext_Host_lastOctet(ctx, field)
			case "instanceSize":
				return ec.fieldContext_Host_instanceSize(ctx, field)
			case "allowMacChanges":
				return ec.fieldContext_Host_allowMacChanges(ctx, field)
			case "exposedTcpPorts":
				return ec.fieldContext_Host_exposedTcpPorts(ctx, field)
			case "exposedUdpPorts":
				return ec.fieldContext_Host_exposedUdpPorts(ctx, field)
			case "overridePassword":
				return ec.fieldContext_Host_overridePassword(ctx, field)
			case "vars":
				return ec.fieldContext_Host_vars(ctx, field)
			case "userGroups":
				return ec.fieldContext_Host_userGroups(ctx, field)
			case "provisionSteps":
				return ec.fieldContext_Host_provisionSteps(ctx, field)
			case "tags":
				return ec.fieldContext_Host_tags(ctx, field)
			case "Disk":
				return ec.fieldContext_Host_Disk(ctx, field)
			case "Users":
				return ec.fieldContext_Host_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Host_Environment(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Host_IncludedNetworks(ctx, field)
			case "DependOnHostDependencies":
				return ec.fieldContext_Host_DependOnHostDependencies(ctx, field)
			case "RequiredByHostDependencies":
				return ec.fieldContext_Host_RequiredByHostDependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IncludedNetwork_Network(ctx context.Context, field graphql.CollectedField, obj *ent.IncludedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IncludedNetwork_Network(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Network(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Network)
	fc.Result = res
	return ec.marshalONetwork2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IncludedNetwork_Network(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IncludedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Network_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Network_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Network_name(ctx, field)
			case "cidr":
				return ec.fieldContext_Network_cidr(ctx, field)
			case "vdiVisible":
				return ec.fieldContext_Network_vdiVisible(ctx, field)
			case "vars":
				return ec.fieldContext_Network_vars(ctx, field)
			case "tags":
				return ec.fieldContext_Network_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_Network_Environment(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Network_HostDependencies(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Network_IncludedNetworks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Network", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IncludedNetwork_Environments(ctx context.Context, field graphql.CollectedField, obj *ent.IncludedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IncludedNetwork_Environments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environments(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IncludedNetwork_Environments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IncludedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LaForgePageInfo_total(ctx context.Context, field graphql.CollectedField, obj *model.LaForgePageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LaForgePageInfo_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LaForgePageInfo_total(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LaForgePageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LaForgePageInfo_nextOffset(ctx context.Context, field graphql.CollectedField, obj *model.LaForgePageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LaForgePageInfo_nextOffset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextOffset, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LaForgePageInfo_nextOffset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LaForgePageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_loadEnvironment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_loadEnvironment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().LoadEnvironment(rctx, fc.Args["envFilePath"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.Environment); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.Environment`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Environment)
	fc.Result = res
	return ec.marshalOEnvironment2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_loadEnvironment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_loadEnvironment_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createBuild(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createBuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateBuild(rctx, fc.Args["envUUID"].(string), fc.Args["renderFiles"].(bool))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.Build); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.Build`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Build)
	fc.Result = res
	return ec.marshalOBuild2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createBuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createBuild_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteUser(rctx, fc.Args["userUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_executePlan(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_executePlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ExecutePlan(rctx, fc.Args["buildUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.Build); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.Build`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Build)
	fc.Result = res
	return ec.marshalOBuild2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_executePlan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_executePlan_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteBuild(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteBuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DeleteBuild(rctx, fc.Args["buildUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteBuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteBuild_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateTask(rctx, fc.Args["proHostUUID"].(string), fc.Args["command"].(model.AgentCommand), fc.Args["args"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_dumpBuild(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_dumpBuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().DumpBuild(rctx, fc.Args["buildUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_dumpBuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_dumpBuild_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_rebuild(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_rebuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().Rebuild(rctx, fc.Args["rootPlans"].([]*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_rebuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_rebuild_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_approveCommit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_approveCommit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ApproveCommit(rctx, fc.Args["commitUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_approveCommit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_approveCommit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelCommit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cancelCommit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CancelCommit(rctx, fc.Args["commitUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cancelCommit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelCommit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createAgentTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createAgentTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateAgentTasks(rctx, fc.Args["hostHCLID"].(string), fc.Args["command"].(model.AgentCommand), fc.Args["buildUUID"].(string), fc.Args["args"].([]string), fc.Args["teams"].([]int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.AgentTask); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.AgentTask`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.AgentTask)
	fc.Result = res
	return ec.marshalNAgentTask2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createAgentTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AgentTask_id(ctx, field)
			case "args":
				return ec.fieldContext_AgentTask_args(ctx, field)
			case "command":
				return ec.fieldContext_AgentTask_command(ctx, field)
			case "number":
				return ec.fieldContext_AgentTask_number(ctx, field)
			case "output":
				return ec.fieldContext_AgentTask_output(ctx, field)
			case "state":
				return ec.fieldContext_AgentTask_state(ctx, field)
			case "errorMessage":
				return ec.fieldContext_AgentTask_errorMessage(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_AgentTask_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_AgentTask_ProvisioningScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentTask_ProvisionedHost(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_AgentTask_AdhocPlans(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentTask", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createAgentTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createBatchAgentTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createBatchAgentTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateBatchAgentTasks(rctx, fc.Args["proHostUUIDs"].([]string), fc.Args["command"].(model.AgentCommand), fc.Args["args"].([]string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.AgentTask); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.AgentTask`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.AgentTask)
	fc.Result = res
	return ec.marshalNAgentTask2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createBatchAgentTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AgentTask_id(ctx, field)
			case "args":
				return ec.fieldContext_AgentTask_args(ctx, field)
			case "command":
				return ec.fieldContext_AgentTask_command(ctx, field)
			case "number":
				return ec.fieldContext_AgentTask_number(ctx, field)
			case "output":
				return ec.fieldContext_AgentTask_output(ctx, field)
			case "state":
				return ec.fieldContext_AgentTask_state(ctx, field)
			case "errorMessage":
				return ec.fieldContext_AgentTask_errorMessage(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_AgentTask_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_AgentTask_ProvisioningScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentTask_ProvisionedHost(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_AgentTask_AdhocPlans(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentTask", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createBatchAgentTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createEnviromentFromRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createEnviromentFromRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateEnviromentFromRepo(rctx, fc.Args["repoURL"].(string), fc.Args["branchName"].(string), fc.Args["envFilePath"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.Environment); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.Environment`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createEnviromentFromRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createEnviromentFromRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateEnviromentViaPull(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateEnviromentViaPull(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().UpdateEnviromentViaPull(rctx, fc.Args["envUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.Environment); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.Environment`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateEnviromentViaPull(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateEnviromentViaPull_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_cancelBuild(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_cancelBuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CancelBuild(rctx, fc.Args["buildUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_cancelBuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_cancelBuild_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_modifySelfPassword(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_modifySelfPassword(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ModifySelfPassword(rctx, fc.Args["currentPassword"].(string), fc.Args["newPassword"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_modifySelfPassword(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_modifySelfPassword_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_modifySelfUserInfo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_modifySelfUserInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ModifySelfUserInfo(rctx, fc.Args["firstName"].(*string), fc.Args["lastName"].(*string), fc.Args["email"].(*string), fc.Args["phone"].(*string), fc.Args["company"].(*string), fc.Args["occupation"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.AuthUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.AuthUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.AuthUser)
	fc.Result = res
	return ec.marshalOAuthUser2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAuthUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_modifySelfUserInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AuthUser_id(ctx, field)
			case "username":
				return ec.fieldContext_AuthUser_username(ctx, field)
			case "firstName":
				return ec.fieldContext_AuthUser_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_AuthUser_lastName(ctx, field)
			case "email":
				return ec.fieldContext_AuthUser_email(ctx, field)
			case "phone":
				return ec.fieldContext_AuthUser_phone(ctx, field)
			case "company":
				return ec.fieldContext_AuthUser_company(ctx, field)
			case "occupation":
				return ec.fieldContext_AuthUser_occupation(ctx, field)
			case "publicKey":
				return ec.fieldContext_AuthUser_publicKey(ctx, field)
			case "role":
				return ec.fieldContext_AuthUser_role(ctx, field)
			case "provider":
				return ec.fieldContext_AuthUser_provider(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_AuthUser_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthUser", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_modifySelfUserInfo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CreateUser(rctx, fc.Args["username"].(string), fc.Args["password"].(string), fc.Args["role"].(model.RoleLevel), fc.Args["provider"].(model.ProviderType))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.AuthUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.AuthUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.AuthUser)
	fc.Result = res
	return ec.marshalOAuthUser2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAuthUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AuthUser_id(ctx, field)
			case "username":
				return ec.fieldContext_AuthUser_username(ctx, field)
			case "firstName":
				return ec.fieldContext_AuthUser_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_AuthUser_lastName(ctx, field)
			case "email":
				return ec.fieldContext_AuthUser_email(ctx, field)
			case "phone":
				return ec.fieldContext_AuthUser_phone(ctx, field)
			case "company":
				return ec.fieldContext_AuthUser_company(ctx, field)
			case "occupation":
				return ec.fieldContext_AuthUser_occupation(ctx, field)
			case "publicKey":
				return ec.fieldContext_AuthUser_publicKey(ctx, field)
			case "role":
				return ec.fieldContext_AuthUser_role(ctx, field)
			case "provider":
				return ec.fieldContext_AuthUser_provider(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_AuthUser_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthUser", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createUser_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_modifyAdminUserInfo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_modifyAdminUserInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ModifyAdminUserInfo(rctx, fc.Args["userID"].(string), fc.Args["username"].(*string), fc.Args["firstName"].(*string), fc.Args["lastName"].(*string), fc.Args["email"].(*string), fc.Args["phone"].(*string), fc.Args["company"].(*string), fc.Args["occupation"].(*string), fc.Args["role"].(*model.RoleLevel), fc.Args["provider"].(*model.ProviderType))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.AuthUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.AuthUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.AuthUser)
	fc.Result = res
	return ec.marshalOAuthUser2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAuthUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_modifyAdminUserInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AuthUser_id(ctx, field)
			case "username":
				return ec.fieldContext_AuthUser_username(ctx, field)
			case "firstName":
				return ec.fieldContext_AuthUser_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_AuthUser_lastName(ctx, field)
			case "email":
				return ec.fieldContext_AuthUser_email(ctx, field)
			case "phone":
				return ec.fieldContext_AuthUser_phone(ctx, field)
			case "company":
				return ec.fieldContext_AuthUser_company(ctx, field)
			case "occupation":
				return ec.fieldContext_AuthUser_occupation(ctx, field)
			case "publicKey":
				return ec.fieldContext_AuthUser_publicKey(ctx, field)
			case "role":
				return ec.fieldContext_AuthUser_role(ctx, field)
			case "provider":
				return ec.fieldContext_AuthUser_provider(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_AuthUser_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthUser", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_modifyAdminUserInfo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_modifyAdminPassword(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_modifyAdminPassword(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ModifyAdminPassword(rctx, fc.Args["userID"].(string), fc.Args["newPassword"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_modifyAdminPassword(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_modifyAdminPassword_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_nukeBackend(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_nukeBackend(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().NukeBackend(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*model.IntMap); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/graphql/graph/model.IntMap`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.IntMap)
	fc.Result = res
	return ec.marshalNintMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐIntMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_nukeBackend(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_intMap_key(ctx, field)
			case "value":
				return ec.fieldContext_intMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type intMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Network_id(ctx context.Context, field graphql.CollectedField, obj *ent.Network) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Network_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Network().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Network_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Network",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Network_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.Network) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Network_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Network_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Network",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Network_name(ctx context.Context, field graphql.CollectedField, obj *ent.Network) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Network_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Network_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Network",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Network_cidr(ctx context.Context, field graphql.CollectedField, obj *ent.Network) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Network_cidr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cidr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Network_cidr(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Network",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Network_vdiVisible(ctx context.Context, field graphql.CollectedField, obj *ent.Network) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Network_vdiVisible(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VdiVisible, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Network_vdiVisible(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Network",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Network_vars(ctx context.Context, field graphql.CollectedField, obj *ent.Network) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Network_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Network().Vars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.VarsMap)
	fc.Result = res
	return ec.marshalOvarsMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐVarsMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Network_vars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Network",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_varsMap_key(ctx, field)
			case "value":
				return ec.fieldContext_varsMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type varsMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Network_tags(ctx context.Context, field graphql.CollectedField, obj *ent.Network) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Network_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Network().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalNtagMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Network_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Network",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Network_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.Network) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Network_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Network_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Network",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Network_HostDependencies(ctx context.Context, field graphql.CollectedField, obj *ent.Network) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Network_HostDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostDependencies(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.HostDependency)
	fc.Result = res
	return ec.marshalNHostDependency2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐHostDependency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Network_HostDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Network",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_HostDependency_id(ctx, field)
			case "hostId":
				return ec.fieldContext_HostDependency_hostId(ctx, field)
			case "networkId":
				return ec.fieldContext_HostDependency_networkId(ctx, field)
			case "RequiredBy":
				return ec.fieldContext_HostDependency_RequiredBy(ctx, field)
			case "DependOnHost":
				return ec.fieldContext_HostDependency_DependOnHost(ctx, field)
			case "DependOnNetwork":
				return ec.fieldContext_HostDependency_DependOnNetwork(ctx, field)
			case "Environment":
				return ec.fieldContext_HostDependency_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostDependency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Network_IncludedNetworks(ctx context.Context, field graphql.CollectedField, obj *ent.Network) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Network_IncludedNetworks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IncludedNetworks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.IncludedNetwork)
	fc.Result = res
	return ec.marshalNIncludedNetwork2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐIncludedNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Network_IncludedNetworks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Network",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_IncludedNetwork_id(ctx, field)
			case "name":
				return ec.fieldContext_IncludedNetwork_name(ctx, field)
			case "includedHosts":
				return ec.fieldContext_IncludedNetwork_includedHosts(ctx, field)
			case "Tags":
				return ec.fieldContext_IncludedNetwork_Tags(ctx, field)
			case "Hosts":
				return ec.fieldContext_IncludedNetwork_Hosts(ctx, field)
			case "Network":
				return ec.fieldContext_IncludedNetwork_Network(ctx, field)
			case "Environments":
				return ec.fieldContext_IncludedNetwork_Environments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IncludedNetwork", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_id(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Plan().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_stepNumber(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_stepNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StepNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_stepNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_type(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Plan().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.PlanType)
	fc.Result = res
	return ec.marshalNPlanType2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐPlanType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PlanType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_NextPlans(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_NextPlans(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextPlans(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Plan)
	fc.Result = res
	return ec.marshalNPlan2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_NextPlans(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Plan_id(ctx, field)
			case "stepNumber":
				return ec.fieldContext_Plan_stepNumber(ctx, field)
			case "type":
				return ec.fieldContext_Plan_type(ctx, field)
			case "NextPlans":
				return ec.fieldContext_Plan_NextPlans(ctx, field)
			case "PrevPlans":
				return ec.fieldContext_Plan_PrevPlans(ctx, field)
			case "Build":
				return ec.fieldContext_Plan_Build(ctx, field)
			case "Team":
				return ec.fieldContext_Plan_Team(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Plan_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Plan_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
			case "Status":
				return ec.fieldContext_Plan_Status(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_Plan_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Plan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_PrevPlans(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_PrevPlans(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrevPlans(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Plan)
	fc.Result = res
	return ec.marshalNPlan2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_PrevPlans(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Plan_id(ctx, field)
			case "stepNumber":
				return ec.fieldContext_Plan_stepNumber(ctx, field)
			case "type":
				return ec.fieldContext_Plan_type(ctx, field)
			case "NextPlans":
				return ec.fieldContext_Plan_NextPlans(ctx, field)
			case "PrevPlans":
				return ec.fieldContext_Plan_PrevPlans(ctx, field)
			case "Build":
				return ec.fieldContext_Plan_Build(ctx, field)
			case "Team":
				return ec.fieldContext_Plan_Team(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Plan_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Plan_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
			case "Status":
				return ec.fieldContext_Plan_Status(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_Plan_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Plan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_Build(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_Build(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Build(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Build)
	fc.Result = res
	return ec.marshalOBuild2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_Build(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_Team(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_Team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Team(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Team)
	fc.Result = res
	return ec.marshalOTeam2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_Team(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "teamNumber":
				return ec.fieldContext_Team_teamNumber(ctx, field)
			case "Build":
				return ec.fieldContext_Team_Build(ctx, field)
			case "Status":
				return ec.fieldContext_Team_Status(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Team_ProvisionedNetworks(ctx, field)
			case "Plan":
				return ec.fieldContext_Team_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_ProvisionedNetwork(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedNetwork(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedNetwork)
	fc.Result = res
	return ec.marshalOProvisionedNetwork2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisionedNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_ProvisionedNetwork(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedNetwork_id(ctx, field)
			case "name":
				return ec.fieldContext_ProvisionedNetwork_name(ctx, field)
			case "cidr":
				return ec.fieldContext_ProvisionedNetwork_cidr(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedNetwork_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedNetwork_Status(ctx, field)
			case "Network":
				return ec.fieldContext_ProvisionedNetwork_Network(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedNetwork_Build(ctx, field)
			case "Team":
				return ec.fieldContext_ProvisionedNetwork_Team(ctx, field)
			case "ProvisionedHosts":
				return ec.fieldContext_ProvisionedNetwork_ProvisionedHosts(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedNetwork_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedNetwork", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_ProvisionedHost(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_ProvisionedHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedHost(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedHost)
	fc.Result = res
	return ec.marshalOProvisionedHost2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisionedHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_ProvisionedHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedHost_id(ctx, field)
			case "subnetIp":
				return ec.fieldContext_ProvisionedHost_subnetIp(ctx, field)
			case "addonType":
				return ec.fieldContext_ProvisionedHost_addonType(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedHost_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedHost_Status(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_ProvisionedHost_ProvisionedNetwork(ctx, field)
			case "Host":
				return ec.fieldContext_ProvisionedHost_Host(ctx, field)
			case "EndStepPlan":
				return ec.fieldContext_ProvisionedHost_EndStepPlan(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedHost_Build(ctx, field)
			case "ProvisioningSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningSteps(ctx, field)
			case "ProvisioningScheduledSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningScheduledSteps(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_ProvisionedHost_AgentStatuses(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisionedHost_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedHost_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisionedHost_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedHost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_ProvisioningStep(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_ProvisioningStep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisioningStep(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisioningStep)
	fc.Result = res
	return ec.marshalOProvisioningStep2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisioningStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_ProvisioningStep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisioningStep_id(ctx, field)
			case "type":
				return ec.fieldContext_ProvisioningStep_type(ctx, field)
			case "stepNumber":
				return ec.fieldContext_ProvisioningStep_stepNumber(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisioningStep_Status(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_ProvisioningStep_ProvisionedHost(ctx, field)
			case "Script":
				return ec.fieldContext_ProvisioningStep_Script(ctx, field)
			case "Command":
				return ec.fieldContext_ProvisioningStep_Command(ctx, field)
			case "DNSRecord":
				return ec.fieldContext_ProvisioningStep_DNSRecord(ctx, field)
			case "FileDelete":
				return ec.fieldContext_ProvisioningStep_FileDelete(ctx, field)
			case "FileDownload":
				return ec.fieldContext_ProvisioningStep_FileDownload(ctx, field)
			case "FileExtract":
				return ec.fieldContext_ProvisioningStep_FileExtract(ctx, field)
			case "Ansible":
				return ec.fieldContext_ProvisioningStep_Ansible(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisioningStep_Plan(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisioningStep_AgentTasks(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisioningStep_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisioningStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_ProvisioningScheduledStep(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisioningScheduledStep(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisioningScheduledStep)
	fc.Result = res
	return ec.marshalOProvisioningScheduledStep2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisioningScheduledStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_ProvisioningScheduledStep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisioningScheduledStep_id(ctx, field)
			case "type":
				return ec.fieldContext_ProvisioningScheduledStep_type(ctx, field)
			case "runTime":
				return ec.fieldContext_ProvisioningScheduledStep_runTime(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisioningScheduledStep_Status(ctx, field)
			case "ScheduledStep":
				return ec.fieldContext_ProvisioningScheduledStep_ScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_ProvisioningScheduledStep_ProvisionedHost(ctx, field)
			case "Script":
				return ec.fieldContext_ProvisioningScheduledStep_Script(ctx, field)
			case "Command":
				return ec.fieldContext_ProvisioningScheduledStep_Command(ctx, field)
			case "DNSRecord":
				return ec.fieldContext_ProvisioningScheduledStep_DNSRecord(ctx, field)
			case "FileDelete":
				return ec.fieldContext_ProvisioningScheduledStep_FileDelete(ctx, field)
			case "FileDownload":
				return ec.fieldContext_ProvisioningScheduledStep_FileDownload(ctx, field)
			case "FileExtract":
				return ec.fieldContext_ProvisioningScheduledStep_FileExtract(ctx, field)
			case "Ansible":
				return ec.fieldContext_ProvisioningScheduledStep_Ansible(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisioningScheduledStep_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisioningScheduledStep_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisioningScheduledStep_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisioningScheduledStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_Status(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_Status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Status)
	fc.Result = res
	return ec.marshalNStatus2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_Status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Plan_PlanDiffs(ctx context.Context, field graphql.CollectedField, obj *ent.Plan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Plan_PlanDiffs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlanDiffs(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.PlanDiff)
	fc.Result = res
	return ec.marshalNPlanDiff2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐPlanDiff(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Plan_PlanDiffs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Plan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PlanDiff_id(ctx, field)
			case "revision":
				return ec.fieldContext_PlanDiff_revision(ctx, field)
			case "newState":
				return ec.fieldContext_PlanDiff_newState(ctx, field)
			case "BuildCommit":
				return ec.fieldContext_PlanDiff_BuildCommit(ctx, field)
			case "Plan":
				return ec.fieldContext_PlanDiff_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlanDiff", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_planning(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_planning(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Planning, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_planning(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_awaiting(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_awaiting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Awaiting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_awaiting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_parentAwaiting(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_parentAwaiting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentAwaiting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_parentAwaiting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_inProgress(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_inProgress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InProgress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_inProgress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_failed(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_failed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Failed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_failed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_complete(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_complete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Complete, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_complete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_tainted(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_tainted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tainted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_tainted(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_undefined(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_undefined(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Undefined, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_undefined(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_toDelete(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_toDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToDelete, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_toDelete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_deleteInProgress(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_deleteInProgress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeleteInProgress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_deleteInProgress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_deleted(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_deleted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deleted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_deleted(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_toRebuild(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_toRebuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToRebuild, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_toRebuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanCounts_cancelled(ctx context.Context, field graphql.CollectedField, obj *model.PlanCounts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanCounts_cancelled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cancelled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanCounts_cancelled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanCounts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanDiff_id(ctx context.Context, field graphql.CollectedField, obj *ent.PlanDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanDiff_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PlanDiff().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanDiff_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanDiff",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanDiff_revision(ctx context.Context, field graphql.CollectedField, obj *ent.PlanDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanDiff_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanDiff_revision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanDiff_newState(ctx context.Context, field graphql.CollectedField, obj *ent.PlanDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanDiff_newState(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PlanDiff().NewState(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ProvisionStatus)
	fc.Result = res
	return ec.marshalNProvisionStatus2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐProvisionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanDiff_newState(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanDiff",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProvisionStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanDiff_BuildCommit(ctx context.Context, field graphql.CollectedField, obj *ent.PlanDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanDiff_BuildCommit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildCommit(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.BuildCommit)
	fc.Result = res
	return ec.marshalNBuildCommit2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuildCommit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanDiff_BuildCommit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanDiff",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BuildCommit_id(ctx, field)
			case "type":
				return ec.fieldContext_BuildCommit_type(ctx, field)
			case "revision":
				return ec.fieldContext_BuildCommit_revision(ctx, field)
			case "state":
				return ec.fieldContext_BuildCommit_state(ctx, field)
			case "createdAt":
				return ec.fieldContext_BuildCommit_createdAt(ctx, field)
			case "Build":
				return ec.fieldContext_BuildCommit_Build(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_BuildCommit_ServerTasks(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_BuildCommit_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildCommit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanDiff_Plan(ctx context.Context, field graphql.CollectedField, obj *ent.PlanDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanDiff_Plan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plan(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Plan)
	fc.Result = res
	return ec.marshalNPlan2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanDiff_Plan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanDiff",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Plan_id(ctx, field)
			case "stepNumber":
				return ec.fieldContext_Plan_stepNumber(ctx, field)
			case "type":
				return ec.fieldContext_Plan_type(ctx, field)
			case "NextPlans":
				return ec.fieldContext_Plan_NextPlans(ctx, field)
			case "PrevPlans":
				return ec.fieldContext_Plan_PrevPlans(ctx, field)
			case "Build":
				return ec.fieldContext_Plan_Build(ctx, field)
			case "Team":
				return ec.fieldContext_Plan_Team(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Plan_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Plan_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
			case "Status":
				return ec.fieldContext_Plan_Status(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_Plan_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Plan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_id(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProvisionedHost().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_subnetIp(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_subnetIp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubnetIP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_subnetIp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_addonType(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_addonType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProvisionedHost().AddonType(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ProvisionedHostAddonType)
	fc.Result = res
	return ec.marshalOProvisionedHostAddonType2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐProvisionedHostAddonType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_addonType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProvisionedHostAddonType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_vars(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProvisionedHost().Vars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.VarsMap)
	fc.Result = res
	return ec.marshalOvarsMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐVarsMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_vars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_varsMap_key(ctx, field)
			case "value":
				return ec.fieldContext_varsMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type varsMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_Status(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_Status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Status)
	fc.Result = res
	return ec.marshalNStatus2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_Status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_ProvisionedNetwork(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_ProvisionedNetwork(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedNetwork(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedNetwork)
	fc.Result = res
	return ec.marshalNProvisionedNetwork2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisionedNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_ProvisionedNetwork(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedNetwork_id(ctx, field)
			case "name":
				return ec.fieldContext_ProvisionedNetwork_name(ctx, field)
			case "cidr":
				return ec.fieldContext_ProvisionedNetwork_cidr(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedNetwork_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedNetwork_Status(ctx, field)
			case "Network":
				return ec.fieldContext_ProvisionedNetwork_Network(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedNetwork_Build(ctx, field)
			case "Team":
				return ec.fieldContext_ProvisionedNetwork_Team(ctx, field)
			case "ProvisionedHosts":
				return ec.fieldContext_ProvisionedNetwork_ProvisionedHosts(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedNetwork_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedNetwork", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_Host(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_Host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Host(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Host)
	fc.Result = res
	return ec.marshalNHost2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_Host(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Host_hclId(ctx, field)
			case "hostname":
				return ec.fieldContext_Host_hostname(ctx, field)
			case "description":
				return ec.fieldContext_Host_description(ctx, field)
			case "OS":
				return ec.fieldContext_Host_OS(ctx, field)
			case "lastOctet":
				return ec.fieldContext_Host_lastOctet(ctx, field)
			case "instanceSize":
				return ec.fieldContext_Host_instanceSize(ctx, field)
			case "allowMacChanges":
				return ec.fieldContext_Host_allowMacChanges(ctx, field)
			case "exposedTcpPorts":
				return ec.fieldContext_Host_exposedTcpPorts(ctx, field)
			case "exposedUdpPorts":
				return ec.fieldContext_Host_exposedUdpPorts(ctx, field)
			case "overridePassword":
				return ec.fieldContext_Host_overridePassword(ctx, field)
			case "vars":
				return ec.fieldContext_Host_vars(ctx, field)
			case "userGroups":
				return ec.fieldContext_Host_userGroups(ctx, field)
			case "provisionSteps":
				return ec.fieldContext_Host_provisionSteps(ctx, field)
			case "tags":
				return ec.fieldContext_Host_tags(ctx, field)
			case "Disk":
				return ec.fieldContext_Host_Disk(ctx, field)
			case "Users":
				return ec.fieldContext_Host_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Host_Environment(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Host_IncludedNetworks(ctx, field)
			case "DependOnHostDependencies":
				return ec.fieldContext_Host_DependOnHostDependencies(ctx, field)
			case "RequiredByHostDependencies":
				return ec.fieldContext_Host_RequiredByHostDependencies(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_EndStepPlan(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_EndStepPlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndStepPlan(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Plan)
	fc.Result = res
	return ec.marshalOPlan2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_EndStepPlan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Plan_id(ctx, field)
			case "stepNumber":
				return ec.fieldContext_Plan_stepNumber(ctx, field)
			case "type":
				return ec.fieldContext_Plan_type(ctx, field)
			case "NextPlans":
				return ec.fieldContext_Plan_NextPlans(ctx, field)
			case "PrevPlans":
				return ec.fieldContext_Plan_PrevPlans(ctx, field)
			case "Build":
				return ec.fieldContext_Plan_Build(ctx, field)
			case "Team":
				return ec.fieldContext_Plan_Team(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Plan_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Plan_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
			case "Status":
				return ec.fieldContext_Plan_Status(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_Plan_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Plan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_Build(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_Build(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Build(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Build)
	fc.Result = res
	return ec.marshalNBuild2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_Build(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_ProvisioningSteps(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_ProvisioningSteps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisioningSteps(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ProvisioningStep)
	fc.Result = res
	return ec.marshalNProvisioningStep2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisioningStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_ProvisioningSteps(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisioningStep_id(ctx, field)
			case "type":
				return ec.fieldContext_ProvisioningStep_type(ctx, field)
			case "stepNumber":
				return ec.fieldContext_ProvisioningStep_stepNumber(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisioningStep_Status(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_ProvisioningStep_ProvisionedHost(ctx, field)
			case "Script":
				return ec.fieldContext_ProvisioningStep_Script(ctx, field)
			case "Command":
				return ec.fieldContext_ProvisioningStep_Command(ctx, field)
			case "DNSRecord":
				return ec.fieldContext_ProvisioningStep_DNSRecord(ctx, field)
			case "FileDelete":
				return ec.fieldContext_ProvisioningStep_FileDelete(ctx, field)
			case "FileDownload":
				return ec.fieldContext_ProvisioningStep_FileDownload(ctx, field)
			case "FileExtract":
				return ec.fieldContext_ProvisioningStep_FileExtract(ctx, field)
			case "Ansible":
				return ec.fieldContext_ProvisioningStep_Ansible(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisioningStep_Plan(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisioningStep_AgentTasks(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisioningStep_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisioningStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_ProvisioningScheduledSteps(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_ProvisioningScheduledSteps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisioningScheduledSteps(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ProvisioningScheduledStep)
	fc.Result = res
	return ec.marshalNProvisioningScheduledStep2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisioningScheduledStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_ProvisioningScheduledSteps(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisioningScheduledStep_id(ctx, field)
			case "type":
				return ec.fieldContext_ProvisioningScheduledStep_type(ctx, field)
			case "runTime":
				return ec.fieldContext_ProvisioningScheduledStep_runTime(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisioningScheduledStep_Status(ctx, field)
			case "ScheduledStep":
				return ec.fieldContext_ProvisioningScheduledStep_ScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_ProvisioningScheduledStep_ProvisionedHost(ctx, field)
			case "Script":
				return ec.fieldContext_ProvisioningScheduledStep_Script(ctx, field)
			case "Command":
				return ec.fieldContext_ProvisioningScheduledStep_Command(ctx, field)
			case "DNSRecord":
				return ec.fieldContext_ProvisioningScheduledStep_DNSRecord(ctx, field)
			case "FileDelete":
				return ec.fieldContext_ProvisioningScheduledStep_FileDelete(ctx, field)
			case "FileDownload":
				return ec.fieldContext_ProvisioningScheduledStep_FileDownload(ctx, field)
			case "FileExtract":
				return ec.fieldContext_ProvisioningScheduledStep_FileExtract(ctx, field)
			case "Ansible":
				return ec.fieldContext_ProvisioningScheduledStep_Ansible(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisioningScheduledStep_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisioningScheduledStep_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisioningScheduledStep_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisioningScheduledStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_AgentStatuses(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_AgentStatuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentStatuses(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.AgentStatus)
	fc.Result = res
	return ec.marshalNAgentStatus2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_AgentStatuses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "clientId":
				return ec.fieldContext_AgentStatus_clientId(ctx, field)
			case "hostname":
				return ec.fieldContext_AgentStatus_hostname(ctx, field)
			case "upTime":
				return ec.fieldContext_AgentStatus_upTime(ctx, field)
			case "bootTime":
				return ec.fieldContext_AgentStatus_bootTime(ctx, field)
			case "numProcs":
				return ec.fieldContext_AgentStatus_numProcs(ctx, field)
			case "OS":
				return ec.fieldContext_AgentStatus_OS(ctx, field)
			case "hostID":
				return ec.fieldContext_AgentStatus_hostID(ctx, field)
			case "load1":
				return ec.fieldContext_AgentStatus_load1(ctx, field)
			case "load5":
				return ec.fieldContext_AgentStatus_load5(ctx, field)
			case "load15":
				return ec.fieldContext_AgentStatus_load15(ctx, field)
			case "totalMem":
				return ec.fieldContext_AgentStatus_totalMem(ctx, field)
			case "freeMem":
				return ec.fieldContext_AgentStatus_freeMem(ctx, field)
			case "usedMem":
				return ec.fieldContext_AgentStatus_usedMem(ctx, field)
			case "timestamp":
				return ec.fieldContext_AgentStatus_timestamp(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentStatus_ProvisionedHost(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_AgentStatus_ProvisionedNetwork(ctx, field)
			case "Build":
				return ec.fieldContext_AgentStatus_Build(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_AgentTasks(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_AgentTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentTasks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.AgentTask)
	fc.Result = res
	return ec.marshalNAgentTask2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_AgentTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AgentTask_id(ctx, field)
			case "args":
				return ec.fieldContext_AgentTask_args(ctx, field)
			case "command":
				return ec.fieldContext_AgentTask_command(ctx, field)
			case "number":
				return ec.fieldContext_AgentTask_number(ctx, field)
			case "output":
				return ec.fieldContext_AgentTask_output(ctx, field)
			case "state":
				return ec.fieldContext_AgentTask_state(ctx, field)
			case "errorMessage":
				return ec.fieldContext_AgentTask_errorMessage(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_AgentTask_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_AgentTask_ProvisioningScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentTask_ProvisionedHost(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_AgentTask_AdhocPlans(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_Plan(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_Plan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plan(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Plan)
	fc.Result = res
	return ec.marshalNPlan2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_Plan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Plan_id(ctx, field)
			case "stepNumber":
				return ec.fieldContext_Plan_stepNumber(ctx, field)
			case "type":
				return ec.fieldContext_Plan_type(ctx, field)
			case "NextPlans":
				return ec.fieldContext_Plan_NextPlans(ctx, field)
			case "PrevPlans":
				return ec.fieldContext_Plan_PrevPlans(ctx, field)
			case "Build":
				return ec.fieldContext_Plan_Build(ctx, field)
			case "Team":
				return ec.fieldContext_Plan_Team(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Plan_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Plan_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
			case "Status":
				return ec.fieldContext_Plan_Status(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_Plan_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Plan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedHost_GinFileMiddleware(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedHost_GinFileMiddleware(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GinFileMiddleware(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.GinFileMiddleware)
	fc.Result = res
	return ec.marshalOGinFileMiddleware2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐGinFileMiddleware(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedHost_GinFileMiddleware(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedHost",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GinFileMiddleware_id(ctx, field)
			case "urlId":
				return ec.fieldContext_GinFileMiddleware_urlId(ctx, field)
			case "filePath":
				return ec.fieldContext_GinFileMiddleware_filePath(ctx, field)
			case "accessed":
				return ec.fieldContext_GinFileMiddleware_accessed(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_GinFileMiddleware_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_GinFileMiddleware_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_GinFileMiddleware_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GinFileMiddleware", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedNetwork_id(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedNetwork_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProvisionedNetwork().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedNetwork_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedNetwork_name(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedNetwork_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedNetwork_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedNetwork_cidr(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedNetwork_cidr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cidr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedNetwork_cidr(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedNetwork",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedNetwork_vars(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedNetwork_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProvisionedNetwork().Vars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.VarsMap)
	fc.Result = res
	return ec.marshalOvarsMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐVarsMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedNetwork_vars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_varsMap_key(ctx, field)
			case "value":
				return ec.fieldContext_varsMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type varsMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedNetwork_Status(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedNetwork_Status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Status)
	fc.Result = res
	return ec.marshalOStatus2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedNetwork_Status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedNetwork_Network(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedNetwork_Network(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Network(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Network)
	fc.Result = res
	return ec.marshalONetwork2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedNetwork_Network(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Network_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Network_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Network_name(ctx, field)
			case "cidr":
				return ec.fieldContext_Network_cidr(ctx, field)
			case "vdiVisible":
				return ec.fieldContext_Network_vdiVisible(ctx, field)
			case "vars":
				return ec.fieldContext_Network_vars(ctx, field)
			case "tags":
				return ec.fieldContext_Network_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_Network_Environment(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Network_HostDependencies(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Network_IncludedNetworks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Network", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedNetwork_Build(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedNetwork_Build(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Build(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Build)
	fc.Result = res
	return ec.marshalOBuild2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedNetwork_Build(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedNetwork_Team(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedNetwork_Team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Team(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Team)
	fc.Result = res
	return ec.marshalOTeam2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedNetwork_Team(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "teamNumber":
				return ec.fieldContext_Team_teamNumber(ctx, field)
			case "Build":
				return ec.fieldContext_Team_Build(ctx, field)
			case "Status":
				return ec.fieldContext_Team_Status(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Team_ProvisionedNetworks(ctx, field)
			case "Plan":
				return ec.fieldContext_Team_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedNetwork_ProvisionedHosts(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedNetwork_ProvisionedHosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedHosts(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ProvisionedHost)
	fc.Result = res
	return ec.marshalNProvisionedHost2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisionedHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedNetwork_ProvisionedHosts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedHost_id(ctx, field)
			case "subnetIp":
				return ec.fieldContext_ProvisionedHost_subnetIp(ctx, field)
			case "addonType":
				return ec.fieldContext_ProvisionedHost_addonType(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedHost_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedHost_Status(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_ProvisionedHost_ProvisionedNetwork(ctx, field)
			case "Host":
				return ec.fieldContext_ProvisionedHost_Host(ctx, field)
			case "EndStepPlan":
				return ec.fieldContext_ProvisionedHost_EndStepPlan(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedHost_Build(ctx, field)
			case "ProvisioningSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningSteps(ctx, field)
			case "ProvisioningScheduledSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningScheduledSteps(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_ProvisionedHost_AgentStatuses(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisionedHost_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedHost_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisionedHost_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedHost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisionedNetwork_Plan(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisionedNetwork) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisionedNetwork_Plan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plan(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Plan)
	fc.Result = res
	return ec.marshalOPlan2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisionedNetwork_Plan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisionedNetwork",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Plan_id(ctx, field)
			case "stepNumber":
				return ec.fieldContext_Plan_stepNumber(ctx, field)
			case "type":
				return ec.fieldContext_Plan_type(ctx, field)
			case "NextPlans":
				return ec.fieldContext_Plan_NextPlans(ctx, field)
			case "PrevPlans":
				return ec.fieldContext_Plan_PrevPlans(ctx, field)
			case "Build":
				return ec.fieldContext_Plan_Build(ctx, field)
			case "Team":
				return ec.fieldContext_Plan_Team(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Plan_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Plan_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
			case "Status":
				return ec.fieldContext_Plan_Status(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_Plan_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Plan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_id(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProvisioningScheduledStep().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_type(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProvisioningScheduledStep().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ProvisioningScheduledStepType)
	fc.Result = res
	return ec.marshalNProvisioningScheduledStepType2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐProvisioningScheduledStepType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProvisioningScheduledStepType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_runTime(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_runTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RunTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_runTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_Status(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_Status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Status)
	fc.Result = res
	return ec.marshalOStatus2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_Status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_ScheduledStep(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_ScheduledStep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScheduledStep(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ScheduledStep)
	fc.Result = res
	return ec.marshalNScheduledStep2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐScheduledStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_ScheduledStep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ScheduledStep_id(ctx, field)
			case "hclId":
				return ec.fieldContext_ScheduledStep_hclId(ctx, field)
			case "name":
				return ec.fieldContext_ScheduledStep_name(ctx, field)
			case "description":
				return ec.fieldContext_ScheduledStep_description(ctx, field)
			case "step":
				return ec.fieldContext_ScheduledStep_step(ctx, field)
			case "type":
				return ec.fieldContext_ScheduledStep_type(ctx, field)
			case "schedule":
				return ec.fieldContext_ScheduledStep_schedule(ctx, field)
			case "runAt":
				return ec.fieldContext_ScheduledStep_runAt(ctx, field)
			case "Environment":
				return ec.fieldContext_ScheduledStep_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ScheduledStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_ProvisionedHost(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_ProvisionedHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedHost(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedHost)
	fc.Result = res
	return ec.marshalNProvisionedHost2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisionedHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_ProvisionedHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedHost_id(ctx, field)
			case "subnetIp":
				return ec.fieldContext_ProvisionedHost_subnetIp(ctx, field)
			case "addonType":
				return ec.fieldContext_ProvisionedHost_addonType(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedHost_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedHost_Status(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_ProvisionedHost_ProvisionedNetwork(ctx, field)
			case "Host":
				return ec.fieldContext_ProvisionedHost_Host(ctx, field)
			case "EndStepPlan":
				return ec.fieldContext_ProvisionedHost_EndStepPlan(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedHost_Build(ctx, field)
			case "ProvisioningSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningSteps(ctx, field)
			case "ProvisioningScheduledSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningScheduledSteps(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_ProvisionedHost_AgentStatuses(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisionedHost_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedHost_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisionedHost_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedHost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_Script(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_Script(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Script(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Script)
	fc.Result = res
	return ec.marshalOScript2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐScript(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_Script(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Script_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Script_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Script_name(ctx, field)
			case "language":
				return ec.fieldContext_Script_language(ctx, field)
			case "description":
				return ec.fieldContext_Script_description(ctx, field)
			case "source":
				return ec.fieldContext_Script_source(ctx, field)
			case "sourceType":
				return ec.fieldContext_Script_sourceType(ctx, field)
			case "cooldown":
				return ec.fieldContext_Script_cooldown(ctx, field)
			case "timeout":
				return ec.fieldContext_Script_timeout(ctx, field)
			case "ignoreErrors":
				return ec.fieldContext_Script_ignoreErrors(ctx, field)
			case "args":
				return ec.fieldContext_Script_args(ctx, field)
			case "disabled":
				return ec.fieldContext_Script_disabled(ctx, field)
			case "vars":
				return ec.fieldContext_Script_vars(ctx, field)
			case "absPath":
				return ec.fieldContext_Script_absPath(ctx, field)
			case "tags":
				return ec.fieldContext_Script_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Script_Users(ctx, field)
			case "Findings":
				return ec.fieldContext_Script_Findings(ctx, field)
			case "Environment":
				return ec.fieldContext_Script_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Script", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_Command(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_Command(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Command(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Command)
	fc.Result = res
	return ec.marshalOCommand2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐCommand(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_Command(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Command_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Command_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Command_name(ctx, field)
			case "description":
				return ec.fieldContext_Command_description(ctx, field)
			case "program":
				return ec.fieldContext_Command_program(ctx, field)
			case "args":
				return ec.fieldContext_Command_args(ctx, field)
			case "ignoreErrors":
				return ec.fieldContext_Command_ignoreErrors(ctx, field)
			case "disabled":
				return ec.fieldContext_Command_disabled(ctx, field)
			case "cooldown":
				return ec.fieldContext_Command_cooldown(ctx, field)
			case "timeout":
				return ec.fieldContext_Command_timeout(ctx, field)
			case "vars":
				return ec.fieldContext_Command_vars(ctx, field)
			case "tags":
				return ec.fieldContext_Command_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Command_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Command_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Command", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_DNSRecord(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_DNSRecord(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DNSRecord(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.DNSRecord)
	fc.Result = res
	return ec.marshalODNSRecord2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐDNSRecord(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_DNSRecord(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DNSRecord_id(ctx, field)
			case "hclId":
				return ec.fieldContext_DNSRecord_hclId(ctx, field)
			case "name":
				return ec.fieldContext_DNSRecord_name(ctx, field)
			case "values":
				return ec.fieldContext_DNSRecord_values(ctx, field)
			case "type":
				return ec.fieldContext_DNSRecord_type(ctx, field)
			case "zone":
				return ec.fieldContext_DNSRecord_zone(ctx, field)
			case "vars":
				return ec.fieldContext_DNSRecord_vars(ctx, field)
			case "disabled":
				return ec.fieldContext_DNSRecord_disabled(ctx, field)
			case "tags":
				return ec.fieldContext_DNSRecord_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_DNSRecord_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DNSRecord", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_FileDelete(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_FileDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileDelete(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.FileDelete)
	fc.Result = res
	return ec.marshalOFileDelete2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐFileDelete(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_FileDelete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FileDelete_id(ctx, field)
			case "hclId":
				return ec.fieldContext_FileDelete_hclId(ctx, field)
			case "path":
				return ec.fieldContext_FileDelete_path(ctx, field)
			case "tags":
				return ec.fieldContext_FileDelete_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_FileDelete_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileDelete", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_FileDownload(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_FileDownload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileDownload(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.FileDownload)
	fc.Result = res
	return ec.marshalOFileDownload2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐFileDownload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_FileDownload(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FileDownload_id(ctx, field)
			case "hclId":
				return ec.fieldContext_FileDownload_hclId(ctx, field)
			case "sourceType":
				return ec.fieldContext_FileDownload_sourceType(ctx, field)
			case "source":
				return ec.fieldContext_FileDownload_source(ctx, field)
			case "destination":
				return ec.fieldContext_FileDownload_destination(ctx, field)
			case "template":
				return ec.fieldContext_FileDownload_template(ctx, field)
			case "perms":
				return ec.fieldContext_FileDownload_perms(ctx, field)
			case "disabled":
				return ec.fieldContext_FileDownload_disabled(ctx, field)
			case "md5":
				return ec.fieldContext_FileDownload_md5(ctx, field)
			case "absPath":
				return ec.fieldContext_FileDownload_absPath(ctx, field)
			case "tags":
				return ec.fieldContext_FileDownload_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_FileDownload_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileDownload", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_FileExtract(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_FileExtract(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileExtract(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.FileExtract)
	fc.Result = res
	return ec.marshalOFileExtract2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐFileExtract(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_FileExtract(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FileExtract_id(ctx, field)
			case "hclId":
				return ec.fieldContext_FileExtract_hclId(ctx, field)
			case "source":
				return ec.fieldContext_FileExtract_source(ctx, field)
			case "destination":
				return ec.fieldContext_FileExtract_destination(ctx, field)
			case "type":
				return ec.fieldContext_FileExtract_type(ctx, field)
			case "tags":
				return ec.fieldContext_FileExtract_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_FileExtract_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileExtract", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_Ansible(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_Ansible(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ansible(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Ansible)
	fc.Result = res
	return ec.marshalOAnsible2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAnsible(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_Ansible(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Ansible_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Ansible_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Ansible_name(ctx, field)
			case "description":
				return ec.fieldContext_Ansible_description(ctx, field)
			case "source":
				return ec.fieldContext_Ansible_source(ctx, field)
			case "playbookName":
				return ec.fieldContext_Ansible_playbookName(ctx, field)
			case "method":
				return ec.fieldContext_Ansible_method(ctx, field)
			case "inventory":
				return ec.fieldContext_Ansible_inventory(ctx, field)
			case "absPath":
				return ec.fieldContext_Ansible_absPath(ctx, field)
			case "tags":
				return ec.fieldContext_Ansible_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Ansible_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Ansible_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Ansible", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_AgentTasks(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_AgentTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentTasks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.AgentTask)
	fc.Result = res
	return ec.marshalNAgentTask2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_AgentTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AgentTask_id(ctx, field)
			case "args":
				return ec.fieldContext_AgentTask_args(ctx, field)
			case "command":
				return ec.fieldContext_AgentTask_command(ctx, field)
			case "number":
				return ec.fieldContext_AgentTask_number(ctx, field)
			case "output":
				return ec.fieldContext_AgentTask_output(ctx, field)
			case "state":
				return ec.fieldContext_AgentTask_state(ctx, field)
			case "errorMessage":
				return ec.fieldContext_AgentTask_errorMessage(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_AgentTask_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_AgentTask_ProvisioningScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentTask_ProvisionedHost(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_AgentTask_AdhocPlans(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_Plan(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_Plan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plan(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Plan)
	fc.Result = res
	return ec.marshalOPlan2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_Plan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Plan_id(ctx, field)
			case "stepNumber":
				return ec.fieldContext_Plan_stepNumber(ctx, field)
			case "type":
				return ec.fieldContext_Plan_type(ctx, field)
			case "NextPlans":
				return ec.fieldContext_Plan_NextPlans(ctx, field)
			case "PrevPlans":
				return ec.fieldContext_Plan_PrevPlans(ctx, field)
			case "Build":
				return ec.fieldContext_Plan_Build(ctx, field)
			case "Team":
				return ec.fieldContext_Plan_Team(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Plan_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Plan_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
			case "Status":
				return ec.fieldContext_Plan_Status(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_Plan_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Plan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningScheduledStep_GinFileMiddleware(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningScheduledStep_GinFileMiddleware(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GinFileMiddleware(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.GinFileMiddleware)
	fc.Result = res
	return ec.marshalOGinFileMiddleware2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐGinFileMiddleware(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningScheduledStep_GinFileMiddleware(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GinFileMiddleware_id(ctx, field)
			case "urlId":
				return ec.fieldContext_GinFileMiddleware_urlId(ctx, field)
			case "filePath":
				return ec.fieldContext_GinFileMiddleware_filePath(ctx, field)
			case "accessed":
				return ec.fieldContext_GinFileMiddleware_accessed(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_GinFileMiddleware_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_GinFileMiddleware_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_GinFileMiddleware_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GinFileMiddleware", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_id(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProvisioningStep().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_type(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProvisioningStep().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ProvisioningStepType)
	fc.Result = res
	return ec.marshalNProvisioningStepType2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐProvisioningStepType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProvisioningStepType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_stepNumber(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_stepNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StepNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_stepNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_Status(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_Status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Status)
	fc.Result = res
	return ec.marshalOStatus2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_Status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_ProvisionedHost(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_ProvisionedHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedHost(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedHost)
	fc.Result = res
	return ec.marshalNProvisionedHost2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisionedHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_ProvisionedHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedHost_id(ctx, field)
			case "subnetIp":
				return ec.fieldContext_ProvisionedHost_subnetIp(ctx, field)
			case "addonType":
				return ec.fieldContext_ProvisionedHost_addonType(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedHost_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedHost_Status(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_ProvisionedHost_ProvisionedNetwork(ctx, field)
			case "Host":
				return ec.fieldContext_ProvisionedHost_Host(ctx, field)
			case "EndStepPlan":
				return ec.fieldContext_ProvisionedHost_EndStepPlan(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedHost_Build(ctx, field)
			case "ProvisioningSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningSteps(ctx, field)
			case "ProvisioningScheduledSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningScheduledSteps(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_ProvisionedHost_AgentStatuses(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisionedHost_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedHost_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisionedHost_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedHost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_Script(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_Script(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Script(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Script)
	fc.Result = res
	return ec.marshalOScript2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐScript(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_Script(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Script_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Script_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Script_name(ctx, field)
			case "language":
				return ec.fieldContext_Script_language(ctx, field)
			case "description":
				return ec.fieldContext_Script_description(ctx, field)
			case "source":
				return ec.fieldContext_Script_source(ctx, field)
			case "sourceType":
				return ec.fieldContext_Script_sourceType(ctx, field)
			case "cooldown":
				return ec.fieldContext_Script_cooldown(ctx, field)
			case "timeout":
				return ec.fieldContext_Script_timeout(ctx, field)
			case "ignoreErrors":
				return ec.fieldContext_Script_ignoreErrors(ctx, field)
			case "args":
				return ec.fieldContext_Script_args(ctx, field)
			case "disabled":
				return ec.fieldContext_Script_disabled(ctx, field)
			case "vars":
				return ec.fieldContext_Script_vars(ctx, field)
			case "absPath":
				return ec.fieldContext_Script_absPath(ctx, field)
			case "tags":
				return ec.fieldContext_Script_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Script_Users(ctx, field)
			case "Findings":
				return ec.fieldContext_Script_Findings(ctx, field)
			case "Environment":
				return ec.fieldContext_Script_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Script", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_Command(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_Command(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Command(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Command)
	fc.Result = res
	return ec.marshalOCommand2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐCommand(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_Command(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Command_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Command_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Command_name(ctx, field)
			case "description":
				return ec.fieldContext_Command_description(ctx, field)
			case "program":
				return ec.fieldContext_Command_program(ctx, field)
			case "args":
				return ec.fieldContext_Command_args(ctx, field)
			case "ignoreErrors":
				return ec.fieldContext_Command_ignoreErrors(ctx, field)
			case "disabled":
				return ec.fieldContext_Command_disabled(ctx, field)
			case "cooldown":
				return ec.fieldContext_Command_cooldown(ctx, field)
			case "timeout":
				return ec.fieldContext_Command_timeout(ctx, field)
			case "vars":
				return ec.fieldContext_Command_vars(ctx, field)
			case "tags":
				return ec.fieldContext_Command_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Command_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Command_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Command", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_DNSRecord(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_DNSRecord(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DNSRecord(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.DNSRecord)
	fc.Result = res
	return ec.marshalODNSRecord2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐDNSRecord(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_DNSRecord(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DNSRecord_id(ctx, field)
			case "hclId":
				return ec.fieldContext_DNSRecord_hclId(ctx, field)
			case "name":
				return ec.fieldContext_DNSRecord_name(ctx, field)
			case "values":
				return ec.fieldContext_DNSRecord_values(ctx, field)
			case "type":
				return ec.fieldContext_DNSRecord_type(ctx, field)
			case "zone":
				return ec.fieldContext_DNSRecord_zone(ctx, field)
			case "vars":
				return ec.fieldContext_DNSRecord_vars(ctx, field)
			case "disabled":
				return ec.fieldContext_DNSRecord_disabled(ctx, field)
			case "tags":
				return ec.fieldContext_DNSRecord_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_DNSRecord_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DNSRecord", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_FileDelete(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_FileDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileDelete(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.FileDelete)
	fc.Result = res
	return ec.marshalOFileDelete2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐFileDelete(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_FileDelete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FileDelete_id(ctx, field)
			case "hclId":
				return ec.fieldContext_FileDelete_hclId(ctx, field)
			case "path":
				return ec.fieldContext_FileDelete_path(ctx, field)
			case "tags":
				return ec.fieldContext_FileDelete_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_FileDelete_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileDelete", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_FileDownload(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_FileDownload(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileDownload(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.FileDownload)
	fc.Result = res
	return ec.marshalOFileDownload2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐFileDownload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_FileDownload(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FileDownload_id(ctx, field)
			case "hclId":
				return ec.fieldContext_FileDownload_hclId(ctx, field)
			case "sourceType":
				return ec.fieldContext_FileDownload_sourceType(ctx, field)
			case "source":
				return ec.fieldContext_FileDownload_source(ctx, field)
			case "destination":
				return ec.fieldContext_FileDownload_destination(ctx, field)
			case "template":
				return ec.fieldContext_FileDownload_template(ctx, field)
			case "perms":
				return ec.fieldContext_FileDownload_perms(ctx, field)
			case "disabled":
				return ec.fieldContext_FileDownload_disabled(ctx, field)
			case "md5":
				return ec.fieldContext_FileDownload_md5(ctx, field)
			case "absPath":
				return ec.fieldContext_FileDownload_absPath(ctx, field)
			case "tags":
				return ec.fieldContext_FileDownload_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_FileDownload_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileDownload", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_FileExtract(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_FileExtract(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileExtract(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.FileExtract)
	fc.Result = res
	return ec.marshalOFileExtract2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐFileExtract(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_FileExtract(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FileExtract_id(ctx, field)
			case "hclId":
				return ec.fieldContext_FileExtract_hclId(ctx, field)
			case "source":
				return ec.fieldContext_FileExtract_source(ctx, field)
			case "destination":
				return ec.fieldContext_FileExtract_destination(ctx, field)
			case "type":
				return ec.fieldContext_FileExtract_type(ctx, field)
			case "tags":
				return ec.fieldContext_FileExtract_tags(ctx, field)
			case "Environment":
				return ec.fieldContext_FileExtract_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileExtract", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_Ansible(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_Ansible(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ansible(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Ansible)
	fc.Result = res
	return ec.marshalOAnsible2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAnsible(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_Ansible(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Ansible_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Ansible_hclId(ctx, field)
			case "name":
				return ec.fieldContext_Ansible_name(ctx, field)
			case "description":
				return ec.fieldContext_Ansible_description(ctx, field)
			case "source":
				return ec.fieldContext_Ansible_source(ctx, field)
			case "playbookName":
				return ec.fieldContext_Ansible_playbookName(ctx, field)
			case "method":
				return ec.fieldContext_Ansible_method(ctx, field)
			case "inventory":
				return ec.fieldContext_Ansible_inventory(ctx, field)
			case "absPath":
				return ec.fieldContext_Ansible_absPath(ctx, field)
			case "tags":
				return ec.fieldContext_Ansible_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Ansible_Users(ctx, field)
			case "Environment":
				return ec.fieldContext_Ansible_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Ansible", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_Plan(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_Plan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plan(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Plan)
	fc.Result = res
	return ec.marshalOPlan2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_Plan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Plan_id(ctx, field)
			case "stepNumber":
				return ec.fieldContext_Plan_stepNumber(ctx, field)
			case "type":
				return ec.fieldContext_Plan_type(ctx, field)
			case "NextPlans":
				return ec.fieldContext_Plan_NextPlans(ctx, field)
			case "PrevPlans":
				return ec.fieldContext_Plan_PrevPlans(ctx, field)
			case "Build":
				return ec.fieldContext_Plan_Build(ctx, field)
			case "Team":
				return ec.fieldContext_Plan_Team(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Plan_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Plan_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
			case "Status":
				return ec.fieldContext_Plan_Status(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_Plan_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Plan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_AgentTasks(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_AgentTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentTasks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.AgentTask)
	fc.Result = res
	return ec.marshalNAgentTask2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_AgentTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AgentTask_id(ctx, field)
			case "args":
				return ec.fieldContext_AgentTask_args(ctx, field)
			case "command":
				return ec.fieldContext_AgentTask_command(ctx, field)
			case "number":
				return ec.fieldContext_AgentTask_number(ctx, field)
			case "output":
				return ec.fieldContext_AgentTask_output(ctx, field)
			case "state":
				return ec.fieldContext_AgentTask_state(ctx, field)
			case "errorMessage":
				return ec.fieldContext_AgentTask_errorMessage(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_AgentTask_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_AgentTask_ProvisioningScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentTask_ProvisionedHost(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_AgentTask_AdhocPlans(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProvisioningStep_GinFileMiddleware(ctx context.Context, field graphql.CollectedField, obj *ent.ProvisioningStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProvisioningStep_GinFileMiddleware(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GinFileMiddleware(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.GinFileMiddleware)
	fc.Result = res
	return ec.marshalOGinFileMiddleware2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐGinFileMiddleware(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProvisioningStep_GinFileMiddleware(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProvisioningStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GinFileMiddleware_id(ctx, field)
			case "urlId":
				return ec.fieldContext_GinFileMiddleware_urlId(ctx, field)
			case "filePath":
				return ec.fieldContext_GinFileMiddleware_filePath(ctx, field)
			case "accessed":
				return ec.fieldContext_GinFileMiddleware_accessed(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_GinFileMiddleware_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_GinFileMiddleware_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_GinFileMiddleware_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GinFileMiddleware", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_environments(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_environments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Environments(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.Environment); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.Environment`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Environment)
	fc.Result = res
	return ec.marshalOEnvironment2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_environments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_environment(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Environment(rctx, fc.Args["envUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.Environment); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.Environment`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalOEnvironment2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_environment_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_provisionedHost(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_provisionedHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ProvisionedHost(rctx, fc.Args["proHostUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.ProvisionedHost); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.ProvisionedHost`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedHost)
	fc.Result = res
	return ec.marshalOProvisionedHost2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisionedHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_provisionedHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedHost_id(ctx, field)
			case "subnetIp":
				return ec.fieldContext_ProvisionedHost_subnetIp(ctx, field)
			case "addonType":
				return ec.fieldContext_ProvisionedHost_addonType(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedHost_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedHost_Status(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_ProvisionedHost_ProvisionedNetwork(ctx, field)
			case "Host":
				return ec.fieldContext_ProvisionedHost_Host(ctx, field)
			case "EndStepPlan":
				return ec.fieldContext_ProvisionedHost_EndStepPlan(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedHost_Build(ctx, field)
			case "ProvisioningSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningSteps(ctx, field)
			case "ProvisioningScheduledSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningScheduledSteps(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_ProvisionedHost_AgentStatuses(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisionedHost_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedHost_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisionedHost_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedHost", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_provisionedHost_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_provisionedNetwork(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_provisionedNetwork(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ProvisionedNetwork(rctx, fc.Args["proNetUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.ProvisionedNetwork); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.ProvisionedNetwork`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedNetwork)
	fc.Result = res
	return ec.marshalOProvisionedNetwork2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisionedNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_provisionedNetwork(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedNetwork_id(ctx, field)
			case "name":
				return ec.fieldContext_ProvisionedNetwork_name(ctx, field)
			case "cidr":
				return ec.fieldContext_ProvisionedNetwork_cidr(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedNetwork_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedNetwork_Status(ctx, field)
			case "Network":
				return ec.fieldContext_ProvisionedNetwork_Network(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedNetwork_Build(ctx, field)
			case "Team":
				return ec.fieldContext_ProvisionedNetwork_Team(ctx, field)
			case "ProvisionedHosts":
				return ec.fieldContext_ProvisionedNetwork_ProvisionedHosts(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedNetwork_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedNetwork", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_provisionedNetwork_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_provisionedStep(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_provisionedStep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ProvisionedStep(rctx, fc.Args["proStepUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.ProvisioningStep); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.ProvisioningStep`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisioningStep)
	fc.Result = res
	return ec.marshalOProvisioningStep2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisioningStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_provisionedStep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisioningStep_id(ctx, field)
			case "type":
				return ec.fieldContext_ProvisioningStep_type(ctx, field)
			case "stepNumber":
				return ec.fieldContext_ProvisioningStep_stepNumber(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisioningStep_Status(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_ProvisioningStep_ProvisionedHost(ctx, field)
			case "Script":
				return ec.fieldContext_ProvisioningStep_Script(ctx, field)
			case "Command":
				return ec.fieldContext_ProvisioningStep_Command(ctx, field)
			case "DNSRecord":
				return ec.fieldContext_ProvisioningStep_DNSRecord(ctx, field)
			case "FileDelete":
				return ec.fieldContext_ProvisioningStep_FileDelete(ctx, field)
			case "FileDownload":
				return ec.fieldContext_ProvisioningStep_FileDownload(ctx, field)
			case "FileExtract":
				return ec.fieldContext_ProvisioningStep_FileExtract(ctx, field)
			case "Ansible":
				return ec.fieldContext_ProvisioningStep_Ansible(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisioningStep_Plan(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisioningStep_AgentTasks(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisioningStep_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisioningStep", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_provisionedStep_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_plan(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_plan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Plan(rctx, fc.Args["planUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.Plan); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.Plan`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Plan)
	fc.Result = res
	return ec.marshalOPlan2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_plan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Plan_id(ctx, field)
			case "stepNumber":
				return ec.fieldContext_Plan_stepNumber(ctx, field)
			case "type":
				return ec.fieldContext_Plan_type(ctx, field)
			case "NextPlans":
				return ec.fieldContext_Plan_NextPlans(ctx, field)
			case "PrevPlans":
				return ec.fieldContext_Plan_PrevPlans(ctx, field)
			case "Build":
				return ec.fieldContext_Plan_Build(ctx, field)
			case "Team":
				return ec.fieldContext_Plan_Team(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Plan_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Plan_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
			case "Status":
				return ec.fieldContext_Plan_Status(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_Plan_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Plan", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_plan_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_getBuilds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getBuilds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetBuilds(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.Build); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.Build`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Build)
	fc.Result = res
	return ec.marshalOBuild2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getBuilds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_build(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_build(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Build(rctx, fc.Args["buildUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.Build); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.Build`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Build)
	fc.Result = res
	return ec.marshalOBuild2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_build(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_build_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_getBuildCommits(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getBuildCommits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetBuildCommits(rctx, fc.Args["envUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.BuildCommit); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.BuildCommit`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.BuildCommit)
	fc.Result = res
	return ec.marshalOBuildCommit2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuildCommit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getBuildCommits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BuildCommit_id(ctx, field)
			case "type":
				return ec.fieldContext_BuildCommit_type(ctx, field)
			case "revision":
				return ec.fieldContext_BuildCommit_revision(ctx, field)
			case "state":
				return ec.fieldContext_BuildCommit_state(ctx, field)
			case "createdAt":
				return ec.fieldContext_BuildCommit_createdAt(ctx, field)
			case "Build":
				return ec.fieldContext_BuildCommit_Build(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_BuildCommit_ServerTasks(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_BuildCommit_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildCommit", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getBuildCommits_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_getBuildCommit(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getBuildCommit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetBuildCommit(rctx, fc.Args["buildCommitUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.BuildCommit); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.BuildCommit`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.BuildCommit)
	fc.Result = res
	return ec.marshalOBuildCommit2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuildCommit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getBuildCommit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BuildCommit_id(ctx, field)
			case "type":
				return ec.fieldContext_BuildCommit_type(ctx, field)
			case "revision":
				return ec.fieldContext_BuildCommit_revision(ctx, field)
			case "state":
				return ec.fieldContext_BuildCommit_state(ctx, field)
			case "createdAt":
				return ec.fieldContext_BuildCommit_createdAt(ctx, field)
			case "Build":
				return ec.fieldContext_BuildCommit_Build(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_BuildCommit_ServerTasks(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_BuildCommit_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildCommit", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getBuildCommit_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_status(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Status(rctx, fc.Args["statusUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.Status); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.Status`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Status)
	fc.Result = res
	return ec.marshalOStatus2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_status_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_agentStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_agentStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().AgentStatus(rctx, fc.Args["clientId"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.AgentStatus); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.AgentStatus`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.AgentStatus)
	fc.Result = res
	return ec.marshalOAgentStatus2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_agentStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "clientId":
				return ec.fieldContext_AgentStatus_clientId(ctx, field)
			case "hostname":
				return ec.fieldContext_AgentStatus_hostname(ctx, field)
			case "upTime":
				return ec.fieldContext_AgentStatus_upTime(ctx, field)
			case "bootTime":
				return ec.fieldContext_AgentStatus_bootTime(ctx, field)
			case "numProcs":
				return ec.fieldContext_AgentStatus_numProcs(ctx, field)
			case "OS":
				return ec.fieldContext_AgentStatus_OS(ctx, field)
			case "hostID":
				return ec.fieldContext_AgentStatus_hostID(ctx, field)
			case "load1":
				return ec.fieldContext_AgentStatus_load1(ctx, field)
			case "load5":
				return ec.fieldContext_AgentStatus_load5(ctx, field)
			case "load15":
				return ec.fieldContext_AgentStatus_load15(ctx, field)
			case "totalMem":
				return ec.fieldContext_AgentStatus_totalMem(ctx, field)
			case "freeMem":
				return ec.fieldContext_AgentStatus_freeMem(ctx, field)
			case "usedMem":
				return ec.fieldContext_AgentStatus_usedMem(ctx, field)
			case "timestamp":
				return ec.fieldContext_AgentStatus_timestamp(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentStatus_ProvisionedHost(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_AgentStatus_ProvisionedNetwork(ctx, field)
			case "Build":
				return ec.fieldContext_AgentStatus_Build(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentStatus", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_agentStatus_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_getServerTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getServerTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetServerTasks(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.ServerTask); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.ServerTask`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ServerTask)
	fc.Result = res
	return ec.marshalOServerTask2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐServerTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getServerTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServerTask_id(ctx, field)
			case "type":
				return ec.fieldContext_ServerTask_type(ctx, field)
			case "startTime":
				return ec.fieldContext_ServerTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ServerTask_endTime(ctx, field)
			case "errors":
				return ec.fieldContext_ServerTask_errors(ctx, field)
			case "logFilePath":
				return ec.fieldContext_ServerTask_logFilePath(ctx, field)
			case "AuthUser":
				return ec.fieldContext_ServerTask_AuthUser(ctx, field)
			case "Status":
				return ec.fieldContext_ServerTask_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_ServerTask_Environment(ctx, field)
			case "Build":
				return ec.fieldContext_ServerTask_Build(ctx, field)
			case "BuildCommit":
				return ec.fieldContext_ServerTask_BuildCommit(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ServerTask_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServerTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_currentUser(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_currentUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CurrentUser(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.AuthUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.AuthUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.AuthUser)
	fc.Result = res
	return ec.marshalOAuthUser2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAuthUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_currentUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AuthUser_id(ctx, field)
			case "username":
				return ec.fieldContext_AuthUser_username(ctx, field)
			case "firstName":
				return ec.fieldContext_AuthUser_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_AuthUser_lastName(ctx, field)
			case "email":
				return ec.fieldContext_AuthUser_email(ctx, field)
			case "phone":
				return ec.fieldContext_AuthUser_phone(ctx, field)
			case "company":
				return ec.fieldContext_AuthUser_company(ctx, field)
			case "occupation":
				return ec.fieldContext_AuthUser_occupation(ctx, field)
			case "publicKey":
				return ec.fieldContext_AuthUser_publicKey(ctx, field)
			case "role":
				return ec.fieldContext_AuthUser_role(ctx, field)
			case "provider":
				return ec.fieldContext_AuthUser_provider(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_AuthUser_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getUserList(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getUserList(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetUserList(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.AuthUser); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.AuthUser`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.AuthUser)
	fc.Result = res
	return ec.marshalOAuthUser2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAuthUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getUserList(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AuthUser_id(ctx, field)
			case "username":
				return ec.fieldContext_AuthUser_username(ctx, field)
			case "firstName":
				return ec.fieldContext_AuthUser_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_AuthUser_lastName(ctx, field)
			case "email":
				return ec.fieldContext_AuthUser_email(ctx, field)
			case "phone":
				return ec.fieldContext_AuthUser_phone(ctx, field)
			case "company":
				return ec.fieldContext_AuthUser_company(ctx, field)
			case "occupation":
				return ec.fieldContext_AuthUser_occupation(ctx, field)
			case "publicKey":
				return ec.fieldContext_AuthUser_publicKey(ctx, field)
			case "role":
				return ec.fieldContext_AuthUser_role(ctx, field)
			case "provider":
				return ec.fieldContext_AuthUser_provider(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_AuthUser_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getCurrentUserTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getCurrentUserTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetCurrentUserTasks(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.ServerTask); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.ServerTask`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ServerTask)
	fc.Result = res
	return ec.marshalOServerTask2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐServerTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getCurrentUserTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServerTask_id(ctx, field)
			case "type":
				return ec.fieldContext_ServerTask_type(ctx, field)
			case "startTime":
				return ec.fieldContext_ServerTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ServerTask_endTime(ctx, field)
			case "errors":
				return ec.fieldContext_ServerTask_errors(ctx, field)
			case "logFilePath":
				return ec.fieldContext_ServerTask_logFilePath(ctx, field)
			case "AuthUser":
				return ec.fieldContext_ServerTask_AuthUser(ctx, field)
			case "Status":
				return ec.fieldContext_ServerTask_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_ServerTask_Environment(ctx, field)
			case "Build":
				return ec.fieldContext_ServerTask_Build(ctx, field)
			case "BuildCommit":
				return ec.fieldContext_ServerTask_BuildCommit(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ServerTask_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServerTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getAgentTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getAgentTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetAgentTasks(rctx, fc.Args["proStepUUID"].(*string), fc.Args["proSchedStepUUID"].(*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.AgentTask); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.AgentTask`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.AgentTask)
	fc.Result = res
	return ec.marshalOAgentTask2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getAgentTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AgentTask_id(ctx, field)
			case "args":
				return ec.fieldContext_AgentTask_args(ctx, field)
			case "command":
				return ec.fieldContext_AgentTask_command(ctx, field)
			case "number":
				return ec.fieldContext_AgentTask_number(ctx, field)
			case "output":
				return ec.fieldContext_AgentTask_output(ctx, field)
			case "state":
				return ec.fieldContext_AgentTask_state(ctx, field)
			case "errorMessage":
				return ec.fieldContext_AgentTask_errorMessage(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_AgentTask_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_AgentTask_ProvisioningScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentTask_ProvisionedHost(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_AgentTask_AdhocPlans(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentTask", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getAgentTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_listAgentStatuses(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_listAgentStatuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListAgentStatuses(rctx, fc.Args["buildUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.AgentStatus); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.AgentStatus`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.AgentStatus)
	fc.Result = res
	return ec.marshalOAgentStatus2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_listAgentStatuses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "clientId":
				return ec.fieldContext_AgentStatus_clientId(ctx, field)
			case "hostname":
				return ec.fieldContext_AgentStatus_hostname(ctx, field)
			case "upTime":
				return ec.fieldContext_AgentStatus_upTime(ctx, field)
			case "bootTime":
				return ec.fieldContext_AgentStatus_bootTime(ctx, field)
			case "numProcs":
				return ec.fieldContext_AgentStatus_numProcs(ctx, field)
			case "OS":
				return ec.fieldContext_AgentStatus_OS(ctx, field)
			case "hostID":
				return ec.fieldContext_AgentStatus_hostID(ctx, field)
			case "load1":
				return ec.fieldContext_AgentStatus_load1(ctx, field)
			case "load5":
				return ec.fieldContext_AgentStatus_load5(ctx, field)
			case "load15":
				return ec.fieldContext_AgentStatus_load15(ctx, field)
			case "totalMem":
				return ec.fieldContext_AgentStatus_totalMem(ctx, field)
			case "freeMem":
				return ec.fieldContext_AgentStatus_freeMem(ctx, field)
			case "usedMem":
				return ec.fieldContext_AgentStatus_usedMem(ctx, field)
			case "timestamp":
				return ec.fieldContext_AgentStatus_timestamp(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentStatus_ProvisionedHost(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_AgentStatus_ProvisionedNetwork(ctx, field)
			case "Build":
				return ec.fieldContext_AgentStatus_Build(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentStatus", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_listAgentStatuses_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_listBuildStatuses(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_listBuildStatuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ListBuildStatuses(rctx, fc.Args["buildUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.Status); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.Status`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Status)
	fc.Result = res
	return ec.marshalOStatus2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_listBuildStatuses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_listBuildStatuses_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_getAllAgentStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getAllAgentStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetAllAgentStatus(rctx, fc.Args["buildUUID"].(string), fc.Args["count"].(int), fc.Args["offset"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.AgentStatusBatch); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/graphql/graph/model.AgentStatusBatch`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AgentStatusBatch)
	fc.Result = res
	return ec.marshalOAgentStatusBatch2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐAgentStatusBatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getAllAgentStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "agentStatuses":
				return ec.fieldContext_AgentStatusBatch_agentStatuses(ctx, field)
			case "pageInfo":
				return ec.fieldContext_AgentStatusBatch_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentStatusBatch", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getAllAgentStatus_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_getAllPlanStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getAllPlanStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetAllPlanStatus(rctx, fc.Args["buildUUID"].(string), fc.Args["count"].(int), fc.Args["offset"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.StatusBatch); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/graphql/graph/model.StatusBatch`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.StatusBatch)
	fc.Result = res
	return ec.marshalOStatusBatch2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐStatusBatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getAllPlanStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "statuses":
				return ec.fieldContext_StatusBatch_statuses(ctx, field)
			case "pageInfo":
				return ec.fieldContext_StatusBatch_pageInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StatusBatch", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getAllPlanStatus_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_getPlanStatusCounts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getPlanStatusCounts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().GetPlanStatusCounts(rctx, fc.Args["buildUUID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.PlanCounts); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/graphql/graph/model.PlanCounts`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PlanCounts)
	fc.Result = res
	return ec.marshalNPlanCounts2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐPlanCounts(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getPlanStatusCounts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "planning":
				return ec.fieldContext_PlanCounts_planning(ctx, field)
			case "awaiting":
				return ec.fieldContext_PlanCounts_awaiting(ctx, field)
			case "parentAwaiting":
				return ec.fieldContext_PlanCounts_parentAwaiting(ctx, field)
			case "inProgress":
				return ec.fieldContext_PlanCounts_inProgress(ctx, field)
			case "failed":
				return ec.fieldContext_PlanCounts_failed(ctx, field)
			case "complete":
				return ec.fieldContext_PlanCounts_complete(ctx, field)
			case "tainted":
				return ec.fieldContext_PlanCounts_tainted(ctx, field)
			case "undefined":
				return ec.fieldContext_PlanCounts_undefined(ctx, field)
			case "toDelete":
				return ec.fieldContext_PlanCounts_toDelete(ctx, field)
			case "deleteInProgress":
				return ec.fieldContext_PlanCounts_deleteInProgress(ctx, field)
			case "deleted":
				return ec.fieldContext_PlanCounts_deleted(ctx, field)
			case "toRebuild":
				return ec.fieldContext_PlanCounts_toRebuild(ctx, field)
			case "cancelled":
				return ec.fieldContext_PlanCounts_cancelled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlanCounts", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getPlanStatusCounts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_viewServerTaskLogs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_viewServerTaskLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ViewServerTaskLogs(rctx, fc.Args["taskID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_viewServerTaskLogs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_viewServerTaskLogs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_viewAgentTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_viewAgentTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ViewAgentTask(rctx, fc.Args["taskID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*ent.AgentTask); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/ent.AgentTask`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.AgentTask)
	fc.Result = res
	return ec.marshalNAgentTask2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_viewAgentTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AgentTask_id(ctx, field)
			case "args":
				return ec.fieldContext_AgentTask_args(ctx, field)
			case "command":
				return ec.fieldContext_AgentTask_command(ctx, field)
			case "number":
				return ec.fieldContext_AgentTask_number(ctx, field)
			case "output":
				return ec.fieldContext_AgentTask_output(ctx, field)
			case "state":
				return ec.fieldContext_AgentTask_state(ctx, field)
			case "errorMessage":
				return ec.fieldContext_AgentTask_errorMessage(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_AgentTask_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_AgentTask_ProvisioningScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentTask_ProvisionedHost(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_AgentTask_AdhocPlans(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentTask", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_viewAgentTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_serverTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_serverTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ServerTasks(rctx, fc.Args["taskUUIDs"].([]*string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*ent.ServerTask); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*github.com/gen0cide/laforge/ent.ServerTask`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ServerTask)
	fc.Result = res
	return ec.marshalOServerTask2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐServerTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_serverTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServerTask_id(ctx, field)
			case "type":
				return ec.fieldContext_ServerTask_type(ctx, field)
			case "startTime":
				return ec.fieldContext_ServerTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ServerTask_endTime(ctx, field)
			case "errors":
				return ec.fieldContext_ServerTask_errors(ctx, field)
			case "logFilePath":
				return ec.fieldContext_ServerTask_logFilePath(ctx, field)
			case "AuthUser":
				return ec.fieldContext_ServerTask_AuthUser(ctx, field)
			case "Status":
				return ec.fieldContext_ServerTask_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_ServerTask_Environment(ctx, field)
			case "Build":
				return ec.fieldContext_ServerTask_Build(ctx, field)
			case "BuildCommit":
				return ec.fieldContext_ServerTask_BuildCommit(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ServerTask_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServerTask", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_serverTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_serverConfig(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_serverConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().ServerConfig(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ServerConfig); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/gen0cide/laforge/graphql/graph/model.ServerConfig`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ServerConfig)
	fc.Result = res
	return ec.marshalOServerConfig2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐServerConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_serverConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ConfigFile":
				return ec.fieldContext_ServerConfig_ConfigFile(ctx, field)
			case "Debug":
				return ec.fieldContext_ServerConfig_Debug(ctx, field)
			case "LogFolder":
				return ec.fieldContext_ServerConfig_LogFolder(ctx, field)
			case "GinMode":
				return ec.fieldContext_ServerConfig_GinMode(ctx, field)
			case "Builders":
				return ec.fieldContext_ServerConfig_Builders(ctx, field)
			case "Database":
				return ec.fieldContext_ServerConfig_Database(ctx, field)
			case "Auth":
				return ec.fieldContext_ServerConfig_Auth(ctx, field)
			case "UI":
				return ec.fieldContext_ServerConfig_UI(ctx, field)
			case "Agent":
				return ec.fieldContext_ServerConfig_Agent(ctx, field)
			case "Graphql":
				return ec.fieldContext_ServerConfig_Graphql(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServerConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommit_id(ctx context.Context, field graphql.CollectedField, obj *ent.RepoCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommit_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RepoCommit().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommit_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommit_revision(ctx context.Context, field graphql.CollectedField, obj *ent.RepoCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommit_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommit_revision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommit_hash(ctx context.Context, field graphql.CollectedField, obj *ent.RepoCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommit_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommit_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommit_author(ctx context.Context, field graphql.CollectedField, obj *ent.RepoCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommit_author(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RepoCommit().Author(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommit_author(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommit_committer(ctx context.Context, field graphql.CollectedField, obj *ent.RepoCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommit_committer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RepoCommit().Committer(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommit_committer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommit",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommit_pgpSignature(ctx context.Context, field graphql.CollectedField, obj *ent.RepoCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommit_pgpSignature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PgpSignature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommit_pgpSignature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommit_message(ctx context.Context, field graphql.CollectedField, obj *ent.RepoCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommit_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommit_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommit_treeHash(ctx context.Context, field graphql.CollectedField, obj *ent.RepoCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommit_treeHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TreeHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommit_treeHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommit_parentHashes(ctx context.Context, field graphql.CollectedField, obj *ent.RepoCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommit_parentHashes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentHashes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommit_parentHashes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommit",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommit_Repository(ctx context.Context, field graphql.CollectedField, obj *ent.RepoCommit) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommit_Repository(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repository(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Repository)
	fc.Result = res
	return ec.marshalNRepository2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐRepository(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommit_Repository(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommit",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Repository_id(ctx, field)
			case "repoUrl":
				return ec.fieldContext_Repository_repoUrl(ctx, field)
			case "branchName":
				return ec.fieldContext_Repository_branchName(ctx, field)
			case "environmentFilepath":
				return ec.fieldContext_Repository_environmentFilepath(ctx, field)
			case "Environments":
				return ec.fieldContext_Repository_Environments(ctx, field)
			case "RepoCommits":
				return ec.fieldContext_Repository_RepoCommits(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Repository", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_id(ctx context.Context, field graphql.CollectedField, obj *ent.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_repoUrl(ctx context.Context, field graphql.CollectedField, obj *ent.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_repoUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_repoUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_branchName(ctx context.Context, field graphql.CollectedField, obj *ent.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_branchName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BranchName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_branchName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_environmentFilepath(ctx context.Context, field graphql.CollectedField, obj *ent.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_environmentFilepath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Repository().EnvironmentFilepath(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_environmentFilepath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_Environments(ctx context.Context, field graphql.CollectedField, obj *ent.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_Environments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environments(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_Environments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Repository_RepoCommits(ctx context.Context, field graphql.CollectedField, obj *ent.Repository) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Repository_RepoCommits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoCommits(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.RepoCommit)
	fc.Result = res
	return ec.marshalNRepoCommit2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐRepoCommit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Repository_RepoCommits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Repository",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RepoCommit_id(ctx, field)
			case "revision":
				return ec.fieldContext_RepoCommit_revision(ctx, field)
			case "hash":
				return ec.fieldContext_RepoCommit_hash(ctx, field)
			case "author":
				return ec.fieldContext_RepoCommit_author(ctx, field)
			case "committer":
				return ec.fieldContext_RepoCommit_committer(ctx, field)
			case "pgpSignature":
				return ec.fieldContext_RepoCommit_pgpSignature(ctx, field)
			case "message":
				return ec.fieldContext_RepoCommit_message(ctx, field)
			case "treeHash":
				return ec.fieldContext_RepoCommit_treeHash(ctx, field)
			case "parentHashes":
				return ec.fieldContext_RepoCommit_parentHashes(ctx, field)
			case "Repository":
				return ec.fieldContext_RepoCommit_Repository(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoCommit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScheduledStep_id(ctx context.Context, field graphql.CollectedField, obj *ent.ScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScheduledStep_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ScheduledStep().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScheduledStep_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScheduledStep_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.ScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScheduledStep_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScheduledStep_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScheduledStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScheduledStep_name(ctx context.Context, field graphql.CollectedField, obj *ent.ScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScheduledStep_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScheduledStep_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScheduledStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScheduledStep_description(ctx context.Context, field graphql.CollectedField, obj *ent.ScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScheduledStep_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScheduledStep_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScheduledStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScheduledStep_step(ctx context.Context, field graphql.CollectedField, obj *ent.ScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScheduledStep_step(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Step, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScheduledStep_step(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScheduledStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScheduledStep_type(ctx context.Context, field graphql.CollectedField, obj *ent.ScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScheduledStep_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ScheduledStep().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ScheduledStepType)
	fc.Result = res
	return ec.marshalNScheduledStepType2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐScheduledStepType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScheduledStep_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ScheduledStepType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScheduledStep_schedule(ctx context.Context, field graphql.CollectedField, obj *ent.ScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScheduledStep_schedule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Schedule, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScheduledStep_schedule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScheduledStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScheduledStep_runAt(ctx context.Context, field graphql.CollectedField, obj *ent.ScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScheduledStep_runAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RunAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScheduledStep_runAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScheduledStep",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ScheduledStep_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.ScheduledStep) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ScheduledStep_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalOEnvironment2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ScheduledStep_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ScheduledStep",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_id(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Script().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_name(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_language(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_language(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Language, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_language(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_description(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_source(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_sourceType(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_sourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_sourceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_cooldown(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_cooldown(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cooldown, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_cooldown(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_timeout(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_timeout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timeout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_timeout(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_ignoreErrors(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_ignoreErrors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IgnoreErrors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_ignoreErrors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_args(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_disabled(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_disabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_vars(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Script().Vars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.VarsMap)
	fc.Result = res
	return ec.marshalOvarsMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐVarsMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_vars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_varsMap_key(ctx, field)
			case "value":
				return ec.fieldContext_varsMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type varsMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_absPath(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_absPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AbsPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_absPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_tags(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Script().Tags(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalOtagMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_Users(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_Users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.User)
	fc.Result = res
	return ec.marshalNUser2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_Users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "hclId":
				return ec.fieldContext_User_hclId(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "uuid":
				return ec.fieldContext_User_uuid(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "Tag":
				return ec.fieldContext_User_Tag(ctx, field)
			case "Environments":
				return ec.fieldContext_User_Environments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_Findings(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_Findings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Findings(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Finding)
	fc.Result = res
	return ec.marshalNFinding2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐFinding(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_Findings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Finding_id(ctx, field)
			case "name":
				return ec.fieldContext_Finding_name(ctx, field)
			case "description":
				return ec.fieldContext_Finding_description(ctx, field)
			case "severity":
				return ec.fieldContext_Finding_severity(ctx, field)
			case "difficulty":
				return ec.fieldContext_Finding_difficulty(ctx, field)
			case "tags":
				return ec.fieldContext_Finding_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Finding_Users(ctx, field)
			case "Host":
				return ec.fieldContext_Finding_Host(ctx, field)
			case "Script":
				return ec.fieldContext_Finding_Script(ctx, field)
			case "Environment":
				return ec.fieldContext_Finding_Environment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Finding", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Script_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.Script) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Script_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Script_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Script",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerConfig_ConfigFile(ctx context.Context, field graphql.CollectedField, obj *model.ServerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerConfig_ConfigFile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfigFile, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerConfig_ConfigFile(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerConfig_Debug(ctx context.Context, field graphql.CollectedField, obj *model.ServerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerConfig_Debug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Debug, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerConfig_Debug(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerConfig_LogFolder(ctx context.Context, field graphql.CollectedField, obj *model.ServerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerConfig_LogFolder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LogFolder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerConfig_LogFolder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerConfig_GinMode(ctx context.Context, field graphql.CollectedField, obj *model.ServerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerConfig_GinMode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GinMode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerConfig_GinMode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerConfig_Builders(ctx context.Context, field graphql.CollectedField, obj *model.ServerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerConfig_Builders(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Builders, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalNMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerConfig_Builders(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerConfig_Database(ctx context.Context, field graphql.CollectedField, obj *model.ServerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerConfig_Database(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Database, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.DatabaseConfig)
	fc.Result = res
	return ec.marshalODatabaseConfig2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐDatabaseConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerConfig_Database(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "PostgresUri":
				return ec.fieldContext_DatabaseConfig_PostgresUri(ctx, field)
			case "AdminUser":
				return ec.fieldContext_DatabaseConfig_AdminUser(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DatabaseConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerConfig_Auth(ctx context.Context, field graphql.CollectedField, obj *model.ServerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerConfig_Auth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Auth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AuthConfig)
	fc.Result = res
	return ec.marshalOAuthConfig2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐAuthConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerConfig_Auth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "GithubId":
				return ec.fieldContext_AuthConfig_GithubId(ctx, field)
			case "CookieTimeout":
				return ec.fieldContext_AuthConfig_CookieTimeout(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerConfig_UI(ctx context.Context, field graphql.CollectedField, obj *model.ServerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerConfig_UI(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UI, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UIConfig)
	fc.Result = res
	return ec.marshalOUIConfig2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐUIConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerConfig_UI(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "HttpsEnabled":
				return ec.fieldContext_UIConfig_HttpsEnabled(ctx, field)
			case "AllowedOrigins":
				return ec.fieldContext_UIConfig_AllowedOrigins(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UIConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerConfig_Agent(ctx context.Context, field graphql.CollectedField, obj *model.ServerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerConfig_Agent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Agent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AgentConfig)
	fc.Result = res
	return ec.marshalOAgentConfig2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐAgentConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerConfig_Agent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "GrpcServerUri":
				return ec.fieldContext_AgentConfig_GrpcServerUri(ctx, field)
			case "ApiDownloadUrl":
				return ec.fieldContext_AgentConfig_ApiDownloadUrl(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerConfig_Graphql(ctx context.Context, field graphql.CollectedField, obj *model.ServerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerConfig_Graphql(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Graphql, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GraphqlConfig)
	fc.Result = res
	return ec.marshalOGraphqlConfig2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐGraphqlConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerConfig_Graphql(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Hostname":
				return ec.fieldContext_GraphqlConfig_Hostname(ctx, field)
			case "RedisServerUri":
				return ec.fieldContext_GraphqlConfig_RedisServerUri(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GraphqlConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerTask_id(ctx context.Context, field graphql.CollectedField, obj *ent.ServerTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerTask_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServerTask().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerTask_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerTask_type(ctx context.Context, field graphql.CollectedField, obj *ent.ServerTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerTask_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ServerTask().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ServerTaskType)
	fc.Result = res
	return ec.marshalNServerTaskType2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐServerTaskType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerTask_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ServerTaskType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerTask_startTime(ctx context.Context, field graphql.CollectedField, obj *ent.ServerTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerTask_startTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerTask_startTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerTask_endTime(ctx context.Context, field graphql.CollectedField, obj *ent.ServerTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerTask_endTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerTask_endTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerTask_errors(ctx context.Context, field graphql.CollectedField, obj *ent.ServerTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerTask_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerTask_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerTask_logFilePath(ctx context.Context, field graphql.CollectedField, obj *ent.ServerTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerTask_logFilePath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LogFilePath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerTask_logFilePath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerTask_AuthUser(ctx context.Context, field graphql.CollectedField, obj *ent.ServerTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerTask_AuthUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthUser(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.AuthUser)
	fc.Result = res
	return ec.marshalNAuthUser2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAuthUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerTask_AuthUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AuthUser_id(ctx, field)
			case "username":
				return ec.fieldContext_AuthUser_username(ctx, field)
			case "firstName":
				return ec.fieldContext_AuthUser_firstName(ctx, field)
			case "lastName":
				return ec.fieldContext_AuthUser_lastName(ctx, field)
			case "email":
				return ec.fieldContext_AuthUser_email(ctx, field)
			case "phone":
				return ec.fieldContext_AuthUser_phone(ctx, field)
			case "company":
				return ec.fieldContext_AuthUser_company(ctx, field)
			case "occupation":
				return ec.fieldContext_AuthUser_occupation(ctx, field)
			case "publicKey":
				return ec.fieldContext_AuthUser_publicKey(ctx, field)
			case "role":
				return ec.fieldContext_AuthUser_role(ctx, field)
			case "provider":
				return ec.fieldContext_AuthUser_provider(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_AuthUser_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerTask_Status(ctx context.Context, field graphql.CollectedField, obj *ent.ServerTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerTask_Status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Status)
	fc.Result = res
	return ec.marshalNStatus2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerTask_Status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerTask_Environment(ctx context.Context, field graphql.CollectedField, obj *ent.ServerTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerTask_Environment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environment(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Environment)
	fc.Result = res
	return ec.marshalOEnvironment2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerTask_Environment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerTask_Build(ctx context.Context, field graphql.CollectedField, obj *ent.ServerTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerTask_Build(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Build(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Build)
	fc.Result = res
	return ec.marshalOBuild2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerTask_Build(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerTask_BuildCommit(ctx context.Context, field graphql.CollectedField, obj *ent.ServerTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerTask_BuildCommit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildCommit(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.BuildCommit)
	fc.Result = res
	return ec.marshalOBuildCommit2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuildCommit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerTask_BuildCommit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BuildCommit_id(ctx, field)
			case "type":
				return ec.fieldContext_BuildCommit_type(ctx, field)
			case "revision":
				return ec.fieldContext_BuildCommit_revision(ctx, field)
			case "state":
				return ec.fieldContext_BuildCommit_state(ctx, field)
			case "createdAt":
				return ec.fieldContext_BuildCommit_createdAt(ctx, field)
			case "Build":
				return ec.fieldContext_BuildCommit_Build(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_BuildCommit_ServerTasks(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_BuildCommit_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildCommit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerTask_GinFileMiddleware(ctx context.Context, field graphql.CollectedField, obj *ent.ServerTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerTask_GinFileMiddleware(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GinFileMiddleware(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.GinFileMiddleware)
	fc.Result = res
	return ec.marshalNGinFileMiddleware2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐGinFileMiddleware(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerTask_GinFileMiddleware(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerTask",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GinFileMiddleware_id(ctx, field)
			case "urlId":
				return ec.fieldContext_GinFileMiddleware_urlId(ctx, field)
			case "filePath":
				return ec.fieldContext_GinFileMiddleware_filePath(ctx, field)
			case "accessed":
				return ec.fieldContext_GinFileMiddleware_accessed(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_GinFileMiddleware_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_GinFileMiddleware_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_GinFileMiddleware_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GinFileMiddleware", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_id(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Status().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_state(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Status().State(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ProvisionStatus)
	fc.Result = res
	return ec.marshalNProvisionStatus2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐProvisionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProvisionStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_statusFor(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_statusFor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Status().StatusFor(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ProvisionStatusFor)
	fc.Result = res
	return ec.marshalNProvisionStatusFor2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐProvisionStatusFor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_statusFor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProvisionStatusFor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_startedAt(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_startedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Status().StartedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_startedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_endedAt(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_endedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Status().EndedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_endedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_failed(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_failed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Failed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_failed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_completed(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_completed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Completed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_completed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_error(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_Build(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_Build(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Build(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Build)
	fc.Result = res
	return ec.marshalOBuild2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_Build(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_ProvisionedNetwork(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedNetwork(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedNetwork)
	fc.Result = res
	return ec.marshalOProvisionedNetwork2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisionedNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_ProvisionedNetwork(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedNetwork_id(ctx, field)
			case "name":
				return ec.fieldContext_ProvisionedNetwork_name(ctx, field)
			case "cidr":
				return ec.fieldContext_ProvisionedNetwork_cidr(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedNetwork_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedNetwork_Status(ctx, field)
			case "Network":
				return ec.fieldContext_ProvisionedNetwork_Network(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedNetwork_Build(ctx, field)
			case "Team":
				return ec.fieldContext_ProvisionedNetwork_Team(ctx, field)
			case "ProvisionedHosts":
				return ec.fieldContext_ProvisionedNetwork_ProvisionedHosts(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedNetwork_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedNetwork", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_ProvisionedHost(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_ProvisionedHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedHost(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisionedHost)
	fc.Result = res
	return ec.marshalOProvisionedHost2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisionedHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_ProvisionedHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedHost_id(ctx, field)
			case "subnetIp":
				return ec.fieldContext_ProvisionedHost_subnetIp(ctx, field)
			case "addonType":
				return ec.fieldContext_ProvisionedHost_addonType(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedHost_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedHost_Status(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_ProvisionedHost_ProvisionedNetwork(ctx, field)
			case "Host":
				return ec.fieldContext_ProvisionedHost_Host(ctx, field)
			case "EndStepPlan":
				return ec.fieldContext_ProvisionedHost_EndStepPlan(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedHost_Build(ctx, field)
			case "ProvisioningSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningSteps(ctx, field)
			case "ProvisioningScheduledSteps":
				return ec.fieldContext_ProvisionedHost_ProvisioningScheduledSteps(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_ProvisionedHost_AgentStatuses(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisionedHost_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedHost_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisionedHost_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedHost", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_ProvisioningStep(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_ProvisioningStep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisioningStep(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisioningStep)
	fc.Result = res
	return ec.marshalOProvisioningStep2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisioningStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_ProvisioningStep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisioningStep_id(ctx, field)
			case "type":
				return ec.fieldContext_ProvisioningStep_type(ctx, field)
			case "stepNumber":
				return ec.fieldContext_ProvisioningStep_stepNumber(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisioningStep_Status(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_ProvisioningStep_ProvisionedHost(ctx, field)
			case "Script":
				return ec.fieldContext_ProvisioningStep_Script(ctx, field)
			case "Command":
				return ec.fieldContext_ProvisioningStep_Command(ctx, field)
			case "DNSRecord":
				return ec.fieldContext_ProvisioningStep_DNSRecord(ctx, field)
			case "FileDelete":
				return ec.fieldContext_ProvisioningStep_FileDelete(ctx, field)
			case "FileDownload":
				return ec.fieldContext_ProvisioningStep_FileDownload(ctx, field)
			case "FileExtract":
				return ec.fieldContext_ProvisioningStep_FileExtract(ctx, field)
			case "Ansible":
				return ec.fieldContext_ProvisioningStep_Ansible(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisioningStep_Plan(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisioningStep_AgentTasks(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisioningStep_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisioningStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_Team(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_Team(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Team(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Team)
	fc.Result = res
	return ec.marshalOTeam2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_Team(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Team_id(ctx, field)
			case "teamNumber":
				return ec.fieldContext_Team_teamNumber(ctx, field)
			case "Build":
				return ec.fieldContext_Team_Build(ctx, field)
			case "Status":
				return ec.fieldContext_Team_Status(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Team_ProvisionedNetworks(ctx, field)
			case "Plan":
				return ec.fieldContext_Team_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Team", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_Plan(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_Plan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plan(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Plan)
	fc.Result = res
	return ec.marshalOPlan2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_Plan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Plan_id(ctx, field)
			case "stepNumber":
				return ec.fieldContext_Plan_stepNumber(ctx, field)
			case "type":
				return ec.fieldContext_Plan_type(ctx, field)
			case "NextPlans":
				return ec.fieldContext_Plan_NextPlans(ctx, field)
			case "PrevPlans":
				return ec.fieldContext_Plan_PrevPlans(ctx, field)
			case "Build":
				return ec.fieldContext_Plan_Build(ctx, field)
			case "Team":
				return ec.fieldContext_Plan_Team(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Plan_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Plan_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
			case "Status":
				return ec.fieldContext_Plan_Status(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_Plan_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Plan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_ServerTask(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_ServerTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServerTask(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ServerTask)
	fc.Result = res
	return ec.marshalOServerTask2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐServerTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_ServerTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServerTask_id(ctx, field)
			case "type":
				return ec.fieldContext_ServerTask_type(ctx, field)
			case "startTime":
				return ec.fieldContext_ServerTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ServerTask_endTime(ctx, field)
			case "errors":
				return ec.fieldContext_ServerTask_errors(ctx, field)
			case "logFilePath":
				return ec.fieldContext_ServerTask_logFilePath(ctx, field)
			case "AuthUser":
				return ec.fieldContext_ServerTask_AuthUser(ctx, field)
			case "Status":
				return ec.fieldContext_ServerTask_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_ServerTask_Environment(ctx, field)
			case "Build":
				return ec.fieldContext_ServerTask_Build(ctx, field)
			case "BuildCommit":
				return ec.fieldContext_ServerTask_BuildCommit(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ServerTask_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServerTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_AdhocPlan(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_AdhocPlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdhocPlan(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.AdhocPlan)
	fc.Result = res
	return ec.marshalOAdhocPlan2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAdhocPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_AdhocPlan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AdhocPlan_id(ctx, field)
			case "NextAdhocPlans":
				return ec.fieldContext_AdhocPlan_NextAdhocPlans(ctx, field)
			case "PrevAdhocPlans":
				return ec.fieldContext_AdhocPlan_PrevAdhocPlans(ctx, field)
			case "Build":
				return ec.fieldContext_AdhocPlan_Build(ctx, field)
			case "Status":
				return ec.fieldContext_AdhocPlan_Status(ctx, field)
			case "AgentTask":
				return ec.fieldContext_AdhocPlan_AgentTask(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdhocPlan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Status_ProvisioningScheduledStep(ctx context.Context, field graphql.CollectedField, obj *ent.Status) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisioningScheduledStep(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ProvisioningScheduledStep)
	fc.Result = res
	return ec.marshalOProvisioningScheduledStep2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisioningScheduledStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Status_ProvisioningScheduledStep(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Status",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisioningScheduledStep_id(ctx, field)
			case "type":
				return ec.fieldContext_ProvisioningScheduledStep_type(ctx, field)
			case "runTime":
				return ec.fieldContext_ProvisioningScheduledStep_runTime(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisioningScheduledStep_Status(ctx, field)
			case "ScheduledStep":
				return ec.fieldContext_ProvisioningScheduledStep_ScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_ProvisioningScheduledStep_ProvisionedHost(ctx, field)
			case "Script":
				return ec.fieldContext_ProvisioningScheduledStep_Script(ctx, field)
			case "Command":
				return ec.fieldContext_ProvisioningScheduledStep_Command(ctx, field)
			case "DNSRecord":
				return ec.fieldContext_ProvisioningScheduledStep_DNSRecord(ctx, field)
			case "FileDelete":
				return ec.fieldContext_ProvisioningScheduledStep_FileDelete(ctx, field)
			case "FileDownload":
				return ec.fieldContext_ProvisioningScheduledStep_FileDownload(ctx, field)
			case "FileExtract":
				return ec.fieldContext_ProvisioningScheduledStep_FileExtract(ctx, field)
			case "Ansible":
				return ec.fieldContext_ProvisioningScheduledStep_Ansible(ctx, field)
			case "AgentTasks":
				return ec.fieldContext_ProvisioningScheduledStep_AgentTasks(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisioningScheduledStep_Plan(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ProvisioningScheduledStep_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisioningScheduledStep", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StatusBatch_statuses(ctx context.Context, field graphql.CollectedField, obj *model.StatusBatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StatusBatch_statuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Statuses, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Status)
	fc.Result = res
	return ec.marshalNStatus2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StatusBatch_statuses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StatusBatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StatusBatch_pageInfo(ctx context.Context, field graphql.CollectedField, obj *model.StatusBatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StatusBatch_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.LaForgePageInfo)
	fc.Result = res
	return ec.marshalNLaForgePageInfo2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐLaForgePageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StatusBatch_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StatusBatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "total":
				return ec.fieldContext_LaForgePageInfo_total(ctx, field)
			case "nextOffset":
				return ec.fieldContext_LaForgePageInfo_nextOffset(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LaForgePageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_updatedAgentStatus(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_updatedAgentStatus(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().UpdatedAgentStatus(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *ent.AgentStatus); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/gen0cide/laforge/ent.AgentStatus`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *ent.AgentStatus):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNAgentStatus2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentStatus(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_updatedAgentStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "clientId":
				return ec.fieldContext_AgentStatus_clientId(ctx, field)
			case "hostname":
				return ec.fieldContext_AgentStatus_hostname(ctx, field)
			case "upTime":
				return ec.fieldContext_AgentStatus_upTime(ctx, field)
			case "bootTime":
				return ec.fieldContext_AgentStatus_bootTime(ctx, field)
			case "numProcs":
				return ec.fieldContext_AgentStatus_numProcs(ctx, field)
			case "OS":
				return ec.fieldContext_AgentStatus_OS(ctx, field)
			case "hostID":
				return ec.fieldContext_AgentStatus_hostID(ctx, field)
			case "load1":
				return ec.fieldContext_AgentStatus_load1(ctx, field)
			case "load5":
				return ec.fieldContext_AgentStatus_load5(ctx, field)
			case "load15":
				return ec.fieldContext_AgentStatus_load15(ctx, field)
			case "totalMem":
				return ec.fieldContext_AgentStatus_totalMem(ctx, field)
			case "freeMem":
				return ec.fieldContext_AgentStatus_freeMem(ctx, field)
			case "usedMem":
				return ec.fieldContext_AgentStatus_usedMem(ctx, field)
			case "timestamp":
				return ec.fieldContext_AgentStatus_timestamp(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentStatus_ProvisionedHost(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_AgentStatus_ProvisionedNetwork(ctx, field)
			case "Build":
				return ec.fieldContext_AgentStatus_Build(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_updatedStatus(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_updatedStatus(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().UpdatedStatus(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *ent.Status); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/gen0cide/laforge/ent.Status`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *ent.Status):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNStatus2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐStatus(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_updatedStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_updatedServerTask(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_updatedServerTask(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().UpdatedServerTask(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *ent.ServerTask); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/gen0cide/laforge/ent.ServerTask`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *ent.ServerTask):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNServerTask2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐServerTask(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_updatedServerTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ServerTask_id(ctx, field)
			case "type":
				return ec.fieldContext_ServerTask_type(ctx, field)
			case "startTime":
				return ec.fieldContext_ServerTask_startTime(ctx, field)
			case "endTime":
				return ec.fieldContext_ServerTask_endTime(ctx, field)
			case "errors":
				return ec.fieldContext_ServerTask_errors(ctx, field)
			case "logFilePath":
				return ec.fieldContext_ServerTask_logFilePath(ctx, field)
			case "AuthUser":
				return ec.fieldContext_ServerTask_AuthUser(ctx, field)
			case "Status":
				return ec.fieldContext_ServerTask_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_ServerTask_Environment(ctx, field)
			case "Build":
				return ec.fieldContext_ServerTask_Build(ctx, field)
			case "BuildCommit":
				return ec.fieldContext_ServerTask_BuildCommit(ctx, field)
			case "GinFileMiddleware":
				return ec.fieldContext_ServerTask_GinFileMiddleware(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServerTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_updatedBuild(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_updatedBuild(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().UpdatedBuild(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *ent.Build); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/gen0cide/laforge/ent.Build`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *ent.Build):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNBuild2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuild(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_updatedBuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_updatedCommit(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_updatedCommit(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().UpdatedCommit(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *ent.BuildCommit); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/gen0cide/laforge/ent.BuildCommit`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *ent.BuildCommit):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNBuildCommit2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuildCommit(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_updatedCommit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BuildCommit_id(ctx, field)
			case "type":
				return ec.fieldContext_BuildCommit_type(ctx, field)
			case "revision":
				return ec.fieldContext_BuildCommit_revision(ctx, field)
			case "state":
				return ec.fieldContext_BuildCommit_state(ctx, field)
			case "createdAt":
				return ec.fieldContext_BuildCommit_createdAt(ctx, field)
			case "Build":
				return ec.fieldContext_BuildCommit_Build(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_BuildCommit_ServerTasks(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_BuildCommit_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildCommit", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_updatedAgentTask(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_updatedAgentTask(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().UpdatedAgentTask(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan *ent.AgentTask); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan *github.com/gen0cide/laforge/ent.AgentTask`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *ent.AgentTask):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNAgentTask2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentTask(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_updatedAgentTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AgentTask_id(ctx, field)
			case "args":
				return ec.fieldContext_AgentTask_args(ctx, field)
			case "command":
				return ec.fieldContext_AgentTask_command(ctx, field)
			case "number":
				return ec.fieldContext_AgentTask_number(ctx, field)
			case "output":
				return ec.fieldContext_AgentTask_output(ctx, field)
			case "state":
				return ec.fieldContext_AgentTask_state(ctx, field)
			case "errorMessage":
				return ec.fieldContext_AgentTask_errorMessage(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_AgentTask_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_AgentTask_ProvisioningScheduledStep(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_AgentTask_ProvisionedHost(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_AgentTask_AdhocPlans(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgentTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_streamServerTaskLog(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_streamServerTaskLog(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Subscription().StreamServerTaskLog(rctx, fc.Args["taskID"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			roles, err := ec.unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx, []interface{}{"ADMIN", "USER"})
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, roles)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(<-chan string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be <-chan string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan string):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalNString2string(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_streamServerTaskLog(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_streamServerTaskLog_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Tag_id(ctx context.Context, field graphql.CollectedField, obj *ent.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Tag().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_uuid(ctx context.Context, field graphql.CollectedField, obj *ent.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_uuid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Tag().UUID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_uuid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_name(ctx context.Context, field graphql.CollectedField, obj *ent.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_description(ctx context.Context, field graphql.CollectedField, obj *ent.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Tag().Description(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TagMap)
	fc.Result = res
	return ec.marshalNtagMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐTagMap(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_tagMap_key(ctx, field)
			case "value":
				return ec.fieldContext_tagMap_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type tagMap", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_id(ctx context.Context, field graphql.CollectedField, obj *ent.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Team().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_teamNumber(ctx context.Context, field graphql.CollectedField, obj *ent.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_teamNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_teamNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_Build(ctx context.Context, field graphql.CollectedField, obj *ent.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_Build(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Build(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Build)
	fc.Result = res
	return ec.marshalNBuild2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_Build(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "revision":
				return ec.fieldContext_Build_revision(ctx, field)
			case "environmentRevision":
				return ec.fieldContext_Build_environmentRevision(ctx, field)
			case "completedPlan":
				return ec.fieldContext_Build_completedPlan(ctx, field)
			case "Status":
				return ec.fieldContext_Build_Status(ctx, field)
			case "Environment":
				return ec.fieldContext_Build_Environment(ctx, field)
			case "Competition":
				return ec.fieldContext_Build_Competition(ctx, field)
			case "LatestBuildCommit":
				return ec.fieldContext_Build_LatestBuildCommit(ctx, field)
			case "RepoCommit":
				return ec.fieldContext_Build_RepoCommit(ctx, field)
			case "ProvisionedNetworks":
				return ec.fieldContext_Build_ProvisionedNetworks(ctx, field)
			case "Teams":
				return ec.fieldContext_Build_Teams(ctx, field)
			case "Plans":
				return ec.fieldContext_Build_Plans(ctx, field)
			case "BuildCommits":
				return ec.fieldContext_Build_BuildCommits(ctx, field)
			case "AdhocPlans":
				return ec.fieldContext_Build_AdhocPlans(ctx, field)
			case "AgentStatuses":
				return ec.fieldContext_Build_AgentStatuses(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Build_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_Status(ctx context.Context, field graphql.CollectedField, obj *ent.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_Status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Status)
	fc.Result = res
	return ec.marshalOStatus2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_Status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Status_id(ctx, field)
			case "state":
				return ec.fieldContext_Status_state(ctx, field)
			case "statusFor":
				return ec.fieldContext_Status_statusFor(ctx, field)
			case "startedAt":
				return ec.fieldContext_Status_startedAt(ctx, field)
			case "endedAt":
				return ec.fieldContext_Status_endedAt(ctx, field)
			case "failed":
				return ec.fieldContext_Status_failed(ctx, field)
			case "completed":
				return ec.fieldContext_Status_completed(ctx, field)
			case "error":
				return ec.fieldContext_Status_error(ctx, field)
			case "Build":
				return ec.fieldContext_Status_Build(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Status_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Status_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Status_ProvisioningStep(ctx, field)
			case "Team":
				return ec.fieldContext_Status_Team(ctx, field)
			case "Plan":
				return ec.fieldContext_Status_Plan(ctx, field)
			case "ServerTask":
				return ec.fieldContext_Status_ServerTask(ctx, field)
			case "AdhocPlan":
				return ec.fieldContext_Status_AdhocPlan(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Status_ProvisioningScheduledStep(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Status", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_ProvisionedNetworks(ctx context.Context, field graphql.CollectedField, obj *ent.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_ProvisionedNetworks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisionedNetworks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ProvisionedNetwork)
	fc.Result = res
	return ec.marshalNProvisionedNetwork2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisionedNetwork(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_ProvisionedNetworks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProvisionedNetwork_id(ctx, field)
			case "name":
				return ec.fieldContext_ProvisionedNetwork_name(ctx, field)
			case "cidr":
				return ec.fieldContext_ProvisionedNetwork_cidr(ctx, field)
			case "vars":
				return ec.fieldContext_ProvisionedNetwork_vars(ctx, field)
			case "Status":
				return ec.fieldContext_ProvisionedNetwork_Status(ctx, field)
			case "Network":
				return ec.fieldContext_ProvisionedNetwork_Network(ctx, field)
			case "Build":
				return ec.fieldContext_ProvisionedNetwork_Build(ctx, field)
			case "Team":
				return ec.fieldContext_ProvisionedNetwork_Team(ctx, field)
			case "ProvisionedHosts":
				return ec.fieldContext_ProvisionedNetwork_ProvisionedHosts(ctx, field)
			case "Plan":
				return ec.fieldContext_ProvisionedNetwork_Plan(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProvisionedNetwork", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Team_Plan(ctx context.Context, field graphql.CollectedField, obj *ent.Team) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Team_Plan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plan(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Plan)
	fc.Result = res
	return ec.marshalNPlan2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Team_Plan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Team",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Plan_id(ctx, field)
			case "stepNumber":
				return ec.fieldContext_Plan_stepNumber(ctx, field)
			case "type":
				return ec.fieldContext_Plan_type(ctx, field)
			case "NextPlans":
				return ec.fieldContext_Plan_NextPlans(ctx, field)
			case "PrevPlans":
				return ec.fieldContext_Plan_PrevPlans(ctx, field)
			case "Build":
				return ec.fieldContext_Plan_Build(ctx, field)
			case "Team":
				return ec.fieldContext_Plan_Team(ctx, field)
			case "ProvisionedNetwork":
				return ec.fieldContext_Plan_ProvisionedNetwork(ctx, field)
			case "ProvisionedHost":
				return ec.fieldContext_Plan_ProvisionedHost(ctx, field)
			case "ProvisioningStep":
				return ec.fieldContext_Plan_ProvisioningStep(ctx, field)
			case "ProvisioningScheduledStep":
				return ec.fieldContext_Plan_ProvisioningScheduledStep(ctx, field)
			case "Status":
				return ec.fieldContext_Plan_Status(ctx, field)
			case "PlanDiffs":
				return ec.fieldContext_Plan_PlanDiffs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Plan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_HttpsEnabled(ctx context.Context, field graphql.CollectedField, obj *model.UIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UIConfig_HttpsEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HTTPSEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UIConfig_HttpsEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_AllowedOrigins(ctx context.Context, field graphql.CollectedField, obj *model.UIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UIConfig_AllowedOrigins(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllowedOrigins, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2ᚕᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UIConfig_AllowedOrigins(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_hclId(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_hclId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HclID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_hclId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_uuid(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_uuid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UUID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_uuid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_Tag(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_Tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tag(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Tag)
	fc.Result = res
	return ec.marshalNTag2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_Tag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			case "uuid":
				return ec.fieldContext_Tag_uuid(ctx, field)
			case "name":
				return ec.fieldContext_Tag_name(ctx, field)
			case "description":
				return ec.fieldContext_Tag_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_Environments(ctx context.Context, field graphql.CollectedField, obj *ent.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_Environments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Environments(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Environment)
	fc.Result = res
	return ec.marshalNEnvironment2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_Environments(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Environment_id(ctx, field)
			case "hclId":
				return ec.fieldContext_Environment_hclId(ctx, field)
			case "competitionId":
				return ec.fieldContext_Environment_competitionId(ctx, field)
			case "name":
				return ec.fieldContext_Environment_name(ctx, field)
			case "description":
				return ec.fieldContext_Environment_description(ctx, field)
			case "builder":
				return ec.fieldContext_Environment_builder(ctx, field)
			case "teamCount":
				return ec.fieldContext_Environment_teamCount(ctx, field)
			case "revision":
				return ec.fieldContext_Environment_revision(ctx, field)
			case "adminCidrs":
				return ec.fieldContext_Environment_adminCidrs(ctx, field)
			case "exposedVdiPorts":
				return ec.fieldContext_Environment_exposedVdiPorts(ctx, field)
			case "config":
				return ec.fieldContext_Environment_config(ctx, field)
			case "tags":
				return ec.fieldContext_Environment_tags(ctx, field)
			case "Users":
				return ec.fieldContext_Environment_Users(ctx, field)
			case "Hosts":
				return ec.fieldContext_Environment_Hosts(ctx, field)
			case "Competitions":
				return ec.fieldContext_Environment_Competitions(ctx, field)
			case "Identities":
				return ec.fieldContext_Environment_Identities(ctx, field)
			case "Commands":
				return ec.fieldContext_Environment_Commands(ctx, field)
			case "Scripts":
				return ec.fieldContext_Environment_Scripts(ctx, field)
			case "FileDownloads":
				return ec.fieldContext_Environment_FileDownloads(ctx, field)
			case "FileDeletes":
				return ec.fieldContext_Environment_FileDeletes(ctx, field)
			case "FileExtracts":
				return ec.fieldContext_Environment_FileExtracts(ctx, field)
			case "IncludedNetworks":
				return ec.fieldContext_Environment_IncludedNetworks(ctx, field)
			case "Findings":
				return ec.fieldContext_Environment_Findings(ctx, field)
			case "DNSRecords":
				return ec.fieldContext_Environment_DNSRecords(ctx, field)
			case "DNS":
				return ec.fieldContext_Environment_DNS(ctx, field)
			case "Networks":
				return ec.fieldContext_Environment_Networks(ctx, field)
			case "HostDependencies":
				return ec.fieldContext_Environment_HostDependencies(ctx, field)
			case "Ansibles":
				return ec.fieldContext_Environment_Ansibles(ctx, field)
			case "ScheduledSteps":
				return ec.fieldContext_Environment_ScheduledSteps(ctx, field)
			case "Builds":
				return ec.fieldContext_Environment_Builds(ctx, field)
			case "Repositories":
				return ec.fieldContext_Environment_Repositories(ctx, field)
			case "ServerTasks":
				return ec.fieldContext_Environment_ServerTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Environment", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _configMap_key(ctx context.Context, field graphql.CollectedField, obj *model.ConfigMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_configMap_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_configMap_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "configMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _configMap_value(ctx context.Context, field graphql.CollectedField, obj *model.ConfigMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_configMap_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_configMap_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "configMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _intMap_key(ctx context.Context, field graphql.CollectedField, obj *model.IntMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_intMap_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_intMap_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "intMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _intMap_value(ctx context.Context, field graphql.CollectedField, obj *model.IntMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_intMap_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_intMap_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "intMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _tagMap_key(ctx context.Context, field graphql.CollectedField, obj *model.TagMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_tagMap_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_tagMap_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "tagMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _tagMap_value(ctx context.Context, field graphql.CollectedField, obj *model.TagMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_tagMap_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_tagMap_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "tagMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _varsMap_key(ctx context.Context, field graphql.CollectedField, obj *model.VarsMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_varsMap_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_varsMap_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "varsMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _varsMap_value(ctx context.Context, field graphql.CollectedField, obj *model.VarsMap) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_varsMap_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_varsMap_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "varsMap",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var adhocPlanImplementors = []string{"AdhocPlan"}

func (ec *executionContext) _AdhocPlan(ctx context.Context, sel ast.SelectionSet, obj *ent.AdhocPlan) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adhocPlanImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdhocPlan")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AdhocPlan_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "NextAdhocPlans":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AdhocPlan_NextAdhocPlans(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "PrevAdhocPlans":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AdhocPlan_PrevAdhocPlans(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Build":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AdhocPlan_Build(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AdhocPlan_Status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "AgentTask":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AdhocPlan_AgentTask(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var agentConfigImplementors = []string{"AgentConfig"}

func (ec *executionContext) _AgentConfig(ctx context.Context, sel ast.SelectionSet, obj *model.AgentConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, agentConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AgentConfig")
		case "GrpcServerUri":

			out.Values[i] = ec._AgentConfig_GrpcServerUri(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ApiDownloadUrl":

			out.Values[i] = ec._AgentConfig_ApiDownloadUrl(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var agentStatusImplementors = []string{"AgentStatus"}

func (ec *executionContext) _AgentStatus(ctx context.Context, sel ast.SelectionSet, obj *ent.AgentStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, agentStatusImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AgentStatus")
		case "clientId":

			out.Values[i] = ec._AgentStatus_clientId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "hostname":

			out.Values[i] = ec._AgentStatus_hostname(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "upTime":

			out.Values[i] = ec._AgentStatus_upTime(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "bootTime":

			out.Values[i] = ec._AgentStatus_bootTime(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "numProcs":

			out.Values[i] = ec._AgentStatus_numProcs(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "OS":

			out.Values[i] = ec._AgentStatus_OS(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "hostID":

			out.Values[i] = ec._AgentStatus_hostID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "load1":

			out.Values[i] = ec._AgentStatus_load1(ctx, field, obj)

		case "load5":

			out.Values[i] = ec._AgentStatus_load5(ctx, field, obj)

		case "load15":

			out.Values[i] = ec._AgentStatus_load15(ctx, field, obj)

		case "totalMem":

			out.Values[i] = ec._AgentStatus_totalMem(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "freeMem":

			out.Values[i] = ec._AgentStatus_freeMem(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "usedMem":

			out.Values[i] = ec._AgentStatus_usedMem(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "timestamp":

			out.Values[i] = ec._AgentStatus_timestamp(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "ProvisionedHost":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AgentStatus_ProvisionedHost(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisionedNetwork":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AgentStatus_ProvisionedNetwork(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Build":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AgentStatus_Build(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var agentStatusBatchImplementors = []string{"AgentStatusBatch"}

func (ec *executionContext) _AgentStatusBatch(ctx context.Context, sel ast.SelectionSet, obj *model.AgentStatusBatch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, agentStatusBatchImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AgentStatusBatch")
		case "agentStatuses":

			out.Values[i] = ec._AgentStatusBatch_agentStatuses(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pageInfo":

			out.Values[i] = ec._AgentStatusBatch_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var agentTaskImplementors = []string{"AgentTask"}

func (ec *executionContext) _AgentTask(ctx context.Context, sel ast.SelectionSet, obj *ent.AgentTask) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, agentTaskImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AgentTask")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AgentTask_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "args":

			out.Values[i] = ec._AgentTask_args(ctx, field, obj)

		case "command":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AgentTask_command(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "number":

			out.Values[i] = ec._AgentTask_number(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "output":

			out.Values[i] = ec._AgentTask_output(ctx, field, obj)

		case "state":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AgentTask_state(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "errorMessage":

			out.Values[i] = ec._AgentTask_errorMessage(ctx, field, obj)

		case "ProvisioningStep":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AgentTask_ProvisioningStep(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisioningScheduledStep":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AgentTask_ProvisioningScheduledStep(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisionedHost":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AgentTask_ProvisionedHost(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "AdhocPlans":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AgentTask_AdhocPlans(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var ansibleImplementors = []string{"Ansible"}

func (ec *executionContext) _Ansible(ctx context.Context, sel ast.SelectionSet, obj *ent.Ansible) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ansibleImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Ansible")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Ansible_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._Ansible_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Ansible_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":

			out.Values[i] = ec._Ansible_description(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "source":

			out.Values[i] = ec._Ansible_source(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "playbookName":

			out.Values[i] = ec._Ansible_playbookName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "method":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Ansible_method(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "inventory":

			out.Values[i] = ec._Ansible_inventory(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "absPath":

			out.Values[i] = ec._Ansible_absPath(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Ansible_tags(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Users":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Ansible_Users(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Ansible_Environment(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var authConfigImplementors = []string{"AuthConfig"}

func (ec *executionContext) _AuthConfig(ctx context.Context, sel ast.SelectionSet, obj *model.AuthConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, authConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuthConfig")
		case "GithubId":

			out.Values[i] = ec._AuthConfig_GithubId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CookieTimeout":

			out.Values[i] = ec._AuthConfig_CookieTimeout(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var authUserImplementors = []string{"AuthUser"}

func (ec *executionContext) _AuthUser(ctx context.Context, sel ast.SelectionSet, obj *ent.AuthUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, authUserImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuthUser")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AuthUser_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "username":

			out.Values[i] = ec._AuthUser_username(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "firstName":

			out.Values[i] = ec._AuthUser_firstName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "lastName":

			out.Values[i] = ec._AuthUser_lastName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "email":

			out.Values[i] = ec._AuthUser_email(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "phone":

			out.Values[i] = ec._AuthUser_phone(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "company":

			out.Values[i] = ec._AuthUser_company(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "occupation":

			out.Values[i] = ec._AuthUser_occupation(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "publicKey":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AuthUser_publicKey(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "role":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AuthUser_role(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "provider":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AuthUser_provider(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ServerTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AuthUser_ServerTasks(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var buildImplementors = []string{"Build"}

func (ec *executionContext) _Build(ctx context.Context, sel ast.SelectionSet, obj *ent.Build) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Build")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "revision":

			out.Values[i] = ec._Build_revision(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "environmentRevision":

			out.Values[i] = ec._Build_environmentRevision(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "completedPlan":

			out.Values[i] = ec._Build_completedPlan(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_Status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_Environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Competition":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_Competition(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "LatestBuildCommit":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_LatestBuildCommit(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "RepoCommit":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_RepoCommit(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisionedNetworks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_ProvisionedNetworks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Teams":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_Teams(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Plans":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_Plans(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "BuildCommits":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_BuildCommits(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "AdhocPlans":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_AdhocPlans(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "AgentStatuses":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_AgentStatuses(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ServerTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Build_ServerTasks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var buildCommitImplementors = []string{"BuildCommit"}

func (ec *executionContext) _BuildCommit(ctx context.Context, sel ast.SelectionSet, obj *ent.BuildCommit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildCommitImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildCommit")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BuildCommit_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "type":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BuildCommit_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "revision":

			out.Values[i] = ec._BuildCommit_revision(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "state":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BuildCommit_state(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "createdAt":

			out.Values[i] = ec._BuildCommit_createdAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Build":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BuildCommit_Build(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ServerTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BuildCommit_ServerTasks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "PlanDiffs":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BuildCommit_PlanDiffs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var builderConfigImplementors = []string{"BuilderConfig"}

func (ec *executionContext) _BuilderConfig(ctx context.Context, sel ast.SelectionSet, obj *model.BuilderConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, builderConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuilderConfig")
		case "Builder":

			out.Values[i] = ec._BuilderConfig_Builder(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ConfigFile":

			out.Values[i] = ec._BuilderConfig_ConfigFile(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var commandImplementors = []string{"Command"}

func (ec *executionContext) _Command(ctx context.Context, sel ast.SelectionSet, obj *ent.Command) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, commandImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Command")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Command_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._Command_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Command_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":

			out.Values[i] = ec._Command_description(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "program":

			out.Values[i] = ec._Command_program(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "args":

			out.Values[i] = ec._Command_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "ignoreErrors":

			out.Values[i] = ec._Command_ignoreErrors(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "disabled":

			out.Values[i] = ec._Command_disabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "cooldown":

			out.Values[i] = ec._Command_cooldown(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "timeout":

			out.Values[i] = ec._Command_timeout(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "vars":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Command_vars(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Command_tags(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Users":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Command_Users(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Command_Environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var competitionImplementors = []string{"Competition"}

func (ec *executionContext) _Competition(ctx context.Context, sel ast.SelectionSet, obj *ent.Competition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, competitionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Competition")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Competition_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._Competition_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "rootPassword":

			out.Values[i] = ec._Competition_rootPassword(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "startTime":

			out.Values[i] = ec._Competition_startTime(ctx, field, obj)

		case "stopTime":

			out.Values[i] = ec._Competition_stopTime(ctx, field, obj)

		case "config":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Competition_config(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Competition_tags(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "DNS":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Competition_DNS(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Competition_Environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Builds":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Competition_Builds(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var dNSImplementors = []string{"DNS"}

func (ec *executionContext) _DNS(ctx context.Context, sel ast.SelectionSet, obj *ent.DNS) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dNSImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DNS")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DNS_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._DNS_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":

			out.Values[i] = ec._DNS_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "rootDomain":

			out.Values[i] = ec._DNS_rootDomain(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "dnsServers":

			out.Values[i] = ec._DNS_dnsServers(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "ntpServers":

			out.Values[i] = ec._DNS_ntpServers(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "config":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DNS_config(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environments":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DNS_Environments(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Competitions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DNS_Competitions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var dNSRecordImplementors = []string{"DNSRecord"}

func (ec *executionContext) _DNSRecord(ctx context.Context, sel ast.SelectionSet, obj *ent.DNSRecord) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dNSRecordImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DNSRecord")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DNSRecord_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._DNSRecord_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._DNSRecord_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "values":

			out.Values[i] = ec._DNSRecord_values(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":

			out.Values[i] = ec._DNSRecord_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "zone":

			out.Values[i] = ec._DNSRecord_zone(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "vars":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DNSRecord_vars(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "disabled":

			out.Values[i] = ec._DNSRecord_disabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DNSRecord_tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DNSRecord_Environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var databaseConfigImplementors = []string{"DatabaseConfig"}

func (ec *executionContext) _DatabaseConfig(ctx context.Context, sel ast.SelectionSet, obj *model.DatabaseConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, databaseConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DatabaseConfig")
		case "PostgresUri":

			out.Values[i] = ec._DatabaseConfig_PostgresUri(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "AdminUser":

			out.Values[i] = ec._DatabaseConfig_AdminUser(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var diskImplementors = []string{"Disk"}

func (ec *executionContext) _Disk(ctx context.Context, sel ast.SelectionSet, obj *ent.Disk) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, diskImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Disk")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Disk_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "size":

			out.Values[i] = ec._Disk_size(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Host":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Disk_Host(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var environmentImplementors = []string{"Environment"}

func (ec *executionContext) _Environment(ctx context.Context, sel ast.SelectionSet, obj *ent.Environment) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, environmentImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Environment")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._Environment_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "competitionId":

			out.Values[i] = ec._Environment_competitionId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Environment_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":

			out.Values[i] = ec._Environment_description(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "builder":

			out.Values[i] = ec._Environment_builder(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "teamCount":

			out.Values[i] = ec._Environment_teamCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "revision":

			out.Values[i] = ec._Environment_revision(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "adminCidrs":

			out.Values[i] = ec._Environment_adminCidrs(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "exposedVdiPorts":

			out.Values[i] = ec._Environment_exposedVdiPorts(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "config":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_config(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_tags(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Users":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_Users(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Hosts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_Hosts(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Competitions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_Competitions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Identities":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_Identities(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Commands":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_Commands(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Scripts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_Scripts(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "FileDownloads":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_FileDownloads(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "FileDeletes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_FileDeletes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "FileExtracts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_FileExtracts(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "IncludedNetworks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_IncludedNetworks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Findings":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_Findings(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "DNSRecords":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_DNSRecords(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "DNS":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_DNS(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Networks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_Networks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "HostDependencies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_HostDependencies(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Ansibles":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_Ansibles(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ScheduledSteps":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_ScheduledSteps(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Builds":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_Builds(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Repositories":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_Repositories(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ServerTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Environment_ServerTasks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var fileDeleteImplementors = []string{"FileDelete"}

func (ec *executionContext) _FileDelete(ctx context.Context, sel ast.SelectionSet, obj *ent.FileDelete) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fileDeleteImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FileDelete")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FileDelete_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._FileDelete_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "path":

			out.Values[i] = ec._FileDelete_path(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FileDelete_tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FileDelete_Environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var fileDownloadImplementors = []string{"FileDownload"}

func (ec *executionContext) _FileDownload(ctx context.Context, sel ast.SelectionSet, obj *ent.FileDownload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fileDownloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FileDownload")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FileDownload_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._FileDownload_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "sourceType":

			out.Values[i] = ec._FileDownload_sourceType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "source":

			out.Values[i] = ec._FileDownload_source(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "destination":

			out.Values[i] = ec._FileDownload_destination(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "template":

			out.Values[i] = ec._FileDownload_template(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "perms":

			out.Values[i] = ec._FileDownload_perms(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "disabled":

			out.Values[i] = ec._FileDownload_disabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "md5":

			out.Values[i] = ec._FileDownload_md5(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "absPath":

			out.Values[i] = ec._FileDownload_absPath(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FileDownload_tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FileDownload_Environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var fileExtractImplementors = []string{"FileExtract"}

func (ec *executionContext) _FileExtract(ctx context.Context, sel ast.SelectionSet, obj *ent.FileExtract) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fileExtractImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FileExtract")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FileExtract_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._FileExtract_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "source":

			out.Values[i] = ec._FileExtract_source(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "destination":

			out.Values[i] = ec._FileExtract_destination(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":

			out.Values[i] = ec._FileExtract_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FileExtract_tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FileExtract_Environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var findingImplementors = []string{"Finding"}

func (ec *executionContext) _Finding(ctx context.Context, sel ast.SelectionSet, obj *ent.Finding) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, findingImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Finding")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Finding_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "name":

			out.Values[i] = ec._Finding_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":

			out.Values[i] = ec._Finding_description(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "severity":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Finding_severity(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "difficulty":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Finding_difficulty(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Finding_tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Users":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Finding_Users(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Host":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Finding_Host(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Script":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Finding_Script(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Finding_Environment(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var ginFileMiddlewareImplementors = []string{"GinFileMiddleware"}

func (ec *executionContext) _GinFileMiddleware(ctx context.Context, sel ast.SelectionSet, obj *ent.GinFileMiddleware) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ginFileMiddlewareImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GinFileMiddleware")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GinFileMiddleware_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "urlId":

			out.Values[i] = ec._GinFileMiddleware_urlId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "filePath":

			out.Values[i] = ec._GinFileMiddleware_filePath(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "accessed":

			out.Values[i] = ec._GinFileMiddleware_accessed(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "ProvisionedHost":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GinFileMiddleware_ProvisionedHost(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisioningStep":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GinFileMiddleware_ProvisioningStep(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisioningScheduledStep":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GinFileMiddleware_ProvisioningScheduledStep(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var graphqlConfigImplementors = []string{"GraphqlConfig"}

func (ec *executionContext) _GraphqlConfig(ctx context.Context, sel ast.SelectionSet, obj *model.GraphqlConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, graphqlConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GraphqlConfig")
		case "Hostname":

			out.Values[i] = ec._GraphqlConfig_Hostname(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "RedisServerUri":

			out.Values[i] = ec._GraphqlConfig_RedisServerUri(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var hostImplementors = []string{"Host"}

func (ec *executionContext) _Host(ctx context.Context, sel ast.SelectionSet, obj *ent.Host) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Host")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._Host_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "hostname":

			out.Values[i] = ec._Host_hostname(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":

			out.Values[i] = ec._Host_description(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "OS":

			out.Values[i] = ec._Host_OS(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "lastOctet":

			out.Values[i] = ec._Host_lastOctet(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "instanceSize":

			out.Values[i] = ec._Host_instanceSize(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "allowMacChanges":

			out.Values[i] = ec._Host_allowMacChanges(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "exposedTcpPorts":

			out.Values[i] = ec._Host_exposedTcpPorts(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "exposedUdpPorts":

			out.Values[i] = ec._Host_exposedUdpPorts(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "overridePassword":

			out.Values[i] = ec._Host_overridePassword(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "vars":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_vars(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "userGroups":

			out.Values[i] = ec._Host_userGroups(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "provisionSteps":

			out.Values[i] = ec._Host_provisionSteps(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Disk":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_Disk(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Users":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_Users(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_Environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "IncludedNetworks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_IncludedNetworks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "DependOnHostDependencies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_DependOnHostDependencies(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "RequiredByHostDependencies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_RequiredByHostDependencies(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var hostDependencyImplementors = []string{"HostDependency"}

func (ec *executionContext) _HostDependency(ctx context.Context, sel ast.SelectionSet, obj *ent.HostDependency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostDependencyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostDependency")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._HostDependency_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hostId":

			out.Values[i] = ec._HostDependency_hostId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "networkId":

			out.Values[i] = ec._HostDependency_networkId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "RequiredBy":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._HostDependency_RequiredBy(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "DependOnHost":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._HostDependency_DependOnHost(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "DependOnNetwork":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._HostDependency_DependOnNetwork(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._HostDependency_Environment(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var identityImplementors = []string{"Identity"}

func (ec *executionContext) _Identity(ctx context.Context, sel ast.SelectionSet, obj *ent.Identity) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, identityImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Identity")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Identity_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclid":

			out.Values[i] = ec._Identity_hclid(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "firstName":

			out.Values[i] = ec._Identity_firstName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "lastName":

			out.Values[i] = ec._Identity_lastName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "email":

			out.Values[i] = ec._Identity_email(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "password":

			out.Values[i] = ec._Identity_password(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":

			out.Values[i] = ec._Identity_description(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "avatarFile":

			out.Values[i] = ec._Identity_avatarFile(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "vars":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Identity_vars(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Identity_tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Identity_Environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var includedNetworkImplementors = []string{"IncludedNetwork"}

func (ec *executionContext) _IncludedNetwork(ctx context.Context, sel ast.SelectionSet, obj *ent.IncludedNetwork) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, includedNetworkImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IncludedNetwork")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IncludedNetwork_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "name":

			out.Values[i] = ec._IncludedNetwork_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "includedHosts":

			out.Values[i] = ec._IncludedNetwork_includedHosts(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IncludedNetwork_Tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Hosts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IncludedNetwork_Hosts(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Network":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IncludedNetwork_Network(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environments":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IncludedNetwork_Environments(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var laForgePageInfoImplementors = []string{"LaForgePageInfo"}

func (ec *executionContext) _LaForgePageInfo(ctx context.Context, sel ast.SelectionSet, obj *model.LaForgePageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, laForgePageInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LaForgePageInfo")
		case "total":

			out.Values[i] = ec._LaForgePageInfo_total(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "nextOffset":

			out.Values[i] = ec._LaForgePageInfo_nextOffset(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "loadEnvironment":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_loadEnvironment(ctx, field)
			})

		case "createBuild":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createBuild(ctx, field)
			})

		case "deleteUser":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteUser(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "executePlan":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_executePlan(ctx, field)
			})

		case "deleteBuild":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteBuild(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createTask":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createTask(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dumpBuild":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_dumpBuild(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rebuild":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_rebuild(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "approveCommit":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_approveCommit(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cancelCommit":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelCommit(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createAgentTasks":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createAgentTasks(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createBatchAgentTasks":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createBatchAgentTasks(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createEnviromentFromRepo":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createEnviromentFromRepo(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateEnviromentViaPull":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateEnviromentViaPull(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cancelBuild":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_cancelBuild(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "modifySelfPassword":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_modifySelfPassword(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "modifySelfUserInfo":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_modifySelfUserInfo(ctx, field)
			})

		case "createUser":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createUser(ctx, field)
			})

		case "modifyAdminUserInfo":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_modifyAdminUserInfo(ctx, field)
			})

		case "modifyAdminPassword":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_modifyAdminPassword(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "nukeBackend":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_nukeBackend(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var networkImplementors = []string{"Network"}

func (ec *executionContext) _Network(ctx context.Context, sel ast.SelectionSet, obj *ent.Network) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, networkImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Network")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Network_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._Network_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Network_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "cidr":

			out.Values[i] = ec._Network_cidr(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "vdiVisible":

			out.Values[i] = ec._Network_vdiVisible(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "vars":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Network_vars(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Network_tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Network_Environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "HostDependencies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Network_HostDependencies(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "IncludedNetworks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Network_IncludedNetworks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var planImplementors = []string{"Plan"}

func (ec *executionContext) _Plan(ctx context.Context, sel ast.SelectionSet, obj *ent.Plan) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, planImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Plan")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Plan_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "stepNumber":

			out.Values[i] = ec._Plan_stepNumber(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Plan_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "NextPlans":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Plan_NextPlans(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "PrevPlans":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Plan_PrevPlans(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Build":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Plan_Build(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Team":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Plan_Team(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisionedNetwork":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Plan_ProvisionedNetwork(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisionedHost":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Plan_ProvisionedHost(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisioningStep":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Plan_ProvisioningStep(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisioningScheduledStep":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Plan_ProvisioningScheduledStep(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Plan_Status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "PlanDiffs":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Plan_PlanDiffs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var planCountsImplementors = []string{"PlanCounts"}

func (ec *executionContext) _PlanCounts(ctx context.Context, sel ast.SelectionSet, obj *model.PlanCounts) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, planCountsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlanCounts")
		case "planning":

			out.Values[i] = ec._PlanCounts_planning(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "awaiting":

			out.Values[i] = ec._PlanCounts_awaiting(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "parentAwaiting":

			out.Values[i] = ec._PlanCounts_parentAwaiting(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "inProgress":

			out.Values[i] = ec._PlanCounts_inProgress(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "failed":

			out.Values[i] = ec._PlanCounts_failed(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "complete":

			out.Values[i] = ec._PlanCounts_complete(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tainted":

			out.Values[i] = ec._PlanCounts_tainted(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "undefined":

			out.Values[i] = ec._PlanCounts_undefined(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "toDelete":

			out.Values[i] = ec._PlanCounts_toDelete(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteInProgress":

			out.Values[i] = ec._PlanCounts_deleteInProgress(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleted":

			out.Values[i] = ec._PlanCounts_deleted(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "toRebuild":

			out.Values[i] = ec._PlanCounts_toRebuild(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cancelled":

			out.Values[i] = ec._PlanCounts_cancelled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var planDiffImplementors = []string{"PlanDiff"}

func (ec *executionContext) _PlanDiff(ctx context.Context, sel ast.SelectionSet, obj *ent.PlanDiff) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, planDiffImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlanDiff")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PlanDiff_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "revision":

			out.Values[i] = ec._PlanDiff_revision(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "newState":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PlanDiff_newState(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "BuildCommit":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PlanDiff_BuildCommit(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Plan":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PlanDiff_Plan(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var provisionedHostImplementors = []string{"ProvisionedHost"}

func (ec *executionContext) _ProvisionedHost(ctx context.Context, sel ast.SelectionSet, obj *ent.ProvisionedHost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, provisionedHostImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProvisionedHost")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "subnetIp":

			out.Values[i] = ec._ProvisionedHost_subnetIp(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "addonType":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_addonType(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "vars":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_vars(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_Status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisionedNetwork":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_ProvisionedNetwork(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Host":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_Host(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "EndStepPlan":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_EndStepPlan(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Build":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_Build(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisioningSteps":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_ProvisioningSteps(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisioningScheduledSteps":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_ProvisioningScheduledSteps(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "AgentStatuses":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_AgentStatuses(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "AgentTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_AgentTasks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Plan":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_Plan(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "GinFileMiddleware":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedHost_GinFileMiddleware(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var provisionedNetworkImplementors = []string{"ProvisionedNetwork"}

func (ec *executionContext) _ProvisionedNetwork(ctx context.Context, sel ast.SelectionSet, obj *ent.ProvisionedNetwork) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, provisionedNetworkImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProvisionedNetwork")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedNetwork_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "name":

			out.Values[i] = ec._ProvisionedNetwork_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "cidr":

			out.Values[i] = ec._ProvisionedNetwork_cidr(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "vars":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedNetwork_vars(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedNetwork_Status(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Network":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedNetwork_Network(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Build":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedNetwork_Build(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Team":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedNetwork_Team(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisionedHosts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedNetwork_ProvisionedHosts(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Plan":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisionedNetwork_Plan(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var provisioningScheduledStepImplementors = []string{"ProvisioningScheduledStep"}

func (ec *executionContext) _ProvisioningScheduledStep(ctx context.Context, sel ast.SelectionSet, obj *ent.ProvisioningScheduledStep) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, provisioningScheduledStepImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProvisioningScheduledStep")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "type":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "runTime":

			out.Values[i] = ec._ProvisioningScheduledStep_runTime(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_Status(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ScheduledStep":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_ScheduledStep(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisionedHost":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_ProvisionedHost(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Script":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_Script(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Command":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_Command(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "DNSRecord":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_DNSRecord(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "FileDelete":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_FileDelete(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "FileDownload":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_FileDownload(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "FileExtract":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_FileExtract(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Ansible":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_Ansible(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "AgentTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_AgentTasks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Plan":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_Plan(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "GinFileMiddleware":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningScheduledStep_GinFileMiddleware(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var provisioningStepImplementors = []string{"ProvisioningStep"}

func (ec *executionContext) _ProvisioningStep(ctx context.Context, sel ast.SelectionSet, obj *ent.ProvisioningStep) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, provisioningStepImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProvisioningStep")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "type":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "stepNumber":

			out.Values[i] = ec._ProvisioningStep_stepNumber(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_Status(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisionedHost":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_ProvisionedHost(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Script":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_Script(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Command":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_Command(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "DNSRecord":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_DNSRecord(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "FileDelete":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_FileDelete(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "FileDownload":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_FileDownload(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "FileExtract":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_FileExtract(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Ansible":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_Ansible(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Plan":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_Plan(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "AgentTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_AgentTasks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "GinFileMiddleware":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProvisioningStep_GinFileMiddleware(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "environments":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_environments(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_environment(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "provisionedHost":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_provisionedHost(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "provisionedNetwork":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_provisionedNetwork(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "provisionedStep":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_provisionedStep(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "plan":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_plan(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getBuilds":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getBuilds(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "build":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_build(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getBuildCommits":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getBuildCommits(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getBuildCommit":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getBuildCommit(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_status(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "agentStatus":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_agentStatus(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getServerTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getServerTasks(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "currentUser":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_currentUser(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getUserList":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getUserList(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getCurrentUserTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getCurrentUserTasks(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getAgentTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getAgentTasks(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "listAgentStatuses":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listAgentStatuses(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "listBuildStatuses":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_listBuildStatuses(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getAllAgentStatus":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getAllAgentStatus(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getAllPlanStatus":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getAllPlanStatus(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "getPlanStatusCounts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getPlanStatusCounts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "viewServerTaskLogs":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_viewServerTaskLogs(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "viewAgentTask":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_viewAgentTask(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "serverTasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_serverTasks(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "serverConfig":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_serverConfig(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoCommitImplementors = []string{"RepoCommit"}

func (ec *executionContext) _RepoCommit(ctx context.Context, sel ast.SelectionSet, obj *ent.RepoCommit) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoCommitImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoCommit")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoCommit_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "revision":

			out.Values[i] = ec._RepoCommit_revision(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "hash":

			out.Values[i] = ec._RepoCommit_hash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "author":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoCommit_author(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "committer":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoCommit_committer(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "pgpSignature":

			out.Values[i] = ec._RepoCommit_pgpSignature(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "message":

			out.Values[i] = ec._RepoCommit_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "treeHash":

			out.Values[i] = ec._RepoCommit_treeHash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "parentHashes":

			out.Values[i] = ec._RepoCommit_parentHashes(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Repository":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoCommit_Repository(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repositoryImplementors = []string{"Repository"}

func (ec *executionContext) _Repository(ctx context.Context, sel ast.SelectionSet, obj *ent.Repository) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repositoryImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Repository")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "repoUrl":

			out.Values[i] = ec._Repository_repoUrl(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "branchName":

			out.Values[i] = ec._Repository_branchName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "environmentFilepath":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_environmentFilepath(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environments":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_Environments(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "RepoCommits":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Repository_RepoCommits(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var scheduledStepImplementors = []string{"ScheduledStep"}

func (ec *executionContext) _ScheduledStep(ctx context.Context, sel ast.SelectionSet, obj *ent.ScheduledStep) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, scheduledStepImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ScheduledStep")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ScheduledStep_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._ScheduledStep_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._ScheduledStep_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":

			out.Values[i] = ec._ScheduledStep_description(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "step":

			out.Values[i] = ec._ScheduledStep_step(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ScheduledStep_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "schedule":

			out.Values[i] = ec._ScheduledStep_schedule(ctx, field, obj)

		case "runAt":

			out.Values[i] = ec._ScheduledStep_runAt(ctx, field, obj)

		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ScheduledStep_Environment(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var scriptImplementors = []string{"Script"}

func (ec *executionContext) _Script(ctx context.Context, sel ast.SelectionSet, obj *ent.Script) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, scriptImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Script")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Script_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._Script_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Script_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "language":

			out.Values[i] = ec._Script_language(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":

			out.Values[i] = ec._Script_description(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "source":

			out.Values[i] = ec._Script_source(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "sourceType":

			out.Values[i] = ec._Script_sourceType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "cooldown":

			out.Values[i] = ec._Script_cooldown(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "timeout":

			out.Values[i] = ec._Script_timeout(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "ignoreErrors":

			out.Values[i] = ec._Script_ignoreErrors(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "args":

			out.Values[i] = ec._Script_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "disabled":

			out.Values[i] = ec._Script_disabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "vars":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Script_vars(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "absPath":

			out.Values[i] = ec._Script_absPath(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Script_tags(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Users":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Script_Users(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Findings":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Script_Findings(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Script_Environment(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var serverConfigImplementors = []string{"ServerConfig"}

func (ec *executionContext) _ServerConfig(ctx context.Context, sel ast.SelectionSet, obj *model.ServerConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serverConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServerConfig")
		case "ConfigFile":

			out.Values[i] = ec._ServerConfig_ConfigFile(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Debug":

			out.Values[i] = ec._ServerConfig_Debug(ctx, field, obj)

		case "LogFolder":

			out.Values[i] = ec._ServerConfig_LogFolder(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "GinMode":

			out.Values[i] = ec._ServerConfig_GinMode(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Builders":

			out.Values[i] = ec._ServerConfig_Builders(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Database":

			out.Values[i] = ec._ServerConfig_Database(ctx, field, obj)

		case "Auth":

			out.Values[i] = ec._ServerConfig_Auth(ctx, field, obj)

		case "UI":

			out.Values[i] = ec._ServerConfig_UI(ctx, field, obj)

		case "Agent":

			out.Values[i] = ec._ServerConfig_Agent(ctx, field, obj)

		case "Graphql":

			out.Values[i] = ec._ServerConfig_Graphql(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var serverTaskImplementors = []string{"ServerTask"}

func (ec *executionContext) _ServerTask(ctx context.Context, sel ast.SelectionSet, obj *ent.ServerTask) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serverTaskImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServerTask")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ServerTask_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "type":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ServerTask_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "startTime":

			out.Values[i] = ec._ServerTask_startTime(ctx, field, obj)

		case "endTime":

			out.Values[i] = ec._ServerTask_endTime(ctx, field, obj)

		case "errors":

			out.Values[i] = ec._ServerTask_errors(ctx, field, obj)

		case "logFilePath":

			out.Values[i] = ec._ServerTask_logFilePath(ctx, field, obj)

		case "AuthUser":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ServerTask_AuthUser(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ServerTask_Status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environment":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ServerTask_Environment(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Build":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ServerTask_Build(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "BuildCommit":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ServerTask_BuildCommit(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "GinFileMiddleware":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ServerTask_GinFileMiddleware(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var statusImplementors = []string{"Status"}

func (ec *executionContext) _Status(ctx context.Context, sel ast.SelectionSet, obj *ent.Status) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, statusImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Status")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "state":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_state(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "statusFor":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_statusFor(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "startedAt":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_startedAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "endedAt":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_endedAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "failed":

			out.Values[i] = ec._Status_failed(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "completed":

			out.Values[i] = ec._Status_completed(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "error":

			out.Values[i] = ec._Status_error(ctx, field, obj)

		case "Build":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_Build(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisionedNetwork":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_ProvisionedNetwork(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisionedHost":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_ProvisionedHost(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisioningStep":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_ProvisioningStep(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Team":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_Team(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Plan":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_Plan(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ServerTask":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_ServerTask(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "AdhocPlan":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_AdhocPlan(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisioningScheduledStep":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Status_ProvisioningScheduledStep(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var statusBatchImplementors = []string{"StatusBatch"}

func (ec *executionContext) _StatusBatch(ctx context.Context, sel ast.SelectionSet, obj *model.StatusBatch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, statusBatchImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StatusBatch")
		case "statuses":

			out.Values[i] = ec._StatusBatch_statuses(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pageInfo":

			out.Values[i] = ec._StatusBatch_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "updatedAgentStatus":
		return ec._Subscription_updatedAgentStatus(ctx, fields[0])
	case "updatedStatus":
		return ec._Subscription_updatedStatus(ctx, fields[0])
	case "updatedServerTask":
		return ec._Subscription_updatedServerTask(ctx, fields[0])
	case "updatedBuild":
		return ec._Subscription_updatedBuild(ctx, fields[0])
	case "updatedCommit":
		return ec._Subscription_updatedCommit(ctx, fields[0])
	case "updatedAgentTask":
		return ec._Subscription_updatedAgentTask(ctx, fields[0])
	case "streamServerTaskLog":
		return ec._Subscription_streamServerTaskLog(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var tagImplementors = []string{"Tag"}

func (ec *executionContext) _Tag(ctx context.Context, sel ast.SelectionSet, obj *ent.Tag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Tag")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Tag_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "uuid":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Tag_uuid(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "name":

			out.Values[i] = ec._Tag_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "description":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Tag_description(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var teamImplementors = []string{"Team"}

func (ec *executionContext) _Team(ctx context.Context, sel ast.SelectionSet, obj *ent.Team) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teamImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Team")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "teamNumber":

			out.Values[i] = ec._Team_teamNumber(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Build":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_Build(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_Status(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ProvisionedNetworks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_ProvisionedNetworks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Plan":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Team_Plan(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var uIConfigImplementors = []string{"UIConfig"}

func (ec *executionContext) _UIConfig(ctx context.Context, sel ast.SelectionSet, obj *model.UIConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, uIConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UIConfig")
		case "HttpsEnabled":

			out.Values[i] = ec._UIConfig_HttpsEnabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "AllowedOrigins":

			out.Values[i] = ec._UIConfig_AllowedOrigins(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *ent.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hclId":

			out.Values[i] = ec._User_hclId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._User_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "uuid":

			out.Values[i] = ec._User_uuid(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "email":

			out.Values[i] = ec._User_email(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Tag":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_Tag(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Environments":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_Environments(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":

			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":

			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":

			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":

			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":

			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":

			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":

			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":

			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":

			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":

			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":

			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":

			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":

			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":

			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":

			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":

			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":

			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":

			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":

			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":

			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":

			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":

			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":

			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":

			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":

			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":

			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var configMapImplementors = []string{"configMap"}

func (ec *executionContext) _configMap(ctx context.Context, sel ast.SelectionSet, obj *model.ConfigMap) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, configMapImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("configMap")
		case "key":

			out.Values[i] = ec._configMap_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":

			out.Values[i] = ec._configMap_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var intMapImplementors = []string{"intMap"}

func (ec *executionContext) _intMap(ctx context.Context, sel ast.SelectionSet, obj *model.IntMap) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, intMapImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("intMap")
		case "key":

			out.Values[i] = ec._intMap_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":

			out.Values[i] = ec._intMap_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tagMapImplementors = []string{"tagMap"}

func (ec *executionContext) _tagMap(ctx context.Context, sel ast.SelectionSet, obj *model.TagMap) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagMapImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("tagMap")
		case "key":

			out.Values[i] = ec._tagMap_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":

			out.Values[i] = ec._tagMap_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var varsMapImplementors = []string{"varsMap"}

func (ec *executionContext) _varsMap(ctx context.Context, sel ast.SelectionSet, obj *model.VarsMap) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, varsMapImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("varsMap")
		case "key":

			out.Values[i] = ec._varsMap_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":

			out.Values[i] = ec._varsMap_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAdhocPlan2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAdhocPlan(ctx context.Context, sel ast.SelectionSet, v []*ent.AdhocPlan) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAdhocPlan2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAdhocPlan(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNAgentCommand2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐAgentCommand(ctx context.Context, v interface{}) (model.AgentCommand, error) {
	var res model.AgentCommand
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAgentCommand2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐAgentCommand(ctx context.Context, sel ast.SelectionSet, v model.AgentCommand) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNAgentStatus2githubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentStatus(ctx context.Context, sel ast.SelectionSet, v ent.AgentStatus) graphql.Marshaler {
	return ec._AgentStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalNAgentStatus2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentStatus(ctx context.Context, sel ast.SelectionSet, v []*ent.AgentStatus) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAgentStatus2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNAgentStatus2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentStatus(ctx context.Context, sel ast.SelectionSet, v *ent.AgentStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AgentStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNAgentTask2githubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentTask(ctx context.Context, sel ast.SelectionSet, v ent.AgentTask) graphql.Marshaler {
	return ec._AgentTask(ctx, sel, &v)
}

func (ec *executionContext) marshalNAgentTask2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentTask(ctx context.Context, sel ast.SelectionSet, v []*ent.AgentTask) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAgentTask2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNAgentTask2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentTask(ctx context.Context, sel ast.SelectionSet, v *ent.AgentTask) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AgentTask(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAgentTaskState2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐAgentTaskState(ctx context.Context, v interface{}) (model.AgentTaskState, error) {
	var res model.AgentTaskState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAgentTaskState2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐAgentTaskState(ctx context.Context, sel ast.SelectionSet, v model.AgentTaskState) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNAnsible2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAnsible(ctx context.Context, sel ast.SelectionSet, v []*ent.Ansible) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAnsible2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAnsible(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNAnsibleMethod2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐAnsibleMethod(ctx context.Context, v interface{}) (model.AnsibleMethod, error) {
	var res model.AnsibleMethod
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAnsibleMethod2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐAnsibleMethod(ctx context.Context, sel ast.SelectionSet, v model.AnsibleMethod) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNAuthUser2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAuthUser(ctx context.Context, sel ast.SelectionSet, v *ent.AuthUser) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AuthUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNBuild2githubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuild(ctx context.Context, sel ast.SelectionSet, v ent.Build) graphql.Marshaler {
	return ec._Build(ctx, sel, &v)
}

func (ec *executionContext) marshalNBuild2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuild(ctx context.Context, sel ast.SelectionSet, v []*ent.Build) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOBuild2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuild(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNBuild2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuild(ctx context.Context, sel ast.SelectionSet, v *ent.Build) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Build(ctx, sel, v)
}

func (ec *executionContext) marshalNBuildCommit2githubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuildCommit(ctx context.Context, sel ast.SelectionSet, v ent.BuildCommit) graphql.Marshaler {
	return ec._BuildCommit(ctx, sel, &v)
}

func (ec *executionContext) marshalNBuildCommit2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuildCommit(ctx context.Context, sel ast.SelectionSet, v []*ent.BuildCommit) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOBuildCommit2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuildCommit(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNBuildCommit2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuildCommit(ctx context.Context, sel ast.SelectionSet, v *ent.BuildCommit) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BuildCommit(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBuildCommitState2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐBuildCommitState(ctx context.Context, v interface{}) (model.BuildCommitState, error) {
	var res model.BuildCommitState
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBuildCommitState2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐBuildCommitState(ctx context.Context, sel ast.SelectionSet, v model.BuildCommitState) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBuildCommitType2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐBuildCommitType(ctx context.Context, v interface{}) (model.BuildCommitType, error) {
	var res model.BuildCommitType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBuildCommitType2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐBuildCommitType(ctx context.Context, sel ast.SelectionSet, v model.BuildCommitType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCommand2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐCommand(ctx context.Context, sel ast.SelectionSet, v []*ent.Command) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCommand2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐCommand(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNCompetition2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐCompetition(ctx context.Context, sel ast.SelectionSet, v []*ent.Competition) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCompetition2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐCompetition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNCompetition2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐCompetition(ctx context.Context, sel ast.SelectionSet, v *ent.Competition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Competition(ctx, sel, v)
}

func (ec *executionContext) marshalNDNS2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐDNS(ctx context.Context, sel ast.SelectionSet, v []*ent.DNS) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODNS2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐDNS(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNDNSRecord2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐDNSRecord(ctx context.Context, sel ast.SelectionSet, v []*ent.DNSRecord) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODNSRecord2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐDNSRecord(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNDisk2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐDisk(ctx context.Context, sel ast.SelectionSet, v *ent.Disk) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Disk(ctx, sel, v)
}

func (ec *executionContext) marshalNEnvironment2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx context.Context, sel ast.SelectionSet, v []*ent.Environment) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOEnvironment2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNEnvironment2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx context.Context, sel ast.SelectionSet, v *ent.Environment) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Environment(ctx, sel, v)
}

func (ec *executionContext) marshalNFileDelete2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐFileDelete(ctx context.Context, sel ast.SelectionSet, v []*ent.FileDelete) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOFileDelete2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐFileDelete(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNFileDownload2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐFileDownload(ctx context.Context, sel ast.SelectionSet, v []*ent.FileDownload) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOFileDownload2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐFileDownload(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNFileExtract2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐFileExtract(ctx context.Context, sel ast.SelectionSet, v []*ent.FileExtract) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOFileExtract2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐFileExtract(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNFinding2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐFinding(ctx context.Context, sel ast.SelectionSet, v []*ent.Finding) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOFinding2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐFinding(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNFindingDifficulty2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐFindingDifficulty(ctx context.Context, v interface{}) (model.FindingDifficulty, error) {
	var res model.FindingDifficulty
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFindingDifficulty2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐFindingDifficulty(ctx context.Context, sel ast.SelectionSet, v model.FindingDifficulty) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFindingSeverity2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐFindingSeverity(ctx context.Context, v interface{}) (model.FindingSeverity, error) {
	var res model.FindingSeverity
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFindingSeverity2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐFindingSeverity(ctx context.Context, sel ast.SelectionSet, v model.FindingSeverity) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNGinFileMiddleware2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐGinFileMiddleware(ctx context.Context, sel ast.SelectionSet, v []*ent.GinFileMiddleware) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGinFileMiddleware2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐGinFileMiddleware(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNHost2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐHost(ctx context.Context, sel ast.SelectionSet, v []*ent.Host) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOHost2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐHost(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNHost2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐHost(ctx context.Context, sel ast.SelectionSet, v *ent.Host) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Host(ctx, sel, v)
}

func (ec *executionContext) marshalNHostDependency2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐHostDependency(ctx context.Context, sel ast.SelectionSet, v []*ent.HostDependency) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOHostDependency2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐHostDependency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNIdentity2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐIdentity(ctx context.Context, sel ast.SelectionSet, v []*ent.Identity) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOIdentity2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐIdentity(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNIncludedNetwork2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐIncludedNetwork(ctx context.Context, sel ast.SelectionSet, v []*ent.IncludedNetwork) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOIncludedNetwork2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐIncludedNetwork(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int64(ctx context.Context, v interface{}) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	res := graphql.MarshalInt64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2ᚕintᚄ(ctx context.Context, v interface{}) ([]int, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNInt2ᚕintᚄ(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLaForgePageInfo2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐLaForgePageInfo(ctx context.Context, sel ast.SelectionSet, v *model.LaForgePageInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LaForgePageInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNNetwork2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐNetwork(ctx context.Context, sel ast.SelectionSet, v []*ent.Network) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONetwork2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐNetwork(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNPlan2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐPlan(ctx context.Context, sel ast.SelectionSet, v []*ent.Plan) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPlan2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐPlan(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNPlan2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐPlan(ctx context.Context, sel ast.SelectionSet, v *ent.Plan) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Plan(ctx, sel, v)
}

func (ec *executionContext) marshalNPlanCounts2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐPlanCounts(ctx context.Context, sel ast.SelectionSet, v model.PlanCounts) graphql.Marshaler {
	return ec._PlanCounts(ctx, sel, &v)
}

func (ec *executionContext) marshalNPlanCounts2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐPlanCounts(ctx context.Context, sel ast.SelectionSet, v *model.PlanCounts) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PlanCounts(ctx, sel, v)
}

func (ec *executionContext) marshalNPlanDiff2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐPlanDiff(ctx context.Context, sel ast.SelectionSet, v []*ent.PlanDiff) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPlanDiff2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐPlanDiff(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNPlanType2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐPlanType(ctx context.Context, v interface{}) (model.PlanType, error) {
	var res model.PlanType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPlanType2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐPlanType(ctx context.Context, sel ast.SelectionSet, v model.PlanType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNProviderType2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐProviderType(ctx context.Context, v interface{}) (model.ProviderType, error) {
	var res model.ProviderType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProviderType2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐProviderType(ctx context.Context, sel ast.SelectionSet, v model.ProviderType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNProvisionStatus2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐProvisionStatus(ctx context.Context, v interface{}) (model.ProvisionStatus, error) {
	var res model.ProvisionStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProvisionStatus2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐProvisionStatus(ctx context.Context, sel ast.SelectionSet, v model.ProvisionStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNProvisionStatusFor2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐProvisionStatusFor(ctx context.Context, v interface{}) (model.ProvisionStatusFor, error) {
	var res model.ProvisionStatusFor
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProvisionStatusFor2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐProvisionStatusFor(ctx context.Context, sel ast.SelectionSet, v model.ProvisionStatusFor) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNProvisionedHost2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisionedHost(ctx context.Context, sel ast.SelectionSet, v []*ent.ProvisionedHost) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOProvisionedHost2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisionedHost(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNProvisionedHost2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisionedHost(ctx context.Context, sel ast.SelectionSet, v *ent.ProvisionedHost) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProvisionedHost(ctx, sel, v)
}

func (ec *executionContext) marshalNProvisionedNetwork2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisionedNetwork(ctx context.Context, sel ast.SelectionSet, v []*ent.ProvisionedNetwork) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOProvisionedNetwork2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisionedNetwork(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNProvisionedNetwork2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisionedNetwork(ctx context.Context, sel ast.SelectionSet, v *ent.ProvisionedNetwork) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProvisionedNetwork(ctx, sel, v)
}

func (ec *executionContext) marshalNProvisioningScheduledStep2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisioningScheduledStep(ctx context.Context, sel ast.SelectionSet, v []*ent.ProvisioningScheduledStep) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOProvisioningScheduledStep2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisioningScheduledStep(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNProvisioningScheduledStepType2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐProvisioningScheduledStepType(ctx context.Context, v interface{}) (model.ProvisioningScheduledStepType, error) {
	var res model.ProvisioningScheduledStepType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProvisioningScheduledStepType2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐProvisioningScheduledStepType(ctx context.Context, sel ast.SelectionSet, v model.ProvisioningScheduledStepType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNProvisioningStep2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisioningStep(ctx context.Context, sel ast.SelectionSet, v []*ent.ProvisioningStep) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOProvisioningStep2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisioningStep(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNProvisioningStepType2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐProvisioningStepType(ctx context.Context, v interface{}) (model.ProvisioningStepType, error) {
	var res model.ProvisioningStepType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProvisioningStepType2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐProvisioningStepType(ctx context.Context, sel ast.SelectionSet, v model.ProvisioningStepType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRepoCommit2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐRepoCommit(ctx context.Context, sel ast.SelectionSet, v []*ent.RepoCommit) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalORepoCommit2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐRepoCommit(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNRepoCommit2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐRepoCommit(ctx context.Context, sel ast.SelectionSet, v *ent.RepoCommit) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RepoCommit(ctx, sel, v)
}

func (ec *executionContext) marshalNRepository2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐRepository(ctx context.Context, sel ast.SelectionSet, v []*ent.Repository) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalORepository2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐRepository(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNRepository2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐRepository(ctx context.Context, sel ast.SelectionSet, v *ent.Repository) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Repository(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRoleLevel2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevel(ctx context.Context, v interface{}) (model.RoleLevel, error) {
	var res model.RoleLevel
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRoleLevel2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevel(ctx context.Context, sel ast.SelectionSet, v model.RoleLevel) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx context.Context, v interface{}) ([]model.RoleLevel, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.RoleLevel, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNRoleLevel2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevel(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNRoleLevel2ᚕgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevelᚄ(ctx context.Context, sel ast.SelectionSet, v []model.RoleLevel) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRoleLevel2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevel(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNScheduledStep2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐScheduledStep(ctx context.Context, sel ast.SelectionSet, v []*ent.ScheduledStep) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOScheduledStep2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐScheduledStep(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNScheduledStep2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐScheduledStep(ctx context.Context, sel ast.SelectionSet, v *ent.ScheduledStep) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ScheduledStep(ctx, sel, v)
}

func (ec *executionContext) unmarshalNScheduledStepType2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐScheduledStepType(ctx context.Context, v interface{}) (model.ScheduledStepType, error) {
	var res model.ScheduledStepType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNScheduledStepType2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐScheduledStepType(ctx context.Context, sel ast.SelectionSet, v model.ScheduledStepType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNScript2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐScript(ctx context.Context, sel ast.SelectionSet, v []*ent.Script) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOScript2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐScript(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNServerTask2githubᚗcomᚋgen0cideᚋlaforgeᚋentᚐServerTask(ctx context.Context, sel ast.SelectionSet, v ent.ServerTask) graphql.Marshaler {
	return ec._ServerTask(ctx, sel, &v)
}

func (ec *executionContext) marshalNServerTask2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐServerTask(ctx context.Context, sel ast.SelectionSet, v []*ent.ServerTask) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOServerTask2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐServerTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNServerTask2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐServerTask(ctx context.Context, sel ast.SelectionSet, v *ent.ServerTask) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ServerTask(ctx, sel, v)
}

func (ec *executionContext) unmarshalNServerTaskType2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐServerTaskType(ctx context.Context, v interface{}) (model.ServerTaskType, error) {
	var res model.ServerTaskType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNServerTaskType2githubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐServerTaskType(ctx context.Context, sel ast.SelectionSet, v model.ServerTaskType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNStatus2githubᚗcomᚋgen0cideᚋlaforgeᚋentᚐStatus(ctx context.Context, sel ast.SelectionSet, v ent.Status) graphql.Marshaler {
	return ec._Status(ctx, sel, &v)
}

func (ec *executionContext) marshalNStatus2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐStatus(ctx context.Context, sel ast.SelectionSet, v []*ent.Status) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOStatus2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNStatus2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐStatus(ctx context.Context, sel ast.SelectionSet, v *ent.Status) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Status(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNString2ᚕᚖstring(ctx context.Context, v interface{}) ([]*string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕᚖstring(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2ᚖstring(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) marshalNTag2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐTag(ctx context.Context, sel ast.SelectionSet, v []*ent.Tag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTag2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNTeam2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐTeam(ctx context.Context, sel ast.SelectionSet, v []*ent.Team) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTeam2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐTeam(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNUser2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐUser(ctx context.Context, sel ast.SelectionSet, v []*ent.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUser2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNintMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐIntMap(ctx context.Context, sel ast.SelectionSet, v []*model.IntMap) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOintMap2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐIntMap(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNtagMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐTagMap(ctx context.Context, sel ast.SelectionSet, v []*model.TagMap) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOtagMap2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐTagMap(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNvarsMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐVarsMap(ctx context.Context, sel ast.SelectionSet, v []*model.VarsMap) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOvarsMap2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐVarsMap(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOAdhocPlan2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAdhocPlan(ctx context.Context, sel ast.SelectionSet, v []*ent.AdhocPlan) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAdhocPlan2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAdhocPlan(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOAdhocPlan2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAdhocPlan(ctx context.Context, sel ast.SelectionSet, v *ent.AdhocPlan) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdhocPlan(ctx, sel, v)
}

func (ec *executionContext) marshalOAgentConfig2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐAgentConfig(ctx context.Context, sel ast.SelectionSet, v *model.AgentConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AgentConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOAgentStatus2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentStatus(ctx context.Context, sel ast.SelectionSet, v []*ent.AgentStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAgentStatus2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOAgentStatus2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentStatus(ctx context.Context, sel ast.SelectionSet, v *ent.AgentStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AgentStatus(ctx, sel, v)
}

func (ec *executionContext) marshalOAgentStatusBatch2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐAgentStatusBatch(ctx context.Context, sel ast.SelectionSet, v *model.AgentStatusBatch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AgentStatusBatch(ctx, sel, v)
}

func (ec *executionContext) marshalOAgentTask2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentTask(ctx context.Context, sel ast.SelectionSet, v []*ent.AgentTask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAgentTask2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOAgentTask2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAgentTask(ctx context.Context, sel ast.SelectionSet, v *ent.AgentTask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AgentTask(ctx, sel, v)
}

func (ec *executionContext) marshalOAnsible2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAnsible(ctx context.Context, sel ast.SelectionSet, v *ent.Ansible) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Ansible(ctx, sel, v)
}

func (ec *executionContext) marshalOAuthConfig2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐAuthConfig(ctx context.Context, sel ast.SelectionSet, v *model.AuthConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AuthConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOAuthUser2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAuthUser(ctx context.Context, sel ast.SelectionSet, v []*ent.AuthUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAuthUser2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAuthUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOAuthUser2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐAuthUser(ctx context.Context, sel ast.SelectionSet, v *ent.AuthUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AuthUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOBuild2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuild(ctx context.Context, sel ast.SelectionSet, v []*ent.Build) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOBuild2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuild(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOBuild2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuild(ctx context.Context, sel ast.SelectionSet, v *ent.Build) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Build(ctx, sel, v)
}

func (ec *executionContext) marshalOBuildCommit2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuildCommit(ctx context.Context, sel ast.SelectionSet, v []*ent.BuildCommit) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOBuildCommit2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuildCommit(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOBuildCommit2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐBuildCommit(ctx context.Context, sel ast.SelectionSet, v *ent.BuildCommit) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BuildCommit(ctx, sel, v)
}

func (ec *executionContext) marshalOCommand2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐCommand(ctx context.Context, sel ast.SelectionSet, v *ent.Command) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Command(ctx, sel, v)
}

func (ec *executionContext) marshalOCompetition2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐCompetition(ctx context.Context, sel ast.SelectionSet, v *ent.Competition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Competition(ctx, sel, v)
}

func (ec *executionContext) marshalODNS2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐDNS(ctx context.Context, sel ast.SelectionSet, v *ent.DNS) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DNS(ctx, sel, v)
}

func (ec *executionContext) marshalODNSRecord2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐDNSRecord(ctx context.Context, sel ast.SelectionSet, v *ent.DNSRecord) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DNSRecord(ctx, sel, v)
}

func (ec *executionContext) marshalODatabaseConfig2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐDatabaseConfig(ctx context.Context, sel ast.SelectionSet, v *model.DatabaseConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DatabaseConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOEnvironment2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx context.Context, sel ast.SelectionSet, v []*ent.Environment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOEnvironment2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOEnvironment2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐEnvironment(ctx context.Context, sel ast.SelectionSet, v *ent.Environment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Environment(ctx, sel, v)
}

func (ec *executionContext) marshalOFileDelete2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐFileDelete(ctx context.Context, sel ast.SelectionSet, v *ent.FileDelete) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FileDelete(ctx, sel, v)
}

func (ec *executionContext) marshalOFileDownload2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐFileDownload(ctx context.Context, sel ast.SelectionSet, v *ent.FileDownload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FileDownload(ctx, sel, v)
}

func (ec *executionContext) marshalOFileExtract2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐFileExtract(ctx context.Context, sel ast.SelectionSet, v *ent.FileExtract) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FileExtract(ctx, sel, v)
}

func (ec *executionContext) marshalOFinding2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐFinding(ctx context.Context, sel ast.SelectionSet, v *ent.Finding) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Finding(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalOGinFileMiddleware2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐGinFileMiddleware(ctx context.Context, sel ast.SelectionSet, v *ent.GinFileMiddleware) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GinFileMiddleware(ctx, sel, v)
}

func (ec *executionContext) marshalOGraphqlConfig2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐGraphqlConfig(ctx context.Context, sel ast.SelectionSet, v *model.GraphqlConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GraphqlConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOHost2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐHost(ctx context.Context, sel ast.SelectionSet, v *ent.Host) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Host(ctx, sel, v)
}

func (ec *executionContext) marshalOHostDependency2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐHostDependency(ctx context.Context, sel ast.SelectionSet, v *ent.HostDependency) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._HostDependency(ctx, sel, v)
}

func (ec *executionContext) marshalOIdentity2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐIdentity(ctx context.Context, sel ast.SelectionSet, v *ent.Identity) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Identity(ctx, sel, v)
}

func (ec *executionContext) marshalOIncludedNetwork2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐIncludedNetwork(ctx context.Context, sel ast.SelectionSet, v *ent.IncludedNetwork) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._IncludedNetwork(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInt2int64(ctx context.Context, v interface{}) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	res := graphql.MarshalInt64(v)
	return res
}

func (ec *executionContext) marshalONetwork2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐNetwork(ctx context.Context, sel ast.SelectionSet, v *ent.Network) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Network(ctx, sel, v)
}

func (ec *executionContext) marshalOPlan2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐPlan(ctx context.Context, sel ast.SelectionSet, v *ent.Plan) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Plan(ctx, sel, v)
}

func (ec *executionContext) marshalOPlanDiff2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐPlanDiff(ctx context.Context, sel ast.SelectionSet, v *ent.PlanDiff) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PlanDiff(ctx, sel, v)
}

func (ec *executionContext) unmarshalOProviderType2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐProviderType(ctx context.Context, v interface{}) (*model.ProviderType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ProviderType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProviderType2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐProviderType(ctx context.Context, sel ast.SelectionSet, v *model.ProviderType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOProvisionedHost2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisionedHost(ctx context.Context, sel ast.SelectionSet, v *ent.ProvisionedHost) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProvisionedHost(ctx, sel, v)
}

func (ec *executionContext) unmarshalOProvisionedHostAddonType2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐProvisionedHostAddonType(ctx context.Context, v interface{}) (*model.ProvisionedHostAddonType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ProvisionedHostAddonType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProvisionedHostAddonType2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐProvisionedHostAddonType(ctx context.Context, sel ast.SelectionSet, v *model.ProvisionedHostAddonType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOProvisionedNetwork2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisionedNetwork(ctx context.Context, sel ast.SelectionSet, v *ent.ProvisionedNetwork) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProvisionedNetwork(ctx, sel, v)
}

func (ec *executionContext) marshalOProvisioningScheduledStep2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisioningScheduledStep(ctx context.Context, sel ast.SelectionSet, v *ent.ProvisioningScheduledStep) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProvisioningScheduledStep(ctx, sel, v)
}

func (ec *executionContext) marshalOProvisioningStep2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐProvisioningStep(ctx context.Context, sel ast.SelectionSet, v *ent.ProvisioningStep) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProvisioningStep(ctx, sel, v)
}

func (ec *executionContext) marshalORepoCommit2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐRepoCommit(ctx context.Context, sel ast.SelectionSet, v *ent.RepoCommit) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RepoCommit(ctx, sel, v)
}

func (ec *executionContext) marshalORepository2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐRepository(ctx context.Context, sel ast.SelectionSet, v *ent.Repository) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Repository(ctx, sel, v)
}

func (ec *executionContext) unmarshalORoleLevel2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevel(ctx context.Context, v interface{}) (*model.RoleLevel, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.RoleLevel)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORoleLevel2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐRoleLevel(ctx context.Context, sel ast.SelectionSet, v *model.RoleLevel) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOScheduledStep2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐScheduledStep(ctx context.Context, sel ast.SelectionSet, v *ent.ScheduledStep) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ScheduledStep(ctx, sel, v)
}

func (ec *executionContext) marshalOScript2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐScript(ctx context.Context, sel ast.SelectionSet, v *ent.Script) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Script(ctx, sel, v)
}

func (ec *executionContext) marshalOServerConfig2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐServerConfig(ctx context.Context, sel ast.SelectionSet, v *model.ServerConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ServerConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOServerTask2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐServerTask(ctx context.Context, sel ast.SelectionSet, v []*ent.ServerTask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOServerTask2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐServerTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOServerTask2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐServerTask(ctx context.Context, sel ast.SelectionSet, v *ent.ServerTask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ServerTask(ctx, sel, v)
}

func (ec *executionContext) marshalOStatus2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐStatus(ctx context.Context, sel ast.SelectionSet, v []*ent.Status) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOStatus2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOStatus2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐStatus(ctx context.Context, sel ast.SelectionSet, v *ent.Status) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Status(ctx, sel, v)
}

func (ec *executionContext) marshalOStatusBatch2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐStatusBatch(ctx context.Context, sel ast.SelectionSet, v *model.StatusBatch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StatusBatch(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTag2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐTag(ctx context.Context, sel ast.SelectionSet, v *ent.Tag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) marshalOTeam2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐTeam(ctx context.Context, sel ast.SelectionSet, v *ent.Team) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Team(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	return res
}

func (ec *executionContext) marshalOUIConfig2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐUIConfig(ctx context.Context, sel ast.SelectionSet, v *model.UIConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UIConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOUser2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐUser(ctx context.Context, sel ast.SelectionSet, v []*ent.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUser2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOUser2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋentᚐUser(ctx context.Context, sel ast.SelectionSet, v *ent.User) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) marshalOconfigMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐConfigMap(ctx context.Context, sel ast.SelectionSet, v []*model.ConfigMap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOconfigMap2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐConfigMap(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOconfigMap2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐConfigMap(ctx context.Context, sel ast.SelectionSet, v *model.ConfigMap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._configMap(ctx, sel, v)
}

func (ec *executionContext) marshalOintMap2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐIntMap(ctx context.Context, sel ast.SelectionSet, v *model.IntMap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._intMap(ctx, sel, v)
}

func (ec *executionContext) marshalOtagMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐTagMap(ctx context.Context, sel ast.SelectionSet, v []*model.TagMap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOtagMap2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐTagMap(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOtagMap2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐTagMap(ctx context.Context, sel ast.SelectionSet, v *model.TagMap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._tagMap(ctx, sel, v)
}

func (ec *executionContext) marshalOvarsMap2ᚕᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐVarsMap(ctx context.Context, sel ast.SelectionSet, v []*model.VarsMap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOvarsMap2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐVarsMap(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOvarsMap2ᚖgithubᚗcomᚋgen0cideᚋlaforgeᚋgraphqlᚋgraphᚋmodelᚐVarsMap(ctx context.Context, sel ast.SelectionSet, v *model.VarsMap) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._varsMap(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
